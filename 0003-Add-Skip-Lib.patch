From 0a9a218865534f6b94eef63c9fd41cf86948dc86 Mon Sep 17 00:00:00 2001
From: mamingy2 <mingyang.ma@intel.com>
Date: Fri, 9 Jun 2023 14:58:08 +0800
Subject: [PATCH 3/4] Add Skip Lib

---
 CMakeLists.txt                     |    3 +-
 Makefile                           |    2 +-
 source/Lib/SkipLib/AnnexBread.cpp  |  207 ++
 source/Lib/SkipLib/AnnexBread.h    |  191 +
 source/Lib/SkipLib/BinDecoder.cpp  |  348 ++
 source/Lib/SkipLib/BinDecoder.h    |  112 +
 source/Lib/SkipLib/BinEncoder.cpp  |  452 +++
 source/Lib/SkipLib/BinEncoder.h    |  300 ++
 source/Lib/SkipLib/CABACReader.cpp | 3679 ++++++++++++++++++++
 source/Lib/SkipLib/CABACReader.h   |  182 +
 source/Lib/SkipLib/CABACWriter.cpp | 3581 +++++++++++++++++++
 source/Lib/SkipLib/CABACWriter.h   |  223 ++
 source/Lib/SkipLib/CMakeLists.txt  |   46 +
 source/Lib/SkipLib/DecCu.cpp       | 1021 ++++++
 source/Lib/SkipLib/DecCu.h         |  105 +
 source/Lib/SkipLib/DecLib.cpp      | 4180 ++++++++++++++++++++++
 source/Lib/SkipLib/DecLib.h        |  412 +++
 source/Lib/SkipLib/DecSlice.cpp    |  343 ++
 source/Lib/SkipLib/DecSlice.h      |   80 +
 source/Lib/SkipLib/NALread.cpp     |  177 +
 source/Lib/SkipLib/NALread.h       |   73 +
 source/Lib/SkipLib/SEIread.cpp     | 3302 ++++++++++++++++++
 source/Lib/SkipLib/SEIread.h       |  152 +
 source/Lib/SkipLib/VLCReader.cpp   | 5228 ++++++++++++++++++++++++++++
 source/Lib/SkipLib/VLCReader.h     |  149 +
 source/Lib/SkipLib/VLCWriter.cpp   | 3173 +++++++++++++++++
 source/Lib/SkipLib/VLCWriter.h     |  142 +
 27 files changed, 27861 insertions(+), 2 deletions(-)
 create mode 100644 source/Lib/SkipLib/AnnexBread.cpp
 create mode 100644 source/Lib/SkipLib/AnnexBread.h
 create mode 100644 source/Lib/SkipLib/BinDecoder.cpp
 create mode 100644 source/Lib/SkipLib/BinDecoder.h
 create mode 100644 source/Lib/SkipLib/BinEncoder.cpp
 create mode 100644 source/Lib/SkipLib/BinEncoder.h
 create mode 100644 source/Lib/SkipLib/CABACReader.cpp
 create mode 100644 source/Lib/SkipLib/CABACReader.h
 create mode 100644 source/Lib/SkipLib/CABACWriter.cpp
 create mode 100644 source/Lib/SkipLib/CABACWriter.h
 create mode 100644 source/Lib/SkipLib/CMakeLists.txt
 create mode 100644 source/Lib/SkipLib/DecCu.cpp
 create mode 100644 source/Lib/SkipLib/DecCu.h
 create mode 100644 source/Lib/SkipLib/DecLib.cpp
 create mode 100644 source/Lib/SkipLib/DecLib.h
 create mode 100644 source/Lib/SkipLib/DecSlice.cpp
 create mode 100644 source/Lib/SkipLib/DecSlice.h
 create mode 100644 source/Lib/SkipLib/NALread.cpp
 create mode 100644 source/Lib/SkipLib/NALread.h
 create mode 100644 source/Lib/SkipLib/SEIread.cpp
 create mode 100644 source/Lib/SkipLib/SEIread.h
 create mode 100644 source/Lib/SkipLib/VLCReader.cpp
 create mode 100644 source/Lib/SkipLib/VLCReader.h
 create mode 100644 source/Lib/SkipLib/VLCWriter.cpp
 create mode 100644 source/Lib/SkipLib/VLCWriter.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index 284631a8..c0b77af6 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -62,7 +62,7 @@ include( ${CMAKE_SOURCE_DIR}/cmake/CMakeBuild/cmake/modules/BBuildEnv.cmake )
 # bb_enable_warnings( gcc -Wno-unused-variable )
 # bb_enable_warnings( gcc-4.8 warnings-as-errors -Wno-unused-variable )
 # for gcc 8.2:
-bb_enable_warnings( gcc warnings-as-errors -Wno-sign-compare)
+# bb_enable_warnings( gcc warnings-as-errors -Wno-sign-compare)
 
 if( XCODE )
   bb_enable_warnings( clang warnings-as-errors
@@ -132,6 +132,7 @@ endif()
 add_subdirectory( "source/Lib/DecoderAnalyserLib" )
 add_subdirectory( "source/Lib/DecoderLib" )
 add_subdirectory( "source/Lib/EncoderLib" )
+add_subdirectory( "source/Lib/SkipLib" )
 add_subdirectory( "source/Lib/Utilities" )
 
 add_subdirectory( "source/App/DecoderAnalyserApp" )
diff --git a/Makefile b/Makefile
index 1b3655c6..669f63de 100644
--- a/Makefile
+++ b/Makefile
@@ -16,7 +16,7 @@ BUILD_SCRIPT := $(CURDIR)/cmake/CMakeBuild/bin/cmake.py
 #  make <project>-cp  => clean + build variant=relwithdebinfo
 #
 
-TARGETS := CommonLib DecoderAnalyserApp DecoderAnalyserLib DecoderApp DecoderLib 
+TARGETS := CommonLib DecoderAnalyserApp DecoderAnalyserLib DecoderApp DecoderLib SkipLib
 TARGETS += EncoderApp EncoderLib Utilities SEIRemovalApp StreamMergeApp
 
 ifeq ($(OS),Windows_NT)
diff --git a/source/Lib/SkipLib/AnnexBread.cpp b/source/Lib/SkipLib/AnnexBread.cpp
new file mode 100644
index 00000000..101342d3
--- /dev/null
+++ b/source/Lib/SkipLib/AnnexBread.cpp
@@ -0,0 +1,207 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ \file     AnnexBread.cpp
+ \brief    reading functions for Annex B byte streams
+ */
+
+
+#include <stdint.h>
+#include <vector>
+#include "AnnexBread.h"
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#include "CommonLib/CodingStatistics.h"
+#endif
+
+//! \ingroup DecoderLib
+//! \{
+
+/**
+ * Parse an AVC AnnexB Bytestream bs to extract a single nalUnit
+ * while accumulating bytestream statistics into stats.
+ *
+ * If EOF occurs while trying to extract a NALunit, an exception
+ * of std::ios_base::failure is thrown.  The contsnts of stats will
+ * be correct at this point.
+ */
+static void _byteStreamNALUnit(InputByteStream &bs, std::vector<uint8_t> &nalUnit, AnnexBStats &stats)
+{
+  /* At the beginning of the decoding process, the decoder initialises its
+   * current position in the byte stream to the beginning of the byte stream.
+   * It then extracts and discards each leading_zero_8bits syntax element (if
+   * present), moving the current position in the byte stream forward one
+   * byte at a time, until the current position in the byte stream is such
+   * that the next four bytes in the bitstream form the four-byte sequence
+   * 0x00000001.
+   */
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::SStat &statBits=CodingStatistics::GetStatisticEP(STATS__NAL_UNIT_PACKING);
+#endif
+  while ((bs.eofBeforeNBytes(24/8) || bs.peekBytes(24/8) != 0x000001)
+  &&     (bs.eofBeforeNBytes(32/8) || bs.peekBytes(32/8) != 0x00000001))
+  {
+    uint8_t leading_zero_8bits = bs.readByte();
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#if EPBINCOUNT_FIX
+    statBits.bits+=8;
+#else
+    statBits.bits+=8; statBits.count++;
+#endif
+#endif
+    if(leading_zero_8bits != 0) { THROW( "Leading zero bits not zero" ); }
+    stats.m_numLeadingZero8BitsBytes++;
+  }
+
+  /* 1. When the next four bytes in the bitstream form the four-byte sequence
+   * 0x00000001, the next byte in the byte stream (which is a zero_byte
+   * syntax element) is extracted and discarded and the current position in
+   * the byte stream is set equal to the position of the byte following this
+   * discarded byte.
+   */
+  /* NB, the previous step guarantees this will succeed -- if EOF was
+   * encountered, an exception will stop execution getting this far */
+  if (bs.peekBytes(24/8) != 0x000001)
+  {
+    uint8_t zero_byte = bs.readByte();
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#if EPBINCOUNT_FIX
+    statBits.bits+=8;
+#else
+    statBits.bits+=8; statBits.count++;
+#endif
+#endif
+    CHECK( zero_byte != 0, "Zero byte not '0'" );
+    stats.m_numZeroByteBytes++;
+  }
+
+  /* 2. The next three-byte sequence in the byte stream (which is a
+   * start_code_prefix_one_3bytes) is extracted and discarded and the current
+   * position in the byte stream is set equal to the position of the byte
+   * following this three-byte sequence.
+   */
+  /* NB, (1) guarantees that the next three bytes are 0x00 00 01 */
+  uint32_t start_code_prefix_one_3bytes = bs.readBytes(24/8);
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#if EPBINCOUNT_FIX
+  statBits.bits+=24;
+#else
+  statBits.bits+=24; statBits.count+=3;
+#endif
+#endif
+  if (start_code_prefix_one_3bytes != 0x000001)
+  {
+    THROW("Invalid code prefix");
+  }
+  stats.m_numStartCodePrefixBytes += 3;
+
+  /* 3. NumBytesInNALunit is set equal to the number of bytes starting with
+   * the byte at the current position in the byte stream up to and including
+   * the last byte that precedes the location of any of the following
+   * conditions:
+   *   a. A subsequent byte-aligned three-byte sequence equal to 0x000000, or
+   *   b. A subsequent byte-aligned three-byte sequence equal to 0x000001, or
+   *   c. The end of the byte stream, as determined by unspecified means.
+   */
+  /* 4. NumBytesInNALunit bytes are removed from the bitstream and the
+   * current position in the byte stream is advanced by NumBytesInNALunit
+   * bytes. This sequence of bytes is nal_unit( NumBytesInNALunit ) and is
+   * decoded using the NAL unit decoding process
+   */
+  /* NB, (unsigned)x > 2 implies n!=0 && n!=1 */
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::SStat &bodyStats=CodingStatistics::GetStatisticEP(STATS__NAL_UNIT_TOTAL_BODY);
+#endif
+  while (bs.eofBeforeNBytes(24/8) || bs.peekBytes(24/8) > 2)
+  {
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+    uint8_t thebyte=bs.readByte();bodyStats.bits+=8;bodyStats.count++;
+    nalUnit.push_back(thebyte);
+#else
+    nalUnit.push_back(bs.readByte());
+#endif
+  }
+
+  /* 5. When the current position in the byte stream is:
+   *  - not at the end of the byte stream (as determined by unspecified means)
+   *  - and the next bytes in the byte stream do not start with a three-byte
+   *    sequence equal to 0x000001
+   *  - and the next bytes in the byte stream do not start with a four byte
+   *    sequence equal to 0x00000001,
+   * the decoder extracts and discards each trailing_zero_8bits syntax
+   * element, moving the current position in the byte stream forward one byte
+   * at a time, until the current position in the byte stream is such that:
+   *  - the next bytes in the byte stream form the four-byte sequence
+   *    0x00000001 or
+   *  - the end of the byte stream has been encountered (as determined by
+   *    unspecified means).
+   */
+  /* NB, (3) guarantees there are at least three bytes available or none */
+  while ((bs.eofBeforeNBytes(24/8) || bs.peekBytes(24/8) != 0x000001)
+  &&     (bs.eofBeforeNBytes(32/8) || bs.peekBytes(32/8) != 0x00000001))
+  {
+    uint8_t trailing_zero_8bits = bs.readByte();
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#if EPBINCOUNT_FIX
+    statBits.bits+=8;
+#else
+    statBits.bits+=8; statBits.count++;
+#endif
+#endif
+    CHECK( trailing_zero_8bits != 0, "Trailing zero bits not '0'" );
+    stats.m_numTrailingZero8BitsBytes++;
+  }
+}
+
+/**
+ * Parse an AVC AnnexB Bytestream bs to extract a single nalUnit
+ * while accumulating bytestream statistics into stats.
+ *
+ * Returns false if EOF was reached (NB, nalunit data may be valid),
+ *         otherwise true.
+ */
+bool byteStreamNALUnit(InputByteStream &bs, std::vector<uint8_t> &nalUnit, AnnexBStats &stats)
+{
+  bool eof = false;
+  try
+  {
+    _byteStreamNALUnit(bs, nalUnit, stats);
+  }
+  catch (...)
+  {
+    eof = true;
+  }
+  stats.m_numBytesInNALUnit = uint32_t(nalUnit.size());
+  return eof;
+}
+//! \}
diff --git a/source/Lib/SkipLib/AnnexBread.h b/source/Lib/SkipLib/AnnexBread.h
new file mode 100644
index 00000000..7d1c1520
--- /dev/null
+++ b/source/Lib/SkipLib/AnnexBread.h
@@ -0,0 +1,191 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ \file     AnnexBread.h
+ \brief    reading functions for Annex B byte streams
+ */
+
+#pragma once
+
+#include <cstdint>
+#include <istream>
+#include <vector>
+
+#include "CommonLib/CommonDef.h"
+
+//! \ingroup DecoderLib
+//! \{
+
+class InputByteStream
+{
+public:
+  /**
+   * Create a bytestream reader that will extract bytes from
+   * istream.
+   *
+   * NB, it isn't safe to access istream while in use by a
+   * InputByteStream.
+   *
+   * Side-effects: the exception mask of istream is set to eofbit
+   */
+  InputByteStream(std::istream &istream) : m_numFutureBytes(0), m_futureBytes(0), m_input(istream)
+  {
+    istream.exceptions(std::istream::eofbit | std::istream::badbit);
+  }
+
+  /**
+   * Reset the internal state.  Must be called if input stream is
+   * modified externally to this class
+   */
+  void reset()
+  {
+    m_numFutureBytes = 0;
+    m_futureBytes    = 0;
+  }
+
+  /**
+   * returns true if an EOF will be encountered within the next
+   * n bytes.
+   */
+  bool eofBeforeNBytes(uint32_t n)
+  {
+    CHECK(n > 4, "Unsupported look-ahead value");
+    if (m_numFutureBytes >= n)
+    {
+      return false;
+    }
+
+    n -= m_numFutureBytes;
+    try
+    {
+      for (uint32_t i = 0; i < n; i++)
+      {
+        m_futureBytes = (m_futureBytes << 8) | m_input.get();
+        m_numFutureBytes++;
+      }
+    }
+    catch (...)
+    {
+      return true;
+    }
+    return false;
+  }
+
+  /**
+   * return the next n bytes in the stream without advancing
+   * the stream pointer.
+   *
+   * Returns: an unsigned integer representing an n byte bigendian
+   * word.
+   *
+   * If an attempt is made to read past EOF, an n-byte word is
+   * returned, but the portion that required input bytes beyond EOF
+   * is undefined.
+   *
+   */
+  uint32_t peekBytes(uint32_t n)
+  {
+    eofBeforeNBytes(n);
+    return m_futureBytes >> 8 * (m_numFutureBytes - n);
+  }
+
+  /**
+   * consume and return one byte from the input.
+   *
+   * If bytestream is already at EOF prior to a call to readByte(),
+   * an exception std::ios_base::failure is thrown.
+   */
+  uint8_t readByte()
+  {
+    if (m_numFutureBytes == 0)
+    {
+      uint8_t byte = m_input.get();
+      return byte;
+    }
+    m_numFutureBytes--;
+    const uint8_t wantedByte = m_futureBytes >> 8 * m_numFutureBytes;
+    m_futureBytes &= ~(0xff << 8 * m_numFutureBytes);
+    return wantedByte;
+  }
+
+  /**
+   * consume and return n bytes from the input.  n bytes from
+   * bytestream are interpreted as bigendian when assembling
+   * the return value.
+   */
+  uint32_t readBytes(uint32_t n)
+  {
+    uint32_t val = 0;
+    for (uint32_t i = 0; i < n; i++)
+    {
+      val = (val << 8) | readByte();
+    }
+    return val;
+  }
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  uint32_t getNumBufferedBytes() const { return m_numFutureBytes; }
+#endif
+
+private:
+  uint32_t      m_numFutureBytes; /* number of valid bytes in m_futureBytes */
+  uint32_t      m_futureBytes;    /* bytes that have been peeked */
+  std::istream &m_input;          /* Input stream to read from */
+};
+
+/**
+ * Statistics associated with AnnexB bytestreams
+ */
+struct AnnexBStats
+{
+  uint32_t m_numLeadingZero8BitsBytes;
+  uint32_t m_numZeroByteBytes;
+  uint32_t m_numStartCodePrefixBytes;
+  uint32_t m_numBytesInNALUnit;
+  uint32_t m_numTrailingZero8BitsBytes;
+
+  AnnexBStats& operator+=(const AnnexBStats& rhs)
+  {
+    this->m_numLeadingZero8BitsBytes += rhs.m_numLeadingZero8BitsBytes;
+    this->m_numZeroByteBytes += rhs.m_numZeroByteBytes;
+    this->m_numStartCodePrefixBytes += rhs.m_numStartCodePrefixBytes;
+    this->m_numBytesInNALUnit += rhs.m_numBytesInNALUnit;
+    this->m_numTrailingZero8BitsBytes += rhs.m_numTrailingZero8BitsBytes;
+    return *this;
+  }
+};
+
+bool byteStreamNALUnit(InputByteStream& bs, std::vector<uint8_t>& nalUnit, AnnexBStats& stats);
+
+//! \}
diff --git a/source/Lib/SkipLib/BinDecoder.cpp b/source/Lib/SkipLib/BinDecoder.cpp
new file mode 100644
index 00000000..3cb59d1f
--- /dev/null
+++ b/source/Lib/SkipLib/BinDecoder.cpp
@@ -0,0 +1,348 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     BinDecoder.cpp
+ *  \brief    Low level binary symbol writer
+ */
+
+
+#include "BinDecoder.h"
+#include "CommonLib/Rom.h"
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#include "CommonLib/CodingStatistics.h"
+#endif
+
+#include "CommonLib/dtrace_next.h"
+
+template<class BinProbModel>
+BinDecoderBase::BinDecoderBase(const BinProbModel *dummy)
+  : Ctx(dummy), m_bitstream(nullptr), m_range(0), m_value(0), m_bitsNeeded(0)
+{}
+
+void BinDecoderBase::init( InputBitstream* bitstream )
+{
+  m_bitstream = bitstream;
+}
+
+void BinDecoderBase::uninit()
+{
+  m_bitstream = nullptr;
+}
+
+void BinDecoderBase::start()
+{
+  CHECK(m_bitstream->getNumBitsUntilByteAligned(), "Bitstream is not byte aligned.");
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::UpdateCABACStat(STATS__CABAC_INITIALISATION, 512, 510, 0);
+#endif
+  m_range       = 510;
+  m_value       = (m_bitstream->readByte() << 8) + m_bitstream->readByte();
+  m_bitsNeeded  = -8;
+}
+
+void BinDecoderBase::finish()
+{
+  unsigned lastByte;
+  m_bitstream->peekPreviousByte(lastByte);
+  CHECK( ( ( lastByte << ( 8 + m_bitsNeeded ) ) & 0xff ) != 0x80,
+        "No proper stop/alignment pattern at end of CABAC stream." );
+}
+
+void BinDecoderBase::reset( int qp, int initId )
+{
+  Ctx::init( qp, initId );
+  start();
+}
+
+void BinDecoderBase::riceStatReset(int bitDepth, bool persistentRiceAdaptationEnabledFlag)
+{
+  Ctx::riceStatReset(bitDepth, persistentRiceAdaptationEnabledFlag);
+}
+
+unsigned BinDecoderBase::decodeBinEP()
+{
+  m_value += m_value;
+  if( ++m_bitsNeeded >= 0 )
+  {
+    m_value += m_bitstream->readByte();
+    m_bitsNeeded      = -8;
+  }
+
+  unsigned bin = 0;
+  unsigned scaledRange = m_range << 7;
+  if (m_value >= scaledRange)
+  {
+    m_value -= scaledRange;
+    bin        = 1;
+  }
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP( *ptype, 1, int(bin) );
+#endif
+  DTRACE(g_trace_ctx, D_CABAC, "%d  %d  EP=%d \n", DTRACE_GET_COUNTER(g_trace_ctx, D_CABAC), m_range, bin);
+  return bin;
+}
+
+unsigned BinDecoderBase::decodeBinsEP( unsigned numBins )
+{
+#if ENABLE_TRACING
+  int numBinsOrig = numBins;
+#endif
+
+  if (m_range == 256)
+  {
+    return decodeAlignedBinsEP( numBins );
+  }
+  unsigned remBins = numBins;
+  unsigned bins    = 0;
+  while(   remBins > 8 )
+  {
+    m_value              = (m_value << 8) + (m_bitstream->readByte() << (8 + m_bitsNeeded));
+    unsigned scaledRange = m_range << 15;
+    for( int i = 0; i < 8; i++ )
+    {
+      bins += bins;
+      scaledRange >>= 1;
+      if (m_value >= scaledRange)
+      {
+        bins    ++;
+        m_value -= scaledRange;
+      }
+    }
+    remBins -= 8;
+  }
+  m_bitsNeeded   += remBins;
+  m_value <<= remBins;
+  if( m_bitsNeeded >= 0 )
+  {
+    m_value += m_bitstream->readByte() << m_bitsNeeded;
+    m_bitsNeeded -= 8;
+  }
+  unsigned scaledRange = m_range << (remBins + 7);
+  for ( int i = 0; i < remBins; i++ )
+  {
+    bins += bins;
+    scaledRange >>= 1;
+    if (m_value >= scaledRange)
+    {
+      bins    ++;
+      m_value -= scaledRange;
+    }
+  }
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP( *ptype, numBins, int(bins) );
+#endif
+#if ENABLE_TRACING
+  for( int i = 0; i < numBinsOrig; i++ )
+  {
+    DTRACE(g_trace_ctx, D_CABAC, "%d  %d  EP=%d \n", DTRACE_GET_COUNTER(g_trace_ctx, D_CABAC), m_range,
+           (bins >> (numBinsOrig - 1 - i)) & 1);
+  }
+#endif
+  return bins;
+}
+
+unsigned BinDecoderBase::decodeRemAbsEP(unsigned goRicePar, unsigned cutoff, int maxLog2TrDynamicRange)
+{
+  unsigned prefix = 0;
+  {
+    const unsigned  maxPrefix = 32 - maxLog2TrDynamicRange;
+    unsigned        codeWord = 0;
+    do
+    {
+      prefix++;
+      codeWord = decodeBinEP();
+    } while (codeWord && prefix < maxPrefix);
+    prefix -= 1 - codeWord;
+  }
+
+  unsigned length = goRicePar, offset;
+  if (prefix < cutoff)
+  {
+    offset = prefix << goRicePar;
+  }
+  else
+  {
+    offset = (((1 << (prefix - cutoff)) + cutoff - 1) << goRicePar);
+    {
+      length += (prefix == (32 - maxLog2TrDynamicRange) ? maxLog2TrDynamicRange - goRicePar : prefix - cutoff);
+    }
+  }
+  return offset + decodeBinsEP(length);
+}
+
+unsigned BinDecoderBase::decodeBinTrm()
+{
+  m_range -= 2;
+  unsigned scaledRange = m_range << 7;
+  if (m_value >= scaledRange)
+  {
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+    CodingStatistics::UpdateCABACStat(STATS__CABAC_TRM_BITS, m_range + 2, 2, 1);
+    CodingStatistics::IncrementStatisticEP( STATS__BYTE_ALIGNMENT_BITS, -m_bitsNeeded, 0 );
+#endif
+    return 1;
+  }
+  else
+  {
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+    CodingStatistics::UpdateCABACStat(STATS__CABAC_TRM_BITS, m_range + 2, m_range, 0);
+#endif
+    if (m_range < 256)
+    {
+      m_range += m_range;
+      m_value += m_value;
+      if( ++m_bitsNeeded == 0 )
+      {
+        m_value += m_bitstream->readByte();
+        m_bitsNeeded  = -8;
+      }
+    }
+    return 0;
+  }
+}
+
+void BinDecoderBase::align()
+{
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::UpdateCABACStat(STATS__CABAC_EP_BIT_ALIGNMENT, m_range, 256, 0);
+#endif
+  m_range = 256;
+}
+
+unsigned BinDecoderBase::decodeAlignedBinsEP( unsigned numBins )
+{
+#if ENABLE_TRACING
+  int numBinsOrig = numBins;
+#endif
+  unsigned remBins = numBins;
+  unsigned bins    = 0;
+  while(   remBins > 0 )
+  {
+    // The MSB of m_value is known to be 0 because range is 256. Therefore:
+    //   > The comparison against the symbol range of 128 is simply a test on the next-most-significant bit
+    //   > "Subtracting" the symbol range if the decoded bin is 1 simply involves clearing that bit.
+    //  As a result, the required bins are simply the <binsToRead> next-most-significant bits of m_value
+    //  (m_value is stored MSB-aligned in a 16-bit buffer - hence the shift of 15)
+    //
+    //    m_value = |0|V|V|V|V|V|V|V|V|B|B|B|B|B|B|B|
+    //    (V = usable bit, B = potential buffered bit (buffer refills when m_bitsNeeded >= 0))
+    //
+    unsigned binsToRead = std::min<unsigned>( remBins, 8 ); //read bytes if able to take advantage of the system's byte-read function
+    unsigned binMask    = ( 1 << binsToRead ) - 1;
+    unsigned newBins    = (m_value >> (15 - binsToRead)) & binMask;
+    bins                = ( bins    << binsToRead) | newBins;
+    m_value             = (m_value << binsToRead) & 0x7FFF;
+    remBins            -= binsToRead;
+    m_bitsNeeded       += binsToRead;
+    if( m_bitsNeeded >= 0 )
+    {
+      m_value |= m_bitstream->readByte() << m_bitsNeeded;
+      m_bitsNeeded     -= 8;
+    }
+  }
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP( *ptype, numBins, int(bins) );
+#endif
+#if ENABLE_TRACING
+  for( int i = 0; i < numBinsOrig; i++ )
+  {
+    DTRACE(g_trace_ctx, D_CABAC, "%d  %d  EP=%d \n", DTRACE_GET_COUNTER(g_trace_ctx, D_CABAC), m_range,
+           (bins >> (numBinsOrig - 1 - i)) & 1);
+  }
+#endif
+  return bins;
+}
+
+template<class BinProbModel>
+TBinDecoder<BinProbModel>::TBinDecoder()
+  : BinDecoderBase(static_cast<const BinProbModel *>(nullptr)), m_ctx(static_cast<CtxStore<BinProbModel> &>(*this))
+{}
+
+template <class BinProbModel>
+unsigned TBinDecoder<BinProbModel>::decodeBin( unsigned ctxId )
+{
+  BinProbModel &probModel = m_ctx[ctxId];
+  unsigned      bin       = probModel.mps();
+  uint32_t      lpsRange  = probModel.getLPS(m_range);
+
+  DTRACE(g_trace_ctx, D_CABAC, "%d %d %d  [%d:%d]  %2d(MPS=%d)  ", DTRACE_GET_COUNTER(g_trace_ctx, D_CABAC), ctxId,
+         m_range, m_range - lpsRange, lpsRange, (unsigned int) (probModel.state()),
+         m_value < ((m_range - lpsRange) << 7));
+
+  m_range -= lpsRange;
+  uint32_t scaledRange = m_range << 7;
+  if (m_value < scaledRange)
+  {
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+    CodingStatistics::UpdateCABACStat(*ptype, m_range + lpsRange, m_range, int(bin));
+#endif
+    // MPS path
+    if (m_range < 256)
+    {
+      int numBits = probModel.getRenormBitsRange(m_range);
+      m_range <<= numBits;
+      m_value <<= numBits;
+      m_bitsNeeded += numBits;
+      if( m_bitsNeeded >= 0 )
+      {
+        m_value += m_bitstream->readByte() << m_bitsNeeded;
+        m_bitsNeeded -= 8;
+      }
+    }
+  }
+  else
+  {
+    bin = 1 - bin;
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+    CodingStatistics::UpdateCABACStat(*ptype, m_range + lpsRange, lpsRange, int(bin));
+#endif
+    // LPS path
+    int numBits = probModel.getRenormBitsLPS(lpsRange);
+    m_value -= scaledRange;
+    m_value = m_value << numBits;
+    m_range = lpsRange << numBits;
+    m_bitsNeeded += numBits;
+    if( m_bitsNeeded >= 0 )
+    {
+      m_value += m_bitstream->readByte() << m_bitsNeeded;
+      m_bitsNeeded -= 8;
+    }
+  }
+  probModel.update(bin);
+  //DTRACE_DECR_COUNTER( g_trace_ctx, D_CABAC );
+  DTRACE_WITHOUT_COUNT( g_trace_ctx, D_CABAC, "  -  " "%d" "\n", bin );
+  return  bin;
+}
+
+template class TBinDecoder<BinProbModel_Std>;
+
diff --git a/source/Lib/SkipLib/BinDecoder.h b/source/Lib/SkipLib/BinDecoder.h
new file mode 100644
index 00000000..91298f77
--- /dev/null
+++ b/source/Lib/SkipLib/BinDecoder.h
@@ -0,0 +1,112 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     BinDecoder.h
+ *  \brief    Low level binary symbol writer
+ */
+
+#pragma once
+
+
+#include "CommonLib/Contexts.h"
+#include "CommonLib/BitStream.h"
+
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+class CodingStatisticsClassType;
+#endif
+
+
+
+class BinDecoderBase : public Ctx
+{
+protected:
+  template <class BinProbModel>
+  BinDecoderBase ( const BinProbModel* dummy );
+public:
+  ~BinDecoderBase() {}
+public:
+  void      init    ( InputBitstream* bitstream );
+  void      uninit  ();
+  void      start   ();
+  void      finish  ();
+  void      reset   ( int qp, int initId );
+  void      riceStatReset(int bitDepth, bool persistentRiceAdaptationEnabledFlag);
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  void      set     ( const CodingStatisticsClassType& type) { ptype = &type; }
+#endif
+
+public:
+  virtual unsigned  decodeBin           ( unsigned ctxId    ) = 0;
+
+public:
+  unsigned          decodeBinEP         ();
+  unsigned          decodeBinsEP        ( unsigned numBins  );
+  unsigned          decodeRemAbsEP      ( unsigned goRicePar, unsigned cutoff, int maxLog2TrDynamicRange );
+  unsigned          decodeBinTrm        ();
+  void              align               ();
+  unsigned          getNumBitsRead()
+  {
+    return m_bitstream->getNumBitsRead() + m_bitsNeeded;
+  }
+
+private:
+  unsigned          decodeAlignedBinsEP ( unsigned numBins  );
+protected:
+  InputBitstream   *m_bitstream;
+  uint32_t          m_range;
+  uint32_t          m_value;
+  int32_t           m_bitsNeeded;
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  const CodingStatisticsClassType* ptype;
+#endif
+};
+
+
+
+template <class BinProbModel>
+class TBinDecoder : public BinDecoderBase
+{
+public:
+  TBinDecoder ();
+  ~TBinDecoder() {}
+  unsigned decodeBin ( unsigned ctxId );
+private:
+  CtxStore<BinProbModel> &m_ctx;
+};
+
+
+
+typedef TBinDecoder<BinProbModel_Std>   BinDecoder_Std;
+
+
diff --git a/source/Lib/SkipLib/BinEncoder.cpp b/source/Lib/SkipLib/BinEncoder.cpp
new file mode 100644
index 00000000..8e8dee85
--- /dev/null
+++ b/source/Lib/SkipLib/BinEncoder.cpp
@@ -0,0 +1,452 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#include "BinEncoder.h"
+
+#include "CommonLib/Rom.h"
+#include "CommonLib/dtrace_next.h"
+
+BinCounter::BinCounter()
+  : m_ctxBinsCodedBuffer(Ctx::NumberOfContexts)
+  , m_numBinsCtx(m_ctxBinsCodedBuffer.data())
+  , m_numBinsEP(0)
+  , m_numBinsTrm(0)
+{}
+
+
+void BinCounter::reset()
+{
+  for (std::size_t k = 0; k < m_ctxBinsCodedBuffer.size(); k++)
+  {
+    m_numBinsCtx[k] = 0;
+  }
+  m_numBinsEP  = 0;
+  m_numBinsTrm = 0;
+}
+
+
+uint32_t BinCounter::getAll() const
+{
+  uint32_t count = m_numBinsEP + m_numBinsTrm;
+  for (std::size_t k = 0; k < m_ctxBinsCodedBuffer.size(); k++)
+  {
+    count += m_numBinsCtx[k];
+  }
+  return count;
+}
+
+template<class BinProbModel>
+BinEncoderBase::BinEncoderBase(const BinProbModel *dummy)
+  : BinEncIf(dummy), m_bitstream(nullptr), m_low(0), m_range(0), m_bufferedByte(0), m_numBufferedBytes(0), m_bitsLeft(0)
+{}
+
+void BinEncoderBase::init( OutputBitstream* bitstream )
+{
+  m_bitstream = bitstream;
+}
+
+void BinEncoderBase::uninit()
+{
+  m_bitstream = nullptr;
+}
+
+void BinEncoderBase::start()
+{
+  m_low               = 0;
+  m_range             = 510;
+  m_bufferedByte      = 0xff;
+  m_numBufferedBytes  = 0;
+  m_bitsLeft          = 23;
+  BinCounter::reset();
+  m_binStore.reset();
+}
+
+void BinEncoderBase::finish()
+{
+  if (m_low >> (32 - m_bitsLeft))
+  {
+    m_bitstream->write(m_bufferedByte + 1, 8);
+    while( m_numBufferedBytes > 1 )
+    {
+      m_bitstream->write(0x00, 8);
+      m_numBufferedBytes--;
+    }
+    m_low -= 1 << (32 - m_bitsLeft);
+  }
+  else
+  {
+    if( m_numBufferedBytes > 0 )
+    {
+      m_bitstream->write(m_bufferedByte, 8);
+    }
+    while( m_numBufferedBytes > 1 )
+    {
+      m_bitstream->write(0xff, 8);
+      m_numBufferedBytes--;
+    }
+  }
+  m_bitstream->write(m_low >> 8, 24 - m_bitsLeft);
+}
+
+void BinEncoderBase::restart()
+{
+  m_low               = 0;
+  m_range             = 510;
+  m_bufferedByte      = 0xff;
+  m_numBufferedBytes  = 0;
+  m_bitsLeft          = 23;
+}
+
+void BinEncoderBase::reset( int qp, int initId )
+{
+  Ctx::init( qp, initId );
+  start();
+}
+
+void BinEncoderBase::resetBits()
+{
+  m_low               = 0;
+  m_bufferedByte      = 0xff;
+  m_numBufferedBytes  = 0;
+  m_bitsLeft          = 23;
+  BinCounter::reset();
+}
+
+void BinEncoderBase::encodeBinEP( unsigned bin )
+{
+  DTRACE(g_trace_ctx, D_CABAC, "%d  %d  EP=%d \n", DTRACE_GET_COUNTER(g_trace_ctx, D_CABAC), m_range, bin);
+
+  BinCounter::addEP();
+  m_low <<= 1;
+  if( bin )
+  {
+    m_low += m_range;
+  }
+  m_bitsLeft--;
+  if( m_bitsLeft < 12 )
+  {
+    writeOut();
+  }
+}
+
+void BinEncoderBase::encodeBinsEP( unsigned bins, unsigned numBins )
+{
+  for(int i = 0; i < numBins; i++)
+  {
+    DTRACE(g_trace_ctx, D_CABAC, "%d  %d  EP=%d \n", DTRACE_GET_COUNTER(g_trace_ctx, D_CABAC), m_range,
+           (bins >> (numBins - 1 - i)) & 1);
+  }
+
+  BinCounter::addEP( numBins );
+  if (m_range == 256)
+  {
+    encodeAlignedBinsEP( bins, numBins );
+    return;
+  }
+  while( numBins > 8 )
+  {
+    numBins          -= 8;
+    unsigned pattern  = bins >> numBins;
+    m_low <<= 8;
+    m_low += m_range * pattern;
+    bins             -= pattern << numBins;
+    m_bitsLeft       -= 8;
+    if( m_bitsLeft < 12 )
+    {
+      writeOut();
+    }
+  }
+  m_low <<= numBins;
+  m_low += m_range * bins;
+  m_bitsLeft -= numBins;
+  if( m_bitsLeft < 12 )
+  {
+    writeOut();
+  }
+}
+
+void BinEncoderBase::encodeRemAbsEP(unsigned bins, unsigned goRicePar, unsigned cutoff, int maxLog2TrDynamicRange)
+{
+  const unsigned threshold = cutoff << goRicePar;
+  if (bins < threshold)
+  {
+    const unsigned bitMask = (1 << goRicePar) - 1;
+    const unsigned length = (bins >> goRicePar) + 1;
+    encodeBinsEP((1 << length) - 2, length);
+    encodeBinsEP(bins & bitMask, goRicePar);
+  }
+  else
+  {
+    const unsigned  maxPrefixLength = 32 - cutoff - maxLog2TrDynamicRange;
+    unsigned        prefixLength = 0;
+    unsigned        codeValue = (bins >> goRicePar) - cutoff;
+    unsigned        suffixLength;
+    if (codeValue >= ((1 << maxPrefixLength) - 1))
+    {
+      prefixLength = maxPrefixLength;
+      suffixLength = maxLog2TrDynamicRange;
+    }
+    else
+    {
+      while (codeValue > ((2 << prefixLength) - 2))
+      {
+        prefixLength++;
+      }
+      suffixLength = prefixLength + goRicePar + 1; //+1 for the separator bit
+    }
+    const unsigned totalPrefixLength = prefixLength + cutoff;
+    const unsigned bitMask = (1 << goRicePar) - 1;
+    const unsigned prefix = (1 << totalPrefixLength) - 1;
+    const unsigned suffix = ((codeValue - ((1 << prefixLength) - 1)) << goRicePar) | (bins & bitMask);
+    encodeBinsEP(prefix, totalPrefixLength); //prefix
+    encodeBinsEP(suffix, suffixLength); //separator, suffix, and rParam bits
+  }
+}
+
+void BinEncoderBase::encodeBinTrm( unsigned bin )
+{
+  BinCounter::addTrm();
+  m_range -= 2;
+  if( bin )
+  {
+    m_low += m_range;
+    m_low <<= 7;
+    m_range = 2 << 7;
+    m_bitsLeft -= 7;
+  }
+  else if (m_range >= 256)
+  {
+    return;
+  }
+  else
+  {
+    m_low <<= 1;
+    m_range <<= 1;
+    m_bitsLeft--;
+  }
+  if( m_bitsLeft < 12 )
+  {
+    writeOut();
+  }
+}
+
+
+void BinEncoderBase::align()
+{
+  m_range = 256;
+}
+
+
+void BinEncoderBase::encodeAlignedBinsEP( unsigned bins, unsigned numBins )
+{
+  unsigned remBins = numBins;
+  while( remBins > 0 )
+  {
+    //The process of encoding an EP bin is the same as that of coding a normal
+    //bin where the symbol ranges for 1 and 0 are both half the range:
+    //
+    //  low = (low + range/2) << 1       (to encode a 1)
+    //  low =  low            << 1       (to encode a 0)
+    //
+    //  i.e.
+    //  low = (low + (bin * range/2)) << 1
+    //
+    //  which is equivalent to:
+    //
+    //  low = (low << 1) + (bin * range)
+    //
+    //  this can be generalised for multiple bins, producing the following expression:
+    //
+    unsigned binsToCode = std::min<unsigned>( remBins, 8); //code bytes if able to take advantage of the system's byte-write function
+    unsigned binMask    = ( 1 << binsToCode ) - 1;
+    unsigned newBins    = ( bins >> ( remBins - binsToCode ) ) & binMask;
+    m_low               = (m_low << binsToCode) + (newBins << 8);   // range is known to be 256
+    remBins            -= binsToCode;
+    m_bitsLeft         -= binsToCode;
+    if( m_bitsLeft < 12 )
+    {
+      writeOut();
+    }
+  }
+}
+
+void BinEncoderBase::writeOut()
+{
+  unsigned leadByte = m_low >> (24 - m_bitsLeft);
+  m_bitsLeft       += 8;
+  m_low &= 0xffffffffu >> m_bitsLeft;
+  if( leadByte == 0xff )
+  {
+    m_numBufferedBytes++;
+  }
+  else
+  {
+    if( m_numBufferedBytes > 0 )
+    {
+      unsigned carry  = leadByte >> 8;
+      unsigned byte   = m_bufferedByte + carry;
+      m_bufferedByte  = leadByte & 0xff;
+      m_bitstream->write(byte, 8);
+      byte            = ( 0xff + carry ) & 0xff;
+      while( m_numBufferedBytes > 1 )
+      {
+        m_bitstream->write(byte, 8);
+        m_numBufferedBytes--;
+      }
+    }
+    else
+    {
+      m_numBufferedBytes  = 1;
+      m_bufferedByte      = leadByte;
+    }
+  }
+}
+
+template<class BinProbModel>
+TBinEncoder<BinProbModel>::TBinEncoder()
+  : BinEncoderBase(static_cast<const BinProbModel *>(nullptr)), m_ctx(static_cast<CtxStore<BinProbModel> &>(*this))
+{}
+
+template <class BinProbModel>
+void TBinEncoder<BinProbModel>::encodeBin( unsigned bin, unsigned ctxId )
+{
+  BinCounter::addCtx( ctxId );
+  BinProbModel &probModel = m_ctx[ctxId];
+  uint32_t      lpsRange  = probModel.getLPS(m_range);
+
+  DTRACE(g_trace_ctx, D_CABAC, "%d %d %d  [%d:%d]  %2d(MPS=%d)    -  %d\n", DTRACE_GET_COUNTER(g_trace_ctx, D_CABAC),
+         ctxId, m_range, m_range - lpsRange, lpsRange, (unsigned int) (probModel.state()), bin == probModel.mps(), bin);
+
+  m_range -= lpsRange;
+  if (bin != probModel.mps())
+  {
+    int numBits = probModel.getRenormBitsLPS(lpsRange);
+    m_bitsLeft   -= numBits;
+    m_low += m_range;
+    m_low   = m_low << numBits;
+    m_range = lpsRange << numBits;
+    if( m_bitsLeft < 12 )
+    {
+      writeOut();
+    }
+  }
+  else
+  {
+    if (m_range < 256)
+    {
+      int numBits = probModel.getRenormBitsRange(m_range);
+      m_bitsLeft   -= numBits;
+      m_low <<= numBits;
+      m_range <<= numBits;
+      if( m_bitsLeft < 12 )
+      {
+        writeOut();
+      }
+    }
+  }
+  probModel.update(bin);
+  BinEncoderBase::m_binStore.addBin(bin, ctxId);
+}
+
+template <class BinProbModel>
+BinEncIf* TBinEncoder<BinProbModel>::getTestBinEncoder() const
+{
+  BinEncIf* testBinEncoder = 0;
+  if (m_binStore.inUse())
+  {
+    testBinEncoder = new TBinEncoder<BinProbModel>();
+  }
+  return testBinEncoder;
+}
+
+
+
+
+
+template <class BinProbModel>
+BitEstimatorBase::BitEstimatorBase( const BinProbModel* dummy )
+  : BinEncIf      ( dummy )
+{
+  m_estFracBits = 0;
+}
+
+void BitEstimatorBase::encodeRemAbsEP(unsigned bins, unsigned goRicePar, unsigned cutoff, int maxLog2TrDynamicRange)
+{
+  const unsigned threshold = cutoff << goRicePar;
+  if (bins < threshold)
+  {
+    m_estFracBits += BinProbModelBase::estFracBitsEP((bins >> goRicePar) + 1 + goRicePar);
+  }
+  else
+  {
+    const unsigned  maxPrefixLength = 32 - cutoff - maxLog2TrDynamicRange;
+    unsigned        prefixLength = 0;
+    unsigned        codeValue = (bins >> goRicePar) - cutoff;
+    unsigned        suffixLength;
+    if (codeValue >= ((1 << maxPrefixLength) - 1))
+    {
+      prefixLength = maxPrefixLength;
+      suffixLength = maxLog2TrDynamicRange;
+    }
+    else
+    {
+      while (codeValue > ((2 << prefixLength) - 2))
+      {
+        prefixLength++;
+      }
+      suffixLength = prefixLength + goRicePar + 1; //+1 for the separator bit
+    }
+    m_estFracBits += BinProbModelBase::estFracBitsEP(cutoff + prefixLength + suffixLength);
+  }
+}
+
+void BitEstimatorBase::align()
+{
+  static const uint64_t add   = BinProbModelBase::estFracBitsEP() - 1;
+  static const uint64_t mask  = ~add;
+  m_estFracBits += add;
+  m_estFracBits &= mask;
+}
+
+template<class BinProbModel>
+TBitEstimator<BinProbModel>::TBitEstimator()
+  : BitEstimatorBase(static_cast<const BinProbModel *>(nullptr)), m_ctx(static_cast<CtxStore<BinProbModel> &>(*this))
+{}
+
+
+
+template class TBinEncoder<BinProbModel_Std>;
+
+template class TBitEstimator<BinProbModel_Std>;
+
diff --git a/source/Lib/SkipLib/BinEncoder.h b/source/Lib/SkipLib/BinEncoder.h
new file mode 100644
index 00000000..88b35537
--- /dev/null
+++ b/source/Lib/SkipLib/BinEncoder.h
@@ -0,0 +1,300 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#pragma once
+
+#include "CommonLib/Contexts.h"
+#include "CommonLib/BitStream.h"
+#include "CommonLib/dtrace_next.h"
+
+
+
+class BinStore
+{
+public:
+  BinStore () : m_inUse(false), m_allocated(false)  {}
+  ~BinStore()                                       {}
+
+  void  reset   ()
+  {
+    if( m_inUse )
+    {
+      for( unsigned n = 0; n < Ctx::NumberOfContexts; n++ )
+      {
+        m_binBuffer[n].clear();
+      }
+    }
+  }
+  void  addBin  ( unsigned bin, unsigned ctxId )
+  {
+    if( m_inUse )
+    {
+      std::vector<bool>& binBuffer = m_binBuffer[ctxId];
+      if( binBuffer.size() < m_maxNumBins )
+      {
+        binBuffer.push_back( bin == 1 );
+      }
+    }
+  }
+
+  void                      setUse      ( bool useStore )         { m_inUse = useStore; if(m_inUse){xCheckAlloc();} }
+  bool                      inUse       ()                  const { return m_inUse; }
+  const std::vector<bool>&  getBinVector( unsigned ctxId )  const { return m_binBuffer[ctxId]; }
+
+private:
+  void  xCheckAlloc()
+  {
+    if( !m_allocated )
+    {
+      m_binBuffer.resize( Ctx::NumberOfContexts );
+      for( unsigned n = 0; n < Ctx::NumberOfContexts; n++ )
+      {
+        m_binBuffer[n].reserve( m_maxNumBins );
+      }
+      m_allocated = true;
+    }
+  }
+
+private:
+  static const std::size_t          m_maxNumBins = 100000;
+  bool                              m_inUse;
+  bool                              m_allocated;
+  std::vector< std::vector<bool> >  m_binBuffer;
+};
+
+
+class BinEncIf : public Ctx
+{
+protected:
+  template <class BinProbModel>
+  BinEncIf( const BinProbModel* dummy ) : Ctx( dummy ) {}
+public:
+  virtual ~BinEncIf() {}
+public:
+  virtual void      init              ( OutputBitstream* bitstream )        = 0;
+  virtual void      uninit            ()                                    = 0;
+  virtual void      start             ()                                    = 0;
+  virtual void      finish            ()                                    = 0;
+  virtual void      restart           ()                                    = 0;
+  virtual void      reset             ( int qp, int initId )                = 0;
+public:
+  virtual void      resetBits         ()                                    = 0;
+  virtual uint64_t  getEstFracBits    ()                              const = 0;
+  virtual unsigned  getNumBins        ( unsigned    ctxId )           const = 0;
+public:
+  virtual void      encodeBin         ( unsigned bin,   unsigned ctxId    ) = 0;
+  virtual void      encodeBinEP       ( unsigned bin                      ) = 0;
+  virtual void      encodeBinsEP      ( unsigned bins,  unsigned numBins  ) = 0;
+  virtual void      encodeRemAbsEP    ( unsigned bins,
+                                        unsigned goRicePar,
+                                        unsigned cutoff,
+                                        int      maxLog2TrDynamicRange    ) = 0;
+  virtual void      encodeBinTrm      ( unsigned bin                      ) = 0;
+  virtual void      align             ()                                    = 0;
+public:
+  virtual uint32_t  getNumBins        ()                                    = 0;
+  virtual bool      isEncoding        ()                                    = 0;
+  virtual unsigned  getNumWrittenBits ()                                    = 0;
+public:
+  virtual void            setBinStorage     ( bool b )                      = 0;
+  virtual const BinStore* getBinStore       ()                        const = 0;
+  virtual BinEncIf*       getTestBinEncoder ()                        const = 0;
+};
+
+
+
+class BinCounter
+{
+public:
+  BinCounter();
+  ~BinCounter() {}
+public:
+  void      reset   ();
+  void      addCtx(unsigned ctxId) { m_numBinsCtx[ctxId]++; }
+  void      addEP(unsigned num) { m_numBinsEP += num; }
+  void      addEP() { m_numBinsEP++; }
+  void      addTrm() { m_numBinsTrm++; }
+  uint32_t  getAll  ()                  const;
+  uint32_t  getCtx(unsigned ctxId) const { return m_numBinsCtx[ctxId]; }
+  uint32_t  getEP() const { return m_numBinsEP; }
+  uint32_t  getTrm() const { return m_numBinsTrm; }
+
+private:
+  std::vector<uint32_t> m_ctxBinsCodedBuffer;
+  uint32_t             *m_numBinsCtx;
+  uint32_t              m_numBinsEP;
+  uint32_t              m_numBinsTrm;
+};
+
+
+
+class BinEncoderBase : public BinEncIf, public BinCounter
+{
+protected:
+  template <class BinProbModel>
+  BinEncoderBase ( const BinProbModel* dummy );
+public:
+  ~BinEncoderBase() {}
+public:
+  void      init    ( OutputBitstream* bitstream );
+  void      uninit  ();
+  void      start   ();
+  void      finish  ();
+  void      restart ();
+  void      reset   ( int qp, int initId );
+  void      riceStatReset(int bitDepth, bool persistentRiceAdaptationEnabledFlag);
+public:
+  void      resetBits           ();
+  uint64_t  getEstFracBits      ()                    const { THROW( "not supported" ); return 0; }
+  unsigned  getNumBins          ( unsigned ctxId )    const { return BinCounter::getCtx(ctxId); }
+public:
+  void      encodeBinEP         ( unsigned bin                      );
+  void      encodeBinsEP        ( unsigned bins,  unsigned numBins  );
+  void      encodeRemAbsEP      ( unsigned bins,
+                                  unsigned goRicePar,
+                                  unsigned cutoff,
+                                  int      maxLog2TrDynamicRange    );
+  void      encodeBinTrm        ( unsigned bin                      );
+  void      align               ();
+  unsigned  getNumWrittenBits()
+  {
+    return (m_bitstream->getNumberOfWrittenBits() + 8 * m_numBufferedBytes + 23 - m_bitsLeft);
+  }
+
+public:
+  uint32_t  getNumBins          ()                          { return BinCounter::getAll(); }
+  bool      isEncoding          ()                          { return true; }
+protected:
+  void      encodeAlignedBinsEP ( unsigned bins,  unsigned numBins  );
+  void      writeOut            ();
+protected:
+  OutputBitstream        *m_bitstream;
+  uint32_t                m_low;
+  uint32_t                m_range;
+  uint32_t                m_bufferedByte;
+  int32_t                 m_numBufferedBytes;
+  int32_t                 m_bitsLeft;
+  BinStore                m_binStore;
+};
+
+
+
+template <class BinProbModel>
+class TBinEncoder : public BinEncoderBase
+{
+public:
+  TBinEncoder ();
+  ~TBinEncoder() {}
+  void  encodeBin   ( unsigned bin, unsigned ctxId );
+public:
+  void            setBinStorage(bool b) { m_binStore.setUse(b); }
+  const BinStore *getBinStore() const { return &m_binStore; }
+  BinEncIf*       getTestBinEncoder ()          const;
+private:
+  CtxStore<BinProbModel> &m_ctx;
+};
+
+
+
+
+
+class BitEstimatorBase : public BinEncIf
+{
+protected:
+  template <class BinProbModel>
+  BitEstimatorBase ( const BinProbModel* dummy );
+public:
+  ~BitEstimatorBase() {}
+public:
+  void      init                ( OutputBitstream* bitstream )        {}
+  void      uninit              ()                                    {}
+  void      start() { m_estFracBits = 0; }
+  void      finish              ()                                    {}
+  void      restart() { m_estFracBits = (m_estFracBits >> SCALE_BITS) << SCALE_BITS; }
+  void      reset(int qp, int initId)
+  {
+    Ctx::init(qp, initId);
+    m_estFracBits = 0;
+  }
+
+public:
+  void resetBits() { m_estFracBits = 0; }
+
+  uint64_t  getEstFracBits() const { return m_estFracBits; }
+  unsigned  getNumBins          ( unsigned ctxId )              const { THROW( "not supported for BitEstimator" ); return 0; }
+public:
+  void      encodeBinEP(unsigned bin) { m_estFracBits += BinProbModelBase::estFracBitsEP(); }
+  void      encodeBinsEP(unsigned bins, unsigned numBins) { m_estFracBits += BinProbModelBase::estFracBitsEP(numBins); }
+  void      encodeRemAbsEP      ( unsigned bins,
+                                  unsigned goRicePar,
+                                  unsigned cutoff,
+                                  int      maxLog2TrDynamicRange    );
+  void      align               ();
+public:
+  uint32_t  getNumBins          ()                                      { THROW("Not supported"); return 0; }
+  bool      isEncoding          ()                                      { return false; }
+  unsigned  getNumWrittenBits()
+  {
+    // THROW( "Not supported" );
+    return (uint32_t) 0 /*(m_estFracBits >> SCALE_BITS)*/;
+  }
+
+protected:
+  uint64_t m_estFracBits;
+};
+
+
+
+template <class BinProbModel>
+class TBitEstimator : public BitEstimatorBase
+{
+public:
+  TBitEstimator ();
+  ~TBitEstimator() {}
+  void            encodeBin(unsigned bin, unsigned ctxId) { m_ctx[ctxId].estFracBitsUpdate(bin, m_estFracBits); }
+  void            encodeBinTrm(unsigned bin) { m_estFracBits += BinProbModel::estFracBitsTrm(bin); }
+  void            setBinStorage     ( bool b )        {}
+  const BinStore* getBinStore       ()          const { return 0; }
+  BinEncIf*       getTestBinEncoder ()          const { return 0; }
+private:
+  CtxStore<BinProbModel> &m_ctx;
+};
+
+
+
+typedef TBinEncoder  <BinProbModel_Std>   BinEncoder_Std;
+
+typedef TBitEstimator<BinProbModel_Std>   BitEstimator_Std;
+
+
diff --git a/source/Lib/SkipLib/CABACReader.cpp b/source/Lib/SkipLib/CABACReader.cpp
new file mode 100644
index 00000000..54763416
--- /dev/null
+++ b/source/Lib/SkipLib/CABACReader.cpp
@@ -0,0 +1,3679 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     CABACReader.cpp
+ *  \brief    Reader for low level syntax
+ */
+
+#include "CABACReader.h"
+
+#include "CommonLib/CodingStructure.h"
+#include "CommonLib/TrQuant.h"
+#include "CommonLib/UnitTools.h"
+#include "CommonLib/SampleAdaptiveOffset.h"
+#include "CommonLib/dtrace_next.h"
+#include "CommonLib/Picture.h"
+#include "CommonLib/MatrixIntraPrediction.h"
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#include "CommonLib/CodingStatistics.h"
+#endif
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(x)                                                               \
+  const CodingStatisticsClassType CSCT(x);                                                                             \
+  m_binDecoder.set(CSCT)
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET2(x, y)                                                           \
+  const CodingStatisticsClassType CSCT(x, y);                                                                          \
+  m_binDecoder.set(CSCT)
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE(x, s)                                                       \
+  const CodingStatisticsClassType CSCT(x, s.width, s.height);                                                          \
+  m_binDecoder.set(CSCT)
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(x, s, z)                                                   \
+  const CodingStatisticsClassType CSCT(x, s.width, s.height, z);                                                       \
+  m_binDecoder.set(CSCT)
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_SET(x) m_binDecoder.set(x);
+#else
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(x)
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET2(x,y)
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE(x,s)
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(x,s,z)
+#define RExt__DECODER_DEBUG_BIT_STATISTICS_SET(x)
+#endif
+
+
+void CABACReader::initCtxModels( Slice& slice )
+{
+  SliceType sliceType  = slice.getSliceType();
+  int       qp         = slice.getSliceQp();
+  if( slice.getPPS()->getCabacInitPresentFlag() && slice.getCabacInitFlag() )
+  {
+    switch( sliceType )
+    {
+    case P_SLICE:           // change initialization table to B_SLICE initialization
+      sliceType = B_SLICE;
+      break;
+    case B_SLICE:           // change initialization table to P_SLICE initialization
+      sliceType = P_SLICE;
+      break;
+    default     :           // should not occur
+      THROW( "Invalid slice type" );
+      break;
+    }
+  }
+  m_binDecoder.reset(qp, (int) sliceType);
+  m_binDecoder.setBaseLevel(slice.getRiceBaseLevel());
+  m_binDecoder.riceStatReset(slice.getSPS()->getBitDepth(ChannelType::LUMA),
+                             slice.getSPS()->getSpsRangeExtension().getPersistentRiceAdaptationEnabledFlag());
+}
+
+
+//================================================================================
+//  clause 7.3.8.1
+//--------------------------------------------------------------------------------
+//    bool  terminating_bit()
+//    void  remaining_bytes( noTrailingBytesExpected )
+//================================================================================
+
+bool CABACReader::terminating_bit()
+{
+  if (m_binDecoder.decodeBinTrm())
+  {
+    m_binDecoder.finish();
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+    CodingStatistics::IncrementStatisticEP(STATS__TRAILING_BITS, m_bitstream->readOutTrailingBits(), 0);
+#else
+    m_bitstream->readOutTrailingBits();
+#endif
+    return true;
+  }
+  return false;
+}
+
+void CABACReader::remaining_bytes( bool noTrailingBytesExpected )
+{
+  if( noTrailingBytesExpected )
+  {
+    CHECK(0 != m_bitstream->getNumBitsLeft(), "Bits left when not supposed");
+  }
+  else
+  {
+    while (m_bitstream->getNumBitsLeft())
+    {
+      unsigned trailingNullByte = m_bitstream->readByte();
+      if( trailingNullByte != 0 )
+      {
+        THROW( "Trailing byte should be '0', but has a value of " << std::hex << trailingNullByte << std::dec << "\n" );
+      }
+    }
+  }
+}
+
+//================================================================================
+//  clause 7.3.8.2
+//--------------------------------------------------------------------------------
+//    void  coding_tree_unit( cs, area, qpL, qpC, ctuRsAddr )
+//================================================================================
+
+void CABACReader::coding_tree_unit(CodingStructure &cs, const UnitArea &area, EnumArray<int, ChannelType> &qps,
+                                   unsigned ctuRsAddr)
+{
+  CUCtx           cuCtx(qps[ChannelType::LUMA]);
+  QTBTPartitioner partitioner;
+
+  partitioner.initCtu(area, ChannelType::LUMA, *cs.slice);
+  cs.treeType = partitioner.treeType = TREE_D;
+  cs.modeType = partitioner.modeType = MODE_TYPE_ALL;
+
+
+  sao( cs, ctuRsAddr );
+  if (cs.sps->getALFEnabledFlag() && (cs.slice->getAlfEnabledFlag(COMPONENT_Y)))
+  {
+    const PreCalcValues& pcv = *cs.pcv;
+
+    const int frameWidthInCtus = pcv.widthInCtus;
+
+    const int ry = ctuRsAddr / frameWidthInCtus;
+    const int rx = ctuRsAddr - ry * frameWidthInCtus;
+
+    const Position pos(rx * cs.pcv->maxCUWidth, ry * cs.pcv->maxCUHeight);
+
+    const uint32_t curSliceIdx = cs.slice->getIndependentSliceIdx();
+    const uint32_t curTileIdx  = cs.pps->getTileIdx(pos);
+
+    const bool leftAvail =
+      cs.getCURestricted(pos.offset(-(int) pcv.maxCUWidth, 0), pos, curSliceIdx, curTileIdx, ChannelType::LUMA)
+      != nullptr;
+    const bool aboveAvail =
+      cs.getCURestricted(pos.offset(0, -(int) pcv.maxCUHeight), pos, curSliceIdx, curTileIdx, ChannelType::LUMA)
+      != nullptr;
+
+    const int leftCTUAddr  = leftAvail ? ctuRsAddr - 1 : -1;
+    const int aboveCTUAddr = aboveAvail ? ctuRsAddr - frameWidthInCtus : -1;
+
+    for( int compIdx = 0; compIdx < MAX_NUM_COMPONENT; compIdx++ )
+    {
+      if (cs.slice->getAlfEnabledFlag((ComponentID)compIdx))
+      {
+        AlfMode *alfModes = cs.slice->getPic()->getAlfModes(compIdx);
+        int ctx = 0;
+        ctx += leftCTUAddr > -1 ? (alfModes[leftCTUAddr] != AlfMode::OFF ? 1 : 0) : 0;
+        ctx += aboveCTUAddr > -1 ? (alfModes[aboveCTUAddr] != AlfMode::OFF ? 1 : 0) : 0;
+
+        RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__ALF);
+        const bool enabled = m_binDecoder.decodeBin(Ctx::alfCtbFlag(compIdx * 3 + ctx)) != 0;
+
+        if (!enabled)
+        {
+          alfModes[ctuRsAddr] = AlfMode::OFF;
+        }
+        else
+        {
+          if (isLuma((ComponentID) compIdx))
+          {
+            readAlfCtuFilterIndex(cs, ctuRsAddr);
+          }
+          else
+          {
+            const int apsIdx = cs.slice->getAlfApsIdChroma();
+            CHECK(cs.slice->getAlfAPSs()[apsIdx] == nullptr, "APS not initialized");
+            const AlfParam &alfParam = cs.slice->getAlfAPSs()[apsIdx]->getAlfAPSParam();
+            const int       numAlts  = alfParam.numAlternativesChroma;
+
+            uint8_t decoded = 0;
+            while (decoded < numAlts - 1 && m_binDecoder.decodeBin(Ctx::ctbAlfAlternative(compIdx - 1)))
+            {
+              ++ decoded;
+            }
+
+            alfModes[ctuRsAddr] = AlfMode::CHROMA0 + decoded;
+          }
+        }
+      }
+    }
+  }
+  if (cs.sps->getCCALFEnabledFlag())
+  {
+    for ( int compIdx = 1; compIdx < getNumberValidComponents( cs.pcv->chrFormat ); compIdx++ )
+    {
+      if (cs.slice->m_ccAlfFilterParam.ccAlfFilterEnabled[compIdx - 1])
+      {
+        const int filterCount = cs.slice->m_ccAlfFilterParam.ccAlfFilterCount[compIdx - 1];
+
+        const int ry = ctuRsAddr / cs.pcv->widthInCtus;
+        const int rx = ctuRsAddr % cs.pcv->widthInCtus;
+
+        const Position lumaPos(rx * cs.pcv->maxCUWidth, ry * cs.pcv->maxCUHeight);
+
+        ccAlfFilterControlIdc(cs, ComponentID(compIdx), ctuRsAddr, cs.slice->m_ccAlfFilterControl[compIdx - 1], lumaPos,
+                              filterCount);
+      }
+    }
+  }
+
+  if (CS::isDualITree(cs) && isChromaEnabled(cs.pcv->chrFormat) && cs.pcv->maxCUWidth > 64)
+  {
+    QTBTPartitioner chromaPartitioner;
+    chromaPartitioner.initCtu(area, ChannelType::CHROMA, *cs.slice);
+    CUCtx cuCtxChroma(qps[ChannelType::CHROMA]);
+    coding_tree(cs, partitioner, cuCtx, &chromaPartitioner, &cuCtxChroma);
+    qps[ChannelType::LUMA]   = cuCtx.qp;
+    qps[ChannelType::CHROMA] = cuCtxChroma.qp;
+  }
+  else
+  {
+    coding_tree(cs, partitioner, cuCtx);
+    qps[ChannelType::LUMA] = cuCtx.qp;
+    if (CS::isDualITree(cs) && isChromaEnabled(cs.pcv->chrFormat))
+    {
+      CUCtx cuCtxChroma(qps[ChannelType::CHROMA]);
+      partitioner.initCtu(area, ChannelType::CHROMA, *cs.slice);
+      coding_tree(cs, partitioner, cuCtxChroma);
+      qps[ChannelType::CHROMA] = cuCtxChroma.qp;
+    }
+  }
+
+  DTRACE_COND( ctuRsAddr == 0, g_trace_ctx, D_QP_PER_CTU, "\n%4d %2d", cs.picture->poc, cs.slice->getSliceQpBase() );
+  DTRACE(g_trace_ctx, D_QP_PER_CTU, " %3d", qps[ChannelType::LUMA] - cs.slice->getSliceQpBase());
+}
+
+void CABACReader::readAlfCtuFilterIndex(CodingStructure& cs, unsigned ctuRsAddr)
+{
+  const int  numAps        = cs.slice->getNumAlfApsIdsLuma();
+  const bool alfUseApsFlag = numAps > 0 && m_binDecoder.decodeBin(Ctx::alfUseApsFlag()) != 0;
+
+  AlfMode m;
+  if (alfUseApsFlag)
+  {
+    uint32_t alfLumaPrevFilterIdx = 0;
+    if (numAps > 1)
+    {
+      xReadTruncBinCode(alfLumaPrevFilterIdx, numAps);
+    }
+    m = AlfMode::LUMA0 + alfLumaPrevFilterIdx;
+  }
+  else
+  {
+    uint32_t alfLumaFixedFilterIdx = 0;
+    xReadTruncBinCode(alfLumaFixedFilterIdx, ALF_NUM_FIXED_FILTER_SETS);
+    m = AlfMode::LUMA_FIXED0 + alfLumaFixedFilterIdx;
+  }
+
+  AlfMode *alfModes   = cs.slice->getPic()->getAlfModes(COMPONENT_Y);
+  alfModes[ctuRsAddr] = m;
+}
+
+void CABACReader::ccAlfFilterControlIdc(CodingStructure &cs, const ComponentID compID, const int curIdx,
+                                        uint8_t *filterControlIdc, Position lumaPos, int filterCount)
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__CROSS_COMPONENT_ALF_BLOCK_LEVEL_IDC );
+
+  const Position leftLumaPos  = lumaPos.offset(-(int) cs.pcv->maxCUWidth, 0);
+  const Position aboveLumaPos = lumaPos.offset(0, -(int) cs.pcv->maxCUWidth);
+
+  const uint32_t curSliceIdx = cs.slice->getIndependentSliceIdx();
+  const uint32_t curTileIdx  = cs.pps->getTileIdx(lumaPos);
+
+  const bool leftAvail =
+    cs.getCURestricted(leftLumaPos, lumaPos, curSliceIdx, curTileIdx, ChannelType::LUMA) != nullptr;
+  const bool aboveAvail =
+    cs.getCURestricted(aboveLumaPos, lumaPos, curSliceIdx, curTileIdx, ChannelType::LUMA) != nullptr;
+
+  int ctxt = 0;
+  if (leftAvail)
+  {
+    ctxt += ( filterControlIdc[curIdx - 1] ) ? 1 : 0;
+  }
+  if (aboveAvail)
+  {
+    ctxt += ( filterControlIdc[curIdx - cs.pcv->widthInCtus] ) ? 1 : 0;
+  }
+  ctxt += ( compID == COMPONENT_Cr ) ? 3 : 0;
+
+  int idcVal = m_binDecoder.decodeBin(Ctx::CcAlfFilterControlFlag(ctxt));
+  if ( idcVal )
+  {
+    while ((idcVal != filterCount) && m_binDecoder.decodeBinEP())
+    {
+      idcVal++;
+    }
+  }
+  filterControlIdc[curIdx] = idcVal;
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "ccAlfFilterControlIdc() compID=%d pos=(%d,%d) ctxt=%d, filterCount=%d, idcVal=%d\n",
+         compID, lumaPos.x, lumaPos.y, ctxt, filterCount, idcVal);
+}
+
+//================================================================================
+//  clause 7.3.8.3
+//--------------------------------------------------------------------------------
+//    void  sao( slice, ctuRsAddr )
+//================================================================================
+
+void CABACReader::sao( CodingStructure& cs, unsigned ctuRsAddr )
+{
+  const SPS &sps = *cs.sps;
+
+  if( !sps.getSAOEnabledFlag() )
+  {
+    return;
+  }
+
+  const Slice &slice = *cs.slice;
+
+  SAOBlkParam &saoCtuParams = cs.picture->getSAO()[ctuRsAddr];
+
+  const bool sliceSaoLumaFlag = slice.getSaoEnabledFlag(ChannelType::LUMA);
+  const bool sliceSaoChromaFlag =
+    slice.getSaoEnabledFlag(ChannelType::CHROMA) && isChromaEnabled(sps.getChromaFormatIdc());
+
+  saoCtuParams[COMPONENT_Y].modeIdc  = SAOMode::OFF;
+  saoCtuParams[COMPONENT_Cb].modeIdc = SAOMode::OFF;
+  saoCtuParams[COMPONENT_Cr].modeIdc = SAOMode::OFF;
+
+  if (!sliceSaoLumaFlag && !sliceSaoChromaFlag)
+  {
+    return;
+  }
+
+  // merge
+  const int frameWidthInCtus = cs.pcv->widthInCtus;
+
+  const int ry = ctuRsAddr / frameWidthInCtus;
+  const int rx = ctuRsAddr - ry * frameWidthInCtus;
+
+  const Position  pos( rx * cs.pcv->maxCUWidth, ry * cs.pcv->maxCUHeight );
+  const unsigned  curSliceIdx = cs.slice->getIndependentSliceIdx();
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__SAO );
+
+  auto mergeType = SAOModeMergeTypes::NONE;
+
+  const unsigned curTileIdx = cs.pps->getTileIdx(pos);
+
+  if (cs.getCURestricted(pos.offset(-(int) cs.pcv->maxCUWidth, 0), pos, curSliceIdx, curTileIdx, ChannelType::LUMA))
+  {
+    // sao_merge_left_flag
+    mergeType = m_binDecoder.decodeBin(Ctx::SaoMergeFlag()) ? SAOModeMergeTypes::LEFT : SAOModeMergeTypes::NONE;
+  }
+
+  if (mergeType == SAOModeMergeTypes::NONE
+      && cs.getCURestricted(pos.offset(0, -(int) cs.pcv->maxCUHeight), pos, curSliceIdx, curTileIdx, ChannelType::LUMA))
+  {
+    // sao_merge_above_flag
+    mergeType = m_binDecoder.decodeBin(Ctx::SaoMergeFlag()) ? SAOModeMergeTypes::ABOVE : SAOModeMergeTypes::NONE;
+  }
+
+  if (mergeType != SAOModeMergeTypes::NONE)
+  {
+    if (sliceSaoLumaFlag || sliceSaoChromaFlag)
+    {
+      saoCtuParams[COMPONENT_Y].modeIdc           = SAOMode::MERGE;
+      saoCtuParams[COMPONENT_Y].typeIdc.mergeType = mergeType;
+    }
+    if (sliceSaoChromaFlag)
+    {
+      saoCtuParams[COMPONENT_Cb].modeIdc           = SAOMode::MERGE;
+      saoCtuParams[COMPONENT_Cr].modeIdc           = SAOMode::MERGE;
+      saoCtuParams[COMPONENT_Cb].typeIdc.mergeType = mergeType;
+      saoCtuParams[COMPONENT_Cr].typeIdc.mergeType = mergeType;
+    }
+    return;
+  }
+
+  // explicit parameters
+  ComponentID firstComp = sliceSaoLumaFlag ? COMPONENT_Y : COMPONENT_Cb;
+  ComponentID lastComp  = sliceSaoChromaFlag ? COMPONENT_Cr : COMPONENT_Y;
+  for( ComponentID compID = firstComp; compID <= lastComp; compID = ComponentID( compID + 1 ) )
+  {
+    SAOOffset &sao_pars = saoCtuParams[compID];
+
+    // sao_type_idx_luma / sao_type_idx_chroma
+    if( compID != COMPONENT_Cr )
+    {
+      if (m_binDecoder.decodeBin(Ctx::SaoTypeIdx()))
+      {
+        if (m_binDecoder.decodeBinEP())
+        {
+          // edge offset
+          sao_pars.modeIdc         = SAOMode::NEW;
+          sao_pars.typeIdc.newType = SAOModeNewTypes::START_EO;
+        }
+        else
+        {
+          // band offset
+          sao_pars.modeIdc         = SAOMode::NEW;
+          sao_pars.typeIdc.newType = SAOModeNewTypes::START_BO;
+        }
+      }
+    }
+    else //Cr, follow Cb SAO type
+    {
+      sao_pars.modeIdc = saoCtuParams[COMPONENT_Cb].modeIdc;
+      sao_pars.typeIdc = saoCtuParams[COMPONENT_Cb].typeIdc;
+    }
+    if (sao_pars.modeIdc == SAOMode::OFF)
+    {
+      continue;
+    }
+
+    // sao_offset_abs
+    int       offset[4];
+    const int maxOffsetQVal = SampleAdaptiveOffset::getMaxOffsetQVal( sps.getBitDepth( toChannelType(compID) ) );
+
+    offset[0] = (int) unary_max_eqprob(maxOffsetQVal);
+    offset[1] = (int) unary_max_eqprob(maxOffsetQVal);
+    offset[2] = (int) unary_max_eqprob(maxOffsetQVal);
+    offset[3] = (int) unary_max_eqprob(maxOffsetQVal);
+
+    // band offset mode
+    if (sao_pars.typeIdc.newType == SAOModeNewTypes::START_BO)
+    {
+      // sao_offset_sign
+      for( int k = 0; k < 4; k++ )
+      {
+        if (offset[k] && m_binDecoder.decodeBinEP())
+        {
+          offset[k] = -offset[k];
+        }
+      }
+      // sao_band_position
+      sao_pars.typeAuxInfo = m_binDecoder.decodeBinsEP(NUM_SAO_BO_CLASSES_LOG2);
+      for( int k = 0; k < 4; k++ )
+      {
+        sao_pars.offset[ ( sao_pars.typeAuxInfo + k ) % MAX_NUM_SAO_CLASSES ] = offset[k];
+      }
+      continue;
+    }
+
+    // edge offset mode
+    sao_pars.typeAuxInfo = 0;
+    if( compID != COMPONENT_Cr )
+    {
+      // sao_eo_class_luma / sao_eo_class_chroma
+      sao_pars.typeIdc.newType =
+        SAOModeNewTypes(to_underlying(sao_pars.typeIdc.newType) + m_binDecoder.decodeBinsEP(NUM_SAO_EO_TYPES_LOG2));
+    }
+    else
+    {
+      sao_pars.typeIdc = saoCtuParams[COMPONENT_Cb].typeIdc;
+    }
+    sao_pars.offset[ SAO_CLASS_EO_FULL_VALLEY ] =  offset[0];
+    sao_pars.offset[ SAO_CLASS_EO_HALF_VALLEY ] =  offset[1];
+    sao_pars.offset[ SAO_CLASS_EO_PLAIN       ] =  0;
+    sao_pars.offset[ SAO_CLASS_EO_HALF_PEAK   ] = -offset[2];
+    sao_pars.offset[ SAO_CLASS_EO_FULL_PEAK   ] = -offset[3];
+  }
+}
+
+//================================================================================
+//  clause 7.3.8.4
+//--------------------------------------------------------------------------------
+//    void  coding_tree       ( cs, partitioner, cuCtx )
+//    bool  split_cu_flag     ( cs, partitioner )
+//    split split_cu_mode_mt  ( cs, partitioner )
+//================================================================================
+
+void CABACReader::coding_tree( CodingStructure& cs, Partitioner& partitioner, CUCtx& cuCtx, Partitioner* pPartitionerChroma, CUCtx* pCuCtxChroma)
+{
+  const PPS      &pps         = *cs.pps;
+  const UnitArea &currArea    = partitioner.currArea();
+
+  // Reset delta QP coding flag and ChromaQPAdjustemt coding flag
+  //Note: do not reset qg at chroma CU
+  if( pps.getUseDQP() && partitioner.currQgEnable() && !isChroma(partitioner.chType) )
+  {
+    cuCtx.qgStart    = true;
+    cuCtx.isDQPCoded = false;
+  }
+  if( cs.slice->getUseChromaQpAdj() && partitioner.currQgChromaEnable() )
+  {
+    cuCtx.isChromaQpAdjCoded  = false;
+    cs.chromaQpAdj = 0;
+  }
+
+  // Reset delta QP coding flag and ChromaQPAdjustemt coding flag
+  if (CS::isDualITree(cs) && pPartitionerChroma != nullptr)
+  {
+    if (pps.getUseDQP() && pPartitionerChroma->currQgEnable())
+    {
+      pCuCtxChroma->qgStart    = true;
+      pCuCtxChroma->isDQPCoded = false;
+    }
+    if (cs.slice->getUseChromaQpAdj() && pPartitionerChroma->currQgChromaEnable())
+    {
+      pCuCtxChroma->isChromaQpAdjCoded = false;
+      cs.chromaQpAdj = 0;
+    }
+  }
+
+  const PartSplit splitMode = split_cu_mode( cs, partitioner );
+
+  CHECK( !partitioner.canSplit( splitMode, cs ), "Got an invalid split!" );
+
+  if( splitMode != CU_DONT_SPLIT )
+  {
+    if (CS::isDualITree(cs) && pPartitionerChroma != nullptr
+        && (partitioner.currArea().lwidth() >= 64 || partitioner.currArea().lheight() >= 64))
+    {
+      partitioner.splitCurrArea(CU_QUAD_SPLIT, cs);
+      pPartitionerChroma->splitCurrArea(CU_QUAD_SPLIT, cs);
+      bool beContinue     = true;
+      bool lumaContinue   = true;
+      bool chromaContinue = true;
+
+      while (beContinue)
+      {
+        if (partitioner.currArea().lwidth() > 64 || partitioner.currArea().lheight() > 64)
+        {
+          if (cs.area.block(partitioner.chType).contains(partitioner.currArea().block(partitioner.chType).pos()))
+          {
+            coding_tree(cs, partitioner, cuCtx, pPartitionerChroma, pCuCtxChroma);
+          }
+          lumaContinue   = partitioner.nextPart(cs);
+          chromaContinue = pPartitionerChroma->nextPart(cs);
+          CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+          beContinue = lumaContinue;
+        }
+        else
+        {
+          // dual tree coding under 64x64 block
+          if (cs.area.block(partitioner.chType).contains(partitioner.currArea().block(partitioner.chType).pos()))
+          {
+            coding_tree(cs, partitioner, cuCtx);
+          }
+          lumaContinue = partitioner.nextPart(cs);
+          if (cs.area.block(pPartitionerChroma->chType)
+                .contains(pPartitionerChroma->currArea().block(pPartitionerChroma->chType).pos()))
+          {
+            coding_tree(cs, *pPartitionerChroma, *pCuCtxChroma);
+          }
+          chromaContinue = pPartitionerChroma->nextPart(cs);
+          CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+          beContinue = lumaContinue;
+        }
+      }
+      partitioner.exitCurrSplit();
+      pPartitionerChroma->exitCurrSplit();
+
+      // cat the chroma CUs together
+      CodingUnit *currentCu        = cs.getCU(partitioner.currArea().lumaPos(), ChannelType::LUMA);
+      CodingUnit *nextCu           = nullptr;
+      CodingUnit *tempLastLumaCu   = nullptr;
+      CodingUnit *tempLastChromaCu = nullptr;
+      ChannelType currentChType    = currentCu->chType;
+      while (currentCu->next != nullptr)
+      {
+        nextCu = currentCu->next;
+        if (currentChType != nextCu->chType && isLuma(currentChType))
+        {
+          tempLastLumaCu = currentCu;
+          if (tempLastChromaCu != nullptr)   // swap
+          {
+            tempLastChromaCu->next = nextCu;
+          }
+        }
+        else if (currentChType != nextCu->chType && currentChType == ChannelType::CHROMA)
+        {
+          tempLastChromaCu = currentCu;
+          if (tempLastLumaCu != nullptr)   // swap
+          {
+            tempLastLumaCu->next = nextCu;
+          }
+        }
+        currentCu     = nextCu;
+        currentChType = currentCu->chType;
+      }
+
+      CodingUnit *chromaFirstCu = cs.getCU(pPartitionerChroma->currArea().chromaPos(), ChannelType::CHROMA);
+      tempLastLumaCu->next      = chromaFirstCu;
+    }
+    else
+    {
+      const ModeType modeTypeParent = partitioner.modeType;
+      cs.modeType = partitioner.modeType = mode_constraint(cs, partitioner, splitMode);   // change for child nodes
+      // decide chroma split or not
+      bool chromaNotSplit = modeTypeParent == MODE_TYPE_ALL && partitioner.modeType == MODE_TYPE_INTRA;
+      CHECK(chromaNotSplit && partitioner.chType != ChannelType::LUMA, "chType must be luma");
+      if (partitioner.treeType == TREE_D)
+      {
+        cs.treeType = partitioner.treeType = chromaNotSplit ? TREE_L : TREE_D;
+      }
+      partitioner.splitCurrArea( splitMode, cs );
+      do
+      {
+        if (cs.area.block(partitioner.chType).contains(partitioner.currArea().block(partitioner.chType).pos()))
+        {
+          coding_tree( cs, partitioner, cuCtx );
+        }
+      } while( partitioner.nextPart( cs ) );
+
+      partitioner.exitCurrSplit();
+      if( chromaNotSplit )
+      {
+        CHECK(partitioner.chType != ChannelType::LUMA, "must be luma status");
+        partitioner.chType = ChannelType::CHROMA;
+        cs.treeType = partitioner.treeType = TREE_C;
+
+        if (cs.picture->block(partitioner.chType).contains(partitioner.currArea().block(partitioner.chType).pos()))
+        {
+          coding_tree( cs, partitioner, cuCtx );
+        }
+
+        //recover treeType
+        partitioner.chType = ChannelType::LUMA;
+        cs.treeType = partitioner.treeType = TREE_D;
+      }
+
+      //recover ModeType
+      cs.modeType = partitioner.modeType = modeTypeParent;
+    }
+    return;
+  }
+
+  CodingUnit& cu = cs.addCU( CS::getArea( cs, currArea, partitioner.chType ), partitioner.chType );
+
+  partitioner.setCUData( cu );
+  cu.slice   = cs.slice;
+  cu.tileIdx = cs.pps->getTileIdx( currArea.lumaPos() );
+  CHECK( cu.cs->treeType != partitioner.treeType, "treeType mismatch" );
+  int lumaQPinLocalDualTree = -1;
+
+  // Predict QP on start of quantization group
+  if( cuCtx.qgStart )
+  {
+    cuCtx.qgStart = false;
+    cuCtx.qp = CU::predictQP( cu, cuCtx.qp );
+  }
+
+  if (pps.getUseDQP() && partitioner.isSepTree(cs) && isChroma(cu.chType))
+  {
+    const Position chromaCentral(cu.chromaPos().offset(cu.chromaSize().width >> 1, cu.chromaSize().height >> 1));
+    const Position lumaRefPos(chromaCentral.x << getComponentScaleX(COMPONENT_Cb, cu.chromaFormat), chromaCentral.y << getComponentScaleY(COMPONENT_Cb, cu.chromaFormat));
+    //derive chroma qp, but the chroma qp is saved in cuCtx.qp which is used for luma qp
+    //therefore, after decoding the chroma CU, the cuCtx.qp shall be recovered to luma qp in order to decode next luma cu qp
+    const CodingUnit* colLumaCu = cs.getLumaCU( lumaRefPos );
+    CHECK( colLumaCu == nullptr, "colLumaCU shall exist" );
+    lumaQPinLocalDualTree = cuCtx.qp;
+
+    if (colLumaCu)
+    {
+      cuCtx.qp = colLumaCu->qp;
+    }
+  }
+
+  cu.qp = cuCtx.qp;                 //NOTE: CU QP can be changed by deltaQP signaling at TU level
+  cu.chromaQpAdj = cs.chromaQpAdj;  //NOTE: CU chroma QP adjustment can be changed by adjustment signaling at TU level
+
+  // coding unit
+
+  coding_unit( cu, partitioner, cuCtx );
+  //recover cuCtx.qp to luma qp after decoding the chroma CU
+  if( pps.getUseDQP() && partitioner.isSepTree( cs ) && isChroma( cu.chType ) )
+  {
+    cuCtx.qp = lumaQPinLocalDualTree;
+  }
+
+  uint32_t compBegin;
+  uint32_t numComp;
+  bool jointPLT = false;
+  if (cu.isSepTree())
+  {
+    if( cu.isLocalSepTree() )
+    {
+      compBegin = COMPONENT_Y;
+      numComp   = getNumberValidComponents(cu.chromaFormat);
+      jointPLT = true;
+    }
+    else
+    {
+      if (isLuma(partitioner.chType))
+      {
+        compBegin = COMPONENT_Y;
+        numComp   = 1;
+      }
+      else
+      {
+        compBegin = COMPONENT_Cb;
+        numComp   = 2;
+      }
+    }
+  }
+  else
+  {
+    compBegin = COMPONENT_Y;
+    numComp   = getNumberValidComponents(cu.chromaFormat);
+    jointPLT = true;
+  }
+  if (CU::isPLT(cu))
+  {
+    cs.reorderPrevPLT(cs.prevPLT, cu.curPLTSize, cu.curPLT, cu.reuseflag, compBegin, numComp, jointPLT);
+  }
+  if (cu.chType == ChannelType::CHROMA)
+  {
+    DTRACE( g_trace_ctx, D_QP, "[chroma CU]x=%d, y=%d, w=%d, h=%d, qp=%d\n", cu.Cb().x, cu.Cb().y, cu.Cb().width, cu.Cb().height, cu.qp );
+  }
+  else
+  {
+    DTRACE(g_trace_ctx, D_QP, "x=%d, y=%d, w=%d, h=%d, qp=%d\n", cu.Y().x, cu.Y().y, cu.Y().width, cu.Y().height,
+           cu.qp);
+  }
+}
+
+ModeType CABACReader::mode_constraint( CodingStructure& cs, Partitioner &partitioner, PartSplit splitMode )
+{
+  const int val = cs.signalModeCons(splitMode, partitioner, partitioner.modeType);
+  if( val == LDT_MODE_TYPE_SIGNAL )
+  {
+    int ctxIdx = DeriveCtx::CtxModeConsFlag( cs, partitioner );
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(STATS__CABAC_BITS__MODE_CONSTRAINT_FLAG,
+                                                        partitioner.currArea().block(partitioner.chType).size(),
+                                                        partitioner.chType);
+    bool flag = m_binDecoder.decodeBin(Ctx::ModeConsFlag(ctxIdx));
+    DTRACE( g_trace_ctx, D_SYNTAX, "mode_cons_flag() flag=%d\n", flag );
+    return flag ? MODE_TYPE_INTRA : MODE_TYPE_INTER;
+  }
+  else if( val == LDT_MODE_TYPE_INFER )
+  {
+    return MODE_TYPE_INTRA;
+  }
+  else
+  {
+    return partitioner.modeType;
+  }
+}
+
+PartSplit CABACReader::split_cu_mode( CodingStructure& cs, Partitioner &partitioner )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(
+    STATS__CABAC_BITS__SPLIT_FLAG, partitioner.currArea().block(partitioner.chType).size(), partitioner.chType);
+
+  PartSplit mode = CU_DONT_SPLIT;
+
+  bool canNo, canQt, canBh, canBv, canTh, canTv;
+  partitioner.canSplit( cs, canNo, canQt, canBh, canBv, canTh, canTv );
+
+  bool canSpl[6] = { canNo, canQt, canBh, canBv, canTh, canTv };
+
+  unsigned ctxSplit = 0, ctxQtSplit = 0, ctxBttHV = 0, ctxBttH12 = 0, ctxBttV12;
+  DeriveCtx::CtxSplit( cs, partitioner, ctxSplit, ctxQtSplit, ctxBttHV, ctxBttH12, ctxBttV12, canSpl );
+
+  bool isSplit = canBh || canBv || canTh || canTv || canQt;
+
+  if( canNo && isSplit )
+  {
+    isSplit = m_binDecoder.decodeBin(Ctx::SplitFlag(ctxSplit));
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "split_cu_mode() ctx=%d split=%d\n", ctxSplit, isSplit );
+
+  if( !isSplit )
+  {
+    return CU_DONT_SPLIT;
+  }
+
+  const bool canBtt = canBh || canBv || canTh || canTv;
+  bool       isQt   = canQt;
+
+  if( isQt && canBtt )
+  {
+    isQt = m_binDecoder.decodeBin(Ctx::SplitQtFlag(ctxQtSplit));
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "split_cu_mode() ctx=%d qt=%d\n", ctxQtSplit, isQt );
+
+  if( isQt )
+  {
+    return CU_QUAD_SPLIT;
+  }
+
+  const bool canHor = canBh || canTh;
+  bool        isVer = canBv || canTv;
+
+  if( isVer && canHor )
+  {
+    isVer = m_binDecoder.decodeBin(Ctx::SplitHvFlag(ctxBttHV));
+  }
+
+  const bool can14 = isVer ? canTv : canTh;
+  bool        is12 = isVer ? canBv : canBh;
+
+  if( is12 && can14 )
+  {
+    is12 = m_binDecoder.decodeBin(Ctx::Split12Flag(isVer ? ctxBttV12 : ctxBttH12));
+  }
+
+  if (isVer && is12)
+  {
+    mode = CU_VERT_SPLIT;
+  }
+  else if (isVer && !is12)
+  {
+    mode = CU_TRIV_SPLIT;
+  }
+  else if (!isVer && is12)
+  {
+    mode = CU_HORZ_SPLIT;
+  }
+  else
+  {
+    mode = CU_TRIH_SPLIT;
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "split_cu_mode() ctxHv=%d ctx12=%d mode=%d\n", ctxBttHV, isVer ? ctxBttV12 : ctxBttH12, mode );
+
+  return mode;
+}
+
+//================================================================================
+//  clause 7.3.8.5
+//--------------------------------------------------------------------------------
+//    void  coding_unit               ( cu, partitioner, cuCtx )
+//    void  cu_skip_flag              ( cu )
+//    void  pred_mode                 ( cu )
+//    void  part_mode                 ( cu )
+//    void  cu_pred_data              ( pus )
+//    void  cu_lic_flag               ( cu )
+//    void  intra_luma_pred_modes     ( pus )
+//    void  intra_chroma_pred_mode    ( pu )
+//    void  cu_residual               ( cu, partitioner, cuCtx )
+//    void  rqt_root_cbf              ( cu )
+//    void  end_of_ctu                ( cu, cuCtx )
+//================================================================================
+
+void CABACReader::coding_unit( CodingUnit &cu, Partitioner &partitioner, CUCtx& cuCtx )
+{
+  CodingStructure& cs = *cu.cs;
+  CHECK( cu.treeType != partitioner.treeType || cu.modeType != partitioner.modeType, "treeType or modeType mismatch" );
+  DTRACE( g_trace_ctx, D_SYNTAX, "coding_unit() treeType=%d modeType=%d\n", cu.treeType, cu.modeType );
+  PredictionUnit&    pu = cs.addPU(cu, partitioner.chType);
+  // skip flag
+  if ((!cs.slice->isIntra() || cs.slice->getSPS()->getIBCFlag()) && cu.Y().valid())
+  {
+    cu_skip_flag( cu );
+  }
+
+  // skip data
+  if( cu.skip )
+  {
+    cu.colorTransform = false;
+    cs.addEmptyTUs( partitioner );
+    prediction_unit  ( pu );
+    end_of_ctu( cu, cuCtx );
+    return;
+  }
+
+  // prediction mode and partitioning data
+  pred_mode ( cu );
+  if (CU::isIntra(cu))
+  {
+    adaptive_color_transform(cu);
+  }
+  if (CU::isPLT(cu))
+  {
+    cu.colorTransform = false;
+    cs.addTU(cu, partitioner.chType);
+    if (cu.isSepTree())
+    {
+      if (isLuma(partitioner.chType))
+      {
+        cu_palette_info(cu, COMPONENT_Y, 1, cuCtx);
+      }
+      if (isChromaEnabled(cu.chromaFormat) && partitioner.chType == ChannelType::CHROMA)
+      {
+        cu_palette_info(cu, COMPONENT_Cb, 2, cuCtx);
+      }
+    }
+    else
+    {
+      cu_palette_info(cu, COMPONENT_Y, getNumberValidComponents(cu.chromaFormat), cuCtx);
+    }
+    end_of_ctu(cu, cuCtx);
+    return;
+  }
+
+  // --> create PUs
+
+  // prediction data ( intra prediction modes / reference indexes + motion vectors )
+  cu_pred_data( cu );
+
+  // residual data ( coded block flags + transform coefficient levels )
+  cu_residual( cu, partitioner, cuCtx );
+
+  // check end of cu
+  end_of_ctu( cu, cuCtx );
+}
+
+void CABACReader::cu_skip_flag( CodingUnit& cu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__SKIP_FLAG );
+
+  if ((cu.slice->isIntra() || cu.isConsIntra()) && cu.cs->slice->getSPS()->getIBCFlag())
+  {
+    cu.skip = false;
+    cu.rootCbf = false;
+    cu.predMode = MODE_INTRA;
+    cu.mmvdSkip = false;
+    if (cu.lwidth() <= IBC_MAX_CU_SIZE && cu.lheight() <= IBC_MAX_CU_SIZE)   // disable IBC mode larger than 64x64
+    {
+      unsigned ctxId = DeriveCtx::CtxSkipFlag(cu);
+      unsigned skip  = m_binDecoder.decodeBin(Ctx::SkipFlag(ctxId));
+      DTRACE(g_trace_ctx, D_SYNTAX, "cu_skip_flag() ctx=%d skip=%d\n", ctxId, skip ? 1 : 0);
+      if (skip)
+      {
+        cu.skip     = true;
+        cu.rootCbf  = false;
+        cu.predMode = MODE_IBC;
+        cu.mmvdSkip = false;
+      }
+    }
+    return;
+  }
+  if ( !cu.cs->slice->getSPS()->getIBCFlag() && cu.lwidth() == 4 && cu.lheight() == 4 )
+  {
+    return;
+  }
+  if( !cu.cs->slice->getSPS()->getIBCFlag() && cu.isConsIntra() )
+  {
+    return;
+  }
+  unsigned ctxId  = DeriveCtx::CtxSkipFlag(cu);
+  unsigned skip   = m_binDecoder.decodeBin(Ctx::SkipFlag(ctxId));
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "cu_skip_flag() ctx=%d skip=%d\n", ctxId, skip ? 1 : 0 );
+
+  if (skip && cu.cs->slice->getSPS()->getIBCFlag())
+  {
+    // disable IBC mode larger than 64x64 and disable IBC when only allowing inter mode
+    if (cu.lwidth() <= IBC_MAX_CU_SIZE && cu.lheight() <= IBC_MAX_CU_SIZE && !cu.isConsInter())
+    {
+      if ( cu.lwidth() == 4 && cu.lheight() == 4 )
+      {
+        cu.skip     = true;
+        cu.rootCbf  = false;
+        cu.predMode = MODE_IBC;
+        cu.mmvdSkip = false;
+        return;
+      }
+      unsigned ctxidx = DeriveCtx::CtxIBCFlag(cu);
+      if (m_binDecoder.decodeBin(Ctx::IBCFlag(ctxidx)))
+      {
+        cu.skip                      = true;
+        cu.rootCbf                   = false;
+        cu.predMode                  = MODE_IBC;
+        cu.mmvdSkip                  = false;
+        cu.firstPU->regularMergeFlag = false;
+      }
+      else
+      {
+        cu.predMode = MODE_INTER;
+      }
+      DTRACE(g_trace_ctx, D_SYNTAX, "ibc() ctx=%d cu.predMode=%d\n", ctxidx, cu.predMode);
+    }
+    else
+    {
+      cu.predMode = MODE_INTER;
+    }
+  }
+  if ((skip && CU::isInter(cu) && cu.cs->slice->getSPS()->getIBCFlag()) ||
+    (skip && !cu.cs->slice->getSPS()->getIBCFlag()))
+  {
+    cu.skip     = true;
+    cu.rootCbf  = false;
+    cu.predMode = MODE_INTER;
+  }
+}
+
+void CABACReader::imv_mode( CodingUnit& cu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__OTHER );
+
+  if( !cu.cs->sps->getAMVREnabledFlag() )
+  {
+    return;
+  }
+
+  bool nonZeroMvd = CU::hasSubCUNonZeroMVd(cu);
+  if (!nonZeroMvd)
+  {
+    return;
+  }
+
+  if ( cu.affine )
+  {
+    return;
+  }
+
+  const SPS *sps = cu.cs->sps;
+
+  unsigned value = 0;
+  if (CU::isIBC(cu))
+  {
+    value = 1;
+  }
+  else
+  {
+    value = m_binDecoder.decodeBin(Ctx::ImvFlag(0));
+  }
+  DTRACE( g_trace_ctx, D_SYNTAX, "imv_mode() value=%d ctx=%d\n", value, 0 );
+
+  cu.imv = value;
+  if( sps->getAMVREnabledFlag() && value )
+  {
+    if (!CU::isIBC(cu))
+    {
+      value = m_binDecoder.decodeBin(Ctx::ImvFlag(4));
+      DTRACE(g_trace_ctx, D_SYNTAX, "imv_mode() value=%d ctx=%d\n", value, 4);
+      cu.imv = value ? 1 : IMV_HPEL;
+    }
+    if (value)
+    {
+      value = m_binDecoder.decodeBin(Ctx::ImvFlag(1));
+      DTRACE(g_trace_ctx, D_SYNTAX, "imv_mode() value=%d ctx=%d\n", value, 1);
+      value++;
+      cu.imv = value;
+    }
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "imv_mode() IMVFlag=%d\n", cu.imv );
+}
+
+void CABACReader::affine_amvr_mode( CodingUnit& cu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__OTHER );
+
+  const SPS* sps = cu.slice->getSPS();
+
+  if( !sps->getAffineAmvrEnabledFlag() || !cu.affine )
+  {
+    return;
+  }
+
+  if ( !CU::hasSubCUNonZeroAffineMVd( cu ) )
+  {
+    return;
+  }
+
+  unsigned value = 0;
+  value          = m_binDecoder.decodeBin(Ctx::ImvFlag(2));
+  DTRACE( g_trace_ctx, D_SYNTAX, "affine_amvr_mode() value=%d ctx=%d\n", value, 2 );
+
+  if( value )
+  {
+    value = m_binDecoder.decodeBin(Ctx::ImvFlag(3));
+    DTRACE( g_trace_ctx, D_SYNTAX, "affine_amvr_mode() value=%d ctx=%d\n", value, 3 );
+    value++;
+  }
+
+  cu.imv = value;
+  DTRACE( g_trace_ctx, D_SYNTAX, "affine_amvr_mode() IMVFlag=%d\n", cu.imv );
+}
+
+void CABACReader::pred_mode( CodingUnit& cu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__PRED_MODE );
+  if (cu.cs->slice->getSPS()->getIBCFlag() && cu.chType != ChannelType::CHROMA)
+  {
+    if( cu.isConsInter() )
+    {
+      cu.predMode = MODE_INTER;
+      return;
+    }
+
+    if ( cu.cs->slice->isIntra() || ( cu.lwidth() == 4 && cu.lheight() == 4 ) || cu.isConsIntra() )
+    {
+      cu.predMode = MODE_INTRA;
+      if (cu.lwidth() <= IBC_MAX_CU_SIZE && cu.lheight() <= IBC_MAX_CU_SIZE)   // disable IBC mode larger than 64x64
+      {
+        unsigned ctxidx = DeriveCtx::CtxIBCFlag(cu);
+        if (m_binDecoder.decodeBin(Ctx::IBCFlag(ctxidx)))
+        {
+          cu.predMode = MODE_IBC;
+        }
+      }
+      if (!CU::isIBC(cu) && cu.cs->slice->getSPS()->getPLTMode() && cu.lwidth() <= 64 && cu.lheight() <= 64 && (cu.lumaSize().width * cu.lumaSize().height > 16) )
+      {
+        if (m_binDecoder.decodeBin(Ctx::PLTFlag(0)))
+        {
+          cu.predMode = MODE_PLT;
+        }
+      }
+    }
+    else
+    {
+      if (m_binDecoder.decodeBin(Ctx::PredMode(DeriveCtx::CtxPredModeFlag(cu))))
+      {
+        cu.predMode = MODE_INTRA;
+        if (cu.cs->slice->getSPS()->getPLTMode() && cu.lwidth() <= 64 && cu.lheight() <= 64 && (cu.lumaSize().width * cu.lumaSize().height > 16) )
+        {
+          if (m_binDecoder.decodeBin(Ctx::PLTFlag(0)))
+          {
+            cu.predMode = MODE_PLT;
+          }
+        }
+      }
+      else
+      {
+        cu.predMode = MODE_INTER;
+        if (cu.lwidth() <= IBC_MAX_CU_SIZE && cu.lheight() <= IBC_MAX_CU_SIZE)   // disable IBC mode larger than 64x64
+        {
+          unsigned ctxidx = DeriveCtx::CtxIBCFlag(cu);
+          if (m_binDecoder.decodeBin(Ctx::IBCFlag(ctxidx)))
+          {
+            cu.predMode = MODE_IBC;
+          }
+        }
+      }
+    }
+  }
+  else
+  {
+    if( cu.isConsInter() )
+    {
+      cu.predMode = MODE_INTER;
+      return;
+    }
+
+    if ( cu.cs->slice->isIntra() || (cu.lwidth() == 4 && cu.lheight() == 4) || cu.isConsIntra() )
+    {
+      cu.predMode = MODE_INTRA;
+      if (cu.cs->slice->getSPS()->getPLTMode() && cu.lwidth() <= 64 && cu.lheight() <= 64 && ( ( (!isLuma(cu.chType)) && (cu.chromaSize().width * cu.chromaSize().height > 16) ) || ((isLuma(cu.chType)) && ((cu.lumaSize().width * cu.lumaSize().height) > 16 ) )  ) && (!cu.isLocalSepTree() || isLuma(cu.chType)  )  )
+      {
+        if (m_binDecoder.decodeBin(Ctx::PLTFlag(0)))
+        {
+          cu.predMode = MODE_PLT;
+        }
+      }
+    }
+    else
+    {
+      cu.predMode = m_binDecoder.decodeBin(Ctx::PredMode(DeriveCtx::CtxPredModeFlag(cu))) ? MODE_INTRA : MODE_INTER;
+      if (CU::isIntra(cu) && cu.cs->slice->getSPS()->getPLTMode() && cu.lwidth() <= 64 &&  cu.lheight() <= 64 && ( ( (!isLuma(cu.chType)) && (cu.chromaSize().width * cu.chromaSize().height > 16) ) || ((isLuma(cu.chType)) && ((cu.lumaSize().width * cu.lumaSize().height) > 16 ) )  ) && (!cu.isLocalSepTree() || isLuma(cu.chType)  )  )
+      {
+        if (m_binDecoder.decodeBin(Ctx::PLTFlag(0)))
+        {
+          cu.predMode = MODE_PLT;
+        }
+      }
+    }
+  }
+}
+
+void CABACReader::bdpcm_mode( CodingUnit& cu, const ComponentID compID )
+{
+  if (!CU::bdpcmAllowed(cu, compID))
+  {
+    if (isLuma(compID))
+    {
+      cu.bdpcmMode = BdpcmMode::NONE;
+      if (!CS::isDualITree(*cu.cs))
+      {
+        cu.bdpcmModeChroma = BdpcmMode::NONE;
+      }
+    }
+    else
+    {
+      cu.bdpcmModeChroma = BdpcmMode::NONE;
+    }
+    return;
+  }
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2( STATS__CABAC_BITS__BDPCM_MODE, cu.block(compID).lumaSize(), compID );
+
+  BdpcmMode bdpcmMode;
+  unsigned ctxId = isLuma( compID ) ? 0 : 2;
+  if (m_binDecoder.decodeBin(Ctx::BDPCMMode(ctxId)))
+  {
+    bdpcmMode = m_binDecoder.decodeBin(Ctx::BDPCMMode(ctxId + 1)) ? BdpcmMode::VER : BdpcmMode::HOR;
+  }
+  else
+  {
+    bdpcmMode = BdpcmMode::NONE;
+  }
+  if (isLuma(compID))
+  {
+    cu.bdpcmMode = bdpcmMode;
+  }
+  else
+  {
+    cu.bdpcmModeChroma = bdpcmMode;
+  }
+  if (isLuma(compID))
+  {
+    DTRACE(g_trace_ctx, D_SYNTAX, "bdpcm_mode(%d) x=%d, y=%d, w=%d, h=%d, bdpcm=%d\n", ChannelType::LUMA,
+           cu.lumaPos().x, cu.lumaPos().y, cu.lwidth(), cu.lheight(), cu.bdpcmMode);
+  }
+  else
+  {
+    DTRACE(g_trace_ctx, D_SYNTAX, "bdpcm_mode(%d) x=%d, y=%d, w=%d, h=%d, bdpcm=%d\n", ChannelType::CHROMA,
+           cu.chromaPos().x, cu.chromaPos().y, cu.chromaSize().width, cu.chromaSize().height, cu.bdpcmModeChroma);
+  }
+}
+
+void CABACReader::cu_pred_data( CodingUnit &cu )
+{
+  if( CU::isIntra( cu ) )
+  {
+    if( cu.Y().valid() )
+	{
+      bdpcm_mode(cu, COMPONENT_Y );
+    }
+    intra_luma_pred_modes( cu );
+    if( ( !cu.Y().valid() || (!cu.isSepTree() && cu.Y().valid() ) ) && isChromaEnabled(cu.chromaFormat) )
+    {
+      bdpcm_mode(cu, ComponentID(ChannelType::CHROMA));
+    }
+    intra_chroma_pred_modes( cu );
+    return;
+  }
+  if (!cu.Y().valid()) // dual tree chroma CU
+  {
+    cu.predMode = MODE_IBC;
+    return;
+  }
+
+  for( auto &pu : CU::traversePUs( cu ) )
+  {
+    prediction_unit( pu );
+  }
+
+  imv_mode   ( cu );
+  affine_amvr_mode( cu );
+  cu_bcw_flag( cu );
+}
+
+void CABACReader::cu_bcw_flag(CodingUnit& cu)
+{
+  if(!CU::isBcwIdxCoded(cu))
+  {
+    return;
+  }
+
+  CHECK(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__BCW_IDX);
+
+  uint32_t idx = 0;
+
+  uint32_t symbol = m_binDecoder.decodeBin(Ctx::bcwIdx(0));
+
+  int32_t numBcw = (cu.slice->getCheckLDC()) ? 5 : 3;
+  if(symbol == 1)
+  {
+    uint32_t prefixNumBits = numBcw - 2;
+    uint32_t step = 1;
+
+    idx = 1;
+
+    for(int ui = 0; ui < prefixNumBits; ++ui)
+    {
+      symbol = m_binDecoder.decodeBinEP();
+      if (symbol == 0)
+      {
+        break;
+      }
+      idx += step;
+    }
+  }
+
+  cu.bcwIdx = (uint8_t) g_BcwParsingOrder[idx];
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "cu_bcw_flag() bcw_idx=%d\n", cu.bcwIdx ? 1 : 0);
+}
+
+void CABACReader::xReadTruncBinCode(uint32_t &symbol, uint32_t numSymbols)
+{
+  const int thresh = floorLog2(numSymbols);
+  const int val    = 1 << thresh;
+  const int b      = numSymbols - val;
+
+  symbol = m_binDecoder.decodeBinsEP(thresh);
+  if (symbol >= val - b)
+  {
+    symbol = 2 * symbol - (val - b) + m_binDecoder.decodeBinEP();
+  }
+}
+
+void CABACReader::extend_ref_line(CodingUnit& cu)
+{
+  if (!cu.Y().valid() || !CU::isIntra(cu) || !isLuma(cu.chType) || cu.bdpcmMode != BdpcmMode::NONE)
+  {
+    cu.firstPU->multiRefIdx = 0;
+    return;
+  }
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__MULTI_REF_LINE);
+
+  const int numBlocks = CU::getNumPUs(cu);
+  PredictionUnit* pu = cu.firstPU;
+
+  for (int k = 0; k < numBlocks; k++)
+  {
+    if( !cu.cs->sps->getUseMRL() )
+    {
+      pu->multiRefIdx = 0;
+      pu = pu->next;
+      continue;
+    }
+    bool isFirstLineOfCtu = (((cu.block(COMPONENT_Y).y)&((cu.cs->sps)->getMaxCUWidth() - 1)) == 0);
+    if (isFirstLineOfCtu)
+    {
+      pu->multiRefIdx = 0;
+      continue;
+    }
+    int multiRefIdx = 0;
+
+    if (MRL_NUM_REF_LINES > 1)
+    {
+      multiRefIdx =
+        m_binDecoder.decodeBin(Ctx::MultiRefLineIdx(0)) == 1 ? MULTI_REF_LINE_IDX[1] : MULTI_REF_LINE_IDX[0];
+      if (MRL_NUM_REF_LINES > 2 && multiRefIdx != MULTI_REF_LINE_IDX[0])
+      {
+        multiRefIdx =
+          m_binDecoder.decodeBin(Ctx::MultiRefLineIdx(1)) == 1 ? MULTI_REF_LINE_IDX[2] : MULTI_REF_LINE_IDX[1];
+      }
+    }
+    pu->multiRefIdx = multiRefIdx;
+    pu = pu->next;
+  }
+}
+
+void CABACReader::intra_luma_pred_modes( CodingUnit &cu )
+{
+  if( !cu.Y().valid() )
+  {
+    return;
+  }
+
+  if (cu.bdpcmMode != BdpcmMode::NONE)
+  {
+    cu.firstPU->intraDir[ChannelType::LUMA] = cu.bdpcmMode == BdpcmMode::VER ? VER_IDX : HOR_IDX;
+    return;
+  }
+
+  mip_flag(cu);
+  if (cu.mipFlag)
+  {
+    mip_pred_modes(cu);
+    return;
+  }
+  extend_ref_line( cu );
+  isp_mode( cu );
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(STATS__CABAC_BITS__INTRA_DIR_ANG, cu.lumaSize(),
+                                                      ChannelType::LUMA);
+
+  // prev_intra_luma_pred_flag
+  int numBlocks = CU::getNumPUs( cu );
+  int mpmFlag[4];
+  for( int k = 0; k < numBlocks; k++ )
+  {
+    CHECK(numBlocks != 1, "not supported yet");
+    if ( cu.firstPU->multiRefIdx )
+    {
+      mpmFlag[0] = true;
+    }
+    else
+    {
+      mpmFlag[k] = m_binDecoder.decodeBin(Ctx::IntraLumaMpmFlag());
+    }
+  }
+
+  PredictionUnit *pu = cu.firstPU;
+
+  unsigned mpm_pred[NUM_MOST_PROBABLE_MODES];  // mpm_idx / rem_intra_luma_pred_mode
+  for( int k = 0; k < numBlocks; k++ )
+  {
+    PU::getIntraMPMs( *pu, mpm_pred );
+
+    if( mpmFlag[k] )
+    {
+      uint32_t ipred_idx = 0;
+      {
+        unsigned ctx = (pu->cu->ispMode == ISPType::NONE ? 1 : 0);
+        if (pu->multiRefIdx == 0)
+        {
+          ipred_idx = m_binDecoder.decodeBin(Ctx::IntraLumaPlanarFlag(ctx));
+        }
+        else
+        {
+          ipred_idx = 1;
+        }
+        if( ipred_idx )
+        {
+          ipred_idx += m_binDecoder.decodeBinEP();
+        }
+        if (ipred_idx > 1)
+        {
+          ipred_idx += m_binDecoder.decodeBinEP();
+        }
+        if (ipred_idx > 2)
+        {
+          ipred_idx += m_binDecoder.decodeBinEP();
+        }
+        if (ipred_idx > 3)
+        {
+          ipred_idx += m_binDecoder.decodeBinEP();
+        }
+      }
+      pu->intraDir[ChannelType::LUMA] = mpm_pred[ipred_idx];
+    }
+    else
+    {
+      unsigned ipred_mode = 0;
+
+      xReadTruncBinCode(ipred_mode, NUM_LUMA_MODE - NUM_MOST_PROBABLE_MODES);
+      //postponed sorting of MPMs (only in remaining branch)
+      std::sort( mpm_pred, mpm_pred + NUM_MOST_PROBABLE_MODES );
+
+      for( uint32_t i = 0; i < NUM_MOST_PROBABLE_MODES; i++ )
+      {
+        ipred_mode += (ipred_mode >= mpm_pred[i]);
+      }
+
+      pu->intraDir[ChannelType::LUMA] = ipred_mode;
+    }
+
+    DTRACE(g_trace_ctx, D_SYNTAX, "intra_luma_pred_modes() idx=%d pos=(%d,%d) mode=%d\n", k, pu->lumaPos().x,
+           pu->lumaPos().y, pu->intraDir[ChannelType::LUMA]);
+    pu = pu->next;
+  }
+}
+
+void CABACReader::intra_chroma_pred_modes( CodingUnit& cu )
+{
+  if (!isChromaEnabled(cu.chromaFormat) || (cu.isSepTree() && isLuma(cu.chType)))
+  {
+    return;
+  }
+
+  if (cu.bdpcmModeChroma != BdpcmMode::NONE)
+  {
+    cu.firstPU->intraDir[ChannelType::CHROMA] = cu.bdpcmModeChroma == BdpcmMode::VER ? VER_IDX : HOR_IDX;
+    return;
+  }
+  PredictionUnit *pu = cu.firstPU;
+
+  CHECK(pu->cu != &cu, "Inconsistent PU-CU mapping");
+  intra_chroma_pred_mode(*pu);
+}
+
+bool CABACReader::intra_chroma_lmc_mode(PredictionUnit& pu)
+{
+  int lmModeList[10];
+  PU::getLMSymbolList(pu, lmModeList);
+
+  int symbol = m_binDecoder.decodeBin(Ctx::CclmModeIdx(0));
+
+  if (symbol == 0)
+  {
+    pu.intraDir[ChannelType::CHROMA] = lmModeList[symbol];
+    CHECK(pu.intraDir[ChannelType::CHROMA] != LM_CHROMA_IDX, "should be LM_CHROMA");
+  }
+  else
+  {
+    symbol += m_binDecoder.decodeBinEP();
+    pu.intraDir[ChannelType::CHROMA] = lmModeList[symbol];
+  }
+  return true; //it will only enter this function for LMC modes, so always return true ;
+}
+
+void CABACReader::intra_chroma_pred_mode(PredictionUnit& pu)
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(STATS__CABAC_BITS__INTRA_DIR_ANG,
+                                                      pu.cu->block(pu.chType).lumaSize(), ChannelType::CHROMA);
+  if (pu.cu->colorTransform)
+  {
+    pu.intraDir[ChannelType::CHROMA] = DM_CHROMA_IDX;
+    return;
+  }
+
+  // LM chroma mode
+
+  if (pu.cs->sps->getUseLMChroma() && pu.cu->checkCCLMAllowed())
+  {
+    bool isLMCMode = m_binDecoder.decodeBin(Ctx::CclmModeFlag(0)) ? true : false;
+    if (isLMCMode)
+    {
+      intra_chroma_lmc_mode(pu);
+      return;
+    }
+  }
+
+  if (m_binDecoder.decodeBin(Ctx::IntraChromaPredMode(0)) == 0)
+  {
+    pu.intraDir[ChannelType::CHROMA] = DM_CHROMA_IDX;
+    return;
+  }
+
+  unsigned candId = m_binDecoder.decodeBinsEP(2);
+
+  unsigned chromaCandModes[NUM_CHROMA_MODE];
+  PU::getIntraChromaCandModes(pu, chromaCandModes);
+
+  CHECK(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
+  CHECK(PU::isLMCMode(chromaCandModes[candId]), "The intra dir cannot be LM_CHROMA for this path");
+  CHECK(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
+
+  pu.intraDir[ChannelType::CHROMA] = chromaCandModes[candId];
+}
+
+void CABACReader::cu_residual( CodingUnit& cu, Partitioner &partitioner, CUCtx& cuCtx )
+{
+  if (!CU::isIntra(cu))
+  {
+    PredictionUnit& pu = *cu.firstPU;
+    if( !pu.mergeFlag )
+    {
+      rqt_root_cbf( cu );
+    }
+    else
+    {
+      cu.rootCbf = true;
+    }
+    if( cu.rootCbf )
+    {
+      sbt_mode( cu );
+    }
+    if( !cu.rootCbf )
+    {
+      cu.colorTransform = false;
+      cu.cs->addEmptyTUs( partitioner );
+      return;
+    }
+  }
+
+  if (CU::isInter(cu) || CU::isIBC(cu))
+  {
+    adaptive_color_transform(cu);
+  }
+
+  cuCtx.violatesLfnstConstrained.fill(false);
+  cuCtx.lfnstLastScanPos                              = false;
+  cuCtx.violatesMtsCoeffConstraint                    = false;
+  cuCtx.mtsLastScanPos                                = false;
+
+  ChromaCbfs chromaCbfs;
+  if (cu.ispMode != ISPType::NONE && isLuma(partitioner.chType))
+  {
+    TUIntraSubPartitioner subTuPartitioner( partitioner );
+    transform_tree( *cu.cs, subTuPartitioner, cuCtx, CU::getISPType(cu, getFirstComponentOfChannel(partitioner.chType)), 0 );
+  }
+  else
+  {
+    transform_tree( *cu.cs, partitioner, cuCtx             );
+  }
+
+  residual_lfnst_mode( cu, cuCtx );
+  mts_idx            ( cu, cuCtx );
+}
+
+void CABACReader::rqt_root_cbf( CodingUnit& cu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__QT_ROOT_CBF );
+
+  cu.rootCbf = (m_binDecoder.decodeBin(Ctx::QtRootCbf()));
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "rqt_root_cbf() ctx=0 root_cbf=%d pos=(%d,%d)\n", cu.rootCbf ? 1 : 0, cu.lumaPos().x, cu.lumaPos().y );
+}
+
+void CABACReader::adaptive_color_transform(CodingUnit& cu)
+{
+  if (!cu.slice->getSPS()->getUseColorTrans())
+  {
+    return;
+  }
+
+  if (cu.isSepTree())
+  {
+    return;
+  }
+
+  if (CU::isInter(cu) || CU::isIBC(cu) || CU::isIntra(cu))
+  {
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__ACT );
+    cu.colorTransform = (m_binDecoder.decodeBin(Ctx::ACTFlag()));
+  }
+}
+
+void CABACReader::sbt_mode( CodingUnit& cu )
+{
+  const uint8_t sbtAllowed = cu.checkAllowedSbt();
+  if( !sbtAllowed )
+  {
+    return;
+  }
+
+  SizeType cuWidth = cu.lwidth();
+  SizeType cuHeight = cu.lheight();
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__SBT_MODE );
+  //bin - flag
+  uint8_t ctxIdx = ( cuWidth * cuHeight <= 256 ) ? 1 : 0;
+  bool    sbtFlag = m_binDecoder.decodeBin(Ctx::SbtFlag(ctxIdx));
+  if( !sbtFlag )
+  {
+    return;
+  }
+
+  uint8_t sbtVerHalfAllow = CU::targetSbtAllowed( SBT_VER_HALF, sbtAllowed );
+  uint8_t sbtHorHalfAllow = CU::targetSbtAllowed( SBT_HOR_HALF, sbtAllowed );
+  uint8_t sbtVerQuadAllow = CU::targetSbtAllowed( SBT_VER_QUAD, sbtAllowed );
+  uint8_t sbtHorQuadAllow = CU::targetSbtAllowed( SBT_HOR_QUAD, sbtAllowed );
+
+  //bin - type
+  bool sbtQuadFlag = false;
+  if( ( sbtHorHalfAllow || sbtVerHalfAllow ) && ( sbtHorQuadAllow || sbtVerQuadAllow ) )
+  {
+    sbtQuadFlag = m_binDecoder.decodeBin(Ctx::SbtQuadFlag(0));
+  }
+  else
+  {
+    sbtQuadFlag = 0;
+  }
+
+  //bin - dir
+  bool sbtHorFlag = false;
+  if( ( sbtQuadFlag && sbtVerQuadAllow && sbtHorQuadAllow ) || ( !sbtQuadFlag && sbtVerHalfAllow && sbtHorHalfAllow ) ) //both direction allowed
+  {
+    uint8_t ctxIdx = ( cuWidth == cuHeight ) ? 0 : ( cuWidth < cuHeight ? 1 : 2 );
+    sbtHorFlag     = m_binDecoder.decodeBin(Ctx::SbtHorFlag(ctxIdx));
+  }
+  else
+  {
+    sbtHorFlag = ( sbtQuadFlag && sbtHorQuadAllow ) || ( !sbtQuadFlag && sbtHorHalfAllow );
+  }
+  cu.setSbtIdx( sbtHorFlag ? ( sbtQuadFlag ? SBT_HOR_QUAD : SBT_HOR_HALF ) : ( sbtQuadFlag ? SBT_VER_QUAD : SBT_VER_HALF ) );
+
+  //bin - pos
+  bool sbtPosFlag = m_binDecoder.decodeBin(Ctx::SbtPosFlag(0));
+  cu.setSbtPos( sbtPosFlag ? SBT_POS1 : SBT_POS0 );
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "sbt_mode() pos=(%d,%d) sbtInfo=%d\n", cu.lx(), cu.ly(), (int)cu.sbtInfo );
+}
+
+
+void CABACReader::end_of_ctu( CodingUnit& cu, CUCtx& cuCtx )
+{
+  const Position rbPos =
+    recalcPosition(cu.chromaFormat, cu.chType, ChannelType::LUMA, cu.block(cu.chType).bottomRight().offset(1, 1));
+
+  if (((rbPos.x & cu.cs->pcv->maxCUWidthMask) == 0 || rbPos.x == cu.cs->pps->getPicWidthInLumaSamples())
+      && ((rbPos.y & cu.cs->pcv->maxCUHeightMask) == 0 || rbPos.y == cu.cs->pps->getPicHeightInLumaSamples())
+      && (!cu.isSepTree() || !isChromaEnabled(cu.chromaFormat) || isChroma(cu.chType)))
+  {
+    cuCtx.isDQPCoded = ( cu.cs->pps->getUseDQP() && !cuCtx.isDQPCoded );
+  }
+}
+
+void CABACReader::cu_palette_info(CodingUnit& cu, ComponentID compBegin, uint32_t numComp, CUCtx& cuCtx)
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__PLT_MODE );
+
+  const SPS&      sps = *(cu.cs->sps);
+  TransformUnit&   tu = *cu.firstTU;
+  int curPLTidx = 0;
+
+  if( cu.isLocalSepTree() )
+  {
+    cu.cs->prevPLT.curPLTSize[compBegin] = cu.cs->prevPLT.curPLTSize[COMPONENT_Y];
+  }
+  cu.lastPLTSize[compBegin] = cu.cs->prevPLT.curPLTSize[compBegin];
+
+  int maxPltSize = cu.isSepTree() ? MAXPLTSIZE_DUALTREE : MAXPLTSIZE;
+
+  if (cu.lastPLTSize[compBegin])
+  {
+    xDecodePLTPredIndicator(cu, maxPltSize, compBegin);
+  }
+
+  for (int idx = 0; idx < cu.lastPLTSize[compBegin]; idx++)
+  {
+    if (cu.reuseflag[compBegin][idx])
+    {
+      if( cu.isLocalSepTree() )
+      {
+        for( int comp = COMPONENT_Y; comp < MAX_NUM_COMPONENT; comp++ )
+        {
+          cu.curPLT[comp][curPLTidx] = cu.cs->prevPLT.curPLT[comp][idx];
+        }
+      }
+      else
+      {
+        for (int comp = compBegin; comp < (compBegin + numComp); comp++)
+        {
+          cu.curPLT[comp][curPLTidx] = cu.cs->prevPLT.curPLT[comp][idx];
+        }
+      }
+      curPLTidx++;
+    }
+  }
+
+  uint32_t recievedPLTnum = 0;
+  if (curPLTidx < maxPltSize)
+  {
+    recievedPLTnum = exp_golomb_eqprob(0);
+  }
+
+  cu.curPLTSize[compBegin] = curPLTidx + recievedPLTnum;
+  if( cu.isLocalSepTree() )
+    cu.curPLTSize[COMPONENT_Y] = cu.curPLTSize[compBegin];
+  for (int comp = compBegin; comp < (compBegin + numComp); comp++)
+  {
+    for (int idx = curPLTidx; idx < cu.curPLTSize[compBegin]; idx++)
+    {
+      ComponentID compID = (ComponentID)comp;
+      const int  channelBitDepth = sps.getBitDepth(toChannelType(compID));
+      cu.curPLT[compID][idx]      = m_binDecoder.decodeBinsEP(channelBitDepth);
+      if( cu.isLocalSepTree() )
+      {
+        if( isLuma( cu.chType ) )
+        {
+          cu.curPLT[COMPONENT_Cb][idx] = 1 << (cu.cs->sps->getBitDepth(ChannelType::CHROMA) - 1);
+          cu.curPLT[COMPONENT_Cr][idx] = 1 << (cu.cs->sps->getBitDepth(ChannelType::CHROMA) - 1);
+        }
+        else
+        {
+          cu.curPLT[COMPONENT_Y][idx] = 1 << (cu.cs->sps->getBitDepth(ChannelType::LUMA) - 1);
+        }
+      }
+    }
+  }
+
+  cu.useEscape[compBegin] = true;
+  if (cu.curPLTSize[compBegin] > 0)
+  {
+    uint32_t escCode = 0;
+    escCode                 = m_binDecoder.decodeBinEP();
+    cu.useEscape[compBegin] = (escCode != 0);
+  }
+  uint32_t    indexMaxSize = cu.useEscape[compBegin] ? (cu.curPLTSize[compBegin] + 1) : cu.curPLTSize[compBegin];
+  //encode index map
+  uint32_t    height = cu.block(compBegin).height;
+  uint32_t    width = cu.block(compBegin).width;
+
+  uint32_t total = height * width;
+  if (indexMaxSize > 1)
+  {
+    parseScanRotationModeFlag(cu, compBegin);
+  }
+  else
+  {
+    cu.useRotation[compBegin] = false;
+  }
+
+  if (cu.useEscape[compBegin] && cu.cs->pps->getUseDQP() && !cuCtx.isDQPCoded)
+  {
+    if (!cu.isSepTree() || isLuma(tu.chType))
+    {
+      cu_qp_delta(cu, cuCtx.qp, cu.qp);
+      cuCtx.qp = cu.qp;
+      cuCtx.isDQPCoded = true;
+    }
+  }
+  if (cu.useEscape[compBegin] && cu.cs->slice->getUseChromaQpAdj() && !cuCtx.isChromaQpAdjCoded)
+  {
+    if (!cu.isSepTree() || isChroma(tu.chType))
+    {
+      cu_chroma_qp_offset(cu);
+      cuCtx.isChromaQpAdjCoded = true;
+    }
+  }
+
+  m_scanOrder = g_scanOrder[SCAN_UNGROUPED][(cu.useRotation[compBegin]) ? CoeffScanType::TRAV_VER : CoeffScanType::TRAV_HOR][gp_sizeIdxInfo->idxFrom(width)][gp_sizeIdxInfo->idxFrom(height)];
+  uint32_t prevRunPos = 0;
+  unsigned prevRunType = 0;
+  for (int subSetId = 0; subSetId <= (total - 1) >> LOG2_PALETTE_CG_SIZE; subSetId++)
+  {
+    cuPaletteSubblockInfo(cu, compBegin, numComp, subSetId, prevRunPos, prevRunType);
+  }
+  CHECK(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
+}
+
+void CABACReader::cuPaletteSubblockInfo(CodingUnit& cu, ComponentID compBegin, uint32_t numComp, int subSetId, uint32_t& prevRunPos, unsigned& prevRunType)
+{
+  const SPS&      sps = *(cu.cs->sps);
+  TransformUnit&  tu = *cu.firstTU;
+  PLTtypeBuf      runType      = tu.getrunType(toChannelType(compBegin));
+  PelBuf          curPLTIdx = tu.getcurPLTIdx(compBegin);
+  uint32_t        indexMaxSize = cu.useEscape[compBegin] ? (cu.curPLTSize[compBegin] + 1) : cu.curPLTSize[compBegin];
+  uint32_t        totalPel = cu.block(compBegin).height*cu.block(compBegin).width;
+
+  int minSubPos = subSetId << LOG2_PALETTE_CG_SIZE;
+  int maxSubPos = minSubPos + (1 << LOG2_PALETTE_CG_SIZE);
+  maxSubPos = (maxSubPos > totalPel) ? totalPel : maxSubPos; // if last position is out of the current CU size
+
+  unsigned runCopyFlag[(1 << LOG2_PALETTE_CG_SIZE)];
+  for (int i = 0; i < (1 << LOG2_PALETTE_CG_SIZE); i++)
+  {
+    runCopyFlag[i] = MAX_INT;
+  }
+  if (minSubPos == 0)
+  {
+    runCopyFlag[0] = 0;
+  }
+
+  // PLT runCopy flag and runType - context coded
+  int curPos = minSubPos;
+  for (; curPos < maxSubPos && indexMaxSize > 1; curPos++)
+  {
+    uint32_t posy = m_scanOrder[curPos].y;
+    uint32_t posx = m_scanOrder[curPos].x;
+    uint32_t posyprev = (curPos == 0) ? 0 : m_scanOrder[curPos - 1].y;
+    uint32_t posxprev = (curPos == 0) ? 0 : m_scanOrder[curPos - 1].x;
+    unsigned identityFlag = 1;
+
+    const CtxSet&   ctxSet = (prevRunType == PLT_RUN_INDEX) ? Ctx::IdxRunModel : Ctx::CopyRunModel;
+    if (curPos > 0)
+    {
+      int dist = curPos - prevRunPos - 1;
+      const unsigned  ctxId = DeriveCtx::CtxPltCopyFlag(prevRunType, dist);
+      identityFlag          = m_binDecoder.decodeBin(ctxSet(ctxId));
+      DTRACE(g_trace_ctx, D_SYNTAX, "plt_copy_flag() bin=%d ctx=%d\n", identityFlag, ctxId);
+      runCopyFlag[curPos - minSubPos] = identityFlag;
+    }
+
+    if ( identityFlag == 0 || curPos == 0 )
+    {
+      if (((posy == 0) && !cu.useRotation[compBegin]) || ((posx == 0) && cu.useRotation[compBegin]))
+      {
+        runType.at(posx, posy) = PLT_RUN_INDEX;
+      }
+      else if (curPos != 0 && runType.at(posxprev, posyprev) == PLT_RUN_COPY)
+      {
+        runType.at(posx, posy) = PLT_RUN_INDEX;
+      }
+      else
+      {
+        runType.at(posx, posy) = (m_binDecoder.decodeBin(Ctx::RunTypeFlag()));
+      }
+      DTRACE(g_trace_ctx, D_SYNTAX, "plt_type_flag() bin=%d sp=%d\n", runType.at(posx, posy), curPos);
+      prevRunType = runType.at(posx, posy);
+      prevRunPos  = curPos;
+    }
+    else //assign run information
+    {
+      runType.at(posx, posy) = runType.at(posxprev, posyprev);
+    }
+  }
+
+  // PLT index values - bypass coded
+  uint32_t adjust;
+  uint32_t symbol = 0;
+  curPos = minSubPos;
+  if (indexMaxSize > 1)
+  {
+    for (; curPos < maxSubPos; curPos++)
+    {
+      if (curPos > 0)
+      {
+        adjust = 1;
+      }
+      else
+      {
+        adjust = 0;
+      }
+
+      uint32_t posy = m_scanOrder[curPos].y;
+      uint32_t posx = m_scanOrder[curPos].x;
+      uint32_t posyprev = (curPos == 0) ? 0 : m_scanOrder[curPos - 1].y;
+      uint32_t posxprev = (curPos == 0) ? 0 : m_scanOrder[curPos - 1].x;
+      if ( runCopyFlag[curPos - minSubPos] == 0 && runType.at(posx, posy) == PLT_RUN_INDEX )
+      {
+        xReadTruncBinCode(symbol, indexMaxSize - adjust);
+        xAdjustPLTIndex(cu, symbol, curPos, curPLTIdx, runType, indexMaxSize, compBegin);
+        DTRACE(g_trace_ctx, D_SYNTAX, "plt_idx_idc() value=%d sp=%d\n", curPLTIdx.at(posx, posy), curPos);
+      }
+      else if (runType.at(posx, posy) == PLT_RUN_INDEX)
+      {
+        curPLTIdx.at(posx, posy) = curPLTIdx.at(posxprev, posyprev);
+      }
+      else
+      {
+        curPLTIdx.at(posx, posy) = (cu.useRotation[compBegin]) ? curPLTIdx.at(posx - 1, posy) : curPLTIdx.at(posx, posy - 1);
+      }
+    }
+  }
+  else
+  {
+    for (; curPos < maxSubPos; curPos++)
+    {
+      uint32_t posy = m_scanOrder[curPos].y;
+      uint32_t posx = m_scanOrder[curPos].x;
+      uint32_t posyprev = (curPos == 0) ? 0 : m_scanOrder[curPos - 1].y;
+      uint32_t posxprev = (curPos == 0) ? 0 : m_scanOrder[curPos - 1].x;
+      runType.at(posx, posy) = PLT_RUN_INDEX;
+      if (runCopyFlag[curPos - minSubPos] == 0 && runType.at(posx, posy) == PLT_RUN_INDEX)
+      {
+        curPLTIdx.at(posx, posy) = 0;
+      }
+      else
+      {
+        curPLTIdx.at(posx, posy) = curPLTIdx.at(posxprev, posyprev);
+      }
+    }
+  }
+
+  // Quantized escape colors - bypass coded
+  uint32_t scaleX = getComponentScaleX(COMPONENT_Cb, sps.getChromaFormatIdc());
+  uint32_t scaleY = getComponentScaleY(COMPONENT_Cb, sps.getChromaFormatIdc());
+  for (int comp = compBegin; comp < (compBegin + numComp); comp++)
+  {
+    ComponentID compID = (ComponentID)comp;
+    for (curPos = minSubPos; curPos < maxSubPos; curPos++)
+    {
+      uint32_t posy = m_scanOrder[curPos].y;
+      uint32_t posx = m_scanOrder[curPos].x;
+      if (curPLTIdx.at(posx, posy) == cu.curPLTSize[compBegin])
+      {
+          PLTescapeBuf    escapeValue = tu.getescapeValue((ComponentID)comp);
+          if (compID == COMPONENT_Y || compBegin != COMPONENT_Y)
+          {
+            escapeValue.at(posx, posy) = exp_golomb_eqprob(5);
+            assert(escapeValue.at(posx, posy) < (TCoeff(1) << (cu.cs->sps->getBitDepth(toChannelType((ComponentID)comp)) + 1)));
+            DTRACE(g_trace_ctx, D_SYNTAX, "plt_escape_val() value=%d etype=%d sp=%d\n", escapeValue.at(posx, posy), comp, curPos);
+          }
+          if (compBegin == COMPONENT_Y && compID != COMPONENT_Y && posy % (1 << scaleY) == 0 && posx % (1 << scaleX) == 0)
+          {
+            uint32_t posxC = posx >> scaleX;
+            uint32_t posyC = posy >> scaleY;
+            escapeValue.at(posxC, posyC) = exp_golomb_eqprob(5);
+            assert(escapeValue.at(posxC, posyC) < (TCoeff(1) << (cu.cs->sps->getBitDepth(toChannelType(compID)) + 1)));
+            DTRACE(g_trace_ctx, D_SYNTAX, "plt_escape_val() value=%d etype=%d sp=%d\n", escapeValue.at(posx, posy), comp, curPos);
+          }
+      }
+    }
+  }
+}
+
+void CABACReader::parseScanRotationModeFlag(CodingUnit& cu, ComponentID compBegin)
+{
+  cu.useRotation[compBegin] = m_binDecoder.decodeBin(Ctx::RotationFlag());
+}
+
+void CABACReader::xDecodePLTPredIndicator(CodingUnit& cu, uint32_t maxPLTSize, ComponentID compBegin)
+{
+  uint32_t symbol, numPltPredicted = 0, idx = 0;
+
+  symbol = exp_golomb_eqprob(0);
+
+  if (symbol != 1)
+  {
+    while (idx < cu.lastPLTSize[compBegin] && numPltPredicted < maxPLTSize)
+    {
+      if (idx > 0)
+      {
+        symbol = exp_golomb_eqprob(0);
+      }
+      if (symbol == 1)
+      {
+        break;
+      }
+
+      if (symbol)
+      {
+        idx += symbol - 1;
+      }
+      cu.reuseflag[compBegin][idx] = 1;
+      if( cu.isLocalSepTree() )
+      {
+        cu.reuseflag[COMPONENT_Y][idx] = 1;
+      }
+      numPltPredicted++;
+      idx++;
+    }
+  }
+}
+void CABACReader::xAdjustPLTIndex(CodingUnit& cu, Pel curLevel, uint32_t idx, PelBuf& paletteIdx, PLTtypeBuf& paletteRunType, int maxSymbol, ComponentID compBegin)
+{
+  uint32_t symbol;
+  int refLevel = MAX_INT;
+  uint32_t posy = m_scanOrder[idx].y;
+  uint32_t posx = m_scanOrder[idx].x;
+  if (idx)
+  {
+    uint32_t prevposy = m_scanOrder[idx - 1].y;
+    uint32_t prevposx = m_scanOrder[idx - 1].x;
+    if (paletteRunType.at(prevposx, prevposy) == PLT_RUN_INDEX)
+    {
+      refLevel = paletteIdx.at(prevposx, prevposy);
+      if (paletteIdx.at(prevposx, prevposy) == cu.curPLTSize[compBegin]) // escape
+      {
+        refLevel = maxSymbol - 1;
+      }
+    }
+    else
+    {
+      if (cu.useRotation[compBegin])
+      {
+        assert(prevposx > 0);
+        refLevel = paletteIdx.at(posx - 1, posy);
+        if (paletteIdx.at(posx - 1, posy) == cu.curPLTSize[compBegin]) // escape mode
+        {
+          refLevel = maxSymbol - 1;
+        }
+      }
+      else
+      {
+        assert(prevposy > 0);
+        refLevel = paletteIdx.at(posx, posy - 1);
+        if (paletteIdx.at(posx, posy - 1) == cu.curPLTSize[compBegin]) // escape mode
+        {
+          refLevel = maxSymbol - 1;
+        }
+      }
+    }
+    maxSymbol--;
+  }
+  symbol = curLevel;
+  if (curLevel >= refLevel) // include escape mode
+  {
+    symbol++;
+  }
+  paletteIdx.at(posx, posy) = symbol;
+}
+
+//================================================================================
+//  clause 7.3.8.6
+//--------------------------------------------------------------------------------
+//    void  prediction_unit ( pu, mrgCtx );
+//    void  merge_flag      ( pu );
+//    void  merge_data      ( pu, mrgCtx );
+//    void  merge_idx       ( pu );
+//    void  inter_pred_idc  ( pu );
+//    void  ref_idx         ( pu, refList );
+//    void  mvp_flag        ( pu, refList );
+//================================================================================
+
+void CABACReader::prediction_unit( PredictionUnit& pu )
+{
+  if( pu.cu->skip )
+  {
+    pu.mergeFlag = true;
+  }
+  else
+  {
+    merge_flag( pu );
+  }
+  if( pu.mergeFlag )
+  {
+    merge_data(pu);
+  }
+  else if (CU::isIBC(*pu.cu))
+  {
+    pu.interDir = 1;
+    pu.cu->affine = false;
+    pu.refIdx[REF_PIC_LIST_0] = IBC_REF_IDX;
+    mvd_coding(pu.mvd[REF_PIC_LIST_0]);
+    if (pu.cs->sps->getMaxNumIBCMergeCand() == 1)
+    {
+      pu.mvpIdx[REF_PIC_LIST_0] = 0;
+    }
+    else
+    {
+      mvp_flag(pu, REF_PIC_LIST_0);
+    }
+  }
+  else
+  {
+    inter_pred_idc( pu );
+    affine_flag   ( *pu.cu );
+    smvd_mode( pu );
+
+    if( pu.interDir != 2 /* PRED_L1 */ )
+    {
+      ref_idx     ( pu, REF_PIC_LIST_0 );
+      if( pu.cu->affine )
+      {
+        for (int i = 0; i < pu.cu->getNumAffineMvs(); i++)
+        {
+          mvd_coding(pu.mvdAffi[REF_PIC_LIST_0][i]);
+        }
+      }
+      else
+      {
+        mvd_coding( pu.mvd[REF_PIC_LIST_0] );
+      }
+      mvp_flag    ( pu, REF_PIC_LIST_0 );
+    }
+
+    if( pu.interDir != 1 /* PRED_L0 */ )
+    {
+      if ( pu.cu->smvdMode != 1 )
+      {
+        ref_idx(pu, REF_PIC_LIST_1);
+        if (pu.cu->cs->picHeader->getMvdL1ZeroFlag() && pu.interDir == 3 /* PRED_BI */)
+        {
+          pu.mvd[REF_PIC_LIST_1]        = Mv();
+          pu.mvdAffi[REF_PIC_LIST_1][0] = Mv();
+          pu.mvdAffi[REF_PIC_LIST_1][1] = Mv();
+          pu.mvdAffi[REF_PIC_LIST_1][2] = Mv();
+        }
+        else if (pu.cu->affine)
+        {
+          for (int i = 0; i < pu.cu->getNumAffineMvs(); i++)
+          {
+            mvd_coding(pu.mvdAffi[REF_PIC_LIST_1][i]);
+          }
+        }
+        else
+        {
+          mvd_coding(pu.mvd[REF_PIC_LIST_1]);
+        }
+      }
+      mvp_flag    ( pu, REF_PIC_LIST_1 );
+    }
+  }
+  if( pu.interDir == 3 /* PRED_BI */ && PU::isBipredRestriction(pu) )
+  {
+    pu.mv    [REF_PIC_LIST_1] = Mv(0, 0);
+    pu.refIdx[REF_PIC_LIST_1] = -1;
+    pu.interDir               =  1;
+    pu.cu->bcwIdx             = BCW_DEFAULT;
+  }
+
+  if ( pu.cu->smvdMode )
+  {
+    RefPicList eCurRefList = (RefPicList)(pu.cu->smvdMode - 1);
+    pu.mvd[1 - eCurRefList].set( -pu.mvd[eCurRefList].hor, -pu.mvd[eCurRefList].ver );
+    CHECK(!((pu.mvd[1 - eCurRefList].getHor() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getHor() <= MVD_MAX)) || !((pu.mvd[1 - eCurRefList].getVer() >= MVD_MIN) && (pu.mvd[1 - eCurRefList].getVer() <= MVD_MAX)), "Illegal MVD value");
+    pu.refIdx[1 - eCurRefList] = pu.cs->slice->getSymRefIdx( 1 - eCurRefList );
+  }
+}
+
+void CABACReader::smvd_mode( PredictionUnit& pu )
+{
+  pu.cu->smvdMode = 0;
+  if ( pu.interDir != 3 || pu.cu->affine )
+  {
+    return;
+  }
+
+  if ( pu.cs->slice->getBiDirPred() == false )
+  {
+    return;
+  }
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__SYMMVD_FLAG );
+
+  pu.cu->smvdMode = m_binDecoder.decodeBin(Ctx::SmvdFlag()) ? 1 : 0;
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "symmvd_flag() symmvd=%d pos=(%d,%d) size=%dx%d\n", pu.cu->smvdMode ? 1 : 0, pu.lumaPos().x, pu.lumaPos().y, pu.lumaSize().width, pu.lumaSize().height );
+}
+
+void CABACReader::subblock_merge_flag( CodingUnit& cu )
+{
+  cu.affine = false;
+
+  if ( !cu.cs->slice->isIntra() && (cu.slice->getPicHeader()->getMaxNumAffineMergeCand() > 0) && cu.lumaSize().width >= 8 && cu.lumaSize().height >= 8 )
+  {
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__AFFINE_FLAG );
+
+    unsigned ctxId = DeriveCtx::CtxAffineFlag( cu );
+    cu.affine      = m_binDecoder.decodeBin(Ctx::SubblockMergeFlag(ctxId));
+    DTRACE( g_trace_ctx, D_SYNTAX, "subblock_merge_flag() subblock_merge_flag=%d ctx=%d pos=(%d,%d)\n", cu.affine ? 1 : 0, ctxId, cu.Y().x, cu.Y().y );
+  }
+}
+
+void CABACReader::affine_flag( CodingUnit& cu )
+{
+  if ( !cu.cs->slice->isIntra() && cu.cs->sps->getUseAffine() && cu.lumaSize().width > 8 && cu.lumaSize().height > 8 )
+  {
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__AFFINE_FLAG );
+
+    unsigned ctxId = DeriveCtx::CtxAffineFlag( cu );
+    cu.affine      = m_binDecoder.decodeBin(Ctx::AffineFlag(ctxId));
+    DTRACE( g_trace_ctx, D_SYNTAX, "affine_flag() affine=%d ctx=%d pos=(%d,%d)\n", cu.affine ? 1 : 0, ctxId, cu.Y().x, cu.Y().y );
+
+    if ( cu.affine && cu.cs->sps->getUseAffineType() )
+    {
+      ctxId = 0;
+      cu.affineType = m_binDecoder.decodeBin(Ctx::AffineType(ctxId)) ? AffineModel::_6_PARAMS : AffineModel::_4_PARAMS;
+      DTRACE(g_trace_ctx, D_SYNTAX, "affine_type() affine_type=%d ctx=%d pos=(%d,%d)\n",
+             cu.affineType == AffineModel::_6_PARAMS ? 1 : 0, ctxId, cu.Y().x, cu.Y().y);
+    }
+    else
+    {
+      cu.affineType = AffineModel::_4_PARAMS;
+    }
+  }
+}
+
+void CABACReader::merge_flag( PredictionUnit& pu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__MERGE_FLAG );
+
+  pu.mergeFlag = (m_binDecoder.decodeBin(Ctx::MergeFlag()));
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "merge_flag() merge=%d pos=(%d,%d) size=%dx%d\n", pu.mergeFlag ? 1 : 0, pu.lumaPos().x, pu.lumaPos().y, pu.lumaSize().width, pu.lumaSize().height );
+
+  if (pu.mergeFlag && CU::isIBC(*pu.cu))
+  {
+    pu.mmvdMergeFlag = false;
+    pu.regularMergeFlag = false;
+    return;
+  }
+}
+
+
+void CABACReader::merge_data( PredictionUnit& pu )
+{
+  if (CU::isIBC(*pu.cu))
+  {
+    merge_idx(pu);
+    return;
+  }
+  else
+  {
+    CodingUnit cu = *pu.cu;
+    subblock_merge_flag(*pu.cu);
+    if (pu.cu->affine)
+    {
+      merge_idx(pu);
+      cu.firstPU->regularMergeFlag = false;
+      return;
+    }
+
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__MERGE_FLAG );
+
+    const bool ciipAvailable = pu.cs->sps->getUseCiip() && !pu.cu->skip && pu.cu->lwidth() < MAX_CU_SIZE && pu.cu->lheight() < MAX_CU_SIZE && pu.cu->lwidth() * pu.cu->lheight() >= 64;
+    const bool geoAvailable  = pu.cu->cs->slice->getSPS()->getUseGeo() && pu.cu->cs->slice->isInterB()
+                              && pu.cs->sps->getMaxNumGeoCand() > 1 && pu.cu->lwidth() >= GEO_MIN_CU_SIZE
+                              && pu.cu->lheight() >= GEO_MIN_CU_SIZE && pu.cu->lwidth() <= GEO_MAX_CU_SIZE
+                              && pu.cu->lheight() <= GEO_MAX_CU_SIZE && pu.cu->lwidth() < 8 * pu.cu->lheight()
+                              && pu.cu->lheight() < 8 * pu.cu->lwidth();
+    if (geoAvailable || ciipAvailable)
+    {
+      cu.firstPU->regularMergeFlag = m_binDecoder.decodeBin(Ctx::RegularMergeFlag(cu.skip ? 0 : 1));
+    }
+    else
+    {
+      cu.firstPU->regularMergeFlag = true;
+    }
+    if (cu.firstPU->regularMergeFlag)
+    {
+      if (cu.cs->slice->getSPS()->getUseMMVD())
+      {
+        cu.firstPU->mmvdMergeFlag = m_binDecoder.decodeBin(Ctx::MmvdFlag(0));
+      }
+      else
+      {
+        cu.firstPU->mmvdMergeFlag = false;
+      }
+      if (cu.skip)
+      {
+        cu.mmvdSkip = cu.firstPU->mmvdMergeFlag;
+      }
+    }
+    else
+    {
+      pu.mmvdMergeFlag = false;
+      pu.cu->mmvdSkip = false;
+      if (geoAvailable && ciipAvailable)
+      {
+        ciip_flag(pu);
+      }
+      else if (ciipAvailable)
+      {
+        pu.ciipFlag = true;
+      }
+      else
+      {
+        pu.ciipFlag = false;
+      }
+      if (pu.ciipFlag)
+      {
+        pu.intraDir[ChannelType::LUMA]   = PLANAR_IDX;
+        pu.intraDir[ChannelType::CHROMA] = DM_CHROMA_IDX;
+      }
+      else
+      {
+        pu.cu->geoFlag = true;
+      }
+    }
+  }
+  if (pu.mmvdMergeFlag || pu.cu->mmvdSkip)
+  {
+    mmvd_merge_idx(pu);
+  }
+  else
+  {
+    merge_idx(pu);
+  }
+}
+
+
+void CABACReader::merge_idx( PredictionUnit& pu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__MERGE_INDEX );
+
+  if ( pu.cu->affine )
+  {
+    int numCandminus1 = int( pu.cs->picHeader->getMaxNumAffineMergeCand() ) - 1;
+    pu.mergeIdx = 0;
+    if ( numCandminus1 > 0 )
+    {
+      if (m_binDecoder.decodeBin(Ctx::AffMergeIdx()))
+      {
+        pu.mergeIdx++;
+        for ( ; pu.mergeIdx < numCandminus1; pu.mergeIdx++ )
+        {
+          if (!m_binDecoder.decodeBinEP())
+          {
+            break;
+          }
+        }
+      }
+    }
+    DTRACE( g_trace_ctx, D_SYNTAX, "aff_merge_idx() aff_merge_idx=%d\n", pu.mergeIdx );
+  }
+  else
+  {
+    int numCandminus1 = int(pu.cs->sps->getMaxNumMergeCand()) - 1;
+    pu.mergeIdx       = 0;
+
+    if (pu.cu->geoFlag)
+    {
+      RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__GEO_INDEX);
+      uint32_t splitDir = 0;
+      xReadTruncBinCode(splitDir, GEO_NUM_PARTITION_MODE);
+      pu.geoSplitDir          = splitDir;
+      const int maxNumGeoCand = pu.cs->sps->getMaxNumGeoCand();
+      CHECK(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
+      CHECK(pu.cu->lheight() > 64 || pu.cu->lwidth() > 64, "Incorrect block size of geo flag");
+      int numCandminus2 = maxNumGeoCand - 2;
+      pu.mergeIdx       = 0;
+      uint8_t mergeCand0 = 0;
+      uint8_t mergeCand1 = 0;
+      if (m_binDecoder.decodeBin(Ctx::MergeIdx()))
+      {
+        mergeCand0 += unary_max_eqprob(numCandminus2) + 1;
+      }
+      if (numCandminus2 > 0)
+      {
+        if (m_binDecoder.decodeBin(Ctx::MergeIdx()))
+        {
+          mergeCand1 += unary_max_eqprob(numCandminus2 - 1) + 1;
+        }
+      }
+      mergeCand1 += mergeCand1 >= mergeCand0 ? 1 : 0;
+      pu.geoMergeIdx = { mergeCand0, mergeCand1 };
+      DTRACE(g_trace_ctx, D_SYNTAX, "merge_idx() geo_split_dir=%d\n", splitDir);
+      DTRACE(g_trace_ctx, D_SYNTAX, "merge_idx() geo_idx0=%d\n", mergeCand0);
+      DTRACE(g_trace_ctx, D_SYNTAX, "merge_idx() geo_idx1=%d\n", mergeCand1);
+      return;
+    }
+
+    if (CU::isIBC(*pu.cu))
+    {
+      numCandminus1 = int(pu.cs->sps->getMaxNumIBCMergeCand()) - 1;
+    }
+    if (numCandminus1 > 0)
+    {
+      if (m_binDecoder.decodeBin(Ctx::MergeIdx()))
+      {
+        pu.mergeIdx++;
+        for (; pu.mergeIdx < numCandminus1; pu.mergeIdx++)
+        {
+          if (!m_binDecoder.decodeBinEP())
+          {
+            break;
+          }
+        }
+      }
+    }
+    DTRACE(g_trace_ctx, D_SYNTAX, "merge_idx() merge_idx=%d\n", pu.mergeIdx);
+  }
+}
+
+void CABACReader::mmvd_merge_idx(PredictionUnit& pu)
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__MERGE_INDEX);
+
+  int mvdBaseIdx = 0;
+  if (pu.cs->sps->getMaxNumMergeCand() > 1)
+  {
+    static_assert(MmvdIdx::BASE_MV_NUM == 2, "");
+    mvdBaseIdx = m_binDecoder.decodeBin(Ctx::MmvdMergeIdx());
+  }
+  DTRACE(g_trace_ctx, D_SYNTAX, "base_mvp_idx() base_mvp_idx=%d\n", mvdBaseIdx);
+  int numStepCandMinus1 = MmvdIdx::REFINE_STEP - 1;
+  int mvdStep           = 0;
+  if (m_binDecoder.decodeBin(Ctx::MmvdStepMvpIdx()))
+  {
+    mvdStep++;
+    for (; mvdStep < numStepCandMinus1; mvdStep++)
+    {
+      if (!m_binDecoder.decodeBinEP())
+      {
+        break;
+      }
+    }
+  }
+  DTRACE(g_trace_ctx, D_SYNTAX, "MmvdStepMvpIdx() MmvdStepMvpIdx=%d\n", mvdStep);
+  const int mvdPosition = m_binDecoder.decodeBinsEP(2);
+  DTRACE(g_trace_ctx, D_SYNTAX, "pos() pos=%d\n", mvdPosition);
+  pu.mmvdMergeIdx.pos.position = mvdPosition;
+  pu.mmvdMergeIdx.pos.step     = mvdStep;
+  pu.mmvdMergeIdx.pos.baseIdx  = mvdBaseIdx;
+  DTRACE(g_trace_ctx, D_SYNTAX, "mmvd_merge_idx() mmvd_merge_idx=%d\n", pu.mmvdMergeIdx);
+}
+
+void CABACReader::inter_pred_idc( PredictionUnit& pu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__INTER_DIR );
+
+  if( pu.cs->slice->isInterP() )
+  {
+    pu.interDir = 1;
+    return;
+  }
+  if( !(PU::isBipredRestriction(pu)) )
+  {
+    unsigned ctxId = DeriveCtx::CtxInterDir(pu);
+    if (m_binDecoder.decodeBin(Ctx::InterDir(ctxId)))
+    {
+      DTRACE( g_trace_ctx, D_SYNTAX, "inter_pred_idc() ctx=%d value=%d pos=(%d,%d)\n", ctxId, 3, pu.lumaPos().x, pu.lumaPos().y );
+      pu.interDir = 3;
+      return;
+    }
+  }
+  if (m_binDecoder.decodeBin(Ctx::InterDir(5)))
+  {
+    DTRACE( g_trace_ctx, D_SYNTAX, "inter_pred_idc() ctx=5 value=%d pos=(%d,%d)\n", 2, pu.lumaPos().x, pu.lumaPos().y );
+    pu.interDir = 2;
+    return;
+  }
+  DTRACE( g_trace_ctx, D_SYNTAX, "inter_pred_idc() ctx=5 value=%d pos=(%d,%d)\n", 1, pu.lumaPos().x, pu.lumaPos().y );
+  pu.interDir = 1;
+  return;
+}
+
+void CABACReader::ref_idx( PredictionUnit &pu, RefPicList eRefList )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__REF_FRM_IDX );
+
+  if ( pu.cu->smvdMode )
+  {
+    pu.refIdx[eRefList] = pu.cs->slice->getSymRefIdx( eRefList );
+    return;
+  }
+
+  int numRef  = pu.cs->slice->getNumRefIdx(eRefList);
+
+  if (numRef <= 1 || !m_binDecoder.decodeBin(Ctx::RefPic()))
+  {
+    if( numRef > 1 )
+    {
+      DTRACE( g_trace_ctx, D_SYNTAX, "ref_idx() value=%d pos=(%d,%d)\n", 0, pu.lumaPos().x, pu.lumaPos().y );
+    }
+    pu.refIdx[eRefList] = 0;
+    return;
+  }
+  if (numRef <= 2 || !m_binDecoder.decodeBin(Ctx::RefPic(1)))
+  {
+    DTRACE( g_trace_ctx, D_SYNTAX, "ref_idx() value=%d pos=(%d,%d)\n", 1, pu.lumaPos().x, pu.lumaPos().y );
+    pu.refIdx[eRefList] = 1;
+    return;
+  }
+  for( int idx = 3; ; idx++ )
+  {
+    if (numRef <= idx || !m_binDecoder.decodeBinEP())
+    {
+      pu.refIdx[eRefList] = (signed char)( idx - 1 );
+      DTRACE( g_trace_ctx, D_SYNTAX, "ref_idx() value=%d pos=(%d,%d)\n", idx-1, pu.lumaPos().x, pu.lumaPos().y );
+      return;
+    }
+  }
+}
+
+void CABACReader::mvp_flag( PredictionUnit& pu, RefPicList eRefList )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__MVP_IDX );
+
+  unsigned mvpIdx = m_binDecoder.decodeBin(Ctx::MVPIdx());
+  DTRACE(g_trace_ctx, D_SYNTAX, "mvp_flag() value=%d pos=(%d,%d)\n", mvpIdx, pu.lumaPos().x, pu.lumaPos().y);
+  pu.mvpIdx[eRefList] = mvpIdx;
+  DTRACE(g_trace_ctx, D_SYNTAX, "mvpIdx(refList:%d)=%d\n", eRefList, mvpIdx);
+}
+
+void CABACReader::ciip_flag(PredictionUnit &pu)
+{
+  if (!pu.cs->sps->getUseCiip())
+  {
+    pu.ciipFlag = false;
+    return;
+  }
+  if (pu.cu->skip)
+  {
+    pu.ciipFlag = false;
+    return;
+  }
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__MH_INTRA_FLAG);
+
+  pu.ciipFlag = (m_binDecoder.decodeBin(Ctx::CiipFlag()));
+  DTRACE(g_trace_ctx, D_SYNTAX, "ciip_flag() Ciip=%d pos=(%d,%d) size=%dx%d\n", pu.ciipFlag ? 1 : 0, pu.lumaPos().x,
+         pu.lumaPos().y, pu.lumaSize().width, pu.lumaSize().height);
+}
+
+//================================================================================
+//  clause 7.3.8.8
+//--------------------------------------------------------------------------------
+//    void  transform_tree      ( cs, area, cuCtx, chromaCbfs )
+//    bool  split_transform_flag( depth )
+//    bool  cbf_comp            ( area, depth )
+//================================================================================
+
+void CABACReader::transform_tree( CodingStructure &cs, Partitioner &partitioner, CUCtx& cuCtx,                         const PartSplit ispType, const int subTuIdx )
+{
+  const UnitArea&   area = partitioner.currArea();
+  CodingUnit       &cu           = *cs.getCU(area.block(partitioner.chType), partitioner.chType);
+  int       subTuCounter = subTuIdx;
+
+  // split_transform_flag
+  bool split = partitioner.canSplit(TU_MAX_TR_SPLIT, cs);
+  const unsigned  trDepth = partitioner.currTrDepth;
+
+  if( cu.sbtInfo && partitioner.canSplit( PartSplit( cu.getSbtTuSplit() ), cs ) )
+  {
+    split = true;
+  }
+
+  if (!split && cu.ispMode != ISPType::NONE)
+  {
+    split = partitioner.canSplit( ispType, cs );
+  }
+
+  if( split )
+  {
+    if (partitioner.canSplit(TU_MAX_TR_SPLIT, cs))
+    {
+#if ENABLE_TRACING
+      const CompArea &tuArea = partitioner.currArea().block(partitioner.chType);
+      DTRACE(g_trace_ctx, D_SYNTAX, "transform_tree() maxTrSplit chType=%d pos=(%d,%d) size=%dx%d\n",
+             partitioner.chType, tuArea.x, tuArea.y, tuArea.width, tuArea.height);
+
+#endif
+      partitioner.splitCurrArea(TU_MAX_TR_SPLIT, cs);
+    }
+    else if (cu.ispMode != ISPType::NONE)
+    {
+      partitioner.splitCurrArea(ispType, cs);
+    }
+    else if (cu.sbtInfo && partitioner.canSplit(PartSplit(cu.getSbtTuSplit()), cs))
+    {
+      partitioner.splitCurrArea(PartSplit(cu.getSbtTuSplit()), cs);
+    }
+    else
+    {
+      THROW("Implicit TU split not available!");
+    }
+
+    do
+    {
+      transform_tree( cs, partitioner, cuCtx,          ispType, subTuCounter );
+      subTuCounter += subTuCounter != -1 ? 1 : 0;
+    } while( partitioner.nextPart( cs ) );
+
+    partitioner.exitCurrSplit();
+  }
+  else
+  {
+    TransformUnit &tu = cs.addTU( CS::getArea( cs, area, partitioner.chType ), partitioner.chType );
+    unsigned numBlocks = ::getNumberValidTBlocks( *cs.pcv );
+    tu.checkTuNoResidual( partitioner.currPartIdx() );
+
+    for( unsigned compID = COMPONENT_Y; compID < numBlocks; compID++ )
+    {
+      if( tu.blocks[compID].valid() )
+      {
+        tu.getCoeffs( ComponentID( compID ) ).fill( 0 );
+        tu.getPcmbuf( ComponentID( compID ) ).fill( 0 );
+      }
+    }
+    tu.depth = trDepth;
+    DTRACE(g_trace_ctx, D_SYNTAX, "transform_unit() pos=(%d,%d) size=%dx%d depth=%d trDepth=%d\n",
+           tu.block(tu.chType).x, tu.block(tu.chType).y, tu.block(tu.chType).width, tu.block(tu.chType).height,
+           cu.depth, partitioner.currTrDepth);
+
+    transform_unit(tu, cuCtx, partitioner, subTuCounter);
+  }
+}
+
+bool CABACReader::cbf_comp(const CompArea &area, unsigned depth, const bool prevCbf, const bool useISP,
+                           const BdpcmMode bdpcmMode)
+{
+  unsigned  ctxId = DeriveCtx::CtxQtCbf(area.compID, prevCbf, useISP && isLuma(area.compID));
+  const CtxSet&   ctxSet  = Ctx::QtCbf[ area.compID ];
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(STATS__CABAC_BITS__QT_CBF, area.size(), area.compID);
+
+  if (bdpcmMode != BdpcmMode::NONE)
+  {
+    ctxId = area.compID == COMPONENT_Cr ? 2 : 1;
+  }
+
+  const bool cbf = m_binDecoder.decodeBin(ctxSet(ctxId)) != 0;
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "cbf_comp() etype=%d pos=(%d,%d) ctx=%d cbf=%d\n", area.compID, area.x, area.y, ctxId,
+         cbf ? 1 : 0);
+
+  return cbf;
+}
+
+//================================================================================
+//  clause 7.3.8.9
+//--------------------------------------------------------------------------------
+//    void  mvd_coding( pu, refList )
+//================================================================================
+
+void CABACReader::mvd_coding( Mv &rMvd )
+{
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatisticsClassType ctype_mvd    ( STATS__CABAC_BITS__MVD );
+  CodingStatisticsClassType ctype_mvd_ep ( STATS__CABAC_BITS__MVD_EP );
+#endif
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_mvd );
+
+  // abs_mvd_greater0_flag[ 0 | 1 ]
+  int horAbs = (int) m_binDecoder.decodeBin(Ctx::Mvd());
+  int verAbs = (int) m_binDecoder.decodeBin(Ctx::Mvd());
+
+  // abs_mvd_greater1_flag[ 0 | 1 ]
+  if (horAbs)
+  {
+    horAbs += (int) m_binDecoder.decodeBin(Ctx::Mvd(1));
+  }
+  if (verAbs)
+  {
+    verAbs += (int) m_binDecoder.decodeBin(Ctx::Mvd(1));
+  }
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_mvd_ep );
+
+  // abs_mvd_minus2[ 0 | 1 ] and mvd_sign_flag[ 0 | 1 ]
+  if (horAbs)
+  {
+    if (horAbs > 1)
+    {
+      horAbs += m_binDecoder.decodeRemAbsEP(1, 0, MV_BITS - 1);
+    }
+    if (m_binDecoder.decodeBinEP())
+    {
+      horAbs = -horAbs;
+    }
+  }
+  if (verAbs)
+  {
+    if (verAbs > 1)
+    {
+      verAbs += m_binDecoder.decodeRemAbsEP(1, 0, MV_BITS - 1);
+    }
+    if (m_binDecoder.decodeBinEP())
+    {
+      verAbs = -verAbs;
+    }
+  }
+  rMvd = Mv(horAbs, verAbs);
+  CHECK(!((horAbs >= MVD_MIN) && (horAbs <= MVD_MAX)) || !((verAbs >= MVD_MIN) && (verAbs <= MVD_MAX)), "Illegal MVD value");
+}
+
+//================================================================================
+//  clause 7.3.8.10
+//--------------------------------------------------------------------------------
+//    void  transform_unit      ( tu, cuCtx, chromaCbfs )
+//    void  cu_qp_delta         ( cu )
+//    void  cu_chroma_qp_offset ( cu )
+//================================================================================
+void CABACReader::transform_unit( TransformUnit& tu, CUCtx& cuCtx, Partitioner& partitioner, const int subTuCounter)
+{
+  const UnitArea&         area = partitioner.currArea();
+  const unsigned          trDepth = partitioner.currTrDepth;
+
+  CodingUnit&       cu = *tu.cu;
+  ChromaCbfs        chromaCbfs;
+  chromaCbfs.Cb = chromaCbfs.Cr = false;
+
+  const bool chromaCbfISP =
+    isChromaEnabled(area.chromaFormat) && area.blocks[COMPONENT_Cb].valid() && cu.ispMode != ISPType::NONE;
+
+  // cbf_cb & cbf_cr
+  if (isChromaEnabled(area.chromaFormat) && area.blocks[COMPONENT_Cb].valid()
+      && (!cu.isSepTree() || partitioner.chType == ChannelType::CHROMA)
+      && (cu.ispMode == ISPType::NONE || chromaCbfISP))
+  {
+    const int cbfDepth = chromaCbfISP ? trDepth - 1 : trDepth;
+    if (!(cu.sbtInfo && tu.noResidual))
+    {
+      chromaCbfs.Cb = cbf_comp(area.blocks[COMPONENT_Cb], cbfDepth, false, false, cu.bdpcmModeChroma);
+    }
+
+    if (!(cu.sbtInfo && tu.noResidual))
+    {
+      chromaCbfs.Cr = cbf_comp(area.blocks[COMPONENT_Cr], cbfDepth, chromaCbfs.Cb, false, cu.bdpcmModeChroma);
+    }
+  }
+  else if (cu.isSepTree())
+  {
+    chromaCbfs = ChromaCbfs(false);
+  }
+
+  if (!isChroma(partitioner.chType))
+  {
+    if (!CU::isIntra(cu) && trDepth == 0 && !chromaCbfs.sigChroma(area.chromaFormat))
+    {
+      TU::setCbfAtDepth(tu, COMPONENT_Y, trDepth, 1);
+    }
+    else if (cu.sbtInfo && tu.noResidual)
+    {
+      TU::setCbfAtDepth(tu, COMPONENT_Y, trDepth, 0);
+    }
+    else if (cu.sbtInfo && !chromaCbfs.sigChroma(area.chromaFormat))
+    {
+      assert(!tu.noResidual);
+      TU::setCbfAtDepth(tu, COMPONENT_Y, trDepth, 1);
+    }
+    else
+    {
+      bool lumaCbfIsInferredACT =
+        (cu.colorTransform && CU::isIntra(cu) && trDepth == 0 && !chromaCbfs.sigChroma(area.chromaFormat));
+      bool lastCbfIsInferred    = lumaCbfIsInferredACT; // ISP and ACT are mutually exclusive
+      bool previousCbf          = false;
+      bool rootCbfSoFar         = false;
+      if (cu.ispMode != ISPType::NONE)
+      {
+        uint32_t nTus =
+          cu.ispMode == ISPType::HOR ? cu.lheight() >> floorLog2(tu.lheight()) : cu.lwidth() >> floorLog2(tu.lwidth());
+        if (subTuCounter == nTus - 1)
+        {
+          TransformUnit* tuPointer = cu.firstTU;
+          for (int tuIdx = 0; tuIdx < nTus - 1; tuIdx++)
+          {
+            rootCbfSoFar |= TU::getCbfAtDepth(*tuPointer, COMPONENT_Y, trDepth);
+            tuPointer = tuPointer->next;
+          }
+          if (!rootCbfSoFar)
+          {
+            lastCbfIsInferred = true;
+          }
+        }
+        if (!lastCbfIsInferred)
+        {
+          previousCbf = TU::getPrevTuCbfAtDepth(tu, COMPONENT_Y, trDepth);
+        }
+      }
+      bool cbfY = lastCbfIsInferred ? true : cbf_comp(tu.Y(), trDepth, previousCbf, cu.ispMode != ISPType::NONE, cu.bdpcmMode);
+      TU::setCbfAtDepth(tu, COMPONENT_Y, trDepth, (cbfY ? 1 : 0));
+    }
+  }
+  if (isChromaEnabled(area.chromaFormat) && (cu.ispMode == ISPType::NONE || chromaCbfISP))
+  {
+    TU::setCbfAtDepth(tu, COMPONENT_Cb, trDepth, (chromaCbfs.Cb ? 1 : 0));
+    TU::setCbfAtDepth(tu, COMPONENT_Cr, trDepth, (chromaCbfs.Cr ? 1 : 0));
+  }
+  bool        lumaOnly   = !isChromaEnabled(cu.chromaFormat) || !tu.blocks[COMPONENT_Cb].valid();
+  bool        cbfLuma    = ( tu.cbf[ COMPONENT_Y ] != 0 );
+  bool        cbfChroma  = ( lumaOnly ? false : ( chromaCbfs.Cb || chromaCbfs.Cr ) );
+
+  if( ( cu.lwidth() > 64 || cu.lheight() > 64 || cbfLuma || cbfChroma ) &&
+    (!tu.cu->isSepTree() || isLuma(tu.chType)) )
+  {
+    if( cu.cs->pps->getUseDQP() && !cuCtx.isDQPCoded )
+    {
+      cu_qp_delta(cu, cuCtx.qp, cu.qp);
+      cuCtx.qp = cu.qp;
+      cuCtx.isDQPCoded = true;
+    }
+  }
+  if (!cu.isSepTree() || isChroma(tu.chType))   // !DUAL_TREE_LUMA
+  {
+    SizeType channelWidth = !cu.isSepTree() ? cu.lwidth() : cu.chromaSize().width;
+    SizeType channelHeight = !cu.isSepTree() ? cu.lheight() : cu.chromaSize().height;
+
+    if (cu.cs->slice->getUseChromaQpAdj() && (channelWidth > 64 || channelHeight > 64 || cbfChroma) && !cuCtx.isChromaQpAdjCoded)
+    {
+      cu_chroma_qp_offset(cu);
+      cuCtx.isChromaQpAdjCoded = true;
+    }
+  }
+
+  if( !lumaOnly )
+  {
+    joint_cb_cr( tu, ( tu.cbf[COMPONENT_Cb] ? 2 : 0 ) + ( tu.cbf[COMPONENT_Cr] ? 1 : 0 ) );
+  }
+
+  if (cbfLuma)
+  {
+    residual_coding(tu, COMPONENT_Y, cuCtx);
+  }
+  if (!lumaOnly)
+  {
+    for (ComponentID compID = COMPONENT_Cb; compID <= COMPONENT_Cr; compID = ComponentID(compID + 1))
+    {
+      if (tu.cbf[compID])
+      {
+        residual_coding(tu, compID, cuCtx);
+      }
+    }
+  }
+}
+
+void CABACReader::cu_qp_delta( CodingUnit& cu, int predQP, int8_t& qp )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__DELTA_QP_EP );
+
+  CHECK( predQP == std::numeric_limits<int>::max(), "Invalid predicted QP" );
+  int qpY = predQP;
+  int DQp = unary_max_symbol( Ctx::DeltaQP(), Ctx::DeltaQP(1), CU_DQP_TU_CMAX );
+  if( DQp >= CU_DQP_TU_CMAX )
+  {
+    DQp += exp_golomb_eqprob( CU_DQP_EG_k  );
+  }
+  if( DQp > 0 )
+  {
+    if (m_binDecoder.decodeBinEP())
+    {
+      DQp = -DQp;
+    }
+    int qpBdOffsetY = cu.cs->sps->getQpBDOffset(ChannelType::LUMA);
+    qpY = ( (predQP + DQp + (MAX_QP + 1) + 2 * qpBdOffsetY) % ((MAX_QP + 1) + qpBdOffsetY)) - qpBdOffsetY;
+  }
+  qp = (int8_t)qpY;
+
+  DTRACE(g_trace_ctx, D_DQP, "x=%d, y=%d, d=%d, pred_qp=%d, DQp=%d, qp=%d\n", cu.block(cu.chType).lumaPos().x,
+         cu.block(cu.chType).lumaPos().y, cu.qtDepth, predQP, DQp, qp);
+}
+
+
+void CABACReader::cu_chroma_qp_offset( CodingUnit& cu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(STATS__CABAC_BITS__CHROMA_QP_ADJUSTMENT,
+                                                      cu.block(cu.chType).lumaSize(), ChannelType::CHROMA);
+
+  // cu_chroma_qp_offset_flag
+  int       length  = cu.cs->pps->getChromaQpOffsetListLen();
+  unsigned  qpAdj   = m_binDecoder.decodeBin(Ctx::ChromaQpAdjFlag());
+  if( qpAdj && length > 1 )
+  {
+    // cu_chroma_qp_offset_idx
+    qpAdj += unary_max_symbol( Ctx::ChromaQpAdjIdc(), Ctx::ChromaQpAdjIdc(), length-1 );
+  }
+  /* NB, symbol = 0 if outer flag is not set,
+   *              1 if outer flag is set and there is no inner flag
+   *              1+ otherwise */
+  cu.chromaQpAdj = cu.cs->chromaQpAdj = qpAdj;
+}
+
+//================================================================================
+//  clause 7.3.8.11
+//--------------------------------------------------------------------------------
+//    void        residual_coding         ( tu, compID )
+//    bool        transform_skip_flag     ( tu, compID )
+//    int         last_sig_coeff          ( coeffCtx )
+//    void        residual_coding_subblock( coeffCtx )
+//================================================================================
+
+void CABACReader::joint_cb_cr( TransformUnit& tu, const int cbfMask )
+{
+  if ( !tu.cu->slice->getSPS()->getJointCbCrEnabledFlag() )
+  {
+    return;
+  }
+
+  if ((CU::isIntra(*tu.cu) && cbfMask != 0) || cbfMask == CBF_MASK_CBCR)
+  {
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(STATS__CABAC_BITS__JOINT_CB_CR,
+                                                        tu.blocks[COMPONENT_Cr].lumaSize(), ChannelType::CHROMA);
+    tu.jointCbCr = (m_binDecoder.decodeBin(Ctx::JointCbCrFlag(cbfMask - 1)) ? cbfMask : 0);
+  }
+}
+
+void CABACReader::residual_coding( TransformUnit& tu, ComponentID compID, CUCtx& cuCtx )
+{
+  const CodingUnit& cu = *tu.cu;
+  DTRACE( g_trace_ctx, D_SYNTAX, "residual_coding() etype=%d pos=(%d,%d) size=%dx%d predMode=%d\n", tu.blocks[compID].compID, tu.blocks[compID].x, tu.blocks[compID].y, tu.blocks[compID].width, tu.blocks[compID].height, cu.predMode );
+
+  if( compID == COMPONENT_Cr && tu.jointCbCr == 3 )
+  {
+    return;
+  }
+
+  ts_flag            ( tu, compID );
+
+  if (tu.mtsIdx[compID] == MtsType::SKIP && !tu.cs->slice->getTSResidualCodingDisabledFlag())
+  {
+    residual_codingTS( tu, compID );
+    return;
+  }
+
+  // determine sign hiding
+  bool signHiding = cu.cs->slice->getSignDataHidingEnabledFlag();
+
+  // init coeff coding context
+  CoeffCodingContext  cctx(tu, compID, signHiding, cu.getBdpcmMode(compID));
+  TCoeff*             coeff   = tu.getCoeffs( compID ).buf;
+
+  // parse last coeff position
+  cctx.setScanPosLast( last_sig_coeff( cctx, tu, compID ) );
+  if (tu.mtsIdx[compID] != MtsType::SKIP && tu.blocks[compID].height >= 4 && tu.blocks[compID].width >= 4)
+  {
+    const int maxLfnstPos = ((tu.blocks[compID].height == 4 && tu.blocks[compID].width == 4) || (tu.blocks[compID].height == 8 && tu.blocks[compID].width == 8)) ? 7 : 15;
+    cuCtx.violatesLfnstConstrained[toChannelType(compID)] |= cctx.scanPosLast() > maxLfnstPos;
+  }
+  if (tu.mtsIdx[compID] != MtsType::SKIP && tu.blocks[compID].height >= 4 && tu.blocks[compID].width >= 4)
+  {
+    const int lfnstLastScanPosTh = isLuma( compID ) ? LFNST_LAST_SIG_LUMA : LFNST_LAST_SIG_CHROMA;
+    cuCtx.lfnstLastScanPos |= cctx.scanPosLast() >= lfnstLastScanPosTh;
+  }
+  if (isLuma(compID) && tu.mtsIdx[compID] != MtsType::SKIP)
+  {
+    cuCtx.mtsLastScanPos |= cctx.scanPosLast() >= 1;
+  }
+
+  // parse subblocks
+  const int stateTransTab = ( tu.cs->slice->getDepQuantEnabledFlag() ? 32040 : 0 );
+  int       state         = 0;
+
+  int ctxBinSampleRatio = (compID == COMPONENT_Y) ? MAX_TU_LEVEL_CTX_CODED_BIN_CONSTRAINT_LUMA : MAX_TU_LEVEL_CTX_CODED_BIN_CONSTRAINT_CHROMA;
+  cctx.regBinLimit = (tu.getTbAreaAfterCoefZeroOut(compID) * ctxBinSampleRatio) >> 4;
+
+  int baseLevel = m_binDecoder.getCtx().getBaseLevel();
+  cctx.setBaseLevel(baseLevel);
+  if (tu.cs->slice->getSPS()->getSpsRangeExtension().getPersistentRiceAdaptationEnabledFlag())
+  {
+    cctx.setUpdateHist(1);
+    unsigned riceStats    = m_binDecoder.getCtx().getGRAdaptStats((unsigned) compID);
+    TCoeff historyValue = (TCoeff)1 << riceStats;
+    cctx.setHistValue(historyValue);
+  }
+  for (int subSetId = (cctx.scanPosLast() >> cctx.log2CGSize()); subSetId >= 0; subSetId--)
+  {
+    cctx.initSubblock(subSetId);
+
+    if (tu.cs->sps->getMtsEnabled() && tu.cu->sbtInfo != 0 && tu.blocks[compID].height <= 32
+        && tu.blocks[compID].width <= 32 && compID == COMPONENT_Y)
+    {
+      if ((tu.blocks[compID].height == 32 && cctx.cgPosY() >= (16 >> cctx.log2CGHeight()))
+          || (tu.blocks[compID].width == 32 && cctx.cgPosX() >= (16 >> cctx.log2CGWidth())))
+      {
+        continue;
+      }
+    }
+    residual_coding_subblock(cctx, coeff, stateTransTab, state);
+
+    if (isLuma(compID) && cctx.isSigGroup() && (cctx.cgPosY() > 3 || cctx.cgPosX() > 3))
+    {
+      cuCtx.violatesMtsCoeffConstraint = true;
+    }
+  }
+}
+
+void CABACReader::ts_flag( TransformUnit& tu, ComponentID compID )
+{
+  int tsFlag = tu.cu->getBdpcmMode(compID) != BdpcmMode::NONE || tu.mtsIdx[compID] == MtsType::SKIP ? 1 : 0;
+  int ctxIdx = isLuma(compID) ? 0 : 1;
+
+  if( TU::isTSAllowed ( tu, compID ) )
+  {
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2( STATS__CABAC_BITS__MTS_FLAGS, tu.blocks[compID], compID );
+    tsFlag = m_binDecoder.decodeBin(Ctx::TransformSkipFlag(ctxIdx)) != 0;
+  }
+
+  tu.mtsIdx[compID] = tsFlag ? MtsType::SKIP : MtsType::DCT2_DCT2;
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "ts_flag() etype=%d pos=(%d,%d) mtsIdx=%d\n", COMPONENT_Y, tu.cu->lx(), tu.cu->ly(),
+         (int) tsFlag);
+}
+
+void CABACReader::mts_idx( CodingUnit& cu, CUCtx& cuCtx )
+{
+  TransformUnit &tu = *cu.firstTU;
+  MtsType        mtsIdx = tu.mtsIdx[COMPONENT_Y];   // Transform skip flag has already been decoded
+
+  if (CU::isMTSAllowed(cu, COMPONENT_Y) && !cuCtx.violatesMtsCoeffConstraint && cuCtx.mtsLastScanPos && cu.lfnstIdx == 0
+      && mtsIdx != MtsType::SKIP)
+  {
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2( STATS__CABAC_BITS__MTS_FLAGS, tu.blocks[COMPONENT_Y], COMPONENT_Y );
+    int ctxIdx = 0;
+    int symbol = m_binDecoder.decodeBin(Ctx::MTSIdx(ctxIdx));
+
+    if( symbol )
+    {
+      ctxIdx = 1;
+      mtsIdx = MtsType::DST7_DST7;   // mtsIdx = 2 -- 4
+      for( int i = 0; i < 3; i++, ctxIdx++ )
+      {
+        symbol = m_binDecoder.decodeBin(Ctx::MTSIdx(ctxIdx));
+
+        if( !symbol )
+        {
+          break;
+        }
+
+        mtsIdx++;
+      }
+    }
+  }
+
+  tu.mtsIdx[COMPONENT_Y] = mtsIdx;
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "mts_idx() etype=%d pos=(%d,%d) mtsIdx=%d\n", COMPONENT_Y, tu.cu->lx(), tu.cu->ly(), mtsIdx);
+}
+
+void CABACReader::isp_mode( CodingUnit& cu )
+{
+  if (!CU::isIntra(cu) || !isLuma(cu.chType) || cu.firstPU->multiRefIdx || !cu.cs->sps->getUseISP()
+      || cu.bdpcmMode != BdpcmMode::NONE || !CU::canUseISP(cu, getFirstComponentOfChannel(cu.chType))
+      || cu.colorTransform)
+  {
+    cu.ispMode = ISPType::NONE;
+    return;
+  }
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET(STATS__CABAC_BITS__ISP_MODE_FLAG);
+
+  int symbol = m_binDecoder.decodeBin(Ctx::ISPMode(0));
+
+  if( symbol )
+  {
+    RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__ISP_SPLIT_FLAG );
+    cu.ispMode = m_binDecoder.decodeBin(Ctx::ISPMode(1)) ? ISPType::VER : ISPType::HOR;
+  }
+  DTRACE(g_trace_ctx, D_SYNTAX, "intra_subPartitions() etype=%d pos=(%d,%d) ispIdx=%d\n", cu.chType,
+         cu.block(cu.chType).x, cu.block(cu.chType).y, (int) cu.ispMode);
+}
+
+void CABACReader::residual_lfnst_mode( CodingUnit& cu,  CUCtx& cuCtx  )
+{
+  int chIdx = cu.isSepTree() && isChroma(cu.chType) ? 1 : 0;
+  if ((cu.ispMode != ISPType::NONE && !CU::canUseLfnstWithISP(cu, cu.chType))
+      || (cu.cs->sps->getUseLFNST() && CU::isIntra(cu) && cu.mipFlag && !allowLfnstWithMip(cu.firstPU->lumaSize()))
+      || (cu.isSepTree() && isChroma(cu.chType) && std::min(cu.chromaSize().width, cu.chromaSize().height) < 4)
+      || (cu.blocks[chIdx].lumaSize().width > cu.cs->sps->getMaxTbSize()
+          || cu.blocks[chIdx].lumaSize().height > cu.cs->sps->getMaxTbSize()))
+  {
+    return;
+  }
+
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__LFNST );
+
+  if( cu.cs->sps->getUseLFNST() && CU::isIntra( cu ) )
+  {
+    const bool lumaFlag              = cu.isSepTree() ? (   isLuma( cu.chType ) ? true : false ) : true;
+    const bool chromaFlag            = cu.isSepTree() ? ( isChroma( cu.chType ) ? true : false ) : true;
+    bool       nonZeroCoeffNonTsCorner8x8 = (lumaFlag && cuCtx.violatesLfnstConstrained[ChannelType::LUMA])
+                                      || (chromaFlag && cuCtx.violatesLfnstConstrained[ChannelType::CHROMA]);
+    bool isTrSkip = false;
+    for (auto &currTU : CU::traverseTUs(cu))
+    {
+      const uint32_t numValidComp = getNumberValidComponents(cu.chromaFormat);
+      for (uint32_t compID = COMPONENT_Y; compID < numValidComp; compID++)
+      {
+        if (currTU.blocks[compID].valid() && TU::getCbf(currTU, (ComponentID) compID)
+            && currTU.mtsIdx[compID] == MtsType::SKIP)
+        {
+          isTrSkip = true;
+          break;
+        }
+      }
+    }
+    if ((!cuCtx.lfnstLastScanPos && cu.ispMode == ISPType::NONE) || nonZeroCoeffNonTsCorner8x8 || isTrSkip)
+    {
+      cu.lfnstIdx = 0;
+      return;
+    }
+  }
+  else
+  {
+    cu.lfnstIdx = 0;
+    return;
+  }
+
+  unsigned cctx = 0;
+  if ( cu.isSepTree() ) cctx++;
+
+  uint32_t idxLFNST = m_binDecoder.decodeBin(Ctx::LFNSTIdx(cctx));
+  if( idxLFNST )
+  {
+    idxLFNST += m_binDecoder.decodeBin(Ctx::LFNSTIdx(2));
+  }
+  cu.lfnstIdx = idxLFNST;
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "residual_lfnst_mode() etype=%d pos=(%d,%d) mode=%d\n", COMPONENT_Y, cu.lx(), cu.ly(), ( int ) cu.lfnstIdx );
+}
+
+int CABACReader::last_sig_coeff( CoeffCodingContext& cctx, TransformUnit& tu, ComponentID compID )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2( STATS__CABAC_BITS__LAST_SIG_X_Y, Size( cctx.width(), cctx.height() ), cctx.compID() );
+
+  unsigned PosLastX = 0, PosLastY = 0;
+  unsigned maxLastPosX = cctx.maxLastPosX();
+  unsigned maxLastPosY = cctx.maxLastPosY();
+  unsigned zoTbWdith   = getNonzeroTuSize(cctx.width());
+  unsigned zoTbHeight  = getNonzeroTuSize(cctx.height());
+
+  if (tu.cs->sps->getMtsEnabled() && tu.cu->sbtInfo != 0 && tu.blocks[compID].width <= 32
+      && tu.blocks[compID].height <= 32 && compID == COMPONENT_Y)
+  {
+    maxLastPosX = (tu.blocks[compID].width == 32) ? g_groupIdx[15] : maxLastPosX;
+    maxLastPosY = (tu.blocks[compID].height == 32) ? g_groupIdx[15] : maxLastPosY;
+    zoTbWdith  = (tu.blocks[compID].width == 32) ? 16 : zoTbWdith;
+    zoTbHeight = (tu.blocks[compID].height == 32) ? 16 : zoTbHeight;
+  }
+
+  for( ; PosLastX < maxLastPosX; PosLastX++ )
+  {
+    if (!m_binDecoder.decodeBin(cctx.lastXCtxId(PosLastX)))
+    {
+      break;
+    }
+  }
+  for( ; PosLastY < maxLastPosY; PosLastY++ )
+  {
+    if (!m_binDecoder.decodeBin(cctx.lastYCtxId(PosLastY)))
+    {
+      break;
+    }
+  }
+  if( PosLastX > 3 )
+  {
+    uint32_t temp    = 0;
+    uint32_t uiCount = ( PosLastX - 2 ) >> 1;
+    for ( int i = uiCount - 1; i >= 0; i-- )
+    {
+      temp += m_binDecoder.decodeBinEP() << i;
+    }
+    PosLastX = g_minInGroup[PosLastX] + temp;
+  }
+  if( PosLastY > 3 )
+  {
+    uint32_t temp    = 0;
+    uint32_t uiCount = ( PosLastY - 2 ) >> 1;
+    for ( int i = uiCount - 1; i >= 0; i-- )
+    {
+      temp += m_binDecoder.decodeBinEP() << i;
+    }
+    PosLastY = g_minInGroup[PosLastY] + temp;
+  }
+
+  if (tu.cu->slice->getReverseLastSigCoeffFlag())
+  {
+    PosLastX = zoTbWdith - 1 - PosLastX;
+    PosLastY = zoTbHeight - 1 - PosLastY;
+  }
+  int blkPos;
+  blkPos = PosLastX + (PosLastY * cctx.width());
+
+  int scanPos = 0;
+  for( ; scanPos < cctx.maxNumCoeff() - 1; scanPos++ )
+  {
+    if( blkPos == cctx.blockPos( scanPos ) )
+    {
+      break;
+    }
+  }
+  return scanPos;
+}
+
+static void checkCoeffInRange(const CoeffCodingContext &cctx, const TCoeff coeff)
+{
+  CHECK( coeff < cctx.minCoeff() || coeff > cctx.maxCoeff(),
+         "TransCoeffLevel outside allowable range" );
+}
+
+void CABACReader::residual_coding_subblock( CoeffCodingContext& cctx, TCoeff* coeff, const int stateTransTable, int& state )
+{
+  // NOTE: All coefficients of the subblock must be set to zero before calling this function
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatisticsClassType ctype_group ( STATS__CABAC_BITS__SIG_COEFF_GROUP_FLAG,  cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_map   ( STATS__CABAC_BITS__SIG_COEFF_MAP_FLAG,    cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_par   ( STATS__CABAC_BITS__PAR_FLAG,              cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_gt1   ( STATS__CABAC_BITS__GT1_FLAG,              cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_gt2   ( STATS__CABAC_BITS__GT2_FLAG,              cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_escs  ( STATS__CABAC_BITS__ESCAPE_BITS,           cctx.width(), cctx.height(), cctx.compID() );
+#endif
+
+  //===== init =====
+  const int   minSubPos   = cctx.minSubPos();
+  const bool  isLast      = cctx.isLast();
+  int         firstSigPos = ( isLast ? cctx.scanPosLast() : cctx.maxSubPos() );
+  int         nextSigPos  = firstSigPos;
+  int baseLevel = cctx.getBaseLevel();
+  bool updateHistory = cctx.getUpdateHist();
+
+  //===== decode significant_coeffgroup_flag =====
+  RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_group );
+  bool sigGroup = ( isLast || !minSubPos );
+  if( !sigGroup )
+  {
+    sigGroup = m_binDecoder.decodeBin(cctx.sigGroupCtxId());
+  }
+  if( sigGroup )
+  {
+    cctx.setSigGroup();
+  }
+  else
+  {
+    return;
+  }
+
+  uint8_t   ctxOffset[16];
+
+  //===== decode absolute values =====
+  const int inferSigPos   = nextSigPos != cctx.scanPosLast() ? ( cctx.isNotFirst() ? minSubPos : -1 ) : nextSigPos;
+  int       firstNZPos    = nextSigPos;
+  int       lastNZPos     = -1;
+  int       numNonZero    =  0;
+  int       remRegBins    = cctx.regBinLimit;
+  int       firstPosMode2 = minSubPos - 1;
+  int       sigBlkPos[ 1 << MLS_CG_SIZE ];
+
+  for( ; nextSigPos >= minSubPos && remRegBins >= 4; nextSigPos-- )
+  {
+    int      blkPos     = cctx.blockPos( nextSigPos );
+    unsigned sigFlag    = ( !numNonZero && nextSigPos == inferSigPos );
+    if( !sigFlag )
+    {
+      RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_map );
+      const unsigned sigCtxId = cctx.sigCtxIdAbs( nextSigPos, coeff, state );
+      sigFlag                 = m_binDecoder.decodeBin(sigCtxId);
+      DTRACE( g_trace_ctx, D_SYNTAX_RESI, "sig_bin() bin=%d ctx=%d\n", sigFlag, sigCtxId );
+      remRegBins--;
+    }
+    else if( nextSigPos != cctx.scanPosLast() )
+    {
+      cctx.sigCtxIdAbs( nextSigPos, coeff, state ); // required for setting variables that are needed for gtx/par context selection
+    }
+
+    if( sigFlag )
+    {
+      uint8_t&  ctxOff = ctxOffset[ nextSigPos - minSubPos ];
+      ctxOff           = cctx.ctxOffsetAbs();
+      sigBlkPos[ numNonZero++ ] = blkPos;
+      firstNZPos = nextSigPos;
+      lastNZPos  = std::max<int>( lastNZPos, nextSigPos );
+
+      RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_gt1 );
+      unsigned gt1Flag = m_binDecoder.decodeBin(cctx.greater1CtxIdAbs(ctxOff));
+      DTRACE( g_trace_ctx, D_SYNTAX_RESI, "gt1_flag() bin=%d ctx=%d\n", gt1Flag, cctx.greater1CtxIdAbs(ctxOff) );
+      remRegBins--;
+
+      unsigned parFlag = 0;
+      unsigned gt2Flag = 0;
+      if( gt1Flag )
+      {
+        RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_par );
+        parFlag = m_binDecoder.decodeBin(cctx.parityCtxIdAbs(ctxOff));
+        DTRACE( g_trace_ctx, D_SYNTAX_RESI, "par_flag() bin=%d ctx=%d\n", parFlag, cctx.parityCtxIdAbs( ctxOff ) );
+
+        remRegBins--;
+        RExt__DECODER_DEBUG_BIT_STATISTICS_SET(ctype_gt2);
+        gt2Flag = m_binDecoder.decodeBin(cctx.greater2CtxIdAbs(ctxOff));
+        DTRACE( g_trace_ctx, D_SYNTAX_RESI, "gt2_flag() bin=%d ctx=%d\n", gt2Flag, cctx.greater2CtxIdAbs( ctxOff ) );
+        remRegBins--;
+      }
+      coeff[ blkPos ] += 1 + parFlag + gt1Flag + (gt2Flag << 1);
+    }
+
+    state = ( stateTransTable >> ((state<<2)+((coeff[blkPos]&1)<<1)) ) & 3;
+  }
+  firstPosMode2 = nextSigPos;
+  cctx.regBinLimit = remRegBins;
+
+  //===== 2nd PASS: Go-rice codes =====
+  for( int scanPos = firstSigPos; scanPos > firstPosMode2; scanPos-- )
+  {
+    TCoeff& tcoeff = coeff[ cctx.blockPos( scanPos ) ];
+    if( tcoeff >= 4 )
+    {
+      const unsigned ricePar = (cctx.*(cctx.deriveRiceRRC))(scanPos, coeff, baseLevel);
+
+      RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_escs );
+      int rem = m_binDecoder.decodeRemAbsEP(ricePar, COEF_REMAIN_BIN_REDUCTION, cctx.maxLog2TrDRange());
+      DTRACE( g_trace_ctx, D_SYNTAX_RESI, "rem_val() bin=%d ctx=%d\n", rem, ricePar );
+      tcoeff += (rem<<1);
+      if ((updateHistory) && (rem > 0))
+      {
+        unsigned &riceStats = m_binDecoder.getCtx().getGRAdaptStats((unsigned) (cctx.compID()));
+        cctx.updateRiceStat(riceStats, rem, 1);
+        cctx.setUpdateHist(0);
+        updateHistory = 0;
+      }
+    }
+  }
+
+  //===== coeff bypass ====
+  for( int scanPos = firstPosMode2; scanPos >= minSubPos; scanPos-- )
+  {
+    int rice = (cctx.*(cctx.deriveRiceRRC))(scanPos, coeff, 0);
+    int       pos0   = g_goRicePosCoeff0(state, rice);
+    RExt__DECODER_DEBUG_BIT_STATISTICS_SET(ctype_escs);
+    int rem = m_binDecoder.decodeRemAbsEP(rice, COEF_REMAIN_BIN_REDUCTION, cctx.maxLog2TrDRange());
+    DTRACE( g_trace_ctx, D_SYNTAX_RESI, "rem_val() bin=%d ctx=%d\n", rem, rice );
+    TCoeff    tcoeff  = ( rem == pos0 ? 0 : rem < pos0 ? rem+1 : rem );
+    state = ( stateTransTable >> ((state<<2)+((tcoeff&1)<<1)) ) & 3;
+    if ((updateHistory) && (rem > 0))
+    {
+      unsigned &riceStats = m_binDecoder.getCtx().getGRAdaptStats((unsigned) (cctx.compID()));
+      cctx.updateRiceStat(riceStats, rem, 0);
+      cctx.setUpdateHist(0);
+      updateHistory = 0;
+    }
+    if( tcoeff )
+    {
+      int        blkPos         = cctx.blockPos( scanPos );
+      sigBlkPos[ numNonZero++ ] = blkPos;
+      firstNZPos = scanPos;
+      lastNZPos  = std::max<int>( lastNZPos, scanPos );
+      coeff[blkPos] = tcoeff;
+    }
+  }
+
+  //===== decode sign's =====
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2( STATS__CABAC_BITS__SIGN_BIT, Size( cctx.width(), cctx.height() ), cctx.compID() );
+  const unsigned  numSigns    = ( cctx.hideSign( firstNZPos, lastNZPos ) ? numNonZero - 1 : numNonZero );
+  unsigned        signPattern = numSigns > 0 ? m_binDecoder.decodeBinsEP(numSigns) << (32 - numSigns) : 0;
+
+  //===== set final coefficents =====
+  TCoeff sumAbs = 0;
+  for( unsigned k = 0; k < numSigns; k++ )
+  {
+    TCoeff AbsCoeff       = coeff[ sigBlkPos[ k ] ];
+    sumAbs               += AbsCoeff;
+    coeff[ sigBlkPos[k] ] = ( signPattern & ( 1u << 31 ) ? -AbsCoeff : AbsCoeff );
+    signPattern         <<= 1;
+
+    checkCoeffInRange(cctx, coeff[sigBlkPos[k]]);
+    // NOTE: when Slice::getDepQuantEnabledFlag() is true, additional checks are required to determine
+    // whether coeff is in valid range (see DQIntern::Quantizer::dequantBlock)
+  }
+  if( numNonZero > numSigns )
+  {
+    int k                 = numSigns;
+    TCoeff AbsCoeff       = coeff[ sigBlkPos[ k ] ];
+    sumAbs               += AbsCoeff;
+    coeff[ sigBlkPos[k] ] = ( sumAbs & 1 ? -AbsCoeff : AbsCoeff );
+    checkCoeffInRange(cctx, coeff[sigBlkPos[k]]);
+  }
+}
+
+void CABACReader::residual_codingTS( TransformUnit& tu, ComponentID compID )
+{
+  DTRACE( g_trace_ctx, D_SYNTAX, "residual_codingTS() etype=%d pos=(%d,%d) size=%dx%d\n", tu.blocks[compID].compID, tu.blocks[compID].x, tu.blocks[compID].y, tu.blocks[compID].width, tu.blocks[compID].height );
+
+  // init coeff coding context
+  CoeffCodingContext  cctx(tu, compID, false, tu.cu->getBdpcmMode(compID));
+  TCoeff*             coeff   = tu.getCoeffs( compID ).buf;
+  int maxCtxBins = (cctx.maxNumCoeff() * 7) >> 2;
+  cctx.setNumCtxBins(maxCtxBins);
+
+  for( int subSetId = 0; subSetId <= ( cctx.maxNumCoeff() - 1 ) >> cctx.log2CGSize(); subSetId++ )
+  {
+    cctx.initSubblock         ( subSetId );
+    int goRiceParam = 1;
+    if (tu.cu->slice->getSPS()->getSpsRangeExtension().getTSRCRicePresentFlag() && tu.mtsIdx[compID] == MtsType::SKIP)
+    {
+      goRiceParam = goRiceParam + tu.cu->slice->getTsrcIndex();
+    }
+    residual_coding_subblockTS( cctx, coeff, goRiceParam);
+  }
+}
+
+void CABACReader::residual_coding_subblockTS(CoeffCodingContext &cctx, TCoeff *coeff, const int riceParam)
+{
+  // NOTE: All coefficients of the subblock must be set to zero before calling this function
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatisticsClassType ctype_group ( STATS__CABAC_BITS__SIG_COEFF_GROUP_FLAG,  cctx.width(), cctx.height(), cctx.compID() );
+#if TR_ONLY_COEFF_STATS
+  CodingStatisticsClassType ctype_map   ( STATS__CABAC_BITS__SIG_COEFF_MAP_FLAG_TS, cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_par   ( STATS__CABAC_BITS__PAR_FLAG_TS,           cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_gt1   ( STATS__CABAC_BITS__GT1_FLAG_TS,           cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_gt2   ( STATS__CABAC_BITS__GT2_FLAG_TS,           cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_escs  ( STATS__CABAC_BITS__ESCAPE_BITS_TS,        cctx.width(), cctx.height(), cctx.compID() );
+#else
+  CodingStatisticsClassType ctype_map   ( STATS__CABAC_BITS__SIG_COEFF_MAP_FLAG,    cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_par   ( STATS__CABAC_BITS__PAR_FLAG,              cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_gt1   ( STATS__CABAC_BITS__GT1_FLAG,              cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_gt2   ( STATS__CABAC_BITS__GT2_FLAG,              cctx.width(), cctx.height(), cctx.compID() );
+  CodingStatisticsClassType ctype_escs  ( STATS__CABAC_BITS__ESCAPE_BITS,           cctx.width(), cctx.height(), cctx.compID() );
+#endif
+
+#endif
+
+  //===== init =====
+  const int   minSubPos   = cctx.maxSubPos();
+  int         firstSigPos = cctx.minSubPos();
+  int         nextSigPos  = firstSigPos;
+  unsigned    signPattern = 0;
+
+  //===== decode significant_coeffgroup_flag =====
+  RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_group );
+  bool sigGroup = cctx.isLastSubSet() && cctx.noneSigGroup();
+  if( !sigGroup )
+  {
+    sigGroup = m_binDecoder.decodeBin(cctx.sigGroupCtxId(true));
+    DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_sigGroup() bin=%d ctx=%d\n", sigGroup, cctx.sigGroupCtxId());
+  }
+  if( sigGroup )
+  {
+    cctx.setSigGroup();
+  }
+  else
+  {
+    return;
+  }
+
+  //===== decode absolute values =====
+  const int inferSigPos   = minSubPos;
+  int       numNonZero    =  0;
+  int       sigBlkPos[ 1 << MLS_CG_SIZE ];
+
+  int lastScanPosPass1 = -1;
+  int lastScanPosPass2 = -1;
+  for (; nextSigPos <= minSubPos && cctx.numCtxBins() >= 4; nextSigPos++)
+  {
+    int      blkPos     = cctx.blockPos( nextSigPos );
+    unsigned sigFlag    = ( !numNonZero && nextSigPos == inferSigPos );
+    if( !sigFlag )
+    {
+      RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_map );
+      const unsigned sigCtxId = cctx.sigCtxIdAbsTS(nextSigPos, coeff);
+      sigFlag                 = m_binDecoder.decodeBin(sigCtxId);
+      DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_sig_bin() bin=%d ctx=%d\n", sigFlag, sigCtxId);
+      cctx.decimateNumCtxBins(1);
+    }
+
+    if( sigFlag )
+    {
+      //===== decode sign's =====
+#if TR_ONLY_COEFF_STATS
+      RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2(STATS__CABAC_BITS__SIGN_BIT_TS, Size(cctx.width(), cctx.height()), cctx.compID());
+#else
+      RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET_SIZE2( STATS__CABAC_BITS__SIGN_BIT, Size( cctx.width(), cctx.height() ), cctx.compID() );
+#endif
+      int sign;
+      const unsigned signCtxId = cctx.signCtxIdAbsTS(nextSigPos, coeff, cctx.bdpcm());
+      sign                     = m_binDecoder.decodeBin(signCtxId);
+      cctx.decimateNumCtxBins(1);
+
+      signPattern += ( sign << numNonZero );
+
+      sigBlkPos[numNonZero++] = blkPos;
+
+      RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_gt1 );
+      unsigned gt1Flag;
+      const unsigned gt1CtxId = cctx.lrg1CtxIdAbsTS(nextSigPos, coeff, cctx.bdpcm());
+      gt1Flag                 = m_binDecoder.decodeBin(gt1CtxId);
+      DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_gt1_flag() bin=%d ctx=%d\n", gt1Flag, gt1CtxId);
+      cctx.decimateNumCtxBins(1);
+
+      unsigned parFlag = 0;
+      if( gt1Flag )
+      {
+        RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_par );
+        parFlag = m_binDecoder.decodeBin(cctx.parityCtxIdAbsTS());
+        DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_par_flag() bin=%d ctx=%d\n", parFlag, cctx.parityCtxIdAbsTS());
+        cctx.decimateNumCtxBins(1);
+      }
+      coeff[ blkPos ] = (sign ? -1 : 1 ) * (TCoeff)(1 + parFlag + gt1Flag);
+    }
+    lastScanPosPass1 = nextSigPos;
+  }
+
+  int cutoffVal = 2;
+  const int numGtBins = 4;
+
+  //===== 2nd PASS: gt2 =====
+  for (int scanPos = firstSigPos; scanPos <= minSubPos && cctx.numCtxBins() >= 4; scanPos++)
+  {
+    TCoeff& tcoeff = coeff[cctx.blockPos(scanPos)];
+    cutoffVal = 2;
+    for (int i = 0; i < numGtBins; i++)
+    {
+      if( tcoeff < 0)
+      {
+        tcoeff = -tcoeff;
+      }
+      if (tcoeff >= cutoffVal)
+      {
+        RExt__DECODER_DEBUG_BIT_STATISTICS_SET(ctype_gt2);
+        unsigned gt2Flag;
+        gt2Flag = m_binDecoder.decodeBin(cctx.greaterXCtxIdAbsTS(cutoffVal >> 1));
+        tcoeff += (gt2Flag << 1);
+        DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_gt%d_flag() bin=%d ctx=%d sp=%d coeff=%d\n", i, gt2Flag,
+               cctx.greaterXCtxIdAbsTS(cutoffVal >> 1), scanPos, tcoeff);
+        cctx.decimateNumCtxBins(1);
+      }
+      cutoffVal += 2;
+    }
+    lastScanPosPass2 = scanPos;
+  }
+  //===== 3rd PASS: Go-rice codes =====
+  for( int scanPos = firstSigPos; scanPos <= minSubPos; scanPos++ )
+  {
+    TCoeff& tcoeff = coeff[ cctx.blockPos( scanPos ) ];
+    RExt__DECODER_DEBUG_BIT_STATISTICS_SET( ctype_escs );
+
+    cutoffVal = (scanPos <= lastScanPosPass2 ? 10 : (scanPos <= lastScanPosPass1 ? 2 : 0));
+    if (tcoeff < 0)
+    {
+      tcoeff = -tcoeff;
+    }
+    if( tcoeff >= cutoffVal )
+    {
+      int       rice = riceParam;
+      int       rem  = m_binDecoder.decodeRemAbsEP(rice, COEF_REMAIN_BIN_REDUCTION, cctx.maxLog2TrDRange());
+      DTRACE( g_trace_ctx, D_SYNTAX_RESI, "ts_rem_val() bin=%d ctx=%d sp=%d\n", rem, rice, scanPos );
+      tcoeff += (scanPos <= lastScanPosPass1) ? (rem << 1) : rem;
+      if (tcoeff && scanPos > lastScanPosPass1)
+      {
+        int      blkPos = cctx.blockPos(scanPos);
+        int      sign   = m_binDecoder.decodeBinEP();
+        signPattern += (sign << numNonZero);
+        sigBlkPos[numNonZero++] = blkPos;
+      }
+    }
+    if (cctx.bdpcm() == BdpcmMode::NONE && cutoffVal)
+    {
+      if (tcoeff > 0)
+      {
+        int rightPixel, belowPixel;
+        cctx.neighTS(rightPixel, belowPixel, scanPos, coeff);
+        tcoeff = cctx.decDeriveModCoeff(rightPixel, belowPixel, tcoeff);
+      }
+    }
+  }
+
+  //===== set final coefficents =====
+  for( unsigned k = 0; k < numNonZero; k++ )
+  {
+    TCoeff AbsCoeff       = coeff[ sigBlkPos[ k ] ];
+    coeff[ sigBlkPos[k] ] = ( signPattern & 1 ? -AbsCoeff : AbsCoeff );
+    signPattern         >>= 1;
+    checkCoeffInRange(cctx, coeff[sigBlkPos[k]]);
+  }
+}
+
+//================================================================================
+//  helper functions
+//--------------------------------------------------------------------------------
+//    unsigned  unary_max_symbol ( ctxId0, ctxId1, maxSymbol )
+//    unsigned  unary_max_eqprob (                 maxSymbol )
+//    unsigned  exp_golomb_eqprob( count )
+//================================================================================
+
+unsigned CABACReader::unary_max_symbol( unsigned ctxId0, unsigned ctxIdN, unsigned maxSymbol  )
+{
+  unsigned onesRead = 0;
+  while (onesRead < maxSymbol && m_binDecoder.decodeBin(onesRead == 0 ? ctxId0 : ctxIdN) == 1)
+  {
+    ++onesRead;
+  }
+  return onesRead;
+}
+
+unsigned CABACReader::unary_max_eqprob( unsigned maxSymbol )
+{
+  for( unsigned k = 0; k < maxSymbol; k++ )
+  {
+    if (!m_binDecoder.decodeBinEP())
+    {
+      return k;
+    }
+  }
+  return maxSymbol;
+}
+
+unsigned CABACReader::exp_golomb_eqprob( unsigned count )
+{
+  unsigned symbol = 0;
+  unsigned bit    = 1;
+  while( bit )
+  {
+    bit = m_binDecoder.decodeBinEP();
+    symbol += bit << count++;
+  }
+  if( --count )
+  {
+    symbol += m_binDecoder.decodeBinsEP(count);
+  }
+  return symbol;
+}
+
+void CABACReader::mip_flag( CodingUnit& cu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__OTHER );
+
+  if( !cu.Y().valid() )
+  {
+    return;
+  }
+  if( !cu.cs->sps->getUseMIP() )
+  {
+    cu.mipFlag = false;
+    return;
+  }
+
+  unsigned ctxId = DeriveCtx::CtxMipFlag( cu );
+  cu.mipFlag     = m_binDecoder.decodeBin(Ctx::MipFlag(ctxId));
+  DTRACE( g_trace_ctx, D_SYNTAX, "mip_flag() pos=(%d,%d) mode=%d\n", cu.lumaPos().x, cu.lumaPos().y, cu.mipFlag ? 1 : 0 );
+}
+
+void CABACReader::mip_pred_modes( CodingUnit &cu )
+{
+  RExt__DECODER_DEBUG_BIT_STATISTICS_CREATE_SET( STATS__CABAC_BITS__OTHER );
+
+  if( !cu.Y().valid() )
+  {
+    return;
+  }
+  for( auto &pu : CU::traversePUs( cu ) )
+  {
+    mip_pred_mode( pu );
+  }
+}
+
+void CABACReader::mip_pred_mode( PredictionUnit &pu )
+{
+  pu.mipTransposedFlag = bool(m_binDecoder.decodeBinEP());
+
+  uint32_t mipMode;
+  const int numModes = MatrixIntraPrediction::getNumModesMip(pu.Y());
+  xReadTruncBinCode( mipMode, numModes );
+  pu.intraDir[ChannelType::LUMA] = mipMode;
+  CHECKD(pu.intraDir[ChannelType::LUMA] < 0 || pu.intraDir[ChannelType::LUMA] >= numModes, "Invalid MIP mode");
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "mip_pred_mode() pos=(%d,%d) mode=%d transposed=%d\n", pu.lumaPos().x, pu.lumaPos().y,
+         pu.intraDir[ChannelType::LUMA], pu.mipTransposedFlag ? 1 : 0);
+}
diff --git a/source/Lib/SkipLib/CABACReader.h b/source/Lib/SkipLib/CABACReader.h
new file mode 100644
index 00000000..98704b00
--- /dev/null
+++ b/source/Lib/SkipLib/CABACReader.h
@@ -0,0 +1,182 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     CABACReader.h
+ *  \brief    Reader for low level syntax
+ */
+
+#ifndef __CABACREADER__
+#define __CABACREADER__
+
+#include "BinDecoder.h"
+
+#include "CommonLib/ContextModelling.h"
+#include "CommonLib/MotionInfo.h"
+#include "CommonLib/UnitPartitioner.h"
+
+
+class CABACReader
+{
+public:
+  CABACReader(BinDecoderBase &binDecoder) : m_binDecoder(binDecoder), m_bitstream(nullptr) {}
+  virtual ~CABACReader() {}
+
+public:
+  void        initCtxModels             ( Slice&                        slice );
+  void        initBitstream(InputBitstream *bitstream)
+  {
+    m_bitstream = bitstream;
+    m_binDecoder.init(m_bitstream);
+  }
+  const Ctx &getCtx() const { return m_binDecoder.getCtx(); }
+  Ctx       &getCtx() { return m_binDecoder.getCtx(); }
+
+public:
+  // slice segment data (clause 7.3.8.1)
+  bool        terminating_bit           ();
+  void        remaining_bytes           ( bool                          noTrailingBytesExpected );
+
+  // coding tree unit (clause 7.3.8.2)
+  void coding_tree_unit(CodingStructure &cs, const UnitArea &area, EnumArray<int, ChannelType> &qps,
+                        unsigned ctuRsAddr);
+
+  // sao (clause 7.3.8.3)
+  void        sao                       ( CodingStructure&              cs,     unsigned        ctuRsAddr );
+
+  void        readAlfCtuFilterIndex(CodingStructure&              cs, unsigned        ctuRsAddr);
+
+  void ccAlfFilterControlIdc(CodingStructure &cs, const ComponentID compID, const int curIdx, uint8_t *filterControlIdc,
+                             Position lumaPos, int filterCount);
+
+  // coding (quad)tree (clause 7.3.8.4)
+  void        coding_tree               ( CodingStructure&              cs,     Partitioner&    pm,       CUCtx& cuCtx, Partitioner* pPartitionerChroma = nullptr, CUCtx* pCuCtxChroma = nullptr);
+  PartSplit   split_cu_mode             ( CodingStructure&              cs,     Partitioner&    pm );
+  ModeType    mode_constraint           ( CodingStructure&              cs,     Partitioner&    pm,       const PartSplit splitMode );
+
+  // coding unit (clause 7.3.8.5)
+  void        coding_unit               ( CodingUnit&                   cu,     Partitioner&    pm,       CUCtx& cuCtx );
+  void        cu_skip_flag              ( CodingUnit&                   cu );
+  void        pred_mode                 ( CodingUnit&                   cu );
+  void        bdpcm_mode                ( CodingUnit&                   cu,     const ComponentID compID );
+  void        cu_pred_data              ( CodingUnit&                   cu );
+  void        cu_bcw_flag               ( CodingUnit&                   cu );
+  void        extend_ref_line           (CodingUnit&                     cu);
+  void        intra_luma_pred_modes     ( CodingUnit&                   cu );
+  void        intra_chroma_pred_modes   ( CodingUnit&                   cu );
+  bool        intra_chroma_lmc_mode     ( PredictionUnit&               pu );
+  void        intra_chroma_pred_mode    ( PredictionUnit&               pu );
+  void        cu_residual               ( CodingUnit&                   cu,     Partitioner&    pm,       CUCtx& cuCtx );
+  void        rqt_root_cbf              ( CodingUnit&                   cu );
+  void        adaptive_color_transform(CodingUnit&             cu);
+  void        sbt_mode                  ( CodingUnit&                   cu );
+  void        end_of_ctu                ( CodingUnit&                   cu,     CUCtx&          cuCtx );
+  void        mip_flag                  ( CodingUnit&                   cu );
+  void        mip_pred_modes            ( CodingUnit&                   cu );
+  void        mip_pred_mode             ( PredictionUnit&               pu );
+  void        cu_palette_info           ( CodingUnit&                   cu,     ComponentID     compBegin, uint32_t numComp, CUCtx& cuCtx );
+  void        cuPaletteSubblockInfo     ( CodingUnit&                   cu,     ComponentID     compBegin, uint32_t numComp, int subSetId, uint32_t& prevRunPos, unsigned& prevRunType );
+  // prediction unit (clause 7.3.8.6)
+  void        prediction_unit           ( PredictionUnit&               pu );
+  void        merge_flag                ( PredictionUnit&               pu );
+  void        merge_data                ( PredictionUnit&               pu );
+  void        affine_flag               ( CodingUnit&                   cu );
+  void        subblock_merge_flag       ( CodingUnit&                   cu );
+  void        merge_idx                 ( PredictionUnit&               pu );
+  void        mmvd_merge_idx(PredictionUnit&               pu);
+  void        imv_mode                  ( CodingUnit&                   cu );
+  void        affine_amvr_mode          ( CodingUnit&                   cu );
+  void        inter_pred_idc            ( PredictionUnit&               pu );
+  void        ref_idx                   ( PredictionUnit&               pu,     RefPicList      eRefList );
+  void        mvp_flag                  ( PredictionUnit&               pu,     RefPicList      eRefList );
+  void        ciip_flag(PredictionUnit &pu);
+  void        smvd_mode              ( PredictionUnit&               pu );
+
+
+  // transform tree (clause 7.3.8.8)
+  void        transform_tree            ( CodingStructure&              cs, Partitioner&    pm, CUCtx& cuCtx, const PartSplit ispType = TU_NO_ISP, const int subTuIdx = -1 );
+  bool cbf_comp(const CompArea &area, unsigned depth, bool prevCbf, bool useISP, BdpcmMode bdpcmMode);
+
+  // mvd coding (clause 7.3.8.9)
+  void        mvd_coding                ( Mv &rMvd );
+
+  // transform unit (clause 7.3.8.10)
+  void        transform_unit            ( TransformUnit&                tu,     CUCtx&          cuCtx, Partitioner& pm,        const int subTuCounter = -1 );
+  void        cu_qp_delta               ( CodingUnit&                   cu,     int             predQP, int8_t& qp );
+  void        cu_chroma_qp_offset       ( CodingUnit&                   cu );
+
+  // residual coding (clause 7.3.8.11)
+  void        residual_coding           ( TransformUnit&                tu,     ComponentID     compID, CUCtx& cuCtx );
+  void        ts_flag                   ( TransformUnit&                tu,     ComponentID     compID );
+  void        mts_idx                   ( CodingUnit&                   cu,     CUCtx&          cuCtx  );
+  void        residual_lfnst_mode       ( CodingUnit&                   cu,     CUCtx&          cuCtx  );
+  void        isp_mode                  ( CodingUnit&                   cu );
+  int         last_sig_coeff            ( CoeffCodingContext&           cctx,   TransformUnit& tu, ComponentID   compID );
+  void        residual_coding_subblock  ( CoeffCodingContext&           cctx,   TCoeff*         coeff, const int stateTransTable, int& state );
+  void        residual_codingTS         ( TransformUnit&                tu,     ComponentID     compID );
+  void        residual_coding_subblockTS( CoeffCodingContext&           cctx,   TCoeff*         coeff, int riceParam);
+  void        joint_cb_cr               ( TransformUnit&                tu,     const int cbfMask );
+
+
+private:
+  unsigned    unary_max_symbol          ( unsigned ctxId0, unsigned ctxIdN, unsigned maxSymbol );
+  unsigned    unary_max_eqprob          (                                   unsigned maxSymbol );
+  unsigned    exp_golomb_eqprob         ( unsigned count );
+  unsigned    get_num_bits_read() { return m_binDecoder.getNumBitsRead(); }
+
+  void        xReadTruncBinCode(uint32_t &symbol, uint32_t numSymbols);
+  void        parseScanRotationModeFlag ( CodingUnit& cu,           ComponentID compBegin );
+  void        xDecodePLTPredIndicator   ( CodingUnit& cu,           uint32_t maxPLTSize,   ComponentID compBegin );
+  void        xAdjustPLTIndex           ( CodingUnit& cu,           Pel curLevel,          uint32_t idx, PelBuf& paletteIdx, PLTtypeBuf& paletteRunType, int maxSymbol, ComponentID compBegin );
+public:
+private:
+  BinDecoderBase &m_binDecoder;
+  InputBitstream *m_bitstream;
+  ScanElement*    m_scanOrder;
+};
+
+
+class CABACDecoder
+{
+public:
+  CABACDecoder() : m_CABACReaderStd(m_BinDecoderStd), m_CABACReader{ &m_CABACReaderStd } {}
+
+  CABACReader *getCABACReader(BpmType id) { return m_CABACReader[id]; }
+
+private:
+  BinDecoder_Std          m_BinDecoderStd;
+  CABACReader             m_CABACReaderStd;
+
+  EnumArray<CABACReader *, BpmType> m_CABACReader;
+};
+
+#endif
diff --git a/source/Lib/SkipLib/CABACWriter.cpp b/source/Lib/SkipLib/CABACWriter.cpp
new file mode 100644
index 00000000..0a960693
--- /dev/null
+++ b/source/Lib/SkipLib/CABACWriter.cpp
@@ -0,0 +1,3581 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     CABACWriter.cpp
+ *  \brief    Writer for low level syntax
+ */
+
+#include "CommonLib/Contexts.h"
+#include "CABACWriter.h"
+
+#include "CommonLib/UnitTools.h"
+#include "CommonLib/dtrace_buffer.h"
+
+#include <map>
+#include <algorithm>
+#include <limits>
+
+
+//! \ingroup EncoderLib
+//! \{
+
+void CABACWriter::initCtxModels( const Slice& slice )
+{
+  int       qp                = slice.getSliceQp();
+  SliceType sliceType         = slice.getSliceType();
+  SliceType encCABACTableIdx  = slice.getEncCABACTableIdx();
+  if( !slice.isIntra() && (encCABACTableIdx==B_SLICE || encCABACTableIdx==P_SLICE) && slice.getPPS()->getCabacInitPresentFlag() )
+  {
+    sliceType = encCABACTableIdx;
+  }
+  m_binEncoder.reset(qp, (int) sliceType);
+  m_binEncoder.setBaseLevel(slice.getRiceBaseLevel());
+  m_binEncoder.riceStatReset(slice.getSPS()->getBitDepth(ChannelType::LUMA),
+                             slice.getSPS()->getSpsRangeExtension().getPersistentRiceAdaptationEnabledFlag());
+}
+
+template <class BinProbModel>
+SliceType xGetCtxInitId( const Slice& slice, const BinEncIf& binEncoder, Ctx& ctxTest )
+{
+  const CtxStore<BinProbModel>& ctxStoreTest = static_cast<const CtxStore<BinProbModel>&>( ctxTest );
+  const CtxStore<BinProbModel>& ctxStoreRef  = static_cast<const CtxStore<BinProbModel>&>( binEncoder.getCtx() );
+  int qp = slice.getSliceQp();
+  if( !slice.isIntra() )
+  {
+    SliceType aSliceTypeChoices[] = { B_SLICE, P_SLICE };
+    uint64_t  bestCost            = std::numeric_limits<uint64_t>::max();
+    SliceType bestSliceType       = aSliceTypeChoices[0];
+    for (uint32_t idx=0; idx<2; idx++)
+    {
+      uint64_t  curCost           = 0;
+      SliceType curSliceType      = aSliceTypeChoices[idx];
+      ctxTest.init( qp, (int)curSliceType );
+      for( int k = 0; k < Ctx::NumberOfContexts; k++ )
+      {
+        if( binEncoder.getNumBins(k) > 0 )
+        {
+          curCost += uint64_t( binEncoder.getNumBins(k) ) * ctxStoreRef[k].estFracExcessBits( ctxStoreTest[k] );
+        }
+      }
+      if (curCost < bestCost)
+      {
+        bestSliceType = curSliceType;
+        bestCost      = curCost;
+      }
+    }
+    return bestSliceType;
+  }
+  else
+  {
+    return I_SLICE;
+  }
+}
+
+SliceType CABACWriter::getCtxInitId( const Slice& slice )
+{
+  switch (m_testCtx.getBpmType())
+  {
+  case BpmType::STD: return xGetCtxInitId<BinProbModel_Std>(slice, m_binEncoder, m_testCtx);
+  default:        return  NUMBER_OF_SLICE_TYPES;
+  }
+}
+
+unsigned estBits( BinEncIf& binEnc, const std::vector<bool>& bins, const Ctx& ctx, const int ctxId, const uint8_t winSize )
+{
+  binEnc.initCtxAndWinSize( ctxId, ctx, winSize );
+  binEnc.start();
+  const std::size_t numBins   = bins.size();
+  unsigned          startBits = binEnc.getNumWrittenBits();
+  for( std::size_t binId = 0; binId < numBins; binId++ )
+  {
+    unsigned  bin = ( bins[binId] ? 1 : 0 );
+    binEnc.encodeBin( bin, ctxId );
+  }
+  unsigned endBits    = binEnc.getNumWrittenBits();
+  unsigned codedBits  = endBits - startBits;
+  return   codedBits;
+}
+
+//================================================================================
+//  clause 7.3.8.1
+//--------------------------------------------------------------------------------
+//    void  end_of_slice()
+//================================================================================
+
+void CABACWriter::end_of_slice()
+{
+  m_binEncoder.encodeBinTrm(1);
+  m_binEncoder.finish();
+}
+
+//================================================================================
+//  clause 7.3.8.2
+//--------------------------------------------------------------------------------
+//    bool  coding_tree_unit( cs, area, qp, ctuRsAddr, skipSao, skipAlf )
+//================================================================================
+
+void CABACWriter::coding_tree_unit(CodingStructure &cs, const UnitArea &area, EnumArray<int, ChannelType> &qps,
+                                   unsigned ctuRsAddr, bool skipSao /* = false */, bool skipAlf /* = false */)
+{
+  CUCtx           cuCtx(qps[ChannelType::LUMA]);
+  QTBTPartitioner partitioner;
+
+  partitioner.initCtu(area, ChannelType::LUMA, *cs.slice);
+
+  if( !skipSao )
+  {
+    sao( *cs.slice, ctuRsAddr );
+  }
+
+  if (!skipAlf)
+  {
+    for (int compIdx = 0; compIdx < MAX_NUM_COMPONENT; compIdx++)
+    {
+      codeAlfCtuEnableFlag(cs, ctuRsAddr, compIdx, nullptr);
+      if (isLuma(ComponentID(compIdx)))
+      {
+        codeAlfCtuFilterIndex(cs, ctuRsAddr, cs.slice->getAlfEnabledFlag(COMPONENT_Y));
+      }
+      if (isChroma(ComponentID(compIdx)))
+      {
+        AlfMode *alfModes =
+          cs.slice->getAlfEnabledFlag((ComponentID) compIdx) ? cs.slice->getPic()->getAlfModes(compIdx) : nullptr;
+        if (alfModes != nullptr && alfModes[ctuRsAddr] != AlfMode::OFF)
+        {
+          codeAlfCtuAlternative( cs, ctuRsAddr, compIdx );
+        }
+      }
+    }
+  }
+
+  if ( !skipAlf )
+  {
+    for ( int compIdx = 1; compIdx < getNumberValidComponents( cs.pcv->chrFormat ); compIdx++ )
+    {
+      if (cs.slice->m_ccAlfFilterParam.ccAlfFilterEnabled[compIdx - 1])
+      {
+        const int filterCount   = cs.slice->m_ccAlfFilterParam.ccAlfFilterCount[compIdx - 1];
+
+        const int      ry = ctuRsAddr / cs.pcv->widthInCtus;
+        const int      rx = ctuRsAddr % cs.pcv->widthInCtus;
+        const Position lumaPos(rx * cs.pcv->maxCUWidth, ry * cs.pcv->maxCUHeight);
+
+        codeCcAlfFilterControlIdc(cs.slice->m_ccAlfFilterControl[compIdx - 1][ctuRsAddr], cs, ComponentID(compIdx),
+                                  ctuRsAddr, cs.slice->m_ccAlfFilterControl[compIdx - 1], lumaPos, filterCount);
+      }
+    }
+  }
+
+  if (CS::isDualITree(cs) && isChromaEnabled(cs.pcv->chrFormat) && cs.pcv->maxCUWidth > 64)
+  {
+    CUCtx           chromaCuCtx(qps[ChannelType::CHROMA]);
+    QTBTPartitioner chromaPartitioner;
+    chromaPartitioner.initCtu(area, ChannelType::CHROMA, *cs.slice);
+    coding_tree(cs, partitioner, cuCtx, &chromaPartitioner, &chromaCuCtx);
+    qps[ChannelType::LUMA]   = cuCtx.qp;
+    qps[ChannelType::CHROMA] = chromaCuCtx.qp;
+  }
+  else
+  {
+    coding_tree(cs, partitioner, cuCtx);
+    qps[ChannelType::LUMA] = cuCtx.qp;
+    if (CS::isDualITree(cs) && isChromaEnabled(cs.pcv->chrFormat))
+    {
+      CUCtx cuCtxChroma(qps[ChannelType::CHROMA]);
+      partitioner.initCtu(area, ChannelType::CHROMA, *cs.slice);
+      coding_tree(cs, partitioner, cuCtxChroma);
+      qps[ChannelType::CHROMA] = cuCtxChroma.qp;
+    }
+  }
+}
+
+//================================================================================
+//  clause 7.3.8.3
+//--------------------------------------------------------------------------------
+//    void  sao             ( slice, ctuRsAddr )
+//    void  sao_block_params  ( saoPars, bitDepths, sliceEnabled, leftMergeAvail, aboveMergeAvail, onlyEstMergeInfo )
+//    void  sao_offset_params ( ctbPars, compID, sliceEnabled, bitDepth )
+//================================================================================
+
+void CABACWriter::sao( const Slice& slice, unsigned ctuRsAddr )
+{
+  const SPS& sps = *slice.getSPS();
+  if( !sps.getSAOEnabledFlag() )
+  {
+    return;
+  }
+
+  CodingStructure     &cs           = *slice.getPic()->cs;
+  const PreCalcValues &pcv          = *cs.pcv;
+  const SAOBlkParam   &saoCtuParams = cs.picture->getSAO()[ctuRsAddr];
+
+  const bool sliceSaoLumaFlag = slice.getSaoEnabledFlag(ChannelType::LUMA);
+  const bool sliceSaoChromaFlag =
+    slice.getSaoEnabledFlag(ChannelType::CHROMA) && isChromaEnabled(sps.getChromaFormatIdc());
+
+  if (!sliceSaoLumaFlag && !sliceSaoChromaFlag)
+  {
+    return;
+  }
+
+  const bool sliceEnabled[3] = { sliceSaoLumaFlag, sliceSaoChromaFlag, sliceSaoChromaFlag };
+
+  const int frameWidthInCtus = pcv.widthInCtus;
+
+  const int ry = ctuRsAddr / frameWidthInCtus;
+  const int rx = ctuRsAddr - ry * frameWidthInCtus;
+
+  const Position pos(rx * cs.pcv->maxCUWidth, ry * cs.pcv->maxCUHeight);
+
+  const unsigned curSliceIdx = slice.getIndependentSliceIdx();
+  const unsigned curTileIdx  = cs.pps->getTileIdx(pos);
+
+  const bool leftMergeAvail =
+    cs.getCURestricted(pos.offset(-(int) pcv.maxCUWidth, 0), pos, curSliceIdx, curTileIdx, ChannelType::LUMA)
+    != nullptr;
+  const bool aboveMergeAvail =
+    cs.getCURestricted(pos.offset(0, -(int) pcv.maxCUHeight), pos, curSliceIdx, curTileIdx, ChannelType::LUMA)
+    != nullptr;
+
+  sao_block_params(saoCtuParams, sps.getBitDepths(), sliceEnabled, leftMergeAvail, aboveMergeAvail, false);
+}
+
+void CABACWriter::sao_block_params(const SAOBlkParam &saoPars, const BitDepths &bitDepths, const bool *sliceEnabled,
+                                   bool leftMergeAvail, bool aboveMergeAvail, bool onlyEstMergeInfo)
+{
+  bool isLeftMerge  = false;
+  bool isAboveMerge = false;
+  if( leftMergeAvail )
+  {
+    // sao_merge_left_flag
+    isLeftMerge = (saoPars[COMPONENT_Y].modeIdc == SAOMode::MERGE
+                   && saoPars[COMPONENT_Y].typeIdc.mergeType == SAOModeMergeTypes::LEFT);
+    m_binEncoder.encodeBin((isLeftMerge), Ctx::SaoMergeFlag());
+  }
+  if( aboveMergeAvail && !isLeftMerge )
+  {
+    // sao_merge_above_flag
+    isAboveMerge = (saoPars[COMPONENT_Y].modeIdc == SAOMode::MERGE
+                    && saoPars[COMPONENT_Y].typeIdc.mergeType == SAOModeMergeTypes::ABOVE);
+    m_binEncoder.encodeBin((isAboveMerge), Ctx::SaoMergeFlag());
+  }
+  if( onlyEstMergeInfo )
+  {
+    return; //only for RDO
+  }
+  if( !isLeftMerge && !isAboveMerge )
+  {
+    // explicit parameters
+    for( int compIdx=0; compIdx < MAX_NUM_COMPONENT; compIdx++ )
+    {
+      sao_offset_params(saoPars[compIdx], ComponentID(compIdx), sliceEnabled[compIdx],
+                        bitDepths[toChannelType(ComponentID(compIdx))]);
+    }
+  }
+}
+
+void CABACWriter::sao_offset_params(const SAOOffset &ctbPars, ComponentID compID, bool sliceEnabled, int bitDepth)
+{
+  if( !sliceEnabled )
+  {
+    CHECK(ctbPars.modeIdc != SAOMode::OFF, "Sao must be off, if it is disabled on slice level");
+    return;
+  }
+  const bool isFirstCompOfChType = ( getFirstComponentOfChannel( toChannelType(compID) ) == compID );
+
+  if( isFirstCompOfChType )
+  {
+    // sao_type_idx_luma / sao_type_idx_chroma
+    if (ctbPars.modeIdc == SAOMode::OFF)
+    {
+      m_binEncoder.encodeBin(0, Ctx::SaoTypeIdx());
+    }
+    else if (ctbPars.typeIdc.newType == SAOModeNewTypes::BO)
+    {
+      m_binEncoder.encodeBin(1, Ctx::SaoTypeIdx());
+      m_binEncoder.encodeBinEP(0);
+    }
+    else
+    {
+      CHECK(!(ctbPars.typeIdc.newType < SAOModeNewTypes::START_BO), "Unspecified error");
+      m_binEncoder.encodeBin(1, Ctx::SaoTypeIdx());
+      m_binEncoder.encodeBinEP(1);
+    }
+  }
+
+  if (ctbPars.modeIdc == SAOMode::NEW)
+  {
+    const int maxOffsetQVal = 1; // SampleAdaptiveOffset::getMaxOffsetQVal( bitDepth );
+    int       numClasses    = (ctbPars.typeIdc.newType == SAOModeNewTypes::BO ? 4 : NUM_SAO_EO_CLASSES);
+    int       k             = 0;
+    int       offset[4];
+    for( int i = 0; i < numClasses; i++ )
+    {
+      if (ctbPars.typeIdc.newType != SAOModeNewTypes::BO && i == SAO_CLASS_EO_PLAIN)
+      {
+        continue;
+      }
+      int classIdx =
+        (ctbPars.typeIdc.newType == SAOModeNewTypes::BO ? (ctbPars.typeAuxInfo + i) % NUM_SAO_BO_CLASSES : i);
+      offset[k++]  = ctbPars.offset[classIdx];
+    }
+
+    // sao_offset_abs
+    for( int i = 0; i < 4; i++ )
+    {
+      unsigned absOffset = ( offset[i] < 0 ? -offset[i] : offset[i] );
+      unary_max_eqprob( absOffset, maxOffsetQVal );
+    }
+
+    // band offset mode
+    if (ctbPars.typeIdc.newType == SAOModeNewTypes::BO)
+    {
+      // sao_offset_sign
+      for( int i = 0; i < 4; i++ )
+      {
+        if( offset[i] )
+        {
+          m_binEncoder.encodeBinEP((offset[i] < 0));
+        }
+      }
+      // sao_band_position
+      m_binEncoder.encodeBinsEP(ctbPars.typeAuxInfo, NUM_SAO_BO_CLASSES_LOG2);
+    }
+    // edge offset mode
+    else
+    {
+      if( isFirstCompOfChType )
+      {
+        // sao_eo_class_luma / sao_eo_class_chroma
+        CHECK(ctbPars.typeIdc.newType < SAOModeNewTypes::START_EO, "sao edge offset class is outside valid range");
+        m_binEncoder.encodeBinsEP(to_underlying(ctbPars.typeIdc.newType) - to_underlying(SAOModeNewTypes::START_EO),
+                                  NUM_SAO_EO_TYPES_LOG2);
+      }
+    }
+  }
+}
+
+//================================================================================
+//  clause 7.3.8.4
+//--------------------------------------------------------------------------------
+//    void  coding_tree       ( cs, partitioner, cuCtx )
+//    void  split_cu_flag     ( split, cs, partitioner )
+//    void  split_cu_mode_mt  ( split, cs, partitioner )
+//================================================================================
+
+void CABACWriter::coding_tree(const CodingStructure& cs, Partitioner& partitioner, CUCtx& cuCtx, Partitioner* pPartitionerChroma, CUCtx* pCuCtxChroma)
+{
+  const PPS      &pps         = *cs.pps;
+  const UnitArea &currArea    = partitioner.currArea();
+  const CodingUnit &cu          = *cs.getCU(currArea.block(partitioner.chType), partitioner.chType);
+
+  // Reset delta QP coding flag and ChromaQPAdjustemt coding flag
+  //Note: do not reset qg at chroma CU
+  if( pps.getUseDQP() && partitioner.currQgEnable() && !isChroma( partitioner.chType ) )
+  {
+    cuCtx.qgStart    = true;
+    cuCtx.isDQPCoded          = false;
+  }
+  if( cs.slice->getUseChromaQpAdj() && partitioner.currQgChromaEnable() )
+  {
+    cuCtx.isChromaQpAdjCoded  = false;
+  }
+  // Reset delta QP coding flag and ChromaQPAdjustemt coding flag
+  if (CS::isDualITree(cs) && pPartitionerChroma != nullptr)
+  {
+    if (pps.getUseDQP() && pPartitionerChroma->currQgEnable())
+    {
+      pCuCtxChroma->qgStart    = true;
+      pCuCtxChroma->isDQPCoded = false;
+    }
+    if (cs.slice->getUseChromaQpAdj() && pPartitionerChroma->currQgChromaEnable())
+    {
+      pCuCtxChroma->isChromaQpAdjCoded = false;
+    }
+  }
+
+  const PartSplit splitMode = CU::getSplitAtDepth( cu, partitioner.currDepth );
+
+  split_cu_mode( splitMode, cs, partitioner );
+
+  CHECK( !partitioner.canSplit( splitMode, cs ), "The chosen split mode is invalid!" );
+
+  if( splitMode != CU_DONT_SPLIT )
+  {
+    if (CS::isDualITree(cs) && pPartitionerChroma != nullptr
+        && (partitioner.currArea().lwidth() >= 64 || partitioner.currArea().lheight() >= 64))
+    {
+      partitioner.splitCurrArea(CU_QUAD_SPLIT, cs);
+      pPartitionerChroma->splitCurrArea(CU_QUAD_SPLIT, cs);
+      bool beContinue     = true;
+      bool lumaContinue   = true;
+      bool chromaContinue = true;
+
+      while (beContinue)
+      {
+        if (partitioner.currArea().lwidth() > 64 || partitioner.currArea().lheight() > 64)
+        {
+          if (cs.picture->block(partitioner.chType).contains(partitioner.currArea().block(partitioner.chType).pos()))
+          {
+            coding_tree(cs, partitioner, cuCtx, pPartitionerChroma, pCuCtxChroma);
+          }
+          lumaContinue   = partitioner.nextPart(cs);
+          chromaContinue = pPartitionerChroma->nextPart(cs);
+          CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+          beContinue = lumaContinue;
+        }
+        else
+        {
+          // dual tree coding under 64x64 block
+          if (cs.picture->block(partitioner.chType).contains(partitioner.currArea().block(partitioner.chType).pos()))
+          {
+            coding_tree(cs, partitioner, cuCtx);
+          }
+          lumaContinue = partitioner.nextPart(cs);
+          if (cs.picture->block(pPartitionerChroma->chType)
+                .contains(pPartitionerChroma->currArea().block(pPartitionerChroma->chType).pos()))
+          {
+            coding_tree(cs, *pPartitionerChroma, *pCuCtxChroma);
+          }
+          chromaContinue = pPartitionerChroma->nextPart(cs);
+          CHECK(lumaContinue != chromaContinue, "luma chroma partition should be matched");
+          beContinue = lumaContinue;
+        }
+      }
+      partitioner.exitCurrSplit();
+      pPartitionerChroma->exitCurrSplit();
+    }
+    else
+    {
+      const ModeType modeTypeParent = partitioner.modeType;
+      const ModeType modeTypeChild  = CU::getModeTypeAtDepth(cu, partitioner.currDepth);
+      mode_constraint(splitMode, cs, partitioner, modeTypeChild);
+      partitioner.modeType = modeTypeChild;
+
+      bool chromaNotSplit = modeTypeParent == MODE_TYPE_ALL && modeTypeChild == MODE_TYPE_INTRA ? true : false;
+      CHECK(chromaNotSplit && partitioner.chType != ChannelType::LUMA, "chType must be luma");
+      if (partitioner.treeType == TREE_D)
+      {
+        partitioner.treeType = chromaNotSplit ? TREE_L : TREE_D;
+      }
+      partitioner.splitCurrArea( splitMode, cs );
+
+      do
+      {
+        if (cs.picture->block(partitioner.chType).contains(partitioner.currArea().block(partitioner.chType).pos()))
+        {
+          coding_tree( cs, partitioner, cuCtx );
+        }
+      } while( partitioner.nextPart( cs ) );
+
+      partitioner.exitCurrSplit();
+      if( chromaNotSplit )
+      {
+        if (isChromaEnabled(cs.pcv->chrFormat))
+        {
+          CHECK(partitioner.chType != ChannelType::LUMA, "must be luma status");
+          partitioner.chType   = ChannelType::CHROMA;
+          partitioner.treeType = TREE_C;
+
+          if (cs.picture->block(partitioner.chType).contains(partitioner.currArea().block(partitioner.chType).pos()))
+          {
+            coding_tree(cs, partitioner, cuCtx);
+          }
+        }
+
+        //recover
+        partitioner.chType   = ChannelType::LUMA;
+        partitioner.treeType = TREE_D;
+      }
+      partitioner.modeType = modeTypeParent;
+    }
+    return;
+  }
+
+  // Predict QP on start of quantization group
+  if( cuCtx.qgStart )
+  {
+    cuCtx.qgStart = false;
+    cuCtx.qp = CU::predictQP( cu, cuCtx.qp );
+  }
+  CHECK( cu.treeType != partitioner.treeType, "treeType mismatch" );
+
+
+  // coding unit
+  coding_unit( cu, partitioner, cuCtx );
+
+  if (cu.chType == ChannelType::CHROMA)
+  {
+    DTRACE_COND( (isEncoding()), g_trace_ctx, D_QP, "[chroma CU]x=%d, y=%d, w=%d, h=%d, qp=%d\n", cu.Cb().x, cu.Cb().y, cu.Cb().width, cu.Cb().height, cu.qp );
+  }
+  else
+  {
+    DTRACE_COND((isEncoding()), g_trace_ctx, D_QP, "x=%d, y=%d, w=%d, h=%d, qp=%d\n", cu.Y().x, cu.Y().y, cu.Y().width,
+                cu.Y().height, cu.qp);
+  }
+  DTRACE_BLOCK_REC_COND( ( !isEncoding() ), cs.picture->getRecoBuf( cu ), cu, cu.predMode );
+}
+
+void CABACWriter::mode_constraint( const PartSplit split, const CodingStructure& cs, Partitioner& partitioner, const ModeType modeType )
+{
+  CHECK( split == CU_DONT_SPLIT, "splitMode shall not be no split" );
+  int val = cs.signalModeCons( split, partitioner, partitioner.modeType );
+  if( val == LDT_MODE_TYPE_SIGNAL )
+  {
+    CHECK( modeType == MODE_TYPE_ALL, "shall not be no constraint case" );
+    bool flag = modeType == MODE_TYPE_INTRA;
+    int ctxIdx = DeriveCtx::CtxModeConsFlag( cs, partitioner );
+    m_binEncoder.encodeBin(flag, Ctx::ModeConsFlag(ctxIdx));
+    DTRACE( g_trace_ctx, D_SYNTAX, "mode_cons_flag() flag=%d\n", flag );
+  }
+  else if( val == LDT_MODE_TYPE_INFER )
+  {
+    assert( modeType == MODE_TYPE_INTRA );
+  }
+  else
+  {
+    assert( modeType == partitioner.modeType );
+  }
+}
+
+void CABACWriter::split_cu_mode( const PartSplit split, const CodingStructure& cs, Partitioner& partitioner )
+{
+  bool canNo, canQt, canBh, canBv, canTh, canTv;
+  partitioner.canSplit( cs, canNo, canQt, canBh, canBv, canTh, canTv );
+
+  bool canSpl[6] = { canNo, canQt, canBh, canBv, canTh, canTv };
+
+  unsigned ctxSplit = 0, ctxQtSplit = 0, ctxBttHV = 0, ctxBttH12 = 0, ctxBttV12;
+  DeriveCtx::CtxSplit( cs, partitioner, ctxSplit, ctxQtSplit, ctxBttHV, ctxBttH12, ctxBttV12, canSpl );
+
+  const bool canSplit = canBh || canBv || canTh || canTv || canQt;
+  const bool isNo     = split == CU_DONT_SPLIT;
+
+  if( canNo && canSplit )
+  {
+    m_binEncoder.encodeBin(!isNo, Ctx::SplitFlag(ctxSplit));
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "split_cu_mode() ctx=%d split=%d\n", ctxSplit, !isNo );
+
+  if( isNo )
+  {
+    return;
+  }
+
+  const bool canBtt = canBh || canBv || canTh || canTv;
+  const bool isQt   = split == CU_QUAD_SPLIT;
+
+  if( canQt && canBtt )
+  {
+    m_binEncoder.encodeBin(isQt, Ctx::SplitQtFlag(ctxQtSplit));
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "split_cu_mode() ctx=%d qt=%d\n", ctxQtSplit, isQt );
+
+  if( isQt )
+  {
+    return;
+  }
+
+  const bool canHor = canBh || canTh;
+  const bool canVer = canBv || canTv;
+  const bool  isVer = split == CU_VERT_SPLIT || split == CU_TRIV_SPLIT;
+
+  if( canVer && canHor )
+  {
+    m_binEncoder.encodeBin(isVer, Ctx::SplitHvFlag(ctxBttHV));
+  }
+
+  const bool can14 = isVer ? canTv : canTh;
+  const bool can12 = isVer ? canBv : canBh;
+  const bool  is12 = isVer ? ( split == CU_VERT_SPLIT ) : ( split == CU_HORZ_SPLIT );
+
+  if( can12 && can14 )
+  {
+    m_binEncoder.encodeBin(is12, Ctx::Split12Flag(isVer ? ctxBttV12 : ctxBttH12));
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "split_cu_mode() ctxHv=%d ctx12=%d mode=%d\n", ctxBttHV, isVer ? ctxBttV12 : ctxBttH12, split );
+}
+
+//================================================================================
+//  clause 7.3.8.5
+//--------------------------------------------------------------------------------
+//    void  coding_unit               ( cu, partitioner, cuCtx )
+//    void  cu_skip_flag              ( cu )
+//    void  pred_mode                 ( cu )
+//    void  part_mode                 ( cu )
+//    void  cu_pred_data              ( pus )
+//    void  cu_lic_flag               ( cu )
+//    void  intra_luma_pred_modes     ( pus )
+//    void  intra_chroma_pred_mode    ( pu )
+//    void  cu_residual               ( cu, partitioner, cuCtx )
+//    void  rqt_root_cbf              ( cu )
+//    void  end_of_ctu                ( cu, cuCtx )
+//================================================================================
+
+void CABACWriter::coding_unit( const CodingUnit& cu, Partitioner& partitioner, CUCtx& cuCtx )
+{
+  DTRACE( g_trace_ctx, D_SYNTAX, "coding_unit() treeType=%d modeType=%d\n", cu.treeType, cu.modeType );
+  CodingStructure& cs = *cu.cs;
+
+  // skip flag
+  if ((!cs.slice->isIntra() || cs.slice->getSPS()->getIBCFlag()) && cu.Y().valid())
+  {
+    cu_skip_flag( cu );
+  }
+
+
+  // skip data
+  if( cu.skip )
+  {
+    CHECK( !cu.firstPU->mergeFlag, "Merge flag has to be on!" );
+    CHECK(cu.colorTransform, "ACT should not be enabled for skip mode");
+    PredictionUnit&   pu = *cu.firstPU;
+    prediction_unit ( pu );
+    end_of_ctu      ( cu, cuCtx );
+    return;
+  }
+
+  // prediction mode and partitioning data
+  pred_mode ( cu );
+  if (CU::isIntra(cu))
+  {
+    adaptive_color_transform(cu);
+  }
+  if (CU::isPLT(cu))
+  {
+    CHECK(cu.colorTransform, "ACT should not be enabled for PLT mode");
+    if (cu.isSepTree())
+    {
+      if (isLuma(partitioner.chType))
+      {
+        cu_palette_info(cu, COMPONENT_Y, 1, cuCtx);
+      }
+      if (isChromaEnabled(cu.chromaFormat) && partitioner.chType == ChannelType::CHROMA)
+      {
+        cu_palette_info(cu, COMPONENT_Cb, 2, cuCtx);
+      }
+    }
+    else
+    {
+      cu_palette_info(cu, COMPONENT_Y, getNumberValidComponents(cu.chromaFormat), cuCtx);
+    }
+    end_of_ctu(cu, cuCtx);
+    return;
+  }
+
+  // prediction data ( intra prediction modes / reference indexes + motion vectors )
+  cu_pred_data( cu );
+
+  // residual data ( coded block flags + transform coefficient levels )
+  cu_residual( cu, partitioner, cuCtx );
+
+  // end of cu
+  end_of_ctu( cu, cuCtx );
+}
+
+void CABACWriter::cu_skip_flag( const CodingUnit& cu )
+{
+  unsigned ctxId = DeriveCtx::CtxSkipFlag( cu );
+
+  if ((cu.slice->isIntra() || cu.isConsIntra()) && cu.cs->slice->getSPS()->getIBCFlag())
+  {
+    if (cu.lwidth() <= IBC_MAX_CU_SIZE && cu.lheight() <= IBC_MAX_CU_SIZE)   // disable IBC mode larger than 64x64
+    {
+      m_binEncoder.encodeBin((cu.skip), Ctx::SkipFlag(ctxId));
+      DTRACE(g_trace_ctx, D_SYNTAX, "cu_skip_flag() ctx=%d skip=%d\n", ctxId, cu.skip ? 1 : 0);
+    }
+    return;
+  }
+  if ( !cu.cs->slice->getSPS()->getIBCFlag() && cu.lwidth() == 4 && cu.lheight() == 4 )
+  {
+    return;
+  }
+  if( !cu.cs->slice->getSPS()->getIBCFlag() && cu.isConsIntra() )
+  {
+    return;
+  }
+  m_binEncoder.encodeBin((cu.skip), Ctx::SkipFlag(ctxId));
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "cu_skip_flag() ctx=%d skip=%d\n", ctxId, cu.skip ? 1 : 0 );
+  if (cu.skip && cu.cs->slice->getSPS()->getIBCFlag())
+  {
+    // disable IBC mode larger than 64x64 and disable IBC when only allowing inter mode
+    if (cu.lwidth() <= IBC_MAX_CU_SIZE && cu.lheight() <= IBC_MAX_CU_SIZE && !cu.isConsInter())
+    {
+      if ( cu.lwidth() == 4 && cu.lheight() == 4 )
+      {
+        return;
+      }
+      unsigned ctxidx = DeriveCtx::CtxIBCFlag(cu);
+      m_binEncoder.encodeBin(CU::isIBC(cu) ? 1 : 0, Ctx::IBCFlag(ctxidx));
+      DTRACE(g_trace_ctx, D_SYNTAX, "ibc() ctx=%d cu.predMode=%d\n", ctxidx, cu.predMode);
+    }
+  }
+}
+
+void CABACWriter::pred_mode( const CodingUnit& cu )
+{
+  if (cu.cs->slice->getSPS()->getIBCFlag() && cu.chType != ChannelType::CHROMA)
+  {
+    if( cu.isConsInter() )
+    {
+      assert( CU::isInter( cu ) );
+      return;
+    }
+
+    if ( cu.cs->slice->isIntra() || ( cu.lwidth() == 4 && cu.lheight() == 4 ) || cu.isConsIntra() )
+    {
+      if (cu.lwidth() <= IBC_MAX_CU_SIZE && cu.lheight() <= IBC_MAX_CU_SIZE)
+      {
+        unsigned ctxidx = DeriveCtx::CtxIBCFlag(cu);
+        m_binEncoder.encodeBin(CU::isIBC(cu), Ctx::IBCFlag(ctxidx));
+      }
+      if (!CU::isIBC(cu) && cu.cs->slice->getSPS()->getPLTMode() && cu.lwidth() <= 64 && cu.lheight() <= 64 && (cu.lumaSize().width * cu.lumaSize().height > 16) )
+      {
+        m_binEncoder.encodeBin(CU::isPLT(cu), Ctx::PLTFlag(0));
+      }
+    }
+    else
+    {
+      if( cu.isConsInter() )
+      {
+        return;
+      }
+      m_binEncoder.encodeBin((CU::isIntra(cu) || CU::isPLT(cu)), Ctx::PredMode(DeriveCtx::CtxPredModeFlag(cu)));
+      if (CU::isIntra(cu) || CU::isPLT(cu))
+      {
+        if (cu.cs->slice->getSPS()->getPLTMode() && cu.lwidth() <= 64 && cu.lheight() <= 64 && (cu.lumaSize().width * cu.lumaSize().height > 16) )
+        {
+          m_binEncoder.encodeBin(CU::isPLT(cu), Ctx::PLTFlag(0));
+        }
+      }
+      else
+      {
+        if (cu.lwidth() <= IBC_MAX_CU_SIZE && cu.lheight() <= IBC_MAX_CU_SIZE)   // disable IBC mode larger than 64x64
+        {
+          unsigned ctxidx = DeriveCtx::CtxIBCFlag(cu);
+          m_binEncoder.encodeBin(CU::isIBC(cu), Ctx::IBCFlag(ctxidx));
+        }
+      }
+    }
+  }
+  else
+  {
+    if( cu.isConsInter() )
+    {
+      assert( CU::isInter( cu ) );
+      return;
+    }
+
+    if ( cu.cs->slice->isIntra() || ( cu.lwidth() == 4 && cu.lheight() == 4 ) || cu.isConsIntra() )
+    {
+      if (cu.cs->slice->getSPS()->getPLTMode() && cu.lwidth() <= 64 && cu.lheight() <= 64 && ( ( (!isLuma(cu.chType)) && (cu.chromaSize().width * cu.chromaSize().height > 16) ) || ((isLuma(cu.chType)) && ((cu.lumaSize().width * cu.lumaSize().height) > 16 ) )  ) && (!cu.isLocalSepTree() || isLuma(cu.chType)  ) )
+      {
+        m_binEncoder.encodeBin((CU::isPLT(cu)), Ctx::PLTFlag(0));
+      }
+      return;
+    }
+    m_binEncoder.encodeBin((CU::isIntra(cu) || CU::isPLT(cu)), Ctx::PredMode(DeriveCtx::CtxPredModeFlag(cu)));
+    if ((CU::isIntra(cu) || CU::isPLT(cu)) && cu.cs->slice->getSPS()->getPLTMode() && cu.lwidth() <= 64 && cu.lheight() <= 64 && ( ( (!isLuma(cu.chType)) && (cu.chromaSize().width * cu.chromaSize().height > 16) ) || ((isLuma(cu.chType)) && ((cu.lumaSize().width * cu.lumaSize().height) > 16 ) )  ) && (!cu.isLocalSepTree() || isLuma(cu.chType)  )  )
+    {
+      m_binEncoder.encodeBin((CU::isPLT(cu)), Ctx::PLTFlag(0));
+    }
+  }
+}
+
+void CABACWriter::bdpcm_mode( const CodingUnit& cu, const ComponentID compID )
+{
+  if (!cu.cs->sps->getBDPCMEnabledFlag())
+  {
+    return;
+  }
+  if (!CU::bdpcmAllowed(cu, compID))
+  {
+    return;
+  }
+
+  const BdpcmMode bdpcmMode = cu.getBdpcmMode(compID);
+
+  unsigned ctxId = isLuma(compID) ? 0 : 2;
+  m_binEncoder.encodeBin(bdpcmMode != BdpcmMode::NONE ? 1 : 0, Ctx::BDPCMMode(ctxId));
+
+  if (bdpcmMode != BdpcmMode::NONE)
+  {
+    m_binEncoder.encodeBin(bdpcmMode != BdpcmMode::HOR ? 1 : 0, Ctx::BDPCMMode(ctxId + 1));
+  }
+  if (isLuma(compID))
+  {
+    DTRACE(g_trace_ctx, D_SYNTAX, "bdpcm_mode(%d) x=%d, y=%d, w=%d, h=%d, bdpcm=%d\n", ChannelType::LUMA,
+           cu.lumaPos().x, cu.lumaPos().y, cu.lwidth(), cu.lheight(), cu.bdpcmMode);
+  }
+  else
+  {
+    DTRACE(g_trace_ctx, D_SYNTAX, "bdpcm_mode(%d) x=%d, y=%d, w=%d, h=%d, bdpcm=%d\n", ChannelType::CHROMA,
+           cu.chromaPos().x, cu.chromaPos().y, cu.chromaSize().width, cu.chromaSize().height, cu.bdpcmModeChroma);
+  }
+}
+
+void CABACWriter::cu_pred_data( const CodingUnit& cu )
+{
+  if( CU::isIntra( cu ) )
+  {
+    if( cu.Y().valid() )
+    {
+      bdpcm_mode( cu, COMPONENT_Y );
+    }
+
+    intra_luma_pred_modes  ( cu );
+    if( ( !cu.Y().valid() || ( !cu.isSepTree() && cu.Y().valid() ) ) && isChromaEnabled(cu.chromaFormat) )
+    {
+      bdpcm_mode(cu, ComponentID(ChannelType::CHROMA));
+    }
+    intra_chroma_pred_modes( cu );
+    return;
+  }
+  if (!cu.Y().valid()) // dual tree chroma CU
+  {
+    return;
+  }
+  for( auto &pu : CU::traversePUs( cu ) )
+  {
+    prediction_unit( pu );
+  }
+
+  imv_mode   ( cu );
+  affine_amvr_mode( cu );
+
+  cu_bcw_flag( cu );
+}
+
+void CABACWriter::cu_bcw_flag(const CodingUnit& cu)
+{
+  if(!CU::isBcwIdxCoded(cu))
+  {
+    return;
+  }
+
+  CHECK(!(BCW_NUM > 1 && (BCW_NUM == 2 || (BCW_NUM & 0x01) == 1)), " !( BCW_NUM > 1 && ( BCW_NUM == 2 || ( BCW_NUM & 0x01 ) == 1 ) ) ");
+  const uint8_t bcwCodingIdx = (uint8_t)g_BcwCodingOrder[CU::getValidBcwIdx(cu)];
+
+  const int32_t numBcw = (cu.slice->getCheckLDC()) ? 5 : 3;
+  m_binEncoder.encodeBin((bcwCodingIdx == 0 ? 0 : 1), Ctx::bcwIdx(0));
+  if(numBcw > 2 && bcwCodingIdx != 0)
+  {
+    const uint32_t prefixNumBits = numBcw - 2;
+    const uint32_t step = 1;
+
+    uint8_t idx = 1;
+    for(int ui = 0; ui < prefixNumBits; ++ui)
+    {
+      if (bcwCodingIdx == idx)
+      {
+        m_binEncoder.encodeBinEP(0);
+        break;
+      }
+      else
+      {
+        m_binEncoder.encodeBinEP(1);
+        idx += step;
+      }
+    }
+  }
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "cu_bcw_flag() bcw_idx=%d\n", cu.bcwIdx ? 1 : 0);
+}
+
+void CABACWriter::xWriteTruncBinCode(const uint32_t symbol, const uint32_t numSymbols)
+{
+  CHECKD(symbol >= numSymbols, "symbol must be less than numSymbols");
+
+  const int thresh = floorLog2(numSymbols);
+
+  const int val = 1 << thresh;
+
+  const int b = numSymbols - val;
+
+  if (symbol < val - b)
+  {
+    m_binEncoder.encodeBinsEP(symbol, thresh);
+  }
+  else
+  {
+    m_binEncoder.encodeBinsEP(symbol + val - b, thresh + 1);
+  }
+}
+
+void CABACWriter::extend_ref_line(const PredictionUnit& pu)
+{
+
+  const CodingUnit& cu = *pu.cu;
+  if (!cu.Y().valid() || !CU::isIntra(cu) || !isLuma(cu.chType) || cu.bdpcmMode != BdpcmMode::NONE)
+  {
+    return;
+  }
+  if( !cu.cs->sps->getUseMRL() )
+  {
+    return;
+  }
+  bool isFirstLineOfCtu = (((cu.block(COMPONENT_Y).y)&((cu.cs->sps)->getMaxCUWidth() - 1)) == 0);
+  if (isFirstLineOfCtu)
+  {
+    return;
+  }
+  int multiRefIdx = pu.multiRefIdx;
+  if (MRL_NUM_REF_LINES > 1)
+  {
+    m_binEncoder.encodeBin(multiRefIdx != MULTI_REF_LINE_IDX[0], Ctx::MultiRefLineIdx(0));
+    if (MRL_NUM_REF_LINES > 2 && multiRefIdx != MULTI_REF_LINE_IDX[0])
+    {
+      m_binEncoder.encodeBin(multiRefIdx != MULTI_REF_LINE_IDX[1], Ctx::MultiRefLineIdx(1));
+    }
+  }
+}
+
+void CABACWriter::extend_ref_line(const CodingUnit& cu)
+{
+  if (!cu.Y().valid() || !CU::isIntra(cu) || !isLuma(cu.chType) || cu.bdpcmMode != BdpcmMode::NONE)
+  {
+    return;
+  }
+  if( !cu.cs->sps->getUseMRL() )
+  {
+    return;
+  }
+
+  const int numBlocks = CU::getNumPUs(cu);
+  const PredictionUnit* pu = cu.firstPU;
+
+  for (int k = 0; k < numBlocks; k++)
+  {
+    bool isFirstLineOfCtu = (((cu.block(COMPONENT_Y).y)&((cu.cs->sps)->getMaxCUWidth() - 1)) == 0);
+    if (isFirstLineOfCtu)
+    {
+      return;
+    }
+    int multiRefIdx = pu->multiRefIdx;
+    if (MRL_NUM_REF_LINES > 1)
+    {
+      m_binEncoder.encodeBin(multiRefIdx != MULTI_REF_LINE_IDX[0], Ctx::MultiRefLineIdx(0));
+      if (MRL_NUM_REF_LINES > 2 && multiRefIdx != MULTI_REF_LINE_IDX[0])
+      {
+        m_binEncoder.encodeBin(multiRefIdx != MULTI_REF_LINE_IDX[1], Ctx::MultiRefLineIdx(1));
+      }
+    }
+    pu = pu->next;
+  }
+}
+
+void CABACWriter::intra_luma_pred_modes( const CodingUnit& cu )
+{
+  if( !cu.Y().valid() )
+  {
+    return;
+  }
+
+  if (cu.bdpcmMode != BdpcmMode::NONE)
+  {
+    cu.firstPU->intraDir[ChannelType::LUMA] = cu.bdpcmMode == BdpcmMode::VER ? VER_IDX : HOR_IDX;
+    return;
+  }
+
+  mip_flag(cu);
+  if (cu.mipFlag)
+  {
+    mip_pred_modes(cu);
+    return;
+  }
+  extend_ref_line( cu );
+
+  isp_mode( cu );
+
+  const int numMPMs   = NUM_MOST_PROBABLE_MODES;
+  const int numBlocks = CU::getNumPUs( cu );
+  unsigned  mpm_preds   [4][numMPMs];
+  unsigned  mpm_idxs    [4];
+  unsigned  ipred_modes [4];
+
+  const PredictionUnit* pu = cu.firstPU;
+
+  // prev_intra_luma_pred_flag
+  for( int k = 0; k < numBlocks; k++ )
+  {
+    unsigned*  mpm_pred   = mpm_preds[k];
+    unsigned&  mpm_idx    = mpm_idxs[k];
+    unsigned&  ipred_mode = ipred_modes[k];
+
+    PU::getIntraMPMs( *pu, mpm_pred );
+
+    ipred_mode = pu->intraDir[ChannelType::LUMA];
+    mpm_idx    = numMPMs;
+    for( unsigned idx = 0; idx < numMPMs; idx++ )
+    {
+      if( ipred_mode == mpm_pred[idx] )
+      {
+        mpm_idx = idx;
+        break;
+      }
+    }
+    if ( pu->multiRefIdx )
+    {
+      CHECK(mpm_idx >= numMPMs, "use of non-MPM");
+    }
+    else
+    {
+      m_binEncoder.encodeBin(mpm_idx < numMPMs, Ctx::IntraLumaMpmFlag());
+    }
+
+    pu = pu->next;
+  }
+
+  pu = cu.firstPU;
+
+  // mpm_idx / rem_intra_luma_pred_mode
+  for( int k = 0; k < numBlocks; k++ )
+  {
+    const unsigned& mpm_idx = mpm_idxs[k];
+    if( mpm_idx < numMPMs )
+    {
+      unsigned ctx = (pu->cu->ispMode == ISPType::NONE ? 1 : 0);
+      if (pu->multiRefIdx == 0)
+      {
+        m_binEncoder.encodeBin(mpm_idx > 0, Ctx::IntraLumaPlanarFlag(ctx));
+      }
+      if (mpm_idx)
+      {
+        m_binEncoder.encodeBinEP(mpm_idx > 1);
+      }
+      if (mpm_idx > 1)
+      {
+        m_binEncoder.encodeBinEP(mpm_idx > 2);
+      }
+      if (mpm_idx > 2)
+      {
+        m_binEncoder.encodeBinEP(mpm_idx > 3);
+      }
+      if (mpm_idx > 3)
+      {
+        m_binEncoder.encodeBinEP(mpm_idx > 4);
+      }
+    }
+    else
+    {
+      unsigned* mpm_pred   = mpm_preds[k];
+      unsigned  ipred_mode = ipred_modes[k];
+
+      // sorting of MPMs
+      std::sort( mpm_pred, mpm_pred + numMPMs );
+
+      for (int idx = numMPMs - 1; idx >= 0; idx--)
+      {
+        if (ipred_mode > mpm_pred[idx])
+        {
+          ipred_mode--;
+        }
+      }
+      CHECK(ipred_mode >= 64, "Incorrect mode");
+      xWriteTruncBinCode(ipred_mode,
+                         NUM_LUMA_MODE - NUM_MOST_PROBABLE_MODES);   // Remaining mode is truncated binary coded
+    }
+
+    DTRACE(g_trace_ctx, D_SYNTAX, "intra_luma_pred_modes() idx=%d pos=(%d,%d) mode=%d\n", k, pu->lumaPos().x,
+           pu->lumaPos().y, pu->intraDir[ChannelType::LUMA]);
+    pu = pu->next;
+  }
+}
+
+
+void CABACWriter::intra_luma_pred_mode( const PredictionUnit& pu )
+{
+  if (pu.cu->bdpcmMode != BdpcmMode::NONE)
+  {
+    return;
+  }
+  mip_flag(*pu.cu);
+  if (pu.cu->mipFlag)
+  {
+    mip_pred_mode(pu);
+    return;
+  }
+  extend_ref_line( pu );
+  isp_mode( *pu.cu );
+
+  // prev_intra_luma_pred_flag
+  const int numMPMs  = NUM_MOST_PROBABLE_MODES;
+  unsigned  mpm_pred[numMPMs];
+
+  PU::getIntraMPMs( pu, mpm_pred );
+
+  unsigned ipred_mode = pu.intraDir[ChannelType::LUMA];
+  unsigned mpm_idx = numMPMs;
+
+  for( int idx = 0; idx < numMPMs; idx++ )
+  {
+    if( ipred_mode == mpm_pred[idx] )
+    {
+      mpm_idx = idx;
+      break;
+    }
+  }
+  if ( pu.multiRefIdx )
+  {
+    CHECK(mpm_idx >= numMPMs, "use of non-MPM");
+  }
+  else
+  {
+    m_binEncoder.encodeBin(mpm_idx < numMPMs, Ctx::IntraLumaMpmFlag());
+  }
+
+  // mpm_idx / rem_intra_luma_pred_mode
+  if( mpm_idx < numMPMs )
+  {
+    unsigned ctx = (pu.cu->ispMode == ISPType::NONE ? 1 : 0);
+    if (pu.multiRefIdx == 0)
+    {
+      m_binEncoder.encodeBin(mpm_idx > 0, Ctx::IntraLumaPlanarFlag(ctx));
+    }
+    if (mpm_idx)
+    {
+      m_binEncoder.encodeBinEP(mpm_idx > 1);
+    }
+    if (mpm_idx > 1)
+    {
+      m_binEncoder.encodeBinEP(mpm_idx > 2);
+    }
+    if (mpm_idx > 2)
+    {
+      m_binEncoder.encodeBinEP(mpm_idx > 3);
+    }
+    if (mpm_idx > 3)
+    {
+      m_binEncoder.encodeBinEP(mpm_idx > 4);
+    }
+  }
+  else
+  {
+    std::sort( mpm_pred, mpm_pred + numMPMs );
+    for (int idx = numMPMs - 1; idx >= 0; idx--)
+    {
+      if (ipred_mode > mpm_pred[idx])
+      {
+        ipred_mode--;
+      }
+    }
+    xWriteTruncBinCode(ipred_mode,
+                       NUM_LUMA_MODE - NUM_MOST_PROBABLE_MODES);   // Remaining mode is truncated binary coded
+  }
+}
+
+
+void CABACWriter::intra_chroma_pred_modes( const CodingUnit& cu )
+{
+  if (!isChromaEnabled(cu.chromaFormat) || (cu.isSepTree() && isLuma(cu.chType)))
+  {
+    return;
+  }
+
+  if (cu.bdpcmModeChroma != BdpcmMode::NONE)
+  {
+    cu.firstPU->intraDir[ChannelType::CHROMA] = cu.bdpcmModeChroma == BdpcmMode::VER ? VER_IDX : HOR_IDX;
+    return;
+  }
+  const PredictionUnit* pu = cu.firstPU;
+
+  intra_chroma_pred_mode( *pu );
+}
+void CABACWriter::intra_chroma_lmc_mode(const PredictionUnit& pu)
+{
+  const unsigned intraDir = pu.intraDir[ChannelType::CHROMA];
+  int lmModeList[10];
+  PU::getLMSymbolList(pu, lmModeList);
+  int symbol = -1;
+  for (int k = 0; k < LM_SYMBOL_NUM; k++)
+  {
+    if (lmModeList[k] == intraDir)
+    {
+      symbol = k;
+      break;
+    }
+  }
+  CHECK(symbol < 0, "invalid symbol found");
+
+  m_binEncoder.encodeBin(symbol == 0 ? 0 : 1, Ctx::CclmModeIdx(0));
+
+  if (symbol > 0)
+  {
+    CHECK(symbol > 2, "invalid symbol for MMLM");
+    unsigned int symbol_minus_1 = symbol - 1;
+    m_binEncoder.encodeBinEP(symbol_minus_1);
+  }
+}
+
+void CABACWriter::intra_chroma_pred_mode(const PredictionUnit& pu)
+{
+  const unsigned intraDir = pu.intraDir[ChannelType::CHROMA];
+  if (pu.cu->colorTransform)
+  {
+    CHECK(pu.intraDir[ChannelType::CHROMA] != DM_CHROMA_IDX, "chroma should use DM for adaptive color transform");
+    return;
+  }
+  if (pu.cs->sps->getUseLMChroma() && pu.cu->checkCCLMAllowed())
+  {
+    m_binEncoder.encodeBin(PU::isLMCMode(intraDir) ? 1 : 0, Ctx::CclmModeFlag(0));
+    if (PU::isLMCMode(intraDir))
+    {
+      intra_chroma_lmc_mode(pu);
+      return;
+    }
+  }
+
+  const bool     isDerivedMode = intraDir == DM_CHROMA_IDX;
+  m_binEncoder.encodeBin(isDerivedMode ? 0 : 1, Ctx::IntraChromaPredMode(0));
+  if (isDerivedMode)
+  {
+    return;
+  }
+
+  // chroma candidate index
+  unsigned chromaCandModes[NUM_CHROMA_MODE];
+  PU::getIntraChromaCandModes(pu, chromaCandModes);
+
+  int candId = 0;
+  for (; candId < NUM_CHROMA_MODE; candId++)
+  {
+    if (intraDir == chromaCandModes[candId])
+    {
+      break;
+    }
+  }
+
+  CHECK(candId >= NUM_CHROMA_MODE, "Chroma prediction mode index out of bounds");
+  CHECK(chromaCandModes[candId] == DM_CHROMA_IDX, "The intra dir cannot be DM_CHROMA for this path");
+  {
+    m_binEncoder.encodeBinsEP(candId, 2);
+  }
+}
+
+void CABACWriter::cu_residual( const CodingUnit& cu, Partitioner& partitioner, CUCtx& cuCtx )
+{
+  if (!CU::isIntra(cu))
+  {
+    PredictionUnit& pu = *cu.firstPU;
+    if( !pu.mergeFlag )
+    {
+      rqt_root_cbf( cu );
+    }
+    if( cu.rootCbf )
+    {
+      sbt_mode( cu );
+    }
+
+    if( !cu.rootCbf )
+    {
+      CHECK(cu.colorTransform, "ACT should not be enabled for root_cbf = 0");
+      return;
+    }
+  }
+
+  if (CU::isInter(cu) || CU::isIBC(cu))
+  {
+    adaptive_color_transform(cu);
+  }
+
+  cuCtx.violatesLfnstConstrained.fill(false);
+  cuCtx.lfnstLastScanPos                              = false;
+  cuCtx.violatesMtsCoeffConstraint                    = false;
+  cuCtx.mtsLastScanPos                                = false;
+
+  if (cu.ispMode != ISPType::NONE && isLuma(partitioner.chType))
+  {
+    TUIntraSubPartitioner subTuPartitioner( partitioner );
+    transform_tree( *cu.cs, subTuPartitioner, cuCtx,             CU::getISPType( cu, getFirstComponentOfChannel( partitioner.chType)  ), 0 );
+  }
+  else
+  {
+    transform_tree( *cu.cs, partitioner, cuCtx );
+  }
+
+  residual_lfnst_mode( cu, cuCtx );
+  mts_idx            ( cu, &cuCtx );
+}
+
+void CABACWriter::rqt_root_cbf( const CodingUnit& cu )
+{
+  m_binEncoder.encodeBin(cu.rootCbf, Ctx::QtRootCbf());
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "rqt_root_cbf() ctx=0 root_cbf=%d pos=(%d,%d)\n", cu.rootCbf ? 1 : 0, cu.lumaPos().x, cu.lumaPos().y );
+}
+
+void CABACWriter::adaptive_color_transform(const CodingUnit& cu)
+{
+  if (!cu.slice->getSPS()->getUseColorTrans())
+  {
+    return;
+  }
+
+  if (cu.isSepTree())
+  {
+    CHECK(cu.colorTransform, "adaptive color transform should be disabled when dualtree and localtree are enabled");
+    return;
+  }
+
+  if (CU::isInter(cu) || CU::isIBC(cu) || CU::isIntra(cu))
+  {
+    m_binEncoder.encodeBin(cu.colorTransform, Ctx::ACTFlag());
+  }
+}
+
+void CABACWriter::sbt_mode( const CodingUnit& cu )
+{
+  uint8_t sbtAllowed = cu.checkAllowedSbt();
+  if( !sbtAllowed )
+  {
+    return;
+  }
+
+  SizeType cuWidth = cu.lwidth();
+  SizeType cuHeight = cu.lheight();
+  uint8_t sbtIdx = cu.getSbtIdx();
+  uint8_t sbtPos = cu.getSbtPos();
+
+  //bin - flag
+  bool sbtFlag = cu.sbtInfo != 0;
+  uint8_t ctxIdx = ( cuWidth * cuHeight <= 256 ) ? 1 : 0;
+  m_binEncoder.encodeBin(sbtFlag, Ctx::SbtFlag(ctxIdx));
+  if( !sbtFlag )
+  {
+    return;
+  }
+
+  bool sbtQuadFlag = sbtIdx == SBT_HOR_QUAD || sbtIdx == SBT_VER_QUAD;
+  bool sbtHorFlag = sbtIdx == SBT_HOR_HALF || sbtIdx == SBT_HOR_QUAD;
+  bool sbtPosFlag = sbtPos == SBT_POS1;
+
+  uint8_t sbtVerHalfAllow = CU::targetSbtAllowed( SBT_VER_HALF, sbtAllowed );
+  uint8_t sbtHorHalfAllow = CU::targetSbtAllowed( SBT_HOR_HALF, sbtAllowed );
+  uint8_t sbtVerQuadAllow = CU::targetSbtAllowed( SBT_VER_QUAD, sbtAllowed );
+  uint8_t sbtHorQuadAllow = CU::targetSbtAllowed( SBT_HOR_QUAD, sbtAllowed );
+  //bin - type
+  if( ( sbtHorHalfAllow || sbtVerHalfAllow ) && ( sbtHorQuadAllow || sbtVerQuadAllow ) )
+  {
+    m_binEncoder.encodeBin(sbtQuadFlag, Ctx::SbtQuadFlag(0));
+  }
+  else
+  {
+    assert( sbtQuadFlag == 0 );
+  }
+
+  //bin - dir
+  if( ( sbtQuadFlag && sbtVerQuadAllow && sbtHorQuadAllow ) || ( !sbtQuadFlag && sbtVerHalfAllow && sbtHorHalfAllow ) ) //both direction allowed
+  {
+    uint8_t ctxIdx = ( cuWidth == cuHeight ) ? 0 : ( cuWidth < cuHeight ? 1 : 2 );
+    m_binEncoder.encodeBin(sbtHorFlag, Ctx::SbtHorFlag(ctxIdx));
+  }
+  else
+  {
+    assert( sbtHorFlag == ( ( sbtQuadFlag && sbtHorQuadAllow ) || ( !sbtQuadFlag && sbtHorHalfAllow ) ) );
+  }
+
+  //bin - pos
+  m_binEncoder.encodeBin(sbtPosFlag, Ctx::SbtPosFlag(0));
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "sbt_mode() pos=(%d,%d) sbtInfo=%d\n", cu.lx(), cu.ly(), (int)cu.sbtInfo );
+}
+
+void CABACWriter::end_of_ctu( const CodingUnit& cu, CUCtx& cuCtx )
+{
+  const bool    isLastSubCUOfCtu  = CU::isLastSubCUOfCtu( cu );
+
+  if (isLastSubCUOfCtu && (!cu.isSepTree() || !isChromaEnabled(cu.chromaFormat) || isChroma(cu.chType)))
+  {
+    cuCtx.isDQPCoded = ( cu.cs->pps->getUseDQP() && !cuCtx.isDQPCoded );
+  }
+}
+
+void CABACWriter::cu_palette_info(const CodingUnit& cu, ComponentID compBegin, uint32_t numComp, CUCtx& cuCtx)
+{
+  const SPS&       sps = *(cu.cs->sps);
+  TransformUnit&   tu = *cu.firstTU;
+  uint32_t indexMaxSize = cu.useEscape[compBegin] ? (cu.curPLTSize[compBegin] + 1) : cu.curPLTSize[compBegin];
+
+  int maxPltSize = cu.isSepTree() ? MAXPLTSIZE_DUALTREE : MAXPLTSIZE;
+
+  if (cu.lastPLTSize[compBegin])
+  {
+    xEncodePLTPredIndicator(cu, maxPltSize, compBegin);
+  }
+
+  uint32_t reusedPLTnum = 0;
+  for (int idx = 0; idx < cu.lastPLTSize[compBegin]; idx++)
+  {
+    if (cu.reuseflag[compBegin][idx])
+    {
+      reusedPLTnum++;
+    }
+  }
+  if (reusedPLTnum < maxPltSize)
+  {
+    exp_golomb_eqprob(cu.curPLTSize[compBegin] - reusedPLTnum, 0);
+  }
+
+  for (int comp = compBegin; comp < (compBegin + numComp); comp++)
+  {
+    for (int idx = cu.reusePLTSize[compBegin]; idx < cu.curPLTSize[compBegin]; idx++)
+    {
+      ComponentID compID = (ComponentID)comp;
+      const int  channelBitDepth = sps.getBitDepth(toChannelType(compID));
+      m_binEncoder.encodeBinsEP(cu.curPLT[comp][idx], channelBitDepth);
+    }
+  }
+  uint32_t signalEscape = (cu.useEscape[compBegin]) ? 1 : 0;
+  if (cu.curPLTSize[compBegin] > 0)
+  {
+    m_binEncoder.encodeBinEP(signalEscape);
+  }
+  //encode index map
+  uint32_t   height = cu.block(compBegin).height;
+  uint32_t   width = cu.block(compBegin).width;
+
+  m_scanOrder = g_scanOrder[SCAN_UNGROUPED][(cu.useRotation[compBegin]) ? CoeffScanType::TRAV_VER : CoeffScanType::TRAV_HOR][gp_sizeIdxInfo->idxFrom(width)][gp_sizeIdxInfo->idxFrom(height)];
+  uint32_t total = height * width;
+  if (indexMaxSize > 1)
+  {
+    codeScanRotationModeFlag(cu, compBegin);
+  }
+  else
+  {
+    assert(!cu.useRotation[compBegin]);
+  }
+
+  if (cu.useEscape[compBegin] && cu.cs->pps->getUseDQP() && !cuCtx.isDQPCoded)
+  {
+    if (!cu.isSepTree() || isLuma(tu.chType))
+    {
+      cu_qp_delta(cu, cuCtx.qp, cu.qp);
+      cuCtx.qp = cu.qp;
+      cuCtx.isDQPCoded = true;
+    }
+  }
+  if (cu.useEscape[compBegin] && cu.cs->slice->getUseChromaQpAdj() && !cuCtx.isChromaQpAdjCoded)
+  {
+    if (!CS::isDualITree(*tu.cs) || isChroma(tu.chType))
+    {
+      cu_chroma_qp_offset(cu);
+      cuCtx.isChromaQpAdjCoded = true;
+    }
+  }
+
+  uint32_t prevRunPos = 0;
+  unsigned prevRunType = 0;
+  for (int subSetId = 0; subSetId <= (total - 1) >> LOG2_PALETTE_CG_SIZE; subSetId++)
+  {
+    cuPaletteSubblockInfo(cu, compBegin, numComp, subSetId, prevRunPos, prevRunType);
+  }
+  CHECK(cu.curPLTSize[compBegin] > maxPltSize, " Current palette size is larger than maximum palette size");
+}
+
+void CABACWriter::cuPaletteSubblockInfo(const CodingUnit& cu, ComponentID compBegin, uint32_t numComp, int subSetId, uint32_t& prevRunPos, unsigned& prevRunType)
+{
+  const SPS&      sps = *(cu.cs->sps);
+  TransformUnit&  tu  = *cu.firstTU;
+  PLTtypeBuf      runType      = tu.getrunType(toChannelType(compBegin));
+  PelBuf          curPLTIdx = tu.getcurPLTIdx(compBegin);
+  uint32_t        indexMaxSize = cu.useEscape[compBegin] ? (cu.curPLTSize[compBegin] + 1) : cu.curPLTSize[compBegin];
+  uint32_t        totalPel = cu.block(compBegin).height*cu.block(compBegin).width;
+
+  int minSubPos = subSetId << LOG2_PALETTE_CG_SIZE;
+  int maxSubPos = minSubPos + (1 << LOG2_PALETTE_CG_SIZE);
+  maxSubPos = (maxSubPos > totalPel) ? totalPel : maxSubPos; // if last position is out of the current CU size
+
+  unsigned runCopyFlag[(1 << LOG2_PALETTE_CG_SIZE)];
+  for (int i = 0; i < (1 << LOG2_PALETTE_CG_SIZE); i++)
+  {
+    runCopyFlag[i] = MAX_INT;
+  }
+
+  if (minSubPos == 0)
+  {
+    runCopyFlag[0] = 0;
+  }
+
+  // PLT runCopy flag and runType - context coded
+  int curPos = minSubPos;
+  for (; curPos < maxSubPos && indexMaxSize > 1; curPos++)
+  {
+    uint32_t posy = m_scanOrder[curPos].y;
+    uint32_t posx = m_scanOrder[curPos].x;
+    uint32_t posyprev = (curPos == 0) ? 0 : m_scanOrder[curPos - 1].y;
+    uint32_t posxprev = (curPos == 0) ? 0 : m_scanOrder[curPos - 1].x;
+    // encode runCopyFlag
+    bool identityFlag = !((runType.at(posx, posy) != runType.at(posxprev, posyprev))
+      || ((runType.at(posx, posy) == PLT_RUN_INDEX) && (curPLTIdx.at(posx, posy) != curPLTIdx.at(posxprev, posyprev))));
+
+    const CtxSet&   ctxSet = (prevRunType == PLT_RUN_INDEX)? Ctx::IdxRunModel: Ctx::CopyRunModel;
+    if ( curPos > 0 )
+    {
+      int dist = curPos - prevRunPos - 1;
+      const unsigned  ctxId = DeriveCtx::CtxPltCopyFlag(prevRunType, dist);
+      runCopyFlag[curPos - minSubPos] = identityFlag;
+      m_binEncoder.encodeBin(identityFlag, ctxSet(ctxId));
+      DTRACE(g_trace_ctx, D_SYNTAX, "plt_copy_flag() bin=%d ctx=%d\n", identityFlag, ctxId);
+    }
+    // encode run_type
+    if ( !identityFlag || curPos == 0 )
+    {
+      prevRunPos  = curPos;
+      prevRunType = runType.at(posx, posy);
+      if (((posy == 0) && !cu.useRotation[compBegin]) || ((posx == 0) && cu.useRotation[compBegin]))
+      {
+        assert(runType.at(posx, posy) == PLT_RUN_INDEX);
+      }
+      else if (curPos != 0 && runType.at(posxprev, posyprev) == PLT_RUN_COPY)
+      {
+        assert(runType.at(posx, posy) == PLT_RUN_INDEX);
+      }
+      else
+      {
+        m_binEncoder.encodeBin(runType.at(posx, posy), Ctx::RunTypeFlag());
+      }
+      DTRACE(g_trace_ctx, D_SYNTAX, "plt_type_flag() bin=%d sp=%d\n", runType.at(posx, posy), curPos);
+    }
+  }
+
+  // PLT index values - bypass coded
+  if (indexMaxSize > 1)
+  {
+    curPos = minSubPos;
+    for (; curPos < maxSubPos; curPos++)
+    {
+      uint32_t posy = m_scanOrder[curPos].y;
+      uint32_t posx = m_scanOrder[curPos].x;
+      if ( runCopyFlag[curPos - minSubPos] == 0 && runType.at(posx, posy) == PLT_RUN_INDEX)
+      {
+        writePLTIndex(cu, curPos, curPLTIdx, runType, indexMaxSize, compBegin);
+        DTRACE(g_trace_ctx, D_SYNTAX, "plt_idx_idc() value=%d sp=%d\n", curPLTIdx.at(posx, posy), curPos);
+      }
+    }
+  }
+
+  // Quantized escape colors - bypass coded
+  uint32_t scaleX = getComponentScaleX(COMPONENT_Cb, sps.getChromaFormatIdc());
+  uint32_t scaleY = getComponentScaleY(COMPONENT_Cb, sps.getChromaFormatIdc());
+  for (int comp = compBegin; comp < (compBegin + numComp); comp++)
+  {
+    ComponentID compID = (ComponentID)comp;
+    for (curPos = minSubPos; curPos < maxSubPos; curPos++)
+    {
+      uint32_t posy = m_scanOrder[curPos].y;
+      uint32_t posx = m_scanOrder[curPos].x;
+      if (curPLTIdx.at(posx, posy) == cu.curPLTSize[compBegin])
+      {
+        PLTescapeBuf escapeValue = tu.getescapeValue((ComponentID) comp);
+        if (compID == COMPONENT_Y || compBegin != COMPONENT_Y)
+        {
+          exp_golomb_eqprob((unsigned) escapeValue.at(posx, posy), 5);
+          DTRACE(g_trace_ctx, D_SYNTAX, "plt_escape_val() value=%d etype=%d sp=%d\n", escapeValue.at(posx, posy), comp,
+                 curPos);
+        }
+        if (compBegin == COMPONENT_Y && compID != COMPONENT_Y && posy % (1 << scaleY) == 0 && posx % (1 << scaleX) == 0)
+        {
+          uint32_t posxC = posx >> scaleX;
+          uint32_t posyC = posy >> scaleY;
+          exp_golomb_eqprob((unsigned) escapeValue.at(posxC, posyC), 5);
+          DTRACE(g_trace_ctx, D_SYNTAX, "plt_escape_val() value=%d etype=%d sp=%d\n", escapeValue.at(posx, posy), comp,
+                 curPos);
+        }
+      }
+    }
+  }
+}
+
+void CABACWriter::codeScanRotationModeFlag(const CodingUnit& cu, ComponentID compBegin)
+{
+  m_binEncoder.encodeBin((cu.useRotation[compBegin]), Ctx::RotationFlag());
+}
+
+void CABACWriter::xEncodePLTPredIndicator(const CodingUnit& cu, uint32_t maxPLTSize, ComponentID compBegin)
+{
+  int lastPredIdx = -1;
+  uint32_t run = 0;
+  uint32_t numPLTPredicted = 0;
+  for (uint32_t idx = 0; idx < cu.lastPLTSize[compBegin]; idx++)
+  {
+    if (cu.reuseflag[compBegin][idx])
+    {
+      numPLTPredicted++;
+      lastPredIdx = idx;
+    }
+  }
+
+  int idx = 0;
+  while (idx <= lastPredIdx)
+  {
+    if (cu.reuseflag[compBegin][idx])
+    {
+      exp_golomb_eqprob(run ? run + 1 : run, 0);
+      run = 0;
+    }
+    else
+    {
+      run++;
+    }
+    idx++;
+  }
+  if ((numPLTPredicted < maxPLTSize && lastPredIdx + 1 < cu.lastPLTSize[compBegin]) || !numPLTPredicted)
+  {
+    exp_golomb_eqprob(1, 0);
+  }
+}
+
+Pel CABACWriter::writePLTIndex(const CodingUnit& cu, uint32_t idx, PelBuf& paletteIdx, PLTtypeBuf& paletteRunType, int maxSymbol, ComponentID compBegin)
+{
+  uint32_t posy = m_scanOrder[idx].y;
+  uint32_t posx = m_scanOrder[idx].x;
+  Pel curLevel = (paletteIdx.at(posx, posy) == cu.curPLTSize[compBegin]) ? (maxSymbol - 1) : paletteIdx.at(posx, posy);
+  if (idx) // R0348: remove index redundancy
+  {
+    uint32_t prevposy = m_scanOrder[idx - 1].y;
+    uint32_t prevposx = m_scanOrder[idx - 1].x;
+    if (paletteRunType.at(prevposx, prevposy) == PLT_RUN_INDEX)
+    {
+      Pel leftLevel = paletteIdx.at(prevposx, prevposy); // left index
+      if (leftLevel == cu.curPLTSize[compBegin]) // escape mode
+      {
+        leftLevel = maxSymbol - 1;
+      }
+      assert(leftLevel != curLevel);
+      if (curLevel > leftLevel)
+      {
+        curLevel--;
+      }
+    }
+    else
+    {
+      Pel aboveLevel;
+      if (cu.useRotation[compBegin])
+      {
+        assert(prevposx > 0);
+        aboveLevel = paletteIdx.at(posx - 1, posy);
+        if (paletteIdx.at(posx - 1, posy) == cu.curPLTSize[compBegin]) // escape mode
+        {
+          aboveLevel = maxSymbol - 1;
+        }
+      }
+      else
+      {
+        assert(prevposy > 0);
+        aboveLevel = paletteIdx.at(posx, posy - 1);
+        if (paletteIdx.at(posx, posy - 1) == cu.curPLTSize[compBegin]) // escape mode
+        {
+          aboveLevel = maxSymbol - 1;
+        }
+      }
+      assert(curLevel != aboveLevel);
+      if (curLevel > aboveLevel)
+      {
+        curLevel--;
+      }
+    }
+    maxSymbol--;
+  }
+  assert(maxSymbol > 0);
+  assert(curLevel >= 0);
+  assert(maxSymbol > curLevel);
+  if (maxSymbol > 1)
+  {
+    xWriteTruncBinCode(curLevel, maxSymbol);
+  }
+  return curLevel;
+}
+
+
+//================================================================================
+//  clause 7.3.8.6
+//--------------------------------------------------------------------------------
+//    void  prediction_unit ( pu );
+//    void  merge_flag      ( pu );
+//    void  merge_idx       ( pu );
+//    void  inter_pred_idc  ( pu );
+//    void  ref_idx         ( pu, refList );
+//    void  mvp_flag        ( pu, refList );
+//================================================================================
+
+void CABACWriter::prediction_unit( const PredictionUnit& pu )
+{
+  CHECK( pu.cu->treeType == TREE_C, "cannot be chroma CU" );
+
+  if( pu.cu->skip )
+  {
+    CHECK( !pu.mergeFlag, "merge_flag must be true for skipped CUs" );
+  }
+  else
+  {
+    merge_flag( pu );
+  }
+  if( pu.mergeFlag )
+  {
+    merge_data(pu);
+  }
+  else if (CU::isIBC(*pu.cu))
+  {
+    ref_idx(pu, REF_PIC_LIST_0);
+    mvd_coding(pu, pu.mvd[REF_PIC_LIST_0], pu.cu->imv);
+    if (pu.cs->sps->getMaxNumIBCMergeCand() == 1)
+    {
+      CHECK( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
+    }
+    else
+    {
+      mvp_flag(pu, REF_PIC_LIST_0);
+    }
+  }
+  else
+  {
+    inter_pred_idc( pu );
+    affine_flag   ( *pu.cu );
+    smvd_mode( pu );
+    if( pu.interDir != 2 /* PRED_L1 */ )
+    {
+      ref_idx     ( pu, REF_PIC_LIST_0 );
+      if ( pu.cu->affine )
+      {
+        for (int i = 0; i < pu.cu->getNumAffineMvs(); i++)
+        {
+          mvd_coding(pu, pu.mvdAffi[REF_PIC_LIST_0][i], pu.cu->imv);
+        }
+      }
+      else
+      {
+        mvd_coding(pu, pu.mvd[REF_PIC_LIST_0], pu.cu->imv);
+      }
+      mvp_flag    ( pu, REF_PIC_LIST_0 );
+    }
+    if( pu.interDir != 1 /* PRED_L0 */ )
+    {
+      if ( pu.cu->smvdMode != 1 )
+      {
+        ref_idx(pu, REF_PIC_LIST_1);
+        if (!pu.cs->picHeader->getMvdL1ZeroFlag() || pu.interDir != 3 /* PRED_BI */)
+        {
+          if (pu.cu->affine)
+          {
+            for (int i = 0; i < pu.cu->getNumAffineMvs(); i++)
+            {
+              mvd_coding(pu, pu.mvdAffi[REF_PIC_LIST_1][i], pu.cu->imv);
+            }
+          }
+          else
+          {
+            mvd_coding(pu, pu.mvd[REF_PIC_LIST_1], pu.cu->imv);
+          }
+        }
+      }
+      mvp_flag    ( pu, REF_PIC_LIST_1 );
+    }
+  }
+}
+
+void CABACWriter::smvd_mode( const PredictionUnit& pu )
+{
+  if ( pu.interDir != 3 || pu.cu->affine )
+  {
+    return;
+  }
+
+  if ( pu.cs->slice->getBiDirPred() == false )
+  {
+    return;
+  }
+
+  m_binEncoder.encodeBin(pu.cu->smvdMode ? 1 : 0, Ctx::SmvdFlag());
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "symmvd_flag() symmvd=%d pos=(%d,%d) size=%dx%d\n", pu.cu->smvdMode ? 1 : 0, pu.lumaPos().x, pu.lumaPos().y, pu.lumaSize().width, pu.lumaSize().height );
+}
+
+void CABACWriter::subblock_merge_flag( const CodingUnit& cu )
+{
+
+  if ( !cu.cs->slice->isIntra() && (cu.slice->getPicHeader()->getMaxNumAffineMergeCand() > 0) && cu.lumaSize().width >= 8 && cu.lumaSize().height >= 8 )
+  {
+    unsigned ctxId = DeriveCtx::CtxAffineFlag( cu );
+    m_binEncoder.encodeBin(cu.affine, Ctx::SubblockMergeFlag(ctxId));
+    DTRACE( g_trace_ctx, D_SYNTAX, "subblock_merge_flag() subblock_merge_flag=%d ctx=%d pos=(%d,%d)\n", cu.affine ? 1 : 0, ctxId, cu.Y().x, cu.Y().y );
+  }
+}
+
+void CABACWriter::affine_flag( const CodingUnit& cu )
+{
+  if ( !cu.cs->slice->isIntra() && cu.cs->sps->getUseAffine() && cu.lumaSize().width > 8 && cu.lumaSize().height > 8 )
+  {
+    unsigned ctxId = DeriveCtx::CtxAffineFlag( cu );
+    m_binEncoder.encodeBin(cu.affine, Ctx::AffineFlag(ctxId));
+    DTRACE( g_trace_ctx, D_SYNTAX, "affine_flag() affine=%d ctx=%d pos=(%d,%d)\n", cu.affine ? 1 : 0, ctxId, cu.Y().x, cu.Y().y );
+
+    if ( cu.affine && cu.cs->sps->getUseAffineType() )
+    {
+      unsigned ctxId = 0;
+      m_binEncoder.encodeBin(cu.affineType != AffineModel::_4_PARAMS ? 1 : 0, Ctx::AffineType(ctxId));
+      DTRACE(g_trace_ctx, D_SYNTAX, "affine_type() affine_type=%d ctx=%d pos=(%d,%d)\n",
+             cu.affineType != AffineModel::_4_PARAMS ? 1 : 0, ctxId, cu.Y().x, cu.Y().y);
+    }
+  }
+}
+
+void CABACWriter::merge_flag( const PredictionUnit& pu )
+{
+  m_binEncoder.encodeBin(pu.mergeFlag, Ctx::MergeFlag());
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "merge_flag() merge=%d pos=(%d,%d) size=%dx%d\n", pu.mergeFlag ? 1 : 0, pu.lumaPos().x, pu.lumaPos().y, pu.lumaSize().width, pu.lumaSize().height );
+
+}
+
+void CABACWriter::merge_data(const PredictionUnit& pu)
+{
+  if (CU::isIBC(*pu.cu))
+  {
+    merge_idx(pu);
+    return;
+  }
+  subblock_merge_flag(*pu.cu);
+  if (pu.cu->affine)
+  {
+    merge_idx(pu);
+    return;
+  }
+  const bool ciipAvailable = pu.cs->sps->getUseCiip() && !pu.cu->skip && pu.cu->lwidth() < MAX_CU_SIZE && pu.cu->lheight() < MAX_CU_SIZE && pu.cu->lwidth() * pu.cu->lheight() >= 64;
+  const bool geoAvailable = pu.cu->cs->slice->getSPS()->getUseGeo() && pu.cu->cs->slice->isInterB() &&
+    pu.cs->sps->getMaxNumGeoCand() > 1
+                                                                    && pu.cu->lwidth() >= GEO_MIN_CU_SIZE && pu.cu->lheight() >= GEO_MIN_CU_SIZE
+                                                                    && pu.cu->lwidth() <= GEO_MAX_CU_SIZE && pu.cu->lheight() <= GEO_MAX_CU_SIZE
+                                                                    && pu.cu->lwidth() < 8 * pu.cu->lheight() && pu.cu->lheight() < 8 * pu.cu->lwidth();
+  if (geoAvailable || ciipAvailable)
+  {
+    m_binEncoder.encodeBin(pu.regularMergeFlag, Ctx::RegularMergeFlag(pu.cu->skip ? 0 : 1));
+  }
+  if (pu.regularMergeFlag)
+  {
+    if (pu.cs->sps->getUseMMVD())
+    {
+      m_binEncoder.encodeBin(pu.mmvdMergeFlag, Ctx::MmvdFlag(0));
+      DTRACE(g_trace_ctx, D_SYNTAX, "mmvd_merge_flag() mmvd_merge=%d pos=(%d,%d) size=%dx%d\n", pu.mmvdMergeFlag ? 1 : 0, pu.lumaPos().x, pu.lumaPos().y, pu.lumaSize().width, pu.lumaSize().height);
+    }
+    if (pu.mmvdMergeFlag || pu.cu->mmvdSkip)
+    {
+      mmvd_merge_idx(pu);
+    }
+    else
+    {
+      merge_idx(pu);
+    }
+  }
+  else
+  {
+    if (geoAvailable && ciipAvailable)
+    {
+      ciip_flag(pu);
+    }
+    merge_idx(pu);
+  }
+}
+
+void CABACWriter::imv_mode( const CodingUnit& cu )
+{
+  const SPS *sps = cu.cs->sps;
+
+  if( !sps->getAMVREnabledFlag() )
+  {
+    return;
+  }
+  if ( cu.affine )
+  {
+    return;
+  }
+
+  bool nonZeroMvd = CU::hasSubCUNonZeroMVd(cu);
+  if (!nonZeroMvd)
+  {
+    return;
+  }
+
+  if (CU::isIBC(cu) == false)
+    m_binEncoder.encodeBin((cu.imv > 0), Ctx::ImvFlag(0));
+  DTRACE( g_trace_ctx, D_SYNTAX, "imv_mode() value=%d ctx=%d\n", (cu.imv > 0), 0 );
+
+  if( sps->getAMVREnabledFlag() && cu.imv > 0 )
+  {
+    if (!CU::isIBC(cu))
+    {
+      m_binEncoder.encodeBin(cu.imv < IMV_HPEL, Ctx::ImvFlag(4));
+      DTRACE(g_trace_ctx, D_SYNTAX, "imv_mode() value=%d ctx=%d\n", cu.imv < 3, 4);
+    }
+    if (cu.imv < IMV_HPEL)
+    {
+      m_binEncoder.encodeBin((cu.imv > 1), Ctx::ImvFlag(1));
+      DTRACE(g_trace_ctx, D_SYNTAX, "imv_mode() value=%d ctx=%d\n", (cu.imv > 1), 1);
+    }
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "imv_mode() IMVFlag=%d\n", cu.imv );
+}
+
+void CABACWriter::affine_amvr_mode( const CodingUnit& cu )
+{
+  const SPS* sps = cu.slice->getSPS();
+
+  if( !sps->getAffineAmvrEnabledFlag() || !cu.affine )
+  {
+    return;
+  }
+
+  if ( !CU::hasSubCUNonZeroAffineMVd( cu ) )
+  {
+    return;
+  }
+
+  m_binEncoder.encodeBin((cu.imv > 0), Ctx::ImvFlag(2));
+  DTRACE( g_trace_ctx, D_SYNTAX, "affine_amvr_mode() value=%d ctx=%d\n", (cu.imv > 0), 2 );
+
+  if( cu.imv > 0 )
+  {
+    m_binEncoder.encodeBin((cu.imv > 1), Ctx::ImvFlag(3));
+    DTRACE( g_trace_ctx, D_SYNTAX, "affine_amvr_mode() value=%d ctx=%d\n", (cu.imv > 1), 3 );
+  }
+  DTRACE( g_trace_ctx, D_SYNTAX, "affine_amvr_mode() IMVFlag=%d\n", cu.imv );
+}
+
+void CABACWriter::merge_idx( const PredictionUnit& pu )
+{
+  if ( pu.cu->affine )
+  {
+    int numCandminus1 = int( pu.cs->picHeader->getMaxNumAffineMergeCand() ) - 1;
+    if ( numCandminus1 > 0 )
+    {
+      if ( pu.mergeIdx == 0 )
+      {
+        m_binEncoder.encodeBin(0, Ctx::AffMergeIdx());
+        DTRACE( g_trace_ctx, D_SYNTAX, "aff_merge_idx() aff_merge_idx=%d\n", pu.mergeIdx );
+        return;
+      }
+      else
+      {
+        m_binEncoder.encodeBin(1, Ctx::AffMergeIdx());
+        for ( unsigned idx = 1; idx < numCandminus1; idx++ )
+        {
+          m_binEncoder.encodeBinEP(pu.mergeIdx == idx ? 0 : 1);
+          if ( pu.mergeIdx == idx )
+          {
+            break;
+          }
+        }
+      }
+    }
+    DTRACE( g_trace_ctx, D_SYNTAX, "aff_merge_idx() aff_merge_idx=%d\n", pu.mergeIdx );
+  }
+  else
+  {
+    if( pu.cu->geoFlag )
+    {
+      const uint8_t splitDir = pu.geoSplitDir;
+      const uint8_t candIdx0 = pu.geoMergeIdx[0];
+      uint8_t       candIdx1 = pu.geoMergeIdx[1];
+      DTRACE( g_trace_ctx, D_SYNTAX, "merge_idx() geo_split_dir=%d\n", splitDir );
+      DTRACE( g_trace_ctx, D_SYNTAX, "merge_idx() geo_idx0=%d\n", candIdx0 );
+      DTRACE( g_trace_ctx, D_SYNTAX, "merge_idx() geo_idx1=%d\n", candIdx1 );
+      xWriteTruncBinCode(splitDir, GEO_NUM_PARTITION_MODE);
+      candIdx1 -= candIdx1 < candIdx0 ? 0 : 1;
+      const int maxNumGeoCand = pu.cs->sps->getMaxNumGeoCand();
+      CHECK(maxNumGeoCand < 2, "Incorrect max number of geo candidates");
+      CHECK(candIdx0 >= maxNumGeoCand, "Incorrect candIdx0");
+      CHECK(candIdx1 >= maxNumGeoCand, "Incorrect candIdx1");
+      const int numCandminus2 = maxNumGeoCand - 2;
+      m_binEncoder.encodeBin(candIdx0 == 0 ? 0 : 1, Ctx::MergeIdx());
+      if( candIdx0 > 0 )
+      {
+        unary_max_eqprob(candIdx0 - 1, numCandminus2);
+      }
+      if (numCandminus2 > 0)
+      {
+        m_binEncoder.encodeBin(candIdx1 == 0 ? 0 : 1, Ctx::MergeIdx());
+        if (candIdx1 > 0)
+        {
+          unary_max_eqprob(candIdx1 - 1, numCandminus2 - 1);
+        }
+      }
+      return;
+    }
+    int numCandminus1;
+    if (CU::isIBC(*pu.cu))
+    {
+      numCandminus1 = int(pu.cs->sps->getMaxNumIBCMergeCand()) - 1;
+    }
+    else
+    {
+      numCandminus1 = int(pu.cs->sps->getMaxNumMergeCand()) - 1;
+    }
+    if (numCandminus1 > 0)
+    {
+      if (pu.mergeIdx == 0)
+      {
+        m_binEncoder.encodeBin(0, Ctx::MergeIdx());
+        DTRACE(g_trace_ctx, D_SYNTAX, "merge_idx() merge_idx=%d\n", pu.mergeIdx);
+        return;
+      }
+      else
+      {
+        m_binEncoder.encodeBin(1, Ctx::MergeIdx());
+        for (unsigned idx = 1; idx < numCandminus1; idx++)
+        {
+          m_binEncoder.encodeBinEP(pu.mergeIdx == idx ? 0 : 1);
+          if (pu.mergeIdx == idx)
+          {
+            break;
+          }
+        }
+      }
+    }
+    DTRACE(g_trace_ctx, D_SYNTAX, "merge_idx() merge_idx=%d\n", pu.mergeIdx);
+  }
+}
+void CABACWriter::mmvd_merge_idx(const PredictionUnit& pu)
+{
+  const int mvdBaseIdx  = pu.mmvdMergeIdx.pos.baseIdx;
+  const int mvdStep     = pu.mmvdMergeIdx.pos.step;
+  const int mvdPosition = pu.mmvdMergeIdx.pos.position;
+
+  if (pu.cs->sps->getMaxNumMergeCand() > 1)
+  {
+    static_assert(MmvdIdx::BASE_MV_NUM == 2, "");
+    assert(mvdBaseIdx < 2);
+    m_binEncoder.encodeBin(mvdBaseIdx, Ctx::MmvdMergeIdx());
+  }
+  DTRACE(g_trace_ctx, D_SYNTAX, "base_mvp_idx() base_mvp_idx=%d\n", mvdBaseIdx);
+
+  int numStepCandMinus1 = MmvdIdx::REFINE_STEP - 1;
+  if (numStepCandMinus1 > 0)
+  {
+    if (mvdStep == 0)
+    {
+      m_binEncoder.encodeBin(0, Ctx::MmvdStepMvpIdx());
+    }
+    else
+    {
+      m_binEncoder.encodeBin(1, Ctx::MmvdStepMvpIdx());
+      for (unsigned idx = 1; idx < numStepCandMinus1; idx++)
+      {
+        m_binEncoder.encodeBinEP(mvdStep == idx ? 0 : 1);
+        if (mvdStep == idx)
+        {
+          break;
+        }
+      }
+    }
+  }
+  DTRACE(g_trace_ctx, D_SYNTAX, "MmvdStepMvpIdx() MmvdStepMvpIdx=%d\n", mvdStep);
+
+  m_binEncoder.encodeBinsEP(mvdPosition, 2);
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "pos() pos=%d\n", mvdPosition);
+  DTRACE(g_trace_ctx, D_SYNTAX, "mmvd_merge_idx() mmvd_merge_idx=%d\n", pu.mmvdMergeIdx.val);
+}
+
+void CABACWriter::inter_pred_idc( const PredictionUnit& pu )
+{
+  if( !pu.cs->slice->isInterB() )
+  {
+    return;
+  }
+  if( !(PU::isBipredRestriction(pu)) )
+  {
+    unsigned ctxId = DeriveCtx::CtxInterDir(pu);
+    if( pu.interDir == 3 )
+    {
+      m_binEncoder.encodeBin(1, Ctx::InterDir(ctxId));
+      DTRACE( g_trace_ctx, D_SYNTAX, "inter_pred_idc() ctx=%d value=%d pos=(%d,%d)\n", ctxId, pu.interDir, pu.lumaPos().x, pu.lumaPos().y );
+      return;
+    }
+    else
+    {
+      m_binEncoder.encodeBin(0, Ctx::InterDir(ctxId));
+    }
+  }
+  m_binEncoder.encodeBin((pu.interDir == 2), Ctx::InterDir(5));
+  DTRACE( g_trace_ctx, D_SYNTAX, "inter_pred_idc() ctx=5 value=%d pos=(%d,%d)\n", pu.interDir, pu.lumaPos().x, pu.lumaPos().y );
+}
+
+void CABACWriter::ref_idx( const PredictionUnit& pu, RefPicList eRefList )
+{
+  if ( pu.cu->smvdMode )
+  {
+    CHECK( pu.refIdx[eRefList] != pu.cs->slice->getSymRefIdx( eRefList ), "Invalid reference index!\n" );
+    return;
+  }
+
+  int numRef  = pu.cs->slice->getNumRefIdx(eRefList);
+
+  if (eRefList == REF_PIC_LIST_0 && pu.cs->sps->getIBCFlag())
+  {
+    if (CU::isIBC(*pu.cu))
+    {
+      return;
+    }
+  }
+
+  if( numRef <= 1 )
+  {
+    return;
+  }
+  int refIdx  = pu.refIdx[eRefList];
+  m_binEncoder.encodeBin((refIdx > 0), Ctx::RefPic());
+  if( numRef <= 2 || refIdx == 0 )
+  {
+    DTRACE( g_trace_ctx, D_SYNTAX, "ref_idx() value=%d pos=(%d,%d)\n", refIdx, pu.lumaPos().x, pu.lumaPos().y );
+    return;
+  }
+  m_binEncoder.encodeBin((refIdx > 1), Ctx::RefPic(1));
+  if( numRef <= 3 || refIdx == 1 )
+  {
+    DTRACE( g_trace_ctx, D_SYNTAX, "ref_idx() value=%d pos=(%d,%d)\n", refIdx, pu.lumaPos().x, pu.lumaPos().y );
+    return;
+  }
+  for( int idx = 3; idx < numRef; idx++ )
+  {
+    if( refIdx > idx - 1 )
+    {
+      m_binEncoder.encodeBinEP(1);
+    }
+    else
+    {
+      m_binEncoder.encodeBinEP(0);
+      break;
+    }
+  }
+  DTRACE( g_trace_ctx, D_SYNTAX, "ref_idx() value=%d pos=(%d,%d)\n", refIdx, pu.lumaPos().x, pu.lumaPos().y );
+}
+
+void CABACWriter::mvp_flag( const PredictionUnit& pu, RefPicList eRefList )
+{
+  m_binEncoder.encodeBin(pu.mvpIdx[eRefList], Ctx::MVPIdx());
+  DTRACE( g_trace_ctx, D_SYNTAX, "mvp_flag() value=%d pos=(%d,%d)\n", pu.mvpIdx[eRefList], pu.lumaPos().x, pu.lumaPos().y );
+  DTRACE( g_trace_ctx, D_SYNTAX, "mvpIdx(refList:%d)=%d\n", eRefList, pu.mvpIdx[eRefList] );
+}
+
+void CABACWriter::ciip_flag(const PredictionUnit &pu)
+{
+  if (!pu.cs->sps->getUseCiip())
+  {
+    CHECK(pu.ciipFlag == true, "invalid Ciip SPS");
+    return;
+  }
+  if (pu.cu->skip)
+  {
+    CHECK(pu.ciipFlag == true, "invalid Ciip and skip");
+    return;
+  }
+  m_binEncoder.encodeBin(pu.ciipFlag, Ctx::CiipFlag());
+  DTRACE(g_trace_ctx, D_SYNTAX, "ciip_flag() Ciip=%d pos=(%d,%d) size=%dx%d\n", pu.ciipFlag ? 1 : 0, pu.lumaPos().x,
+         pu.lumaPos().y, pu.lumaSize().width, pu.lumaSize().height);
+}
+
+//================================================================================
+//  clause 7.3.8.8
+//--------------------------------------------------------------------------------
+//    void  transform_tree      ( cs, area, cuCtx, chromaCbfs )
+//    bool  split_transform_flag( split, depth )
+//    bool  cbf_comp            ( cbf, area, depth )
+//================================================================================
+void CABACWriter::transform_tree( const CodingStructure& cs, Partitioner& partitioner, CUCtx& cuCtx,                         const PartSplit ispType, const int subTuIdx )
+{
+  const UnitArea&       area = partitioner.currArea();
+  int             subTuCounter = subTuIdx;
+  const TransformUnit  &tu           = *cs.getTU(area.block(partitioner.chType).pos(), partitioner.chType, subTuIdx);
+  const CodingUnit&     cu = *tu.cu;
+  const unsigned        trDepth = partitioner.currTrDepth;
+  const bool            split = (tu.depth > trDepth);
+
+  // split_transform_flag
+  if( partitioner.canSplit( TU_MAX_TR_SPLIT, cs ) )
+  {
+    CHECK( !split, "transform split implied" );
+  }
+  else if( cu.sbtInfo && partitioner.canSplit( PartSplit( cu.getSbtTuSplit() ), cs ) )
+  {
+    CHECK( !split, "transform split implied - sbt" );
+  }
+  else
+  {
+    CHECK(split && cu.ispMode == ISPType::NONE, "transform split not allowed with QTBT");
+  }
+
+  if( split )
+  {
+    if( partitioner.canSplit( TU_MAX_TR_SPLIT, cs ) )
+    {
+#if ENABLE_TRACING
+      const CompArea &tuArea = partitioner.currArea().block(partitioner.chType);
+      DTRACE( g_trace_ctx, D_SYNTAX, "transform_tree() maxTrSplit chType=%d pos=(%d,%d) size=%dx%d\n", partitioner.chType, tuArea.x, tuArea.y, tuArea.width, tuArea.height );
+
+#endif
+      partitioner.splitCurrArea( TU_MAX_TR_SPLIT, cs );
+    }
+    else if (cu.ispMode != ISPType::NONE)
+    {
+      partitioner.splitCurrArea( ispType, cs );
+    }
+    else if( cu.sbtInfo && partitioner.canSplit( PartSplit( cu.getSbtTuSplit() ), cs ) )
+    {
+      partitioner.splitCurrArea( PartSplit( cu.getSbtTuSplit() ), cs );
+    }
+    else
+    {
+      THROW( "Implicit TU split not available" );
+    }
+
+    do
+    {
+      transform_tree( cs, partitioner, cuCtx,                ispType, subTuCounter );
+      subTuCounter += subTuCounter != -1 ? 1 : 0;
+    } while( partitioner.nextPart( cs ) );
+
+    partitioner.exitCurrSplit();
+  }
+  else
+  {
+    DTRACE(g_trace_ctx, D_SYNTAX, "transform_unit() pos=(%d,%d) size=%dx%d depth=%d trDepth=%d\n",
+           tu.block(tu.chType).x, tu.block(tu.chType).y, tu.block(tu.chType).width, tu.block(tu.chType).height,
+           cu.depth, partitioner.currTrDepth);
+
+    transform_unit( tu, cuCtx, partitioner, subTuCounter);
+  }
+}
+
+void CABACWriter::cbf_comp(bool cbf, const CompArea &area, unsigned depth, const bool prevCbf, const bool useISP,
+                           const BdpcmMode bdpcmMode)
+{
+  unsigned  ctxId = DeriveCtx::CtxQtCbf(area.compID, prevCbf, useISP && isLuma(area.compID));
+  const CtxSet&   ctxSet  = Ctx::QtCbf[ area.compID ];
+
+  if (bdpcmMode != BdpcmMode::NONE)
+  {
+    ctxId = area.compID == COMPONENT_Cr ? 2 : 1;
+  }
+
+  m_binEncoder.encodeBin(cbf ? 1 : 0, ctxSet(ctxId));
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "cbf_comp() etype=%d pos=(%d,%d) ctx=%d cbf=%d\n", area.compID, area.x, area.y, ctxId,
+         cbf ? 1 : 0);
+}
+
+//================================================================================
+//  clause 7.3.8.9
+//--------------------------------------------------------------------------------
+//================================================================================
+void CABACWriter::mvd_coding(const PredictionUnit& pu, Mv mvd, int amvr)
+{
+  if (CU::isIBC(*pu.cu))
+  {
+    mvd.changeIbcPrecInternal2Amvr(amvr);
+  }
+  else if (pu.cu->affine)
+  {
+    mvd.changeAffinePrecInternal2Amvr(amvr);
+  }
+  else
+  {
+    mvd.changeTransPrecInternal2Amvr(amvr);
+  }
+  const int horMvd = mvd.getHor();
+  const int verMvd = mvd.getVer();
+  const unsigned int horAbs = std::abs(horMvd);
+  const unsigned int verAbs = std::abs(verMvd);
+  
+  // abs_mvd_greater0_flag[ 0 | 1 ]
+  m_binEncoder.encodeBin((horAbs > 0), Ctx::Mvd());
+  m_binEncoder.encodeBin((verAbs > 0), Ctx::Mvd());
+
+  // abs_mvd_greater1_flag[ 0 | 1 ]
+  if( horAbs > 0 )
+  {
+    m_binEncoder.encodeBin((horAbs > 1), Ctx::Mvd(1));
+  }
+  if( verAbs > 0 )
+  {
+    m_binEncoder.encodeBin((verAbs > 1), Ctx::Mvd(1));
+  }
+
+  // abs_mvd_minus2[ 0 | 1 ] and mvd_sign_flag[ 0 | 1 ]
+  if( horAbs > 0 )
+  {
+    if( horAbs > 1 )
+    {
+      m_binEncoder.encodeRemAbsEP(horAbs - 2, 1, 0, MV_BITS - 1);
+    }
+    m_binEncoder.encodeBinEP((horMvd < 0));
+  }
+  if( verAbs > 0 )
+  {
+    if( verAbs > 1 )
+    {
+      m_binEncoder.encodeRemAbsEP(verAbs - 2, 1, 0, MV_BITS - 1);
+    }
+    m_binEncoder.encodeBinEP((verMvd < 0));
+  }
+}
+
+//================================================================================
+//  clause 7.3.8.10
+//--------------------------------------------------------------------------------
+//    void  transform_unit      ( tu, cuCtx, chromaCbfs )
+//    void  cu_qp_delta         ( cu )
+//    void  cu_chroma_qp_offset ( cu )
+//================================================================================
+void CABACWriter::transform_unit( const TransformUnit& tu, CUCtx& cuCtx, Partitioner& partitioner, const int subTuCounter)
+{
+  const CodingUnit&       cu = *tu.cu;
+  const UnitArea&         area = partitioner.currArea();
+  const unsigned          trDepth = partitioner.currTrDepth;
+  ChromaCbfs              chromaCbfs;
+  CHECK(tu.depth != trDepth, " transform unit should be not be futher partitioned");
+
+  // cbf_cb & cbf_cr
+  if (isChromaEnabled(area.chromaFormat))
+  {
+    const bool chromaCbfISP = area.blocks[COMPONENT_Cb].valid() && cu.ispMode != ISPType::NONE;
+    if (area.blocks[COMPONENT_Cb].valid() && (!cu.isSepTree() || partitioner.chType == ChannelType::CHROMA)
+        && (cu.ispMode == ISPType::NONE || chromaCbfISP))
+    {
+      unsigned cbfDepth = chromaCbfISP ? trDepth - 1 : trDepth;
+      chromaCbfs.Cb     = TU::getCbfAtDepth(tu, COMPONENT_Cb, trDepth);
+      if (!(cu.sbtInfo && tu.noResidual))
+      {
+        cbf_comp(chromaCbfs.Cb, area.blocks[COMPONENT_Cb], cbfDepth, false, false, cu.getBdpcmMode(COMPONENT_Cb));
+      }
+
+      chromaCbfs.Cr = TU::getCbfAtDepth(tu, COMPONENT_Cr, trDepth);
+      if (!(cu.sbtInfo && tu.noResidual))
+      {
+        cbf_comp(chromaCbfs.Cr, area.blocks[COMPONENT_Cr], cbfDepth, chromaCbfs.Cb, false,
+                 cu.getBdpcmMode(COMPONENT_Cr));
+      }
+    }
+    else if (cu.isSepTree())
+    {
+      chromaCbfs = ChromaCbfs(false);
+    }
+  }
+  else if (cu.isSepTree())
+  {
+    chromaCbfs = ChromaCbfs(false);
+  }
+
+  if (!isChroma(partitioner.chType))
+  {
+    if (!CU::isIntra(cu) && trDepth == 0 && !chromaCbfs.sigChroma(area.chromaFormat))
+    {
+      CHECK(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter units with no chroma coeffs");
+    }
+    else if (cu.sbtInfo && tu.noResidual)
+    {
+      CHECK(TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be false for inter sbt no-residual tu");
+    }
+    else if (cu.sbtInfo && !chromaCbfs.sigChroma(area.chromaFormat))
+    {
+      assert(!tu.noResidual);
+      CHECK(!TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "Luma cbf must be true for inter sbt residual tu");
+    }
+    else
+    {
+      bool lumaCbfIsInferredACT =
+        (cu.colorTransform && CU::isIntra(cu) && trDepth == 0 && !chromaCbfs.sigChroma(area.chromaFormat));
+      CHECK(lumaCbfIsInferredACT && !TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), "adaptive color transform cannot have all zero coefficients");
+      bool lastCbfIsInferred    = lumaCbfIsInferredACT; // ISP and ACT are mutually exclusive
+      bool previousCbf          = false;
+      bool rootCbfSoFar         = false;
+      if (cu.ispMode != ISPType::NONE)
+      {
+        uint32_t nTus =
+          cu.ispMode == ISPType::HOR ? cu.lheight() >> floorLog2(tu.lheight()) : cu.lwidth() >> floorLog2(tu.lwidth());
+        if (subTuCounter == nTus - 1)
+        {
+          TransformUnit* tuPointer = cu.firstTU;
+          for (int tuIdx = 0; tuIdx < subTuCounter; tuIdx++)
+          {
+            rootCbfSoFar |= TU::getCbfAtDepth(*tuPointer, COMPONENT_Y, trDepth);
+            tuPointer = tuPointer->next;
+          }
+          if (!rootCbfSoFar)
+          {
+            lastCbfIsInferred = true;
+          }
+        }
+        if (!lastCbfIsInferred)
+        {
+          previousCbf = TU::getPrevTuCbfAtDepth(tu, COMPONENT_Y, partitioner.currTrDepth);
+        }
+      }
+      if (!lastCbfIsInferred)
+      {
+        cbf_comp(TU::getCbfAtDepth(tu, COMPONENT_Y, trDepth), tu.Y(), trDepth, previousCbf, cu.ispMode != ISPType::NONE,
+                 cu.getBdpcmMode(COMPONENT_Y));
+      }
+    }
+  }
+  bool        lumaOnly  = !isChromaEnabled(cu.chromaFormat) || !tu.blocks[COMPONENT_Cb].valid();
+  bool        cbf[3]    = { TU::getCbf( tu, COMPONENT_Y ), chromaCbfs.Cb, chromaCbfs.Cr };
+  bool        cbfLuma   = ( cbf[ COMPONENT_Y ] != 0 );
+  bool        cbfChroma = false;
+
+  if( !lumaOnly )
+  {
+    if( tu.blocks[COMPONENT_Cb].valid() )
+    {
+      cbf   [ COMPONENT_Cb  ] = TU::getCbf( tu, COMPONENT_Cb );
+      cbf   [ COMPONENT_Cr  ] = TU::getCbf( tu, COMPONENT_Cr );
+    }
+    cbfChroma = ( cbf[ COMPONENT_Cb ] || cbf[ COMPONENT_Cr ] );
+  }
+
+  if( ( cu.lwidth() > 64 || cu.lheight() > 64 || cbfLuma || cbfChroma ) &&
+    (!tu.cu->isSepTree() || isLuma(tu.chType)) )
+  {
+    if( cu.cs->pps->getUseDQP() && !cuCtx.isDQPCoded )
+    {
+      cu_qp_delta(cu, cuCtx.qp, cu.qp);
+      cuCtx.qp = cu.qp;
+      cuCtx.isDQPCoded = true;
+    }
+  }
+  if (!cu.isSepTree() || isChroma(tu.chType))   // !DUAL_TREE_LUMA
+  {
+    SizeType channelWidth = !cu.isSepTree() ? cu.lwidth() : cu.chromaSize().width;
+    SizeType channelHeight = !cu.isSepTree() ? cu.lheight() : cu.chromaSize().height;
+
+    if (cu.cs->slice->getUseChromaQpAdj() && (channelWidth > 64 || channelHeight > 64 || cbfChroma) && !cuCtx.isChromaQpAdjCoded)
+    {
+      cu_chroma_qp_offset(cu);
+      cuCtx.isChromaQpAdjCoded = true;
+    }
+  }
+
+  if( !lumaOnly )
+  {
+    joint_cb_cr( tu, ( cbf[COMPONENT_Cb] ? 2 : 0 ) + ( cbf[COMPONENT_Cr] ? 1 : 0 ) );
+  }
+
+  if (cbfLuma)
+  {
+    residual_coding(tu, COMPONENT_Y, &cuCtx);
+  }
+  if (!lumaOnly)
+  {
+    for (ComponentID compID = COMPONENT_Cb; compID <= COMPONENT_Cr; compID = ComponentID(compID + 1))
+    {
+      if (cbf[compID])
+      {
+        residual_coding(tu, compID, &cuCtx);
+      }
+    }
+  }
+
+  DTRACE_COND((isEncoding()), g_trace_ctx, D_DQP, "x=%d, y=%d, d=%d, qpAdj=%d\n", cu.block(cu.chType).lumaPos().x,
+              cu.block(cu.chType).lumaPos().y, cu.qtDepth, cu.chromaQpAdj);
+}
+
+void CABACWriter::cu_qp_delta( const CodingUnit& cu, int predQP, const int8_t qp )
+{
+  CHECK(!( predQP != std::numeric_limits<int>::max()), "Unspecified error");
+  int       DQp         = qp - predQP;
+  int       qpBdOffsetY = cu.cs->sps->getQpBDOffset(ChannelType::LUMA);
+  DQp                   = ( DQp + (MAX_QP + 1) + (MAX_QP + 1) / 2 + qpBdOffsetY + (qpBdOffsetY / 2)) % ((MAX_QP + 1) + qpBdOffsetY) - (MAX_QP + 1) / 2 - (qpBdOffsetY / 2);
+  unsigned  absDQP      = unsigned( DQp < 0 ? -DQp : DQp );
+  unsigned  unaryDQP    = std::min<unsigned>( absDQP, CU_DQP_TU_CMAX );
+
+  unary_max_symbol( unaryDQP, Ctx::DeltaQP(), Ctx::DeltaQP(1), CU_DQP_TU_CMAX );
+  if( absDQP >= CU_DQP_TU_CMAX )
+  {
+    exp_golomb_eqprob( absDQP - CU_DQP_TU_CMAX, CU_DQP_EG_k );
+  }
+  if( absDQP > 0 )
+  {
+    m_binEncoder.encodeBinEP(DQp < 0);
+  }
+
+  DTRACE_COND((isEncoding()), g_trace_ctx, D_DQP, "x=%d, y=%d, d=%d, pred_qp=%d, DQp=%d, qp=%d\n",
+              cu.block(cu.chType).lumaPos().x, cu.block(cu.chType).lumaPos().y, cu.qtDepth, predQP, DQp, qp);
+}
+
+
+void CABACWriter::cu_chroma_qp_offset( const CodingUnit& cu )
+{
+  // cu_chroma_qp_offset_flag
+  unsigned qpAdj = cu.chromaQpAdj;
+  if( qpAdj == 0 )
+  {
+    m_binEncoder.encodeBin(0, Ctx::ChromaQpAdjFlag());
+  }
+  else
+  {
+    m_binEncoder.encodeBin(1, Ctx::ChromaQpAdjFlag());
+    int length = cu.cs->pps->getChromaQpOffsetListLen();
+    if( length > 1 )
+    {
+      unary_max_symbol( qpAdj-1, Ctx::ChromaQpAdjIdc(), Ctx::ChromaQpAdjIdc(), length-1 );
+    }
+  }
+}
+
+//================================================================================
+//  clause 7.3.8.11
+//--------------------------------------------------------------------------------
+//    void        residual_coding         ( tu, compID )
+//    void        transform_skip_flag     ( tu, compID )
+//    void        last_sig_coeff          ( coeffCtx )
+//    void        residual_coding_subblock( coeffCtx )
+//================================================================================
+
+void CABACWriter::joint_cb_cr( const TransformUnit& tu, const int cbfMask )
+{
+  if ( !tu.cu->slice->getSPS()->getJointCbCrEnabledFlag() )
+  {
+    return;
+  }
+
+  CHECK( tu.jointCbCr && tu.jointCbCr != cbfMask, "wrong value of jointCbCr (" << (int)tu.jointCbCr << " vs " << (int)cbfMask << ")" );
+  if ((CU::isIntra(*tu.cu) && cbfMask != 0) || cbfMask == CBF_MASK_CBCR)
+  {
+    m_binEncoder.encodeBin(tu.jointCbCr ? 1 : 0, Ctx::JointCbCrFlag(cbfMask - 1));
+  }
+}
+
+void CABACWriter::residual_coding( const TransformUnit& tu, ComponentID compID, CUCtx* cuCtx )
+{
+  const CodingUnit& cu = *tu.cu;
+  DTRACE( g_trace_ctx, D_SYNTAX, "residual_coding() etype=%d pos=(%d,%d) size=%dx%d predMode=%d\n", tu.blocks[compID].compID, tu.blocks[compID].x, tu.blocks[compID].y, tu.blocks[compID].width, tu.blocks[compID].height, cu.predMode );
+
+  if( compID == COMPONENT_Cr && tu.jointCbCr == 3 )
+  {
+    return;
+  }
+
+  ts_flag            ( tu, compID );
+
+  if (tu.mtsIdx[compID] == MtsType::SKIP && !tu.cs->slice->getTSResidualCodingDisabledFlag())
+  {
+    residual_codingTS( tu, compID );
+    return;
+  }
+
+  // determine sign hiding
+  bool signHiding = cu.cs->slice->getSignDataHidingEnabledFlag();
+
+  // init coeff coding context
+  CoeffCodingContext  cctx(tu, compID, signHiding, BdpcmMode::NONE);
+  const TCoeff*       coeff   = tu.getCoeffs( compID ).buf;
+
+  // determine and set last coeff position and sig group flags
+  int                      scanPosLast = -1;
+  std::bitset<MLS_GRP_NUM> sigGroupFlags;
+  for( int scanPos = 0; scanPos < cctx.maxNumCoeff(); scanPos++)
+  {
+    unsigned blkPos = cctx.blockPos( scanPos );
+    if( coeff[blkPos] )
+    {
+      scanPosLast = scanPos;
+      sigGroupFlags.set( scanPos >> cctx.log2CGSize() );
+    }
+  }
+  CHECK( scanPosLast < 0, "Coefficient coding called for empty TU" );
+  cctx.setScanPosLast(scanPosLast);
+
+  if (cuCtx && tu.mtsIdx[compID] != MtsType::SKIP && tu.blocks[compID].height >= 4 && tu.blocks[compID].width >= 4)
+  {
+    const int maxLfnstPos = ((tu.blocks[compID].height == 4 && tu.blocks[compID].width == 4) || (tu.blocks[compID].height == 8 && tu.blocks[compID].width == 8)) ? 7 : 15;
+    cuCtx->violatesLfnstConstrained[toChannelType(compID)] |= cctx.scanPosLast() > maxLfnstPos;
+  }
+  if (cuCtx && tu.mtsIdx[compID] != MtsType::SKIP && tu.blocks[compID].height >= 4 && tu.blocks[compID].width >= 4)
+  {
+    const int lfnstLastScanPosTh = isLuma( compID ) ? LFNST_LAST_SIG_LUMA : LFNST_LAST_SIG_CHROMA;
+    cuCtx->lfnstLastScanPos |= cctx.scanPosLast() >= lfnstLastScanPosTh;
+  }
+  if (cuCtx && isLuma(compID) && tu.mtsIdx[compID] != MtsType::SKIP)
+  {
+    cuCtx->mtsLastScanPos |= cctx.scanPosLast() >= 1;
+  }
+
+
+  // code last coeff position
+  last_sig_coeff( cctx, tu, compID );
+
+  // code subblocks
+  const int stateTab = ( tu.cs->slice->getDepQuantEnabledFlag() ? 32040 : 0 );
+  int       state     = 0;
+
+  int ctxBinSampleRatio = (compID == COMPONENT_Y) ? MAX_TU_LEVEL_CTX_CODED_BIN_CONSTRAINT_LUMA : MAX_TU_LEVEL_CTX_CODED_BIN_CONSTRAINT_CHROMA;
+  cctx.regBinLimit = (tu.getTbAreaAfterCoefZeroOut(compID) * ctxBinSampleRatio) >> 4;
+
+  int baseLevel = m_binEncoder.getCtx().getBaseLevel();
+  cctx.setBaseLevel(baseLevel);
+  if (tu.cs->slice->getSPS()->getSpsRangeExtension().getPersistentRiceAdaptationEnabledFlag())
+  {
+    cctx.setUpdateHist(1);
+    unsigned riceStats    = m_binEncoder.getCtx().getGRAdaptStats((unsigned) compID);
+    TCoeff historyValue = (TCoeff)1 << riceStats;
+    cctx.setHistValue(historyValue);
+  }
+  for( int subSetId = ( cctx.scanPosLast() >> cctx.log2CGSize() ); subSetId >= 0; subSetId--)
+  {
+    cctx.initSubblock       ( subSetId, sigGroupFlags[subSetId] );
+
+    if (tu.cs->sps->getMtsEnabled() && tu.cu->sbtInfo != 0 && tu.blocks[compID].height <= 32
+        && tu.blocks[compID].width <= 32 && compID == COMPONENT_Y)
+    {
+      if( ( tu.blocks[ compID ].height == 32 && cctx.cgPosY() >= ( 16 >> cctx.log2CGHeight() ) )
+       || ( tu.blocks[ compID ].width  == 32 && cctx.cgPosX() >= ( 16 >> cctx.log2CGWidth()  ) ) )
+      {
+        continue;
+      }
+    }
+    residual_coding_subblock( cctx, coeff, stateTab, state );
+
+    if ( cuCtx && isLuma(compID) && cctx.isSigGroup() && ( cctx.cgPosY() > 3 || cctx.cgPosX() > 3 ) )
+    {
+      cuCtx->violatesMtsCoeffConstraint = true;
+    }
+  }
+}
+
+void CABACWriter::ts_flag( const TransformUnit& tu, ComponentID compID )
+{
+  const int tsFlag = tu.mtsIdx[compID] == MtsType::SKIP ? 1 : 0;
+  int ctxIdx = isLuma(compID) ? 0 : 1;
+
+  if( TU::isTSAllowed ( tu, compID ) )
+  {
+    m_binEncoder.encodeBin(tsFlag, Ctx::TransformSkipFlag(ctxIdx));
+  }
+  DTRACE( g_trace_ctx, D_SYNTAX, "ts_flag() etype=%d pos=(%d,%d) mtsIdx=%d\n", COMPONENT_Y, tu.cu->lx(), tu.cu->ly(), tsFlag );
+}
+
+void CABACWriter::mts_idx( const CodingUnit& cu, CUCtx* cuCtx )
+{
+  TransformUnit &tu = *cu.firstTU;
+  MtsType        mtsIdx = tu.mtsIdx[COMPONENT_Y];
+
+  if (CU::isMTSAllowed(cu, COMPONENT_Y) && cuCtx && !cuCtx->violatesMtsCoeffConstraint && cuCtx->mtsLastScanPos
+      && cu.lfnstIdx == 0 && mtsIdx != MtsType::SKIP)
+  {
+    int symbol = mtsIdx != MtsType::DCT2_DCT2 ? 1 : 0;
+    int ctxIdx = 0;
+
+    m_binEncoder.encodeBin(symbol, Ctx::MTSIdx(ctxIdx));
+
+    if( symbol )
+    {
+      ctxIdx = 1;
+      for( int i = 0; i < 3; i++, ctxIdx++ )
+      {
+        symbol = mtsIdx > MtsType::DST7_DST7 + i ? 1 : 0;
+        m_binEncoder.encodeBin(symbol, Ctx::MTSIdx(ctxIdx));
+
+        if( !symbol )
+        {
+          break;
+        }
+      }
+    }
+  }
+  DTRACE( g_trace_ctx, D_SYNTAX, "mts_idx() etype=%d pos=(%d,%d) mtsIdx=%d\n", COMPONENT_Y, tu.cu->lx(), tu.cu->ly(), mtsIdx);
+}
+
+void CABACWriter::isp_mode( const CodingUnit& cu )
+{
+  if (!CU::isIntra(cu) || !isLuma(cu.chType) || cu.firstPU->multiRefIdx || !cu.cs->sps->getUseISP()
+      || cu.bdpcmMode != BdpcmMode::NONE || !CU::canUseISP(cu, getFirstComponentOfChannel(cu.chType))
+      || cu.colorTransform)
+  {
+    CHECK(cu.ispMode != ISPType::NONE, "cu.ispMode != 0");
+    return;
+  }
+  if (cu.ispMode == ISPType::NONE)
+  {
+    m_binEncoder.encodeBin(0, Ctx::ISPMode(0));
+  }
+  else
+  {
+    m_binEncoder.encodeBin( 1, Ctx::ISPMode( 0 ) );
+    m_binEncoder.encodeBin(cu.ispMode == ISPType::HOR ? 0 : 1, Ctx::ISPMode(1));
+  }
+  DTRACE(g_trace_ctx, D_SYNTAX, "intra_subPartitions() etype=%d pos=(%d,%d) ispIdx=%d\n", cu.chType,
+         cu.block(cu.chType).x, cu.block(cu.chType).y, (int) cu.ispMode);
+}
+
+void CABACWriter::residual_lfnst_mode( const CodingUnit& cu, CUCtx& cuCtx )
+{
+  int chIdx = cu.isSepTree() && isChroma(cu.chType) ? 1 : 0;
+  if ((cu.ispMode != ISPType::NONE && !CU::canUseLfnstWithISP(cu, cu.chType))
+      || (cu.cs->sps->getUseLFNST() && CU::isIntra(cu) && cu.mipFlag && !allowLfnstWithMip(cu.firstPU->lumaSize()))
+      || (cu.isSepTree() && isChroma(cu.chType) && std::min(cu.blocks[1].width, cu.blocks[1].height) < 4)
+      || (cu.blocks[chIdx].lumaSize().width > cu.cs->sps->getMaxTbSize()
+          || cu.blocks[chIdx].lumaSize().height > cu.cs->sps->getMaxTbSize()))
+  {
+    return;
+  }
+
+  if( cu.cs->sps->getUseLFNST() && CU::isIntra( cu ) )
+  {
+    const bool lumaFlag                   = cu.isSepTree() ? (   isLuma( cu.chType ) ? true : false ) : true;
+    const bool chromaFlag                 = cu.isSepTree() ? ( isChroma( cu.chType ) ? true : false ) : true;
+    bool       nonZeroCoeffNonTsCorner8x8 = (lumaFlag && cuCtx.violatesLfnstConstrained[ChannelType::LUMA])
+                                      || (chromaFlag && cuCtx.violatesLfnstConstrained[ChannelType::CHROMA]);
+    bool isTrSkip = false;
+    for (auto &currTU : CU::traverseTUs(cu))
+    {
+      const uint32_t numValidComp = getNumberValidComponents(cu.chromaFormat);
+      for (uint32_t compID = COMPONENT_Y; compID < numValidComp; compID++)
+      {
+        if (currTU.blocks[compID].valid() && TU::getCbf(currTU, (ComponentID) compID)
+            && currTU.mtsIdx[compID] == MtsType::SKIP)
+        {
+          isTrSkip = true;
+          break;
+        }
+      }
+    }
+    if ((!cuCtx.lfnstLastScanPos && cu.ispMode == ISPType::NONE) || nonZeroCoeffNonTsCorner8x8 || isTrSkip)
+    {
+      return;
+    }
+  }
+  else
+  {
+    return;
+  }
+
+
+  unsigned cctx = 0;
+  if (cu.isSepTree())
+  {
+    cctx++;
+  }
+
+  const uint32_t idxLFNST = cu.lfnstIdx;
+  assert( idxLFNST < 3 );
+  m_binEncoder.encodeBin(idxLFNST ? 1 : 0, Ctx::LFNSTIdx(cctx));
+
+  if( idxLFNST )
+  {
+    m_binEncoder.encodeBin((idxLFNST - 1) ? 1 : 0, Ctx::LFNSTIdx(2));
+  }
+
+  DTRACE( g_trace_ctx, D_SYNTAX, "residual_lfnst_mode() etype=%d pos=(%d,%d) mode=%d\n", COMPONENT_Y, cu.lx(), cu.ly(), ( int ) cu.lfnstIdx );
+}
+
+void CABACWriter::last_sig_coeff( CoeffCodingContext& cctx, const TransformUnit& tu, ComponentID compID )
+{
+  unsigned blkPos = cctx.blockPos( cctx.scanPosLast() );
+  unsigned posX, posY;
+  {
+    posY  = blkPos / cctx.width();
+    posX  = blkPos - ( posY * cctx.width() );
+  }
+
+  unsigned CtxLast;
+  unsigned GroupIdxX = g_groupIdx[posX];
+  unsigned GroupIdxY = g_groupIdx[posY];
+
+  unsigned maxLastPosX = cctx.maxLastPosX();
+  unsigned maxLastPosY = cctx.maxLastPosY();
+
+  unsigned zoTbWdith  = getNonzeroTuSize(cctx.width());
+  unsigned zoTbHeight = getNonzeroTuSize(cctx.height());
+
+  if (tu.cs->sps->getMtsEnabled() && tu.cu->sbtInfo != 0 && tu.blocks[compID].width <= 32
+      && tu.blocks[compID].height <= 32 && compID == COMPONENT_Y)
+  {
+    maxLastPosX = (tu.blocks[compID].width == 32) ? g_groupIdx[15] : maxLastPosX;
+    maxLastPosY = (tu.blocks[compID].height == 32) ? g_groupIdx[15] : maxLastPosY;
+    zoTbWdith = (tu.blocks[compID].width == 32) ? 16 : zoTbWdith;
+    zoTbHeight = (tu.blocks[compID].height == 32) ? 16 : zoTbHeight;
+  }
+  if (isEncoding())
+  {
+    if ((posX + posY) > ((zoTbWdith + zoTbHeight + 2) / 2))
+    {
+      tu.cu->slice->updateCntRightBottom(1);
+    }
+    else
+    {
+      tu.cu->slice->updateCntRightBottom(-1);
+    }
+  }
+  if (tu.cu->slice->getReverseLastSigCoeffFlag())
+  {
+    posX = zoTbWdith - 1 - posX;
+    posY = zoTbHeight - 1 - posY;
+
+    GroupIdxX = g_groupIdx[posX];
+    GroupIdxY = g_groupIdx[posY];
+  }
+
+  for( CtxLast = 0; CtxLast < GroupIdxX; CtxLast++ )
+  {
+    m_binEncoder.encodeBin(1, cctx.lastXCtxId(CtxLast));
+  }
+  if( GroupIdxX < maxLastPosX )
+  {
+    m_binEncoder.encodeBin(0, cctx.lastXCtxId(CtxLast));
+  }
+  for( CtxLast = 0; CtxLast < GroupIdxY; CtxLast++ )
+  {
+    m_binEncoder.encodeBin(1, cctx.lastYCtxId(CtxLast));
+  }
+  if( GroupIdxY < maxLastPosY )
+  {
+    m_binEncoder.encodeBin(0, cctx.lastYCtxId(CtxLast));
+  }
+  if( GroupIdxX > 3 )
+  {
+    posX -= g_minInGroup[GroupIdxX];
+    for (int i = ( ( GroupIdxX - 2 ) >> 1 ) - 1 ; i >= 0; i-- )
+    {
+      m_binEncoder.encodeBinEP((posX >> i) & 1);
+    }
+  }
+  if( GroupIdxY > 3 )
+  {
+    posY -= g_minInGroup[GroupIdxY];
+    for ( int i = ( ( GroupIdxY - 2 ) >> 1 ) - 1 ; i >= 0; i-- )
+    {
+      m_binEncoder.encodeBinEP((posY >> i) & 1);
+    }
+  }
+}
+
+void CABACWriter::residual_coding_subblock( CoeffCodingContext& cctx, const TCoeff* coeff, const int stateTransTable, int& state )
+{
+  //===== init =====
+  const int   minSubPos   = cctx.minSubPos();
+  const bool  isLast      = cctx.isLast();
+  int         firstSigPos = ( isLast ? cctx.scanPosLast() : cctx.maxSubPos() );
+  int         nextSigPos  = firstSigPos;
+  int baseLevel = cctx.getBaseLevel();
+  bool updateHistory = cctx.getUpdateHist();
+
+  //===== encode significant_coeffgroup_flag =====
+  if( !isLast && cctx.isNotFirst() )
+  {
+    if( cctx.isSigGroup() )
+    {
+      m_binEncoder.encodeBin(1, cctx.sigGroupCtxId());
+    }
+    else
+    {
+      m_binEncoder.encodeBin(0, cctx.sigGroupCtxId());
+      return;
+    }
+  }
+
+  uint8_t   ctxOffset[16];
+
+  //===== encode absolute values =====
+  const int inferSigPos     = nextSigPos != cctx.scanPosLast() ? (cctx.isNotFirst() ? minSubPos : -1) : nextSigPos;
+  int       firstNZPos      = nextSigPos;
+  int       lastNZPos       = -1;
+  int       numNonZero      = 0;
+  unsigned  signPattern     = 0;
+  int       remRegBins      = cctx.regBinLimit;
+  int       firstPos2ndPass = minSubPos - 1;
+
+  for( ; nextSigPos >= minSubPos && remRegBins >= 4; nextSigPos-- )
+  {
+    const TCoeff level   = coeff[cctx.blockPos(nextSigPos)];
+    unsigned     sigFlag = (level != 0);
+    if( numNonZero || nextSigPos != inferSigPos )
+    {
+      const unsigned sigCtxId = cctx.sigCtxIdAbs( nextSigPos, coeff, state );
+      m_binEncoder.encodeBin(sigFlag, sigCtxId);
+      DTRACE( g_trace_ctx, D_SYNTAX_RESI, "sig_bin() bin=%d ctx=%d\n", sigFlag, sigCtxId );
+      remRegBins--;
+    }
+    else if( nextSigPos != cctx.scanPosLast() )
+    {
+      cctx.sigCtxIdAbs( nextSigPos, coeff, state ); // required for setting variables that are needed for gtx/par context selection
+    }
+
+    if( sigFlag )
+    {
+      uint8_t&  ctxOff  = ctxOffset[ nextSigPos - minSubPos ];
+      ctxOff            = cctx.ctxOffsetAbs();
+      numNonZero++;
+      firstNZPos  = nextSigPos;
+      lastNZPos   = std::max<int>( lastNZPos, nextSigPos );
+      const TCoeff absLevel = abs(level);
+
+      if (nextSigPos != cctx.scanPosLast())
+      {
+        signPattern <<= 1;
+      }
+      if (level < 0)
+      {
+        signPattern++;
+      }
+
+      const bool gt1 = absLevel > 1;
+      m_binEncoder.encodeBin( gt1, cctx.greater1CtxIdAbs(ctxOff) );
+      DTRACE( g_trace_ctx, D_SYNTAX_RESI, "gt1_flag() bin=%d ctx=%d\n", gt1, cctx.greater1CtxIdAbs(ctxOff) );
+      remRegBins--;
+
+      if( gt1 )
+      {
+        m_binEncoder.encodeBin(absLevel & 1, cctx.parityCtxIdAbs(ctxOff));
+        DTRACE(g_trace_ctx, D_SYNTAX_RESI, "par_flag() bin=%d ctx=%d\n", absLevel & 1, cctx.parityCtxIdAbs(ctxOff));
+
+        remRegBins--;
+        const bool gt2 = absLevel > 3;
+        m_binEncoder.encodeBin(gt2, cctx.greater2CtxIdAbs(ctxOff));
+        DTRACE(g_trace_ctx, D_SYNTAX_RESI, "gt2_flag() bin=%d ctx=%d\n", gt2, cctx.greater2CtxIdAbs(ctxOff));
+        remRegBins--;
+
+        if (gt2)
+        {
+          // Start 2nd pass with first coeff that has absLevel > 3
+          firstPos2ndPass = std::max(firstPos2ndPass, nextSigPos);
+        }
+      }
+    }
+
+    state = (stateTransTable >> ((state << 2) + ((level & 1) << 1))) & 3;
+  }
+  int minPos2ndPass = nextSigPos;
+  cctx.regBinLimit = remRegBins;
+
+  //===== 2nd PASS: Go-rice codes =====
+  for (int scanPos = firstPos2ndPass; scanPos > minPos2ndPass; scanPos--)
+  {
+    unsigned absLevel = (unsigned) abs( coeff[ cctx.blockPos( scanPos ) ] );
+    if( absLevel >= 4 )
+    {
+      const unsigned ricePar = (cctx.*(cctx.deriveRiceRRC))(scanPos, coeff, baseLevel);
+
+      unsigned rem      = ( absLevel - 4 ) >> 1;
+      m_binEncoder.encodeRemAbsEP(rem, ricePar, COEF_REMAIN_BIN_REDUCTION, cctx.maxLog2TrDRange());
+      DTRACE( g_trace_ctx, D_SYNTAX_RESI, "rem_val() bin=%d ctx=%d\n", rem, ricePar );
+      if ((updateHistory) && (rem > 0))
+      {
+        unsigned &riceStats = m_binEncoder.getCtx().getGRAdaptStats((unsigned) (cctx.compID()));
+        cctx.updateRiceStat(riceStats, rem, 1);
+        cctx.setUpdateHist(0);
+        updateHistory = 0;
+      }
+    }
+  }
+
+  //===== coeff bypass ====
+  for (int scanPos = minPos2ndPass; scanPos >= minSubPos; scanPos--)
+  {
+    TCoeff      coeffVal  = coeff[cctx.blockPos(scanPos)];
+    unsigned    absLevel  = (unsigned) abs(coeffVal);
+    int rice = (cctx.*(cctx.deriveRiceRRC))(scanPos, coeff, 0);
+    int         pos0      = g_goRicePosCoeff0(state, rice);
+    unsigned  rem       = ( absLevel == 0 ? pos0 : absLevel <= pos0 ? absLevel-1 : absLevel );
+    m_binEncoder.encodeRemAbsEP(rem, rice, COEF_REMAIN_BIN_REDUCTION, cctx.maxLog2TrDRange());
+    DTRACE( g_trace_ctx, D_SYNTAX_RESI, "rem_val() bin=%d ctx=%d\n", rem, rice );
+    state = ( stateTransTable >> ((state<<2)+((absLevel&1)<<1)) ) & 3;
+    if ((updateHistory) && (rem > 0))
+    {
+      unsigned &riceStats = m_binEncoder.getCtx().getGRAdaptStats((unsigned) cctx.compID());
+      cctx.updateRiceStat(riceStats, rem, 0);
+      cctx.setUpdateHist(0);
+      updateHistory = 0;
+    }
+    if( absLevel )
+    {
+      numNonZero++;
+      firstNZPos = scanPos;
+      lastNZPos   = std::max<int>( lastNZPos, scanPos );
+      signPattern <<= 1;
+      if (coeffVal < 0)
+      {
+        signPattern++;
+      }
+    }
+  }
+
+  //===== encode sign's =====
+  unsigned numSigns = numNonZero;
+  if( cctx.hideSign( firstNZPos, lastNZPos ) )
+  {
+    numSigns    --;
+    signPattern >>= 1;
+  }
+  m_binEncoder.encodeBinsEP(signPattern, numSigns);
+}
+
+void CABACWriter::residual_codingTS( const TransformUnit& tu, ComponentID compID )
+{
+  DTRACE( g_trace_ctx, D_SYNTAX, "residual_codingTS() etype=%d pos=(%d,%d) size=%dx%d\n", tu.blocks[compID].compID, tu.blocks[compID].x, tu.blocks[compID].y, tu.blocks[compID].width, tu.blocks[compID].height );
+
+  // init coeff coding context
+  CoeffCodingContext  cctx    ( tu, compID, false, isLuma(compID) ? tu.cu->bdpcmMode : tu.cu->bdpcmModeChroma);
+  const TCoeff*       coeff   = tu.getCoeffs( compID ).buf;
+  int maxCtxBins = (cctx.maxNumCoeff() * 7) >> 2;
+  cctx.setNumCtxBins(maxCtxBins);
+
+  // determine and set last coeff position and sig group flags
+  std::bitset<MLS_GRP_NUM> sigGroupFlags;
+  for( int scanPos = 0; scanPos < cctx.maxNumCoeff(); scanPos++)
+  {
+    unsigned blkPos = cctx.blockPos( scanPos );
+    if( coeff[blkPos] )
+    {
+      sigGroupFlags.set( scanPos >> cctx.log2CGSize() );
+    }
+  }
+
+  // code subblocks
+  for( int subSetId = 0; subSetId <= ( cctx.maxNumCoeff() - 1 ) >> cctx.log2CGSize(); subSetId++ )
+  {
+    cctx.initSubblock         ( subSetId, sigGroupFlags[subSetId] );
+    int goRiceParam = 1;
+    bool ricePresentFlag = false;
+    unsigned RiceBit[8]   = { 0, 0, 0, 0, 0, 0, 0, 0 };
+    if (tu.cu->slice->getSPS()->getSpsRangeExtension().getTSRCRicePresentFlag() && tu.mtsIdx[compID] == MtsType::SKIP)
+    {
+      goRiceParam = goRiceParam + tu.cu->slice->getTsrcIndex();
+      if (isEncoding())
+      {
+        ricePresentFlag = true;
+        for (int i = 0; i < MAX_TSRC_RICE; i++)
+        {
+          RiceBit[i] = tu.cu->slice->getRiceBit(i);
+        }
+      }
+    }
+    residual_coding_subblockTS( cctx, coeff, RiceBit, goRiceParam, ricePresentFlag);
+    if (tu.cu->slice->getSPS()->getSpsRangeExtension().getTSRCRicePresentFlag() && tu.mtsIdx[compID] == MtsType::SKIP
+        && isEncoding())
+    {
+      for (int i = 0; i < MAX_TSRC_RICE; i++)
+      {
+        tu.cu->slice->setRiceBit(i, RiceBit[i]);
+      }
+    }
+  }
+}
+
+void CABACWriter::residual_coding_subblockTS(CoeffCodingContext &cctx, const TCoeff *coeff, unsigned (&RiceBit)[8],
+                                             const int riceParam, bool ricePresentFlag)
+{
+  //===== init =====
+  const int   minSubPos   = cctx.maxSubPos();
+  int         firstSigPos = cctx.minSubPos();
+  int         nextSigPos  = firstSigPos;
+
+  //===== encode significant_coeffgroup_flag =====
+  if( !cctx.isLastSubSet() || !cctx.only1stSigGroup() )
+  {
+    if( cctx.isSigGroup() )
+    {
+      m_binEncoder.encodeBin(1, cctx.sigGroupCtxId(true));
+      DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_sigGroup() bin=%d ctx=%d\n", 1, cctx.sigGroupCtxId());
+    }
+    else
+    {
+      m_binEncoder.encodeBin(0, cctx.sigGroupCtxId(true));
+      DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_sigGroup() bin=%d ctx=%d\n", 0, cctx.sigGroupCtxId());
+      return;
+    }
+  }
+
+  //===== encode absolute values =====
+  const int inferSigPos   = minSubPos;
+  int       remAbsLevel   = -1;
+  int       numNonZero    =  0;
+
+  int rightPixel, belowPixel, modAbsCoeff;
+
+  int lastScanPosPass1 = -1;
+  int lastScanPosPass2 = -1;
+  for (; nextSigPos <= minSubPos && cctx.numCtxBins() >= 4; nextSigPos++)
+  {
+    TCoeff   coeffVal = coeff[cctx.blockPos(nextSigPos)];
+    unsigned sigFlag  = (coeffVal != 0);
+    if( numNonZero || nextSigPos != inferSigPos )
+    {
+      const unsigned sigCtxId = cctx.sigCtxIdAbsTS(nextSigPos, coeff);
+      m_binEncoder.encodeBin(sigFlag, sigCtxId);
+      DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_sig_bin() bin=%d ctx=%d\n", sigFlag, sigCtxId);
+      cctx.decimateNumCtxBins(1);
+    }
+
+    if( sigFlag )
+    {
+      //===== encode sign's =====
+      int            sign      = coeffVal < 0;
+      const unsigned signCtxId = cctx.signCtxIdAbsTS(nextSigPos, coeff, cctx.bdpcm());
+      m_binEncoder.encodeBin(sign, signCtxId);
+      cctx.decimateNumCtxBins(1);
+      numNonZero++;
+      cctx.neighTS(rightPixel, belowPixel, nextSigPos, coeff);
+      modAbsCoeff = cctx.deriveModCoeff(rightPixel, belowPixel, abs(coeffVal), cctx.bdpcm() != BdpcmMode::NONE);
+      remAbsLevel = modAbsCoeff - 1;
+
+      unsigned gt1 = !!remAbsLevel;
+      const unsigned gt1CtxId = cctx.lrg1CtxIdAbsTS(nextSigPos, coeff, cctx.bdpcm());
+      m_binEncoder.encodeBin(gt1, gt1CtxId);
+      DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_gt1_flag() bin=%d ctx=%d\n", gt1, gt1CtxId);
+      cctx.decimateNumCtxBins(1);
+
+      if( gt1 )
+      {
+        remAbsLevel  -= 1;
+        m_binEncoder.encodeBin(remAbsLevel & 1, cctx.parityCtxIdAbsTS());
+        DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_par_flag() bin=%d ctx=%d\n", remAbsLevel & 1, cctx.parityCtxIdAbsTS());
+        cctx.decimateNumCtxBins(1);
+      }
+    }
+    lastScanPosPass1 = nextSigPos;
+  }
+
+  int cutoffVal = 2;
+  int numGtBins = 4;
+  for (int scanPos = firstSigPos; scanPos <= minSubPos && cctx.numCtxBins() >= 4; scanPos++)
+  {
+    unsigned absLevel;
+    cctx.neighTS(rightPixel, belowPixel, scanPos, coeff);
+    absLevel =
+      cctx.deriveModCoeff(rightPixel, belowPixel, abs(coeff[cctx.blockPos(scanPos)]), cctx.bdpcm() != BdpcmMode::NONE);
+    cutoffVal = 2;
+    for (int i = 0; i < numGtBins; i++)
+    {
+      if (absLevel >= cutoffVal)
+      {
+        unsigned gt2 = (absLevel >= (cutoffVal + 2));
+        m_binEncoder.encodeBin(gt2, cctx.greaterXCtxIdAbsTS(cutoffVal >> 1));
+        DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_gt%d_flag() bin=%d ctx=%d sp=%d coeff=%d\n", i, gt2,
+               cctx.greaterXCtxIdAbsTS(cutoffVal >> 1), scanPos, std::min<int>(absLevel, cutoffVal + 2));
+        cctx.decimateNumCtxBins(1);
+      }
+      cutoffVal += 2;
+    }
+    lastScanPosPass2 = scanPos;
+  }
+
+  //===== coeff bypass ====
+  for( int scanPos = firstSigPos; scanPos <= minSubPos; scanPos++ )
+  {
+    unsigned absLevel;
+    cctx.neighTS(rightPixel, belowPixel, scanPos, coeff);
+    cutoffVal = (scanPos <= lastScanPosPass2 ? 10 : (scanPos <= lastScanPosPass1 ? 2 : 0));
+    absLevel  = cctx.deriveModCoeff(rightPixel, belowPixel, abs(coeff[cctx.blockPos(scanPos)]),
+                                    cctx.bdpcm() != BdpcmMode::NONE || cutoffVal == 0);
+
+    if( absLevel >= cutoffVal )
+    {
+      unsigned  rem = scanPos <= lastScanPosPass1 ? (absLevel - cutoffVal) >> 1 : absLevel;
+      m_binEncoder.encodeRemAbsEP(rem, riceParam, COEF_REMAIN_BIN_REDUCTION, cctx.maxLog2TrDRange());
+      DTRACE(g_trace_ctx, D_SYNTAX_RESI, "ts_rem_val() bin=%d ctx=%d sp=%d\n", rem, riceParam, scanPos);
+      if ( ricePresentFlag && (isEncoding()) && (cctx.compID() == COMPONENT_Y))
+      {
+        for (int idx = 1; idx < 9; idx++)
+        {
+          uint32_t length;
+          uint32_t symbol = rem;
+          if (rem < (5 << idx))
+          {
+            length = rem >> idx;
+            RiceBit[idx - 1] += (length + 1 + idx);
+          }
+          else
+          {
+            length = idx;
+            symbol = symbol - (5 << idx);
+            while (symbol >= (1 << length))
+            {
+              symbol -= (1 << (length++));
+            }
+            RiceBit[idx - 1] += (5 + length + 1 - idx + length);
+          }
+        }
+      }
+
+      if (absLevel && scanPos > lastScanPosPass1)
+      {
+        const int sign = coeff[cctx.blockPos(scanPos)] < 0 ? 1 : 0;
+        m_binEncoder.encodeBinEP(sign);
+      }
+    }
+  }
+}
+
+//================================================================================
+//  helper functions
+//--------------------------------------------------------------------------------
+//    void  unary_max_symbol  ( symbol, ctxId0, ctxIdN, maxSymbol )
+//    void  unary_max_eqprob  ( symbol,                 maxSymbol )
+//    void  exp_golomb_eqprob ( symbol, count )
+//================================================================================
+
+void CABACWriter::unary_max_symbol( unsigned symbol, unsigned ctxId0, unsigned ctxIdN, unsigned maxSymbol )
+{
+  CHECK( symbol > maxSymbol, "symbol > maxSymbol" );
+  const unsigned totalBinsToWrite = std::min( symbol + 1, maxSymbol );
+  for( unsigned binsWritten = 0; binsWritten < totalBinsToWrite; ++binsWritten )
+  {
+    const unsigned nextBin = symbol > binsWritten;
+    m_binEncoder.encodeBin(nextBin, binsWritten == 0 ? ctxId0 : ctxIdN);
+  }
+}
+
+
+void CABACWriter::unary_max_eqprob( unsigned symbol, unsigned maxSymbol )
+{
+  if( maxSymbol == 0 )
+  {
+    return;
+  }
+  bool     codeLast = ( maxSymbol > symbol );
+  unsigned bins     = 0;
+  unsigned numBins  = 0;
+  while( symbol-- )
+  {
+    bins   <<= 1;
+    bins   ++;
+    numBins++;
+  }
+  if( codeLast )
+  {
+    bins  <<= 1;
+    numBins++;
+  }
+  CHECK(!( numBins <= 32 ), "Unspecified error");
+  m_binEncoder.encodeBinsEP(bins, numBins);
+}
+
+void CABACWriter::exp_golomb_eqprob( unsigned symbol, unsigned count )
+{
+  unsigned bins    = 0;
+  unsigned numBins = 0;
+  while( symbol >= (unsigned)(1<<count) )
+  {
+    bins <<= 1;
+    bins++;
+    numBins++;
+    symbol -= 1 << count;
+    count++;
+  }
+  bins <<= 1;
+  numBins++;
+  //CHECK(!( numBins + count <= 32 ), "Unspecified error");
+  m_binEncoder.encodeBinsEP(bins, numBins);
+  m_binEncoder.encodeBinsEP(symbol, count);
+}
+
+void CABACWriter::codeAlfCtuEnableFlags( CodingStructure& cs, ChannelType channel, AlfParam* alfParam)
+{
+  if( isLuma( channel ) )
+  {
+    if (alfParam->enabledFlag[COMPONENT_Y])
+    {
+      codeAlfCtuEnableFlags( cs, COMPONENT_Y, alfParam );
+    }
+  }
+  else
+  {
+    if (alfParam->enabledFlag[COMPONENT_Cb])
+    {
+      codeAlfCtuEnableFlags( cs, COMPONENT_Cb, alfParam );
+    }
+    if (alfParam->enabledFlag[COMPONENT_Cr])
+    {
+      codeAlfCtuEnableFlags( cs, COMPONENT_Cr, alfParam );
+    }
+  }
+}
+void CABACWriter::codeAlfCtuEnableFlags( CodingStructure& cs, ComponentID compID, AlfParam* alfParam)
+{
+  uint32_t numCTUs = cs.pcv->sizeInCtus;
+
+  for( int ctuIdx = 0; ctuIdx < numCTUs; ctuIdx++ )
+  {
+    codeAlfCtuEnableFlag( cs, ctuIdx, compID, alfParam );
+  }
+}
+
+void CABACWriter::codeAlfCtuEnableFlag( CodingStructure& cs, uint32_t ctuRsAddr, const int compIdx, AlfParam* alfParam)
+{
+  const bool alfComponentEnabled =
+    (alfParam != nullptr) ? alfParam->enabledFlag[compIdx] : cs.slice->getAlfEnabledFlag((ComponentID) compIdx);
+
+  if( cs.sps->getALFEnabledFlag() && alfComponentEnabled )
+  {
+    const PreCalcValues& pcv = *cs.pcv;
+
+    const int frameWidthInCtus = pcv.widthInCtus;
+
+    const int ry = ctuRsAddr / frameWidthInCtus;
+    const int rx = ctuRsAddr - ry * frameWidthInCtus;
+
+    const Position pos(rx * cs.pcv->maxCUWidth, ry * cs.pcv->maxCUHeight);
+
+    const uint32_t curSliceIdx = cs.slice->getIndependentSliceIdx();
+    const uint32_t curTileIdx  = cs.pps->getTileIdx(pos);
+
+    const bool leftAvail =
+      cs.getCURestricted(pos.offset(-(int) pcv.maxCUWidth, 0), pos, curSliceIdx, curTileIdx, ChannelType::LUMA)
+      != nullptr;
+    const bool aboveAvail =
+      cs.getCURestricted(pos.offset(0, -(int) pcv.maxCUHeight), pos, curSliceIdx, curTileIdx, ChannelType::LUMA)
+      != nullptr;
+
+    const int leftCTUAddr  = leftAvail ? ctuRsAddr - 1 : -1;
+    const int aboveCTUAddr = aboveAvail ? ctuRsAddr - frameWidthInCtus : -1;
+
+    AlfMode *alfModes = cs.slice->getPic()->getAlfModes(compIdx);
+    int ctx = 0;
+    ctx += leftCTUAddr > -1 ? (alfModes[leftCTUAddr] != AlfMode::OFF ? 1 : 0) : 0;
+    ctx += aboveCTUAddr > -1 ? (alfModes[aboveCTUAddr] != AlfMode::OFF ? 1 : 0) : 0;
+    m_binEncoder.encodeBin(alfModes[ctuRsAddr] != AlfMode::OFF, Ctx::alfCtbFlag(compIdx * 3 + ctx));
+  }
+}
+
+void CABACWriter::codeCcAlfFilterControlIdc(uint8_t idcVal, CodingStructure &cs, const ComponentID compID,
+                                            const int curIdx, const uint8_t *filterControlIdc, Position lumaPos,
+                                            const int filterCount)
+{
+  CHECK(idcVal > filterCount, "Filter index is too large");
+
+  const uint32_t curSliceIdx    = cs.slice->getIndependentSliceIdx();
+  const uint32_t curTileIdx     = cs.pps->getTileIdx( lumaPos );
+  Position       leftLumaPos    = lumaPos.offset(-(int)cs.pcv->maxCUWidth, 0);
+  Position       aboveLumaPos   = lumaPos.offset(0, -(int)cs.pcv->maxCUWidth);
+  bool leftAvail = cs.getCURestricted(leftLumaPos, lumaPos, curSliceIdx, curTileIdx, ChannelType::LUMA) ? true : false;
+  bool aboveAvail =
+    cs.getCURestricted(aboveLumaPos, lumaPos, curSliceIdx, curTileIdx, ChannelType::LUMA) ? true : false;
+  int            ctxt           = 0;
+
+  if (leftAvail)
+  {
+    ctxt += ( filterControlIdc[curIdx - 1]) ? 1 : 0;
+  }
+  if (aboveAvail)
+  {
+    ctxt += (filterControlIdc[curIdx - cs.pcv->widthInCtus]) ? 1 : 0;
+  }
+  ctxt += ( compID == COMPONENT_Cr ) ? 3 : 0;
+
+  m_binEncoder.encodeBin((idcVal == 0) ? 0 : 1, Ctx::CcAlfFilterControlFlag(ctxt));   // ON/OFF flag is context coded
+  if ( idcVal > 0 )
+  {
+    int val = (idcVal - 1);
+    while ( val )
+    {
+      m_binEncoder.encodeBinEP(1);
+      val--;
+    }
+    if ( idcVal < filterCount )
+    {
+      m_binEncoder.encodeBinEP(0);
+    }
+  }
+  DTRACE( g_trace_ctx, D_SYNTAX, "ccAlfFilterControlIdc() compID=%d pos=(%d,%d) ctxt=%d, filterCount=%d, idcVal=%d\n", compID, lumaPos.x, lumaPos.y, ctxt, filterCount, idcVal );
+}
+
+void CABACWriter::mip_flag( const CodingUnit& cu )
+{
+  if( !cu.Y().valid() )
+  {
+    return;
+  }
+  if( !cu.cs->sps->getUseMIP() )
+  {
+    return;
+  }
+
+  unsigned ctxId = DeriveCtx::CtxMipFlag( cu );
+  m_binEncoder.encodeBin(cu.mipFlag, Ctx::MipFlag(ctxId));
+  DTRACE( g_trace_ctx, D_SYNTAX, "mip_flag() pos=(%d,%d) mode=%d\n", cu.lumaPos().x, cu.lumaPos().y, cu.mipFlag ? 1 : 0 );
+}
+
+void CABACWriter::mip_pred_modes( const CodingUnit& cu )
+{
+  if( !cu.Y().valid() )
+  {
+    return;
+  }
+  for( const auto &pu : CU::traversePUs( cu ) )
+  {
+    mip_pred_mode( pu );
+  }
+}
+
+void CABACWriter::mip_pred_mode( const PredictionUnit& pu )
+{
+  m_binEncoder.encodeBinEP((pu.mipTransposedFlag ? 1 : 0));
+
+  const int numModes = 1; //MatrixIntraPrediction::getNumModesMip(pu.Y());
+  CHECKD(pu.intraDir[ChannelType::LUMA] < 0 || pu.intraDir[ChannelType::LUMA] >= numModes, "Invalid MIP mode");
+  xWriteTruncBinCode(pu.intraDir[ChannelType::LUMA], numModes);
+
+  DTRACE(g_trace_ctx, D_SYNTAX, "mip_pred_mode() pos=(%d,%d) mode=%d transposed=%d\n", pu.lumaPos().x, pu.lumaPos().y,
+         pu.intraDir[ChannelType::LUMA], pu.mipTransposedFlag ? 1 : 0);
+}
+
+void CABACWriter::codeAlfCtuFilterIndex(CodingStructure& cs, uint32_t ctuRsAddr, bool alfEnableLuma)
+{
+  if (!cs.sps->getALFEnabledFlag() || !alfEnableLuma)
+  {
+    return;
+  }
+
+  AlfMode *alfModes = cs.slice->getPic()->getAlfModes(COMPONENT_Y);
+
+  AlfMode m = alfModes[ctuRsAddr];
+  if (m == AlfMode::OFF)
+  {
+    return;
+  }
+
+  const int numAps = cs.slice->getNumAlfApsIdsLuma();
+
+  const bool alfUseApsFlag = !isAlfLumaFixed(m);
+
+  if (numAps > 0)
+  {
+    m_binEncoder.encodeBin(alfUseApsFlag ? 1 : 0, Ctx::alfUseApsFlag());
+  }
+  if (alfUseApsFlag)
+  {
+    const uint32_t alfLumaPrevFilterIdx = m - AlfMode::LUMA0;
+    CHECK(alfLumaPrevFilterIdx >= numAps, "alfLumaPrevFilterIdx is too large");
+
+    if (numAps > 1)
+    {
+      xWriteTruncBinCode(alfLumaPrevFilterIdx, numAps);
+    }
+  }
+  else
+  {
+    const uint32_t alfLumaFixedFilterIdx = m - AlfMode::LUMA_FIXED0;
+    xWriteTruncBinCode(alfLumaFixedFilterIdx, ALF_NUM_FIXED_FILTER_SETS);
+  }
+}
+
+void CABACWriter::codeAlfCtuAlternatives( CodingStructure& cs, ChannelType channel, AlfParam* alfParam)
+{
+  if( isChroma( channel ) )
+  {
+    if (alfParam->enabledFlag[COMPONENT_Cb])
+    {
+      codeAlfCtuAlternatives( cs, COMPONENT_Cb, alfParam );
+    }
+    if (alfParam->enabledFlag[COMPONENT_Cr])
+    {
+      codeAlfCtuAlternatives( cs, COMPONENT_Cr, alfParam );
+    }
+  }
+}
+
+void CABACWriter::codeAlfCtuAlternatives( CodingStructure& cs, ComponentID compID, AlfParam* alfParam)
+{
+  if( compID == COMPONENT_Y )
+  {
+    return;
+  }
+  uint32_t numCTUs = cs.pcv->sizeInCtus;
+  AlfMode *alfModes = cs.slice->getPic()->getAlfModes(compID);
+
+  for( int ctuIdx = 0; ctuIdx < numCTUs; ctuIdx++ )
+  {
+    if (alfModes[ctuIdx] != AlfMode::OFF)
+    {
+      codeAlfCtuAlternative( cs, ctuIdx, compID, alfParam );
+    }
+  }
+}
+
+void CABACWriter::codeAlfCtuAlternative( CodingStructure& cs, uint32_t ctuRsAddr, const int compIdx, const AlfParam* alfParam)
+{
+  if( compIdx == COMPONENT_Y )
+  {
+    return;
+  }
+  int apsIdx = alfParam ? 0 : cs.slice->getAlfApsIdChroma();
+  const AlfParam& alfParamRef = alfParam ? (*alfParam) : cs.slice->getAlfAPSs()[apsIdx]->getAlfAPSParam();
+
+  if( alfParam || (cs.sps->getALFEnabledFlag() && cs.slice->getAlfEnabledFlag( (ComponentID)compIdx )) )
+  {
+    AlfMode *alfModes = cs.slice->getPic()->getAlfModes(compIdx);
+
+    if (alfModes[ctuRsAddr] != AlfMode::OFF)
+    {
+      const int numAlts = alfParamRef.numAlternativesChroma;
+      const int numOnes = alfModes[ctuRsAddr] - AlfMode::CHROMA0;
+      CHECK(numOnes >= numAlts, "Invalid ALF mode");
+      for( int i = 0; i < numOnes; ++i )
+      {
+        m_binEncoder.encodeBin(1, Ctx::ctbAlfAlternative(compIdx - 1));
+      }
+      if( numOnes < numAlts-1 )
+      {
+        m_binEncoder.encodeBin(0, Ctx::ctbAlfAlternative(compIdx - 1));
+      }
+    }
+  }
+}
+
+void CABACWriter::rewrite (bool isFirCtu, CodingUnit &cu)
+{
+  if (isFirCtu) 
+  {
+    m_binEncoder.encodeBin(0, Ctx::SaoTypeIdx());
+    m_binEncoder.encodeBin(0, Ctx::SaoTypeIdx());
+  }
+  else
+    m_binEncoder.encodeBin(1, Ctx::SaoMergeFlag());
+  unsigned ctxId;
+  m_binEncoder.encodeBin(0, Ctx::SplitFlag(3));
+  //TODO: cu_skip_flag
+  ctxId = DeriveCtx::CtxSkipFlag1( cu );
+  m_binEncoder.encodeBin((cu.skip), Ctx::SkipFlag(ctxId));
+
+  // ctxId = DeriveCtx::CtxAffineFlag( cu );
+  m_binEncoder.encodeBin(0, Ctx::SubblockMergeFlag(0));
+
+  m_binEncoder.encodeBin(0, Ctx::MmvdFlag(0));
+  m_binEncoder.encodeBin(0, Ctx::MergeIdx());
+}
+
+
+//! \}
diff --git a/source/Lib/SkipLib/CABACWriter.h b/source/Lib/SkipLib/CABACWriter.h
new file mode 100644
index 00000000..15102d9b
--- /dev/null
+++ b/source/Lib/SkipLib/CABACWriter.h
@@ -0,0 +1,223 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     CABACWriter.h
+ *  \brief    Writer for low level syntax
+ */
+
+#ifndef __CABACWRITER__
+#define __CABACWRITER__
+
+#include "CommonLib/BitStream.h"
+#include "CommonLib/ContextModelling.h"
+#include "BinEncoder.h"
+
+
+//! \ingroup EncoderLib
+//! \{
+
+
+class EncCu;
+class CABACWriter
+{
+public:
+  CABACWriter(BinEncIf &binEncoder) : m_binEncoder(binEncoder), m_bitstream(nullptr)
+  {
+    m_testCtx = m_binEncoder.getCtx();
+    m_encCu   = nullptr;
+  }
+  virtual ~CABACWriter() {}
+
+public:
+  void        initCtxModels             ( const Slice&                  slice );
+  void        setEncCu(EncCu *pcEncCu) { m_encCu = pcEncCu; }
+  SliceType   getCtxInitId              ( const Slice&                  slice );
+  void        initBitstream(OutputBitstream *bitstream)
+  {
+    m_bitstream = bitstream;
+    m_binEncoder.init(m_bitstream);
+  }
+
+  const Ctx &getCtx() const { return m_binEncoder.getCtx(); }
+  Ctx       &getCtx() { return m_binEncoder.getCtx(); }
+
+  void     start() { m_binEncoder.start(); }
+  void     resetBits() { m_binEncoder.resetBits(); }
+  uint64_t getEstFracBits() const { return m_binEncoder.getEstFracBits(); }
+  uint32_t getNumBins() { return m_binEncoder.getNumBins(); }
+  bool     isEncoding() { return m_binEncoder.isEncoding(); }
+
+public:
+  // slice segment data (clause 7.3.8.1)
+  void        end_of_slice              ();
+
+  // coding tree unit (clause 7.3.8.2)
+  void coding_tree_unit(CodingStructure &cs, const UnitArea &area, EnumArray<int, ChannelType> &qps, unsigned ctuRsAddr,
+                        bool skipSao = false, bool skipAlf = false);
+
+  // sao (clause 7.3.8.3)
+  void        sao                       ( const Slice&                  slice,    unsigned          ctuRsAddr );
+  void        sao_block_params(const SAOBlkParam &saoPars, const BitDepths &bitDepths, const bool *sliceEnabled,
+                               bool leftMergeAvail, bool aboveMergeAvail, bool onlyEstMergeInfo);
+  void        sao_offset_params(const SAOOffset &ctbPars, ComponentID compID, bool sliceEnabled, int bitDepth);
+  // coding (quad)tree (clause 7.3.8.4)
+  void        coding_tree               ( const CodingStructure&        cs,       Partitioner&      pm,         CUCtx& cuCtx, Partitioner* pPartitionerChroma = nullptr, CUCtx* pCuCtxChroma = nullptr);
+  void        split_cu_mode             ( const PartSplit               split,    const CodingStructure& cs,    Partitioner& pm );
+  void        mode_constraint           ( const PartSplit               split,    const CodingStructure& cs,    Partitioner& pm,    const ModeType modeType );
+
+  // coding unit (clause 7.3.8.5)
+  void        coding_unit               ( const CodingUnit&             cu,       Partitioner&      pm,         CUCtx& cuCtx );
+  void        cu_skip_flag              ( const CodingUnit&             cu );
+  void        pred_mode                 ( const CodingUnit&             cu );
+  void        bdpcm_mode                ( const CodingUnit&             cu,       const ComponentID compID );
+
+  void        cu_pred_data              ( const CodingUnit&             cu );
+  void        cu_bcw_flag               ( const CodingUnit&             cu );
+  void        extend_ref_line           (const PredictionUnit&          pu );
+  void        extend_ref_line           (const CodingUnit&              cu );
+  void        intra_luma_pred_modes     ( const CodingUnit&             cu );
+  void        intra_luma_pred_mode      ( const PredictionUnit&         pu );
+  void        intra_chroma_pred_modes   ( const CodingUnit&             cu );
+  void        intra_chroma_lmc_mode     ( const PredictionUnit&         pu );
+  void        intra_chroma_pred_mode    ( const PredictionUnit&         pu );
+  void        cu_residual               ( const CodingUnit&             cu,       Partitioner&      pm,         CUCtx& cuCtx );
+  void        rqt_root_cbf              ( const CodingUnit&             cu );
+  void        adaptive_color_transform(const CodingUnit&             cu);
+  void        sbt_mode                  ( const CodingUnit&             cu );
+  void        end_of_ctu                ( const CodingUnit&             cu,       CUCtx&            cuCtx );
+  void        mip_flag                  ( const CodingUnit&             cu );
+  void        mip_pred_modes            ( const CodingUnit&             cu );
+  void        mip_pred_mode             ( const PredictionUnit&         pu );
+  void        cu_palette_info           ( const CodingUnit&             cu,       ComponentID       compBegin,     uint32_t numComp,          CUCtx&       cuCtx);
+  void        cuPaletteSubblockInfo     ( const CodingUnit&             cu,       ComponentID       compBegin,     uint32_t numComp,          int subSetId,               uint32_t& prevRunPos,        unsigned& prevRunType );
+  Pel         writePLTIndex             ( const CodingUnit&             cu,       uint32_t          idx,           PelBuf&  paletteIdx,       PLTtypeBuf&  paletteRunType, int         maxSymbol,   ComponentID compBegin );
+  // prediction unit (clause 7.3.8.6)
+  void        prediction_unit           ( const PredictionUnit&         pu );
+  void        merge_flag                ( const PredictionUnit&         pu );
+  void        merge_data                ( const PredictionUnit&         pu );
+  void        affine_flag               ( const CodingUnit&             cu );
+  void        subblock_merge_flag       ( const CodingUnit&             cu );
+  void        merge_idx                 ( const PredictionUnit&         pu );
+  void        mmvd_merge_idx(const PredictionUnit&         pu);
+  void        imv_mode                  ( const CodingUnit&             cu );
+  void        affine_amvr_mode          ( const CodingUnit&             cu );
+  void        inter_pred_idc            ( const PredictionUnit&         pu );
+  void        ref_idx                   ( const PredictionUnit&         pu,       RefPicList        eRefList );
+  void        mvp_flag                  ( const PredictionUnit&         pu,       RefPicList        eRefList );
+
+  void        ciip_flag(const PredictionUnit &pu);
+  void        smvd_mode              ( const PredictionUnit&         pu );
+
+
+  // transform tree (clause 7.3.8.8)
+  void        transform_tree            ( const CodingStructure&        cs,       Partitioner&      pm,     CUCtx& cuCtx,                         const PartSplit ispType = TU_NO_ISP, const int subTuIdx = -1 );
+  void cbf_comp(bool cbf, const CompArea &area, unsigned depth, bool prevCbf, bool useISP, BdpcmMode bdpcmMode);
+
+  // mvd coding (clause 7.3.8.9)
+  void        mvd_coding                ( const PredictionUnit& pu, Mv mvd, int amvr );
+  // transform unit (clause 7.3.8.10)
+  void        transform_unit            ( const TransformUnit&          tu,       CUCtx&            cuCtx,  Partitioner& pm,       const int subTuCounter = -1 );
+  void        cu_qp_delta               ( const CodingUnit&             cu,       int               predQP, const int8_t qp );
+  void        cu_chroma_qp_offset       ( const CodingUnit&             cu );
+
+  // residual coding (clause 7.3.8.11)
+  void        residual_coding           ( const TransformUnit&          tu,       ComponentID       compID, CUCtx* cuCtx = nullptr );
+  void        ts_flag                   ( const TransformUnit&          tu,       ComponentID       compID );
+  void        mts_idx                   ( const CodingUnit&             cu,       CUCtx*            cuCtx  );
+  void        residual_lfnst_mode       ( const CodingUnit&             cu,       CUCtx&            cuCtx );
+  void        isp_mode                  ( const CodingUnit&             cu );
+  void        last_sig_coeff            ( CoeffCodingContext&           cctx,     const TransformUnit& tu, ComponentID       compID );
+  void        residual_coding_subblock  ( CoeffCodingContext&           cctx,     const TCoeff*     coeff, const int stateTransTable, int& state );
+  void        residual_codingTS         ( const TransformUnit&          tu,       ComponentID       compID );
+  void        residual_coding_subblockTS( CoeffCodingContext&           cctx,     const TCoeff*     coeff, unsigned (&RiceBit)[8], int riceParam, bool ricePresentFlag);
+  void        joint_cb_cr               ( const TransformUnit&          tu,       const int cbfMask );
+
+
+  void        codeAlfCtuEnableFlags     ( CodingStructure& cs, ChannelType channel, AlfParam* alfParam);
+  void        codeAlfCtuEnableFlags     ( CodingStructure& cs, ComponentID compID, AlfParam* alfParam);
+  void        codeAlfCtuEnableFlag      ( CodingStructure& cs, uint32_t ctuRsAddr, const int compIdx, AlfParam* alfParam );
+  void        codeAlfCtuFilterIndex(CodingStructure& cs, uint32_t ctuRsAddr, bool alfEnableLuma);
+
+  void        codeAlfCtuAlternatives     ( CodingStructure& cs, ChannelType channel, AlfParam* alfParam);
+  void        codeAlfCtuAlternatives     ( CodingStructure& cs, ComponentID compID, AlfParam* alfParam);
+  void        codeAlfCtuAlternative(CodingStructure &cs, uint32_t ctuRsAddr, const int compIdx,
+                                    const AlfParam *alfParam = nullptr);
+  void codeCcAlfFilterControlIdc(uint8_t idcVal, CodingStructure &cs, const ComponentID compID, const int curIdx,
+                                 const uint8_t *filterControlIdc, Position lumaPos, const int filterCount);
+
+  void        rewrite (bool isFirCtu, CodingUnit &cu);
+
+private:
+  void        unary_max_symbol          ( unsigned symbol, unsigned ctxId0, unsigned ctxIdN, unsigned maxSymbol );
+  void        unary_max_eqprob          ( unsigned symbol,                                   unsigned maxSymbol );
+  void        exp_golomb_eqprob         ( unsigned symbol, unsigned count );
+
+  void        xWriteTruncBinCode(uint32_t symbol, uint32_t numSymbols);
+  void        codeScanRotationModeFlag   ( const CodingUnit& cu,     ComponentID compBegin);
+  void        xEncodePLTPredIndicator    ( const CodingUnit& cu,     uint32_t    maxPltSize, ComponentID compBegin);
+private:
+  BinEncIf         &m_binEncoder;
+  OutputBitstream  *m_bitstream;
+  Ctx               m_testCtx;
+  EncCu            *m_encCu;
+  ScanElement*      m_scanOrder;
+};
+
+
+
+class CABACEncoder
+{
+public:
+  CABACEncoder()
+    : m_CABACWriterStd(m_BinEncoderStd)
+    , m_CABACEstimatorStd(m_BitEstimatorStd)
+    , m_CABACWriter{ &m_CABACWriterStd }
+    , m_CABACEstimator{ &m_CABACEstimatorStd }
+  {}
+
+  CABACWriter *getCABACWriter(const SPS *sps) { return m_CABACWriter[BpmType::STD]; }
+  CABACWriter *getCABACEstimator(const SPS *sps) { return m_CABACEstimator[BpmType::STD]; }
+
+private:
+  BinEncoder_Std      m_BinEncoderStd;
+  BitEstimator_Std    m_BitEstimatorStd;
+  CABACWriter         m_CABACWriterStd;
+  CABACWriter         m_CABACEstimatorStd;
+
+  EnumArray<CABACWriter *, BpmType> m_CABACWriter;
+  EnumArray<CABACWriter *, BpmType> m_CABACEstimator;
+};
+
+//! \}
+
+#endif //__CABACWRITER__
diff --git a/source/Lib/SkipLib/CMakeLists.txt b/source/Lib/SkipLib/CMakeLists.txt
new file mode 100644
index 00000000..12121fee
--- /dev/null
+++ b/source/Lib/SkipLib/CMakeLists.txt
@@ -0,0 +1,46 @@
+# library
+set( LIB_NAME SkipLib )
+
+# get source files
+file( GLOB SRC_FILES "*.cpp" )
+
+# get include files
+file( GLOB INC_FILES "*.h" )
+
+# NATVIS files for Visual Studio
+if( MSVC )
+  file( GLOB NATVIS_FILES "../../VisualStudio/*.natvis" )
+endif()
+
+# library
+add_library( ${LIB_NAME} STATIC ${SRC_FILES} ${INC_FILES} ${NATVIS_FILES} )
+target_compile_definitions( ${LIB_NAME} PUBLIC )
+
+if( EXTENSION_360_VIDEO )
+  target_compile_definitions( ${LIB_NAME} PUBLIC EXTENSION_360_VIDEO=1 )
+endif()
+  
+if( DEFINED ENABLE_TRACING )
+  if( ENABLE_TRACING )
+    target_compile_definitions( ${LIB_NAME} PUBLIC ENABLE_TRACING=1 )
+  else()
+    target_compile_definitions( ${LIB_NAME} PUBLIC ENABLE_TRACING=0 )
+  endif()
+endif()
+
+if( DEFINED ENABLE_HIGH_BITDEPTH )
+  if( ENABLE_HIGH_BITDEPTH )
+    target_compile_definitions( ${LIB_NAME} PUBLIC RExt__HIGH_BIT_DEPTH_SUPPORT=1 )
+  else()
+    target_compile_definitions( ${LIB_NAME} PUBLIC RExt__HIGH_BIT_DEPTH_SUPPORT=0 )
+  endif()
+endif()
+
+target_include_directories( ${LIB_NAME} PUBLIC . )
+target_link_libraries( ${LIB_NAME} CommonLib )
+
+# example: place header files in different folders
+source_group( "Natvis Files" FILES ${NATVIS_FILES} )
+
+# set the folder where to place the projects
+set_target_properties( ${LIB_NAME} PROPERTIES FOLDER lib )
diff --git a/source/Lib/SkipLib/DecCu.cpp b/source/Lib/SkipLib/DecCu.cpp
new file mode 100644
index 00000000..89727033
--- /dev/null
+++ b/source/Lib/SkipLib/DecCu.cpp
@@ -0,0 +1,1021 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     DecCu.cpp
+    \brief    CU decoder class
+*/
+
+#include "DecCu.h"
+
+#include "CommonLib/InterPrediction.h"
+#include "CommonLib/IntraPrediction.h"
+#include "CommonLib/Picture.h"
+#include "CommonLib/UnitTools.h"
+
+#include "CommonLib/dtrace_buffer.h"
+
+#if RExt__DECODER_DEBUG_TOOL_STATISTICS
+#include "CommonLib/CodingStatistics.h"
+#endif
+#if K0149_BLOCK_STATISTICS
+#include "CommonLib/ChromaFormat.h"
+#include "CommonLib/dtrace_blockstatistics.h"
+#endif
+
+//! \ingroup DecoderLib
+//! \{
+
+// ====================================================================================================================
+// Constructor / destructor / create / destroy
+// ====================================================================================================================
+
+DecCu::DecCu() : m_tmpStorageCtu(nullptr) {}
+
+DecCu::~DecCu()
+{
+}
+
+void DecCu::init( TrQuant* pcTrQuant, IntraPrediction* pcIntra, InterPrediction* pcInter)
+{
+  m_pcTrQuant       = pcTrQuant;
+  m_pcIntraPred     = pcIntra;
+  m_pcInterPred     = pcInter;
+}
+
+void DecCu::initDecCuReshaper(Reshape* pcReshape, ChromaFormat chromaFormatIdc)
+{
+  m_pcReshape = pcReshape;
+  if (m_tmpStorageCtu == nullptr)
+  {
+    m_tmpStorageCtu = new PelStorage;
+    m_tmpStorageCtu->create(UnitArea(chromaFormatIdc, Area(0, 0, MAX_CU_SIZE, MAX_CU_SIZE)));
+  }
+
+}
+void DecCu::destoryDecCuReshaprBuf()
+{
+  if (m_tmpStorageCtu)
+  {
+    m_tmpStorageCtu->destroy();
+    delete m_tmpStorageCtu;
+    m_tmpStorageCtu = nullptr;
+  }
+}
+
+// ====================================================================================================================
+// Public member functions
+// ====================================================================================================================
+
+void DecCu::decompressCtu( CodingStructure& cs, const UnitArea& ctuArea )
+{
+  const int maxNumChannelType = isChromaEnabled(cs.pcv->chrFormat) && CS::isDualITree(cs) ? 2 : 1;
+
+  if (cs.resetIBCBuffer)
+  {
+    m_pcInterPred->resetIBCBuffer(cs.pcv->chrFormat, cs.slice->getSPS()->getMaxCUHeight());
+    cs.resetIBCBuffer = false;
+  }
+  for( int ch = 0; ch < maxNumChannelType; ch++ )
+  {
+    const ChannelType chType = ChannelType( ch );
+    Position prevTmpPos;
+    prevTmpPos.x = -1; prevTmpPos.y = -1;
+
+    for( auto &currCU : cs.traverseCUs( CS::getArea( cs, ctuArea, chType ), chType ) )
+    {
+      if(currCU.Y().valid())
+      {
+        const int vSize = std::min<int>(VPDU_SIZE, cs.slice->getSPS()->getMaxCUHeight());
+        if((currCU.Y().x % vSize) == 0 && (currCU.Y().y % vSize) == 0)
+        {
+          for(int x = currCU.Y().x; x < currCU.Y().x + currCU.Y().width; x += vSize)
+          {
+            for(int y = currCU.Y().y; y < currCU.Y().y + currCU.Y().height; y += vSize)
+            {
+              m_pcInterPred->resetVPDUforIBC(cs.pcv->chrFormat, cs.slice->getSPS()->getMaxCUHeight(), vSize,
+                                             x + IBC_BUFFER_SIZE / cs.slice->getSPS()->getMaxCUHeight() / 2, y);
+            }
+          }
+        }
+      }
+      if (!CU::isIntra(currCU) && !CU::isPLT(currCU) && currCU.Y().valid())
+      {
+        xDeriveCuMvs(currCU);
+#if K0149_BLOCK_STATISTICS
+        if(currCU.geoFlag)
+        {
+          storeGeoMergeCtx(m_geoMrgCtx);
+        }
+#endif
+      }
+      switch( currCU.predMode )
+      {
+      case MODE_INTER:
+      case MODE_IBC:
+        xReconInter( currCU );
+        break;
+      case MODE_PLT:
+      case MODE_INTRA:
+        xReconIntraQT( currCU );
+        break;
+      default:
+        THROW( "Invalid prediction mode" );
+        break;
+      }
+
+      m_pcInterPred->xFillIBCBuffer(currCU);
+
+      DTRACE_BLOCK_REC( cs.picture->getRecoBuf( currCU ), currCU, currCU.predMode );
+    }
+  }
+#if K0149_BLOCK_STATISTICS
+  getAndStoreBlockStatistics(cs, ctuArea);
+#endif
+}
+
+// ====================================================================================================================
+// Protected member functions
+// ====================================================================================================================
+
+void DecCu::xIntraRecBlk( TransformUnit& tu, const ComponentID compID )
+{
+  if( !tu.blocks[ compID ].valid() )
+  {
+    return;
+  }
+
+        CodingStructure &cs = *tu.cs;
+  const CompArea &area      = tu.blocks[compID];
+
+  const ChannelType chType  = toChannelType( compID );
+
+        PelBuf piPred       = cs.getPredBuf( area );
+
+  const PredictionUnit &pu  = *tu.cs->getPU( area.pos(), chType );
+
+  const uint32_t chFinalMode = PU::getFinalIntraMode(pu, chType);
+  PelBuf         pReco       = cs.getRecoBuf(area);
+
+  //===== init availability pattern =====
+  bool predRegDiffFromTB = CU::isPredRegDiffFromTB(*tu.cu, compID);
+  bool firstTBInPredReg = CU::isFirstTBInPredReg(*tu.cu, compID, area);
+  CompArea areaPredReg(COMPONENT_Y, tu.chromaFormat, area);
+  if (tu.cu->ispMode != ISPType::NONE && isLuma(compID))
+  {
+    if (predRegDiffFromTB)
+    {
+      if (firstTBInPredReg)
+      {
+        CU::adjustPredArea(areaPredReg);
+        m_pcIntraPred->initIntraPatternChTypeISP(*tu.cu, areaPredReg, pReco);
+      }
+    }
+    else
+    {
+      m_pcIntraPred->initIntraPatternChTypeISP(*tu.cu, area, pReco);
+    }
+  }
+  else
+  {
+    m_pcIntraPred->initIntraPatternChType(*tu.cu, area);
+  }
+
+  //===== get prediction signal =====
+  if (compID != COMPONENT_Y && PU::isLMCMode(chFinalMode))
+  {
+    const PredictionUnit& pu = *tu.cu->firstPU;
+    m_pcIntraPred->xGetLumaRecPixels( pu, area );
+    m_pcIntraPred->predIntraChromaLM(compID, piPred, pu, area, chFinalMode);
+  }
+  else
+  {
+    if( PU::isMIP( pu, chType ) )
+    {
+      m_pcIntraPred->initIntraMip( pu, area );
+      m_pcIntraPred->predIntraMip( compID, piPred, pu );
+    }
+    else
+    {
+      if (predRegDiffFromTB)
+      {
+        if (firstTBInPredReg)
+        {
+          PelBuf piPredReg = cs.getPredBuf(areaPredReg);
+          m_pcIntraPred->predIntraAng(compID, piPredReg, pu);
+        }
+      }
+      else
+      {
+        m_pcIntraPred->predIntraAng(compID, piPred, pu);
+      }
+    }
+  }
+  const Slice           &slice = *cs.slice;
+  bool flag = slice.getLmcsEnabledFlag() && (slice.isIntra() || (!slice.isIntra() && m_pcReshape->getCTUFlag()));
+  if (flag && slice.getPicHeader()->getLmcsChromaResidualScaleFlag() && (compID != COMPONENT_Y) && (tu.cbf[COMPONENT_Cb] || tu.cbf[COMPONENT_Cr]))
+  {
+    const Area      area  = tu.Y().valid()
+                              ? tu.Y()
+                              : Area(recalcPosition(tu.chromaFormat, tu.chType, ChannelType::LUMA, tu.block(tu.chType).pos()),
+                                     recalcSize(tu.chromaFormat, tu.chType, ChannelType::LUMA, tu.block(tu.chType).size()));
+    const CompArea &areaY = CompArea(COMPONENT_Y, tu.chromaFormat, area);
+    int adj = m_pcReshape->calculateChromaAdjVpduNei(tu, areaY);
+    tu.setChromaAdj(adj);
+  }
+  //===== inverse transform =====
+  PelBuf piResi = cs.getResiBuf( area );
+
+  const QpParam cQP( tu, compID );
+
+  if( tu.jointCbCr && isChroma(compID) )
+  {
+    if( compID == COMPONENT_Cb )
+    {
+      PelBuf resiCr = cs.getResiBuf( tu.blocks[ COMPONENT_Cr ] );
+      if( tu.jointCbCr >> 1 )
+      {
+        m_pcTrQuant->invTransformNxN( tu, COMPONENT_Cb, piResi, cQP );
+      }
+      else
+      {
+        const QpParam qpCr( tu, COMPONENT_Cr );
+        m_pcTrQuant->invTransformNxN( tu, COMPONENT_Cr, resiCr, qpCr );
+      }
+      m_pcTrQuant->invTransformICT( tu, piResi, resiCr );
+    }
+  }
+  else if (TU::getCbf(tu, compID))
+  {
+    m_pcTrQuant->invTransformNxN( tu, compID, piResi, cQP );
+  }
+  else
+  {
+    piResi.fill( 0 );
+  }
+
+  //===== reconstruction =====
+  flag = flag && (tu.blocks[compID].width*tu.blocks[compID].height > 4);
+  if (flag && (TU::getCbf(tu, compID) || tu.jointCbCr) && isChroma(compID) && slice.getPicHeader()->getLmcsChromaResidualScaleFlag())
+  {
+    piResi.scaleSignal(tu.getChromaAdj(), 0, tu.cu->cs->slice->clpRng(compID));
+  }
+
+  if (tu.cu->ispMode == ISPType::NONE || !isLuma(compID))
+  {
+    cs.setDecomp( area );
+  }
+  else if (tu.cu->ispMode != ISPType::NONE && isLuma(compID) && CU::isISPFirst(*tu.cu, tu.blocks[compID], compID))
+  {
+    cs.setDecomp( tu.cu->blocks[compID] );
+  }
+
+#if REUSE_CU_RESULTS
+  CompArea    tmpArea(COMPONENT_Y, area.chromaFormat, Position(0, 0), area.size());
+  PelBuf tmpPred;
+#endif
+  if (slice.getLmcsEnabledFlag() && (m_pcReshape->getCTUFlag() || slice.isIntra()) && compID == COMPONENT_Y)
+  {
+#if REUSE_CU_RESULTS
+    tmpPred = m_tmpStorageCtu->getBuf(tmpArea);
+    tmpPred.copyFrom(piPred);
+#endif
+  }
+#if KEEP_PRED_AND_RESI_SIGNALS
+  pReco.reconstruct( piPred, piResi, tu.cu->cs->slice->clpRng( compID ) );
+#else
+  piPred.reconstruct(piPred, piResi, tu.cu->cs->slice->clpRng(compID));
+  pReco.copyFrom( piPred );
+#endif
+  if (slice.getLmcsEnabledFlag() && (m_pcReshape->getCTUFlag() || slice.isIntra()) && compID == COMPONENT_Y)
+  {
+#if REUSE_CU_RESULTS
+    piPred.copyFrom(tmpPred);
+#endif
+  }
+#if REUSE_CU_RESULTS
+  if( cs.pcv->isEncoder )
+  {
+    cs.picture->getRecoBuf( area ).copyFrom( pReco );
+    cs.picture->getPredBuf(area).copyFrom(piPred);
+  }
+#endif
+}
+
+void DecCu::xIntraRecACTBlk(TransformUnit& tu)
+{
+  CodingStructure      &cs = *tu.cs;
+  const PredictionUnit &pu    = *tu.cs->getPU(tu.blocks[COMPONENT_Y], ChannelType::LUMA);
+  const Slice          &slice = *cs.slice;
+
+  CHECK(!tu.Y().valid() || !tu.Cb().valid() || !tu.Cr().valid(), "Invalid TU");
+  CHECK(&pu != tu.cu->firstPU, "wrong PU fetch");
+  CHECK(tu.cu->ispMode != ISPType::NONE, "adaptive color transform cannot be applied to ISP");
+  CHECK(pu.intraDir[ChannelType::CHROMA] != DM_CHROMA_IDX, "chroma should use DM mode for adaptive color transform");
+
+  bool flag = slice.getLmcsEnabledFlag() && (slice.isIntra() || (!slice.isIntra() && m_pcReshape->getCTUFlag()));
+  if (flag && slice.getPicHeader()->getLmcsChromaResidualScaleFlag())
+  {
+    const Area      area  = tu.Y().valid()
+                              ? tu.Y()
+                              : Area(recalcPosition(tu.chromaFormat, tu.chType, ChannelType::LUMA, tu.block(tu.chType).pos()),
+                                     recalcSize(tu.chromaFormat, tu.chType, ChannelType::LUMA, tu.block(tu.chType).size()));
+    const CompArea &areaY = CompArea(COMPONENT_Y, tu.chromaFormat, area);
+    int            adj = m_pcReshape->calculateChromaAdjVpduNei(tu, areaY);
+    tu.setChromaAdj(adj);
+  }
+
+  for (int i = 0; i < getNumberValidComponents(tu.chromaFormat); i++)
+  {
+    ComponentID          compID = (ComponentID)i;
+    const CompArea       &area = tu.blocks[compID];
+    const ChannelType    chType = toChannelType(compID);
+
+    PelBuf piPred = cs.getPredBuf(area);
+    m_pcIntraPred->initIntraPatternChType(*tu.cu, area);
+    if (PU::isMIP(pu, chType))
+    {
+      m_pcIntraPred->initIntraMip(pu, area);
+      m_pcIntraPred->predIntraMip(compID, piPred, pu);
+    }
+    else
+    {
+      m_pcIntraPred->predIntraAng(compID, piPred, pu);
+    }
+
+    PelBuf piResi = cs.getResiBuf(area);
+
+    QpParam cQP(tu, compID);
+
+    if (tu.jointCbCr && isChroma(compID))
+    {
+      if (compID == COMPONENT_Cb)
+      {
+        PelBuf resiCr = cs.getResiBuf(tu.blocks[COMPONENT_Cr]);
+        if (tu.jointCbCr >> 1)
+        {
+          m_pcTrQuant->invTransformNxN(tu, COMPONENT_Cb, piResi, cQP);
+        }
+        else
+        {
+          QpParam qpCr(tu, COMPONENT_Cr);
+
+          m_pcTrQuant->invTransformNxN(tu, COMPONENT_Cr, resiCr, qpCr);
+        }
+        m_pcTrQuant->invTransformICT(tu, piResi, resiCr);
+      }
+    }
+    else
+    {
+      if (TU::getCbf(tu, compID))
+      {
+        m_pcTrQuant->invTransformNxN(tu, compID, piResi, cQP);
+      }
+      else
+      {
+        piResi.fill(0);
+      }
+    }
+
+    cs.setDecomp(area);
+  }
+
+  cs.getResiBuf(tu).colorSpaceConvert(cs.getResiBuf(tu), false, tu.cu->cs->slice->clpRng(COMPONENT_Y));
+
+  for (int i = 0; i < getNumberValidComponents(tu.chromaFormat); i++)
+  {
+    ComponentID          compID = (ComponentID)i;
+    const CompArea       &area = tu.blocks[compID];
+
+    PelBuf piPred = cs.getPredBuf(area);
+    PelBuf piResi = cs.getResiBuf(area);
+    PelBuf piReco = cs.getRecoBuf(area);
+
+    PelBuf tmpPred;
+    if (slice.getLmcsEnabledFlag() && (m_pcReshape->getCTUFlag() || slice.isIntra()) && compID == COMPONENT_Y)
+    {
+      CompArea tmpArea(COMPONENT_Y, area.chromaFormat, Position(0, 0), area.size());
+      tmpPred = m_tmpStorageCtu->getBuf(tmpArea);
+      tmpPred.copyFrom(piPred);
+    }
+
+    if (flag && isChroma(compID) && (tu.blocks[compID].width*tu.blocks[compID].height > 4) && slice.getPicHeader()->getLmcsChromaResidualScaleFlag())
+    {
+      piResi.scaleSignal(tu.getChromaAdj(), 0, tu.cu->cs->slice->clpRng(compID));
+    }
+    piPred.reconstruct(piPred, piResi, tu.cu->cs->slice->clpRng(compID));
+    piReco.copyFrom(piPred);
+
+    if (slice.getLmcsEnabledFlag() && (m_pcReshape->getCTUFlag() || slice.isIntra()) && compID == COMPONENT_Y)
+    {
+      piPred.copyFrom(tmpPred);
+    }
+
+    if (cs.pcv->isEncoder)
+    {
+      cs.picture->getRecoBuf(area).copyFrom(piReco);
+      cs.picture->getPredBuf(area).copyFrom(piPred);
+    }
+  }
+}
+
+void DecCu::xReconIntraQT( CodingUnit &cu )
+{
+  if (CU::isPLT(cu))
+  {
+    if (cu.isSepTree())
+    {
+      if (isLuma(cu.chType))
+      {
+        xReconPLT(cu, COMPONENT_Y, 1);
+      }
+      if (isChromaEnabled(cu.chromaFormat) && cu.chType == ChannelType::CHROMA)
+      {
+        xReconPLT(cu, COMPONENT_Cb, 2);
+      }
+    }
+    else
+    {
+      xReconPLT(cu, COMPONENT_Y, getNumberValidComponents(cu.chromaFormat));
+    }
+    return;
+  }
+
+  if (cu.colorTransform)
+  {
+    xIntraRecACTQT(cu);
+  }
+  else
+  {
+    for (auto chType = ChannelType::LUMA; chType <= ::getLastChannel(cu.chromaFormat); chType++)
+    {
+      if (cu.block(chType).valid())
+      {
+        xIntraRecQT(cu, chType);
+      }
+    }
+  }
+}
+
+void DecCu::xReconPLT(CodingUnit &cu, ComponentID compBegin, uint32_t numComp)
+{
+  const SPS&       sps = *(cu.cs->sps);
+  TransformUnit&   tu = *cu.firstTU;
+  PelBuf    curPLTIdx = tu.getcurPLTIdx(compBegin);
+
+  uint32_t height = cu.block(compBegin).height;
+  uint32_t width = cu.block(compBegin).width;
+
+  //recon. pixels
+  uint32_t scaleX = getComponentScaleX(COMPONENT_Cb, sps.getChromaFormatIdc());
+  uint32_t scaleY = getComponentScaleY(COMPONENT_Cb, sps.getChromaFormatIdc());
+  for (uint32_t y = 0; y < height; y++)
+  {
+    for (uint32_t x = 0; x < width; x++)
+    {
+      for (uint32_t compID = compBegin; compID < (compBegin + numComp); compID++)
+      {
+        const int  channelBitDepth = cu.cs->sps->getBitDepth(toChannelType((ComponentID)compID));
+        const CompArea &area = cu.blocks[compID];
+
+        PelBuf       picReco   = cu.cs->getRecoBuf(area);
+        PLTescapeBuf escapeValue = tu.getescapeValue((ComponentID)compID);
+        if (curPLTIdx.at(x, y) == cu.curPLTSize[compBegin])
+        {
+          TCoeff value;
+          QpParam cQP(tu, (ComponentID)compID);
+          int qp = cQP.Qp(true);
+          int qpRem = qp % 6;
+          int qpPer = qp / 6;
+          if (compBegin != COMPONENT_Y || compID == COMPONENT_Y)
+          {
+            int invquantiserRightShift = IQUANT_SHIFT;
+            int add = 1 << (invquantiserRightShift - 1);
+            value = ((((escapeValue.at(x, y)*g_invQuantScales[0][qpRem]) << qpPer) + add) >> invquantiserRightShift);
+            value = ClipBD<TCoeff>(value, channelBitDepth);
+            picReco.at(x, y) = Pel(value);
+          }
+          else if (compBegin == COMPONENT_Y && compID != COMPONENT_Y && y % (1 << scaleY) == 0 && x % (1 << scaleX) == 0)
+          {
+            uint32_t posYC = y >> scaleY;
+            uint32_t posXC = x >> scaleX;
+            int invquantiserRightShift = IQUANT_SHIFT;
+            int add = 1 << (invquantiserRightShift - 1);
+            value = ((((escapeValue.at(posXC, posYC)*g_invQuantScales[0][qpRem]) << qpPer) + add) >> invquantiserRightShift);
+            value = ClipBD<TCoeff>(value, channelBitDepth);
+            picReco.at(posXC, posYC) = Pel(value);
+          }
+        }
+        else
+        {
+          uint32_t curIdx = curPLTIdx.at(x, y);
+          if (compBegin != COMPONENT_Y || compID == COMPONENT_Y)
+          {
+            picReco.at(x, y) = cu.curPLT[compID][curIdx];
+          }
+          else if (compBegin == COMPONENT_Y && compID != COMPONENT_Y && y % (1 << scaleY) == 0 && x % (1 << scaleX) == 0)
+          {
+            uint32_t posYC = y >> scaleY;
+            uint32_t posXC = x >> scaleX;
+            picReco.at(posXC, posYC) = cu.curPLT[compID][curIdx];
+          }
+        }
+      }
+    }
+  }
+  for (uint32_t compID = compBegin; compID < (compBegin + numComp); compID++)
+  {
+    const CompArea &area = cu.blocks[compID];
+    PelBuf picReco = cu.cs->getRecoBuf(area);
+    cu.cs->picture->getRecoBuf(area).copyFrom(picReco);
+    cu.cs->setDecomp(area);
+  }
+}
+
+/** Function for deriving reconstructed PU/CU chroma samples with QTree structure
+* \param pcRecoYuv pointer to reconstructed sample arrays
+* \param pcPredYuv pointer to prediction sample arrays
+* \param pcResiYuv pointer to residue sample arrays
+* \param chType    texture channel type (luma/chroma)
+* \param rTu       reference to transform data
+*
+\ This function derives reconstructed PU/CU chroma samples with QTree recursive structure
+*/
+
+void DecCu::xIntraRecQT(CodingUnit &cu, const ChannelType chType)
+{
+  for( auto &currTU : CU::traverseTUs( cu ) )
+  {
+    if( isLuma( chType ) )
+    {
+      xIntraRecBlk( currTU, COMPONENT_Y );
+    }
+    else
+    {
+      const uint32_t numValidComp = getNumberValidComponents( cu.chromaFormat );
+
+      for( uint32_t compID = COMPONENT_Cb; compID < numValidComp; compID++ )
+      {
+        xIntraRecBlk( currTU, ComponentID( compID ) );
+      }
+    }
+  }
+}
+
+void DecCu::xIntraRecACTQT(CodingUnit &cu)
+{
+  for (auto &currTU : CU::traverseTUs(cu))
+  {
+    xIntraRecACTBlk(currTU);
+  }
+}
+
+#include "CommonLib/dtrace_buffer.h"
+
+void DecCu::xReconInter(CodingUnit &cu)
+{
+  if( cu.geoFlag )
+  {
+    m_pcInterPred->motionCompensationGeo( cu, m_geoMrgCtx );
+    PU::spanGeoMotionInfo(*cu.firstPU, m_geoMrgCtx, cu.firstPU->geoSplitDir, cu.firstPU->geoMergeIdx);
+  }
+  else
+  {
+    m_pcIntraPred->geneIntrainterPred(cu);
+
+    // inter prediction
+    CHECK(CU::isIBC(cu) && cu.firstPU->ciipFlag, "IBC and Ciip cannot be used together");
+    CHECK(CU::isIBC(cu) && cu.affine, "IBC and Affine cannot be used together");
+    CHECK(CU::isIBC(cu) && cu.geoFlag, "IBC and geo cannot be used together");
+    CHECK(CU::isIBC(cu) && cu.firstPU->mmvdMergeFlag, "IBC and MMVD cannot be used together");
+    const bool luma   = cu.Y().valid();
+    const bool chroma = isChromaEnabled(cu.chromaFormat) && cu.Cb().valid();
+    if (luma && (chroma || !isChromaEnabled(cu.chromaFormat)))
+    {
+      m_pcInterPred->motionCompensateCu(cu, REF_PIC_LIST_X, true, true);
+    }
+    else
+    {
+      m_pcInterPred->motionCompensateCu(cu, REF_PIC_LIST_0, luma, chroma);
+    }
+  }
+  if (cu.Y().valid())
+  {
+    CU::saveMotionForHmvp(cu);
+  }
+
+  if (cu.firstPU->ciipFlag)
+  {
+    if (cu.cs->slice->getLmcsEnabledFlag() && m_pcReshape->getCTUFlag())
+    {
+      cu.cs->getPredBuf(*cu.firstPU).Y().rspSignal(m_pcReshape->getFwdLUT());
+    }
+    m_pcIntraPred->geneWeightedPred(cu.cs->getPredBuf(*cu.firstPU).Y(), *cu.firstPU,
+                                    m_pcIntraPred->getPredictorPtr2(COMPONENT_Y, 0));
+    if (isChromaEnabled(cu.chromaFormat) && cu.chromaSize().width > 2)
+    {
+      m_pcIntraPred->geneWeightedPred(cu.cs->getPredBuf(*cu.firstPU).Cb(), *cu.firstPU,
+                                      m_pcIntraPred->getPredictorPtr2(COMPONENT_Cb, 0));
+      m_pcIntraPred->geneWeightedPred(cu.cs->getPredBuf(*cu.firstPU).Cr(), *cu.firstPU,
+                                      m_pcIntraPred->getPredictorPtr2(COMPONENT_Cr, 0));
+    }
+  }
+
+  DTRACE    ( g_trace_ctx, D_TMP, "pred " );
+  DTRACE_CRC( g_trace_ctx, D_TMP, *cu.cs, cu.cs->getPredBuf( cu ), &cu.Y() );
+
+  // inter recon
+  xDecodeInterTexture(cu);
+
+  // clip for only non-zero cbf case
+  CodingStructure &cs = *cu.cs;
+
+  if (cu.rootCbf)
+  {
+#if REUSE_CU_RESULTS
+    const CompArea &area = cu.blocks[COMPONENT_Y];
+    CompArea    tmpArea(COMPONENT_Y, area.chromaFormat, Position(0, 0), area.size());
+    PelBuf tmpPred;
+#endif
+    if (cs.slice->getLmcsEnabledFlag() && m_pcReshape->getCTUFlag())
+    {
+#if REUSE_CU_RESULTS
+      if (cs.pcv->isEncoder)
+      {
+        tmpPred = m_tmpStorageCtu->getBuf(tmpArea);
+        tmpPred.copyFrom(cs.getPredBuf(cu).get(COMPONENT_Y));
+      }
+#endif
+      if (!cu.firstPU->ciipFlag && !CU::isIBC(cu))
+      {
+        cs.getPredBuf(cu).get(COMPONENT_Y).rspSignal(m_pcReshape->getFwdLUT());
+      }
+    }
+#if KEEP_PRED_AND_RESI_SIGNALS
+    cs.getRecoBuf( cu ).reconstruct( cs.getPredBuf( cu ), cs.getResiBuf( cu ), cs.slice->clpRngs() );
+#else
+    cs.getResiBuf( cu ).reconstruct( cs.getPredBuf( cu ), cs.getResiBuf( cu ), cs.slice->clpRngs() );
+    cs.getRecoBuf( cu ).copyFrom   (                      cs.getResiBuf( cu ) );
+#endif
+    if (cs.slice->getLmcsEnabledFlag() && m_pcReshape->getCTUFlag())
+    {
+#if REUSE_CU_RESULTS
+      if (cs.pcv->isEncoder)
+      {
+        cs.getPredBuf(cu).get(COMPONENT_Y).copyFrom(tmpPred);
+      }
+#endif
+    }
+  }
+  else
+  {
+    cs.getRecoBuf(cu).copyClip(cs.getPredBuf(cu), cs.slice->clpRngs());
+    if (cs.slice->getLmcsEnabledFlag() && m_pcReshape->getCTUFlag() && !cu.firstPU->ciipFlag && !CU::isIBC(cu))
+    {
+      cs.getRecoBuf(cu).get(COMPONENT_Y).rspSignal(m_pcReshape->getFwdLUT());
+    }
+  }
+
+  DTRACE    ( g_trace_ctx, D_TMP, "reco " );
+  DTRACE_CRC( g_trace_ctx, D_TMP, *cu.cs, cu.cs->getRecoBuf( cu ), &cu.Y() );
+
+  cs.setDecomp(cu);
+}
+
+void DecCu::xDecodeInterTU( TransformUnit & currTU, const ComponentID compID )
+{
+  if (!currTU.blocks[compID].valid())
+  {
+    return;
+  }
+
+  const CompArea &area = currTU.blocks[compID];
+
+  CodingStructure& cs = *currTU.cs;
+
+  //===== inverse transform =====
+  PelBuf resiBuf  = cs.getResiBuf(area);
+
+  QpParam cQP(currTU, compID);
+
+  if( currTU.jointCbCr && isChroma(compID) )
+  {
+    if( compID == COMPONENT_Cb )
+    {
+      PelBuf resiCr = cs.getResiBuf( currTU.blocks[ COMPONENT_Cr ] );
+      if( currTU.jointCbCr >> 1 )
+      {
+        m_pcTrQuant->invTransformNxN( currTU, COMPONENT_Cb, resiBuf, cQP );
+      }
+      else
+      {
+        QpParam qpCr(currTU, COMPONENT_Cr);
+        m_pcTrQuant->invTransformNxN( currTU, COMPONENT_Cr, resiCr, qpCr );
+      }
+      m_pcTrQuant->invTransformICT( currTU, resiBuf, resiCr );
+    }
+  }
+  else if (TU::getCbf(currTU, compID))
+  {
+    m_pcTrQuant->invTransformNxN( currTU, compID, resiBuf, cQP );
+  }
+  else
+  {
+    resiBuf.fill( 0 );
+  }
+
+  //===== reconstruction =====
+  const Slice           &slice = *cs.slice;
+  if (!currTU.cu->colorTransform && slice.getLmcsEnabledFlag() && isChroma(compID) && (TU::getCbf(currTU, compID) || currTU.jointCbCr)
+   && slice.getPicHeader()->getLmcsChromaResidualScaleFlag() && currTU.blocks[compID].width * currTU.blocks[compID].height > 4)
+  {
+    resiBuf.scaleSignal(currTU.getChromaAdj(), 0, currTU.cu->cs->slice->clpRng(compID));
+  }
+}
+
+void DecCu::xDecodeInterTexture(CodingUnit &cu)
+{
+  if( !cu.rootCbf )
+  {
+    return;
+  }
+
+  const uint32_t uiNumVaildComp = getNumberValidComponents(cu.chromaFormat);
+
+  if (cu.colorTransform)
+  {
+    CodingStructure  &cs = *cu.cs;
+    const Slice &slice = *cs.slice;
+    for (auto& currTU : CU::traverseTUs(cu))
+    {
+      for (uint32_t ch = 0; ch < uiNumVaildComp; ch++)
+      {
+        const ComponentID compID = ComponentID(ch);
+        if (slice.getLmcsEnabledFlag() && slice.getPicHeader()->getLmcsChromaResidualScaleFlag() && (compID == COMPONENT_Y))
+        {
+          const CompArea &areaY = currTU.blocks[COMPONENT_Y];
+          int adj = m_pcReshape->calculateChromaAdjVpduNei(currTU, areaY);
+          currTU.setChromaAdj(adj);
+        }
+        xDecodeInterTU(currTU, compID);
+      }
+
+      cs.getResiBuf(currTU).colorSpaceConvert(cs.getResiBuf(currTU), false, cu.cs->slice->clpRng(COMPONENT_Y));
+      if (slice.getLmcsEnabledFlag() && slice.getPicHeader()->getLmcsChromaResidualScaleFlag() && currTU.blocks[COMPONENT_Cb].width * currTU.blocks[COMPONENT_Cb].height > 4)
+      {
+        cs.getResiBuf(currTU.blocks[COMPONENT_Cb]).scaleSignal(currTU.getChromaAdj(), 0, currTU.cu->cs->slice->clpRng(COMPONENT_Cb));
+        cs.getResiBuf(currTU.blocks[COMPONENT_Cr]).scaleSignal(currTU.getChromaAdj(), 0, currTU.cu->cs->slice->clpRng(COMPONENT_Cr));
+      }
+    }
+  }
+  else
+  {
+    for (uint32_t ch = 0; ch < uiNumVaildComp; ch++)
+    {
+      const ComponentID compID = ComponentID(ch);
+
+      for (auto &currTU: CU::traverseTUs(cu))
+      {
+        CodingStructure &cs    = *cu.cs;
+        const Slice     &slice = *cs.slice;
+        if (slice.getLmcsEnabledFlag() && slice.getPicHeader()->getLmcsChromaResidualScaleFlag()
+            && (compID == COMPONENT_Y) && (currTU.cbf[COMPONENT_Cb] || currTU.cbf[COMPONENT_Cr]))
+        {
+          const CompArea &areaY = currTU.blocks[COMPONENT_Y];
+          int             adj   = m_pcReshape->calculateChromaAdjVpduNei(currTU, areaY);
+          currTU.setChromaAdj(adj);
+        }
+        xDecodeInterTU(currTU, compID);
+      }
+    }
+  }
+}
+
+void DecCu::xDeriveCuMvs(CodingUnit &cu)
+{
+  for( auto &pu : CU::traversePUs( cu ) )
+  {
+    MergeCtx mrgCtx;
+
+#if RExt__DECODER_DEBUG_TOOL_STATISTICS
+    if( pu.cu->affine )
+    {
+      CodingStatistics::IncrementStatisticTool( CodingStatisticsClassType{ STATS__TOOL_AFF, pu.Y().width, pu.Y().height } );
+    }
+#endif
+
+    if( pu.mergeFlag )
+    {
+      if (pu.mmvdMergeFlag || pu.cu->mmvdSkip)
+      {
+        CHECK(pu.ciipFlag, "invalid Ciip");
+        if (pu.cs->sps->getSbTMVPEnabledFlag())
+        {
+          Size bufSize = g_miScaling.scale(pu.lumaSize());
+          mrgCtx.subPuMvpMiBuf = MotionBuf(m_SubPuMiBuf, bufSize);
+        }
+
+        PU::getInterMergeCandidates(pu, mrgCtx, 1, pu.mmvdMergeIdx.pos.baseIdx + 1);
+        PU::getInterMMVDMergeCandidates(pu, mrgCtx);
+        mrgCtx.setMmvdMergeCandiInfo(pu, pu.mmvdMergeIdx);
+
+        PU::spanMotionInfo(pu, mrgCtx);
+      }
+      else
+      {
+        if( pu.cu->geoFlag )
+        {
+          PU::getGeoMergeCandidates( pu, m_geoMrgCtx );
+        }
+        else if (pu.cu->affine)
+        {
+          AffineMergeCtx affineMergeCtx;
+          if (pu.cs->sps->getSbTMVPEnabledFlag())
+          {
+            Size bufSize          = g_miScaling.scale(pu.lumaSize());
+            mrgCtx.subPuMvpMiBuf  = MotionBuf(m_SubPuMiBuf, bufSize);
+            affineMergeCtx.mrgCtx = &mrgCtx;
+          }
+          PU::getAffineMergeCand(pu, affineMergeCtx, pu.mergeIdx);
+          pu.interDir       = affineMergeCtx.interDirNeighbours[pu.mergeIdx];
+          pu.cu->affineType = affineMergeCtx.affineType[pu.mergeIdx];
+          pu.cu->bcwIdx     = affineMergeCtx.bcwIdx[pu.mergeIdx];
+          pu.mergeType      = affineMergeCtx.mergeType[pu.mergeIdx];
+          if (pu.mergeType == MergeType::SUBPU_ATMVP)
+          {
+            pu.refIdx[0] = affineMergeCtx.mvFieldNeighbours[pu.mergeIdx][0][0].refIdx;
+            pu.refIdx[1] = affineMergeCtx.mvFieldNeighbours[pu.mergeIdx][0][1].refIdx;
+          }
+          else
+          {
+            for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+            {
+              if (pu.cs->slice->getNumRefIdx(l) > 0)
+              {
+                auto &mvField = affineMergeCtx.mvFieldNeighbours[pu.mergeIdx];
+                pu.mvpIdx[l]  = 0;
+                pu.mvpNum[l]  = 0;
+                pu.mvd[l]     = Mv();
+                PU::setAllAffineMvField(pu, mvField, l);
+              }
+            }
+          }
+          PU::spanMotionInfo(pu, mrgCtx);
+        }
+        else
+        {
+          if (CU::isIBC(*pu.cu))
+          {
+            PU::getIBCMergeCandidates(pu, mrgCtx, pu.mergeIdx);
+          }
+          else
+          {
+            PU::getInterMergeCandidates(pu, mrgCtx, 0, pu.mergeIdx);
+          }
+          mrgCtx.setMergeInfo(pu, pu.mergeIdx);
+
+          PU::spanMotionInfo(pu, mrgCtx);
+        }
+      }
+    }
+    else
+    {
+#if REUSE_CU_RESULTS
+      if ( cu.imv && !pu.cu->affine && !cu.cs->pcv->isEncoder )
+#else
+      if (cu.imv && !pu.cu->affine)
+#endif
+      {
+        PU::applyImv(pu, mrgCtx, m_pcInterPred);
+      }
+      else
+      {
+        if( pu.cu->affine )
+        {
+          for ( uint32_t uiRefListIdx = 0; uiRefListIdx < 2; uiRefListIdx++ )
+          {
+            RefPicList eRefList = RefPicList( uiRefListIdx );
+            if ( pu.cs->slice->getNumRefIdx( eRefList ) > 0 && ( pu.interDir & ( 1 << uiRefListIdx ) ) )
+            {
+              AffineAMVPInfo affineAMVPInfo;
+              PU::fillAffineMvpCand( pu, eRefList, pu.refIdx[eRefList], affineAMVPInfo );
+
+              const unsigned mvpIdx = pu.mvpIdx[eRefList];
+
+              pu.mvpNum[eRefList] = affineAMVPInfo.numCand;
+
+              //    Mv mv[3];
+              CHECK( pu.refIdx[eRefList] < 0, "Unexpected negative refIdx." );
+              if (!cu.cs->pcv->isEncoder)
+              {
+                for (int i = 0; i < cu.getNumAffineMvs(); i++)
+                {
+                  pu.mvdAffi[eRefList][i].changeAffinePrecAmvr2Internal(pu.cu->imv);
+                }
+              }
+
+              Mv mvLT = affineAMVPInfo.mvCandLT[mvpIdx] + pu.mvdAffi[eRefList][0];
+              Mv mvRT = affineAMVPInfo.mvCandRT[mvpIdx] + pu.mvdAffi[eRefList][1];
+              mvRT += pu.mvdAffi[eRefList][0];
+
+              Mv mvLB;
+              if (cu.affineType == AffineModel::_6_PARAMS)
+              {
+                mvLB = affineAMVPInfo.mvCandLB[mvpIdx] + pu.mvdAffi[eRefList][2];
+                mvLB += pu.mvdAffi[eRefList][0];
+              }
+              PU::setAllAffineMv(pu, mvLT, mvRT, mvLB, eRefList, true);
+            }
+          }
+        }
+        else if (CU::isIBC(*pu.cu) && pu.interDir == 1)
+        {
+          AMVPInfo amvpInfo;
+          PU::fillIBCMvpCand(pu, amvpInfo);
+          pu.mvpNum[REF_PIC_LIST_0] = amvpInfo.numCand;
+          Mv mvd = pu.mvd[REF_PIC_LIST_0];
+#if REUSE_CU_RESULTS
+          if (!cu.cs->pcv->isEncoder)
+#endif
+          {
+            mvd.changeIbcPrecAmvr2Internal(pu.cu->imv);
+          }
+          if (pu.cs->sps->getMaxNumIBCMergeCand() == 1)
+          {
+            CHECK( pu.mvpIdx[REF_PIC_LIST_0], "mvpIdx for IBC mode should be 0" );
+          }
+          pu.mv[REF_PIC_LIST_0] = amvpInfo.mvCand[pu.mvpIdx[REF_PIC_LIST_0]] + mvd;
+          pu.mv[REF_PIC_LIST_0].foldToStorageBitDepth();
+        }
+        else
+        {
+          for ( uint32_t uiRefListIdx = 0; uiRefListIdx < 2; uiRefListIdx++ )
+          {
+            RefPicList eRefList = RefPicList( uiRefListIdx );
+            if ((pu.cs->slice->getNumRefIdx(eRefList) > 0 || (eRefList == REF_PIC_LIST_0 && CU::isIBC(*pu.cu))) && (pu.interDir & (1 << uiRefListIdx)))
+            {
+              AMVPInfo amvpInfo;
+              PU::fillMvpCand(pu, eRefList, pu.refIdx[eRefList], amvpInfo);
+              pu.mvpNum [eRefList] = amvpInfo.numCand;
+              if (!cu.cs->pcv->isEncoder)
+              {
+                pu.mvd[eRefList].changeTransPrecAmvr2Internal(pu.cu->imv);
+              }
+              pu.mv[eRefList] = amvpInfo.mvCand[pu.mvpIdx[eRefList]] + pu.mvd[eRefList];
+              pu.mv[eRefList].foldToStorageBitDepth();
+            }
+          }
+        }
+        PU::spanMotionInfo( pu, mrgCtx );
+      }
+    }
+    if( !cu.geoFlag )
+    {
+      if( g_mctsDecCheckEnabled && !MCTSHelper::checkMvBufferForMCTSConstraint( pu, true ) )
+      {
+        printf( "DECODER: pu motion vector across tile boundaries (%d,%d,%d,%d)\n", pu.lx(), pu.ly(), pu.lwidth(), pu.lheight() );
+      }
+    }
+    if (CU::isIBC(cu))
+    {
+      const int cuPelX = pu.Y().x;
+      const int cuPelY = pu.Y().y;
+      int roiWidth = pu.lwidth();
+      int roiHeight = pu.lheight();
+      const unsigned int  lcuWidth = pu.cs->slice->getSPS()->getMaxCUWidth();
+      int xPred = pu.mv[0].getHor() >> MV_FRACTIONAL_BITS_INTERNAL;
+      int yPred = pu.mv[0].getVer() >> MV_FRACTIONAL_BITS_INTERNAL;
+      CHECK(!m_pcInterPred->isLumaBvValid(lcuWidth, cuPelX, cuPelY, roiWidth, roiHeight, xPred, yPred), "invalid block vector for IBC detected.");
+    }
+  }
+}
+//! \}
diff --git a/source/Lib/SkipLib/DecCu.h b/source/Lib/SkipLib/DecCu.h
new file mode 100644
index 00000000..b2b129f6
--- /dev/null
+++ b/source/Lib/SkipLib/DecCu.h
@@ -0,0 +1,105 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     DecCu.h
+    \brief    CU decoder class (header)
+*/
+
+#ifndef __DECCU__
+#define __DECCU__
+
+#pragma once
+
+#include "CABACReader.h"
+
+#include "CommonLib/TrQuant.h"
+#include "CommonLib/InterPrediction.h"
+#include "CommonLib/IntraPrediction.h"
+#include "CommonLib/Unit.h"
+#include "CommonLib/Reshape.h"
+//! \ingroup DecoderLib
+//! \{
+
+// ====================================================================================================================
+// Class definition
+// ====================================================================================================================
+
+/// CU decoder class
+class DecCu
+{
+public:
+  DecCu();
+  virtual ~DecCu();
+
+  /// initialize access channels
+  void  init              ( TrQuant* pcTrQuant, IntraPrediction* pcIntra, InterPrediction* pcInter );
+
+  /// destroy internal buffers
+  void  decompressCtu     ( CodingStructure& cs, const UnitArea& ctuArea );
+  Reshape*          m_pcReshape;
+  Reshape* getReshape     () { return m_pcReshape; }
+  void              initDecCuReshaper(Reshape* pcReshape, ChromaFormat chromaFormatIdc);
+  void destoryDecCuReshaprBuf();
+
+  /// reconstruct Ctu information
+protected:
+  void xIntraRecQT        ( CodingUnit&      cu, const ChannelType chType );
+  void xIntraRecACTQT(CodingUnit&      cu);
+
+  void xReconInter        ( CodingUnit&      cu );
+  void xDecodeInterTexture( CodingUnit&      cu );
+  void xReconIntraQT      ( CodingUnit&      cu );
+
+  void xIntraRecBlk       ( TransformUnit&   tu, const ComponentID compID );
+  void xIntraRecACTBlk(TransformUnit&   tu);
+  void xDecodeInterTU     ( TransformUnit&   tu, const ComponentID compID );
+
+  void               xDeriveCuMvs(CodingUnit &cu);
+  void xReconPLT          ( CodingUnit&      cu,       ComponentID compBegin, uint32_t numComp );
+  PelStorage        *m_tmpStorageCtu;
+
+private:
+  TrQuant*          m_pcTrQuant;
+  IntraPrediction*  m_pcIntraPred;
+  InterPrediction*  m_pcInterPred;
+
+
+  MotionInfo        m_SubPuMiBuf[(MAX_CU_SIZE * MAX_CU_SIZE) >> (MIN_CU_LOG2 << 1)];
+
+  MergeCtx          m_geoMrgCtx;
+};
+
+//! \}
+
+#endif
+
diff --git a/source/Lib/SkipLib/DecLib.cpp b/source/Lib/SkipLib/DecLib.cpp
new file mode 100644
index 00000000..3d87d73d
--- /dev/null
+++ b/source/Lib/SkipLib/DecLib.cpp
@@ -0,0 +1,4180 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     DecLib.cpp
+    \brief    decoder class
+*/
+
+#include "NALread.h"
+#include "DecLib.h"
+
+#include "CommonLib/dtrace_next.h"
+#include "CommonLib/dtrace_buffer.h"
+#include "CommonLib/Buffer.h"
+#include "CommonLib/UnitTools.h"
+#include "CommonLib/ProfileTierLevel.h"
+
+#include <fstream>
+#include <set>
+#include <stdio.h>
+#include <fcntl.h>
+#include "AnnexBread.h"
+#include "NALread.h"
+#if K0149_BLOCK_STATISTICS
+#include "CommonLib/dtrace_blockstatistics.h"
+#endif
+
+#if RExt__DECODER_DEBUG_TOOL_STATISTICS
+#include "CommonLib/CodingStatistics.h"
+#endif
+
+bool tryDecodePicture(Picture *pcEncPic, const int expectedPoc, const std::string &bitstreamFileName,
+                      EnumArray<ParameterSetMap<APS>, ApsType> *apsMap, bool bDecodeUntilPocFound, int debugCTU,
+                      int debugPOC)
+{
+  int      poc;
+  PicList *pcListPic = nullptr;
+
+  static bool bFirstCall      = true;             /* TODO: MT */
+  static bool loopFiltered[MAX_VPS_LAYERS] = { false };            /* TODO: MT */
+  static int  iPOCLastDisplay = -MAX_INT;         /* TODO: MT */
+
+  static std::ifstream* bitstreamFile = nullptr;  /* TODO: MT */
+  static InputByteStream* bytestream  = nullptr;  /* TODO: MT */
+  bool bRet = false;
+
+  // create & initialize internal classes
+  static DecLib *pcDecLib = nullptr;              /* TODO: MT */
+
+  if( pcEncPic )
+  {
+    if( bFirstCall )
+    {
+      bitstreamFile = new std::ifstream( bitstreamFileName.c_str(), std::ifstream::in | std::ifstream::binary );
+      bytestream    = new InputByteStream( *bitstreamFile );
+
+      CHECK( !*bitstreamFile, "failed to open bitstream file " << bitstreamFileName.c_str() << " for reading" ) ;
+      // create decoder class
+      pcDecLib = new DecLib;
+      pcDecLib->create();
+
+      // initialize decoder class
+      pcDecLib->init(
+#if  JVET_J0090_MEMORY_BANDWITH_MEASURE
+        ""
+#endif
+      );
+
+      pcDecLib->setDebugCTU( debugCTU );
+      pcDecLib->setDebugPOC( debugPOC );
+      pcDecLib->setDecodedPictureHashSEIEnabled( true );
+      pcDecLib->setAPSMapEnc( apsMap );
+
+      bFirstCall = false;
+      msg( INFO, "start to decode %s \n", bitstreamFileName.c_str() );
+    }
+
+    bool goOn = true;
+
+    // main decoder loop
+    while( !!*bitstreamFile && goOn )
+    {
+      InputNALUnit nalu;
+      nalu.m_nalUnitType = NAL_UNIT_INVALID;
+
+      // determine if next NAL unit will be the first one from a new picture
+      bool bNewPicture = pcDecLib->isNewPicture( bitstreamFile,  bytestream );
+      bool bNewAccessUnit = bNewPicture && pcDecLib->isNewAccessUnit( bNewPicture, bitstreamFile,  bytestream );
+      bNewPicture = bNewPicture && bNewAccessUnit;
+
+      if( !bNewPicture )
+      {
+        AnnexBStats stats = AnnexBStats();
+        byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
+
+        // call actual decoding function
+        if (nalu.getBitstream().getFifo().empty())
+        {
+          /* this can happen if the following occur:
+           *  - empty input file
+           *  - two back-to-back start_code_prefixes
+           *  - start_code_prefix immediately followed by EOF
+           */
+          msg(ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+        }
+        else
+        {
+          read(nalu);
+          int iSkipFrame = 0;
+
+          pcDecLib->decode(nalu, iSkipFrame, iPOCLastDisplay, 0);
+        }
+      }
+
+      if ((bNewPicture || !*bitstreamFile || nalu.m_nalUnitType == NAL_UNIT_EOS) && !pcDecLib->getFirstSliceInSequence(nalu.m_nuhLayerId))
+      {
+        if (!loopFiltered[nalu.m_nuhLayerId] || *bitstreamFile)
+        {
+          pcDecLib->finishPictureLight( poc, pcListPic );
+
+          if( pcListPic )
+          {
+            for( auto & pic : *pcListPic )
+            {
+              if( pic->poc == poc && (!bDecodeUntilPocFound || expectedPoc == poc ) )
+              {
+                CHECK( pcEncPic->slices.size() == 0, "at least one slice should be available" );
+
+                CHECK( expectedPoc != poc, "mismatch in POC - check encoder configuration" );
+
+                if( debugCTU < 0 || poc != debugPOC )
+                {
+                  for (int i = 0; i < pic->slices.size(); i++)
+                  {
+                    if (pcEncPic->slices.size() <= i)
+                    {
+                      pcEncPic->slices.push_back(new Slice);
+                      pcEncPic->slices.back()->initSlice();
+                      pcEncPic->slices.back()->setPPS(pcEncPic->slices[0]->getPPS());
+                      pcEncPic->slices.back()->setSPS(pcEncPic->slices[0]->getSPS());
+                      pcEncPic->slices.back()->setVPS(pcEncPic->slices[0]->getVPS());
+                      pcEncPic->slices.back()->setPic(pcEncPic->slices[0]->getPic());
+                    }
+                    pcEncPic->slices[i]->copySliceInfo(pic->slices[i], false);
+                  }
+                }
+
+                pcEncPic->cs->slice = pcEncPic->slices.back();
+
+                if( debugCTU >= 0 && poc == debugPOC )
+                {
+                  pcEncPic->cs->initStructData();
+
+                  pcEncPic->cs->copyStructure(*pic->cs, ChannelType::LUMA, true, true);
+
+                  if( CS::isDualITree( *pcEncPic->cs ) )
+                  {
+                    pcEncPic->cs->copyStructure(*pic->cs, ChannelType::CHROMA, true, true);
+                  }
+
+                  for( auto &cu : pcEncPic->cs->cus )
+                  {
+                    cu->slice = pcEncPic->cs->slice;
+                  }
+                }
+                else
+                {
+                  if (pic->cs->sps->getSAOEnabledFlag())
+                  {
+                    pcEncPic->copySAO(*pic, 0);
+                  }
+
+                  if (pic->cs->sps->getALFEnabledFlag())
+                  {
+                    pcEncPic->copyAlfData(*pic);
+
+                    for (int i = 0; i < pic->slices.size(); i++)
+                    {
+                      pcEncPic->slices[i]->setNumAlfApsIdsLuma(pic->slices[i]->getNumAlfApsIdsLuma());
+                      pcEncPic->slices[i]->setAlfApsIdsLuma(pic->slices[i]->getAlfApsIdsLuma());
+                      pcEncPic->slices[i]->setAlfAPSs(pic->slices[i]->getAlfAPSs());
+                      pcEncPic->slices[i]->setAlfApsIdChroma(pic->slices[i]->getAlfApsIdChroma());
+                      pcEncPic->slices[i]->setAlfEnabledFlag(COMPONENT_Y,
+                                                             pic->slices[i]->getAlfEnabledFlag(COMPONENT_Y));
+                      pcEncPic->slices[i]->setAlfEnabledFlag(COMPONENT_Cb,
+                                                             pic->slices[i]->getAlfEnabledFlag(COMPONENT_Cb));
+                      pcEncPic->slices[i]->setAlfEnabledFlag(COMPONENT_Cr,
+                                                             pic->slices[i]->getAlfEnabledFlag(COMPONENT_Cr));
+                      pcEncPic->slices[i]->setCcAlfCbApsId(pic->slices[i]->getCcAlfCbApsId());
+                      pcEncPic->slices[i]->setCcAlfCbEnabledFlag(pic->slices[i]->getCcAlfCbEnabledFlag());
+                      pcEncPic->slices[i]->setCcAlfCrApsId(pic->slices[i]->getCcAlfCrApsId());
+                      pcEncPic->slices[i]->setCcAlfCrEnabledFlag(pic->slices[i]->getCcAlfCrEnabledFlag());
+                    }
+                  }
+
+                  pcDecLib->executeLoopFilters();
+                  if (pic->cs->sps->getSAOEnabledFlag())
+                  {
+                    pcEncPic->copySAO(*pic, 1);
+                  }
+
+                  pcEncPic->cs->copyStructure(*pic->cs, ChannelType::LUMA, true, true);
+
+                  if (CS::isDualITree(*pcEncPic->cs))
+                  {
+                    pcEncPic->cs->copyStructure(*pic->cs, ChannelType::CHROMA, true, true);
+                  }
+                }
+                goOn = false; // exit the loop return
+                bRet = true;
+                break;
+              }
+            }
+          }
+          // postpone loop filters
+          if (!bRet)
+          {
+            pcDecLib->executeLoopFilters();
+          }
+
+          pcDecLib->finishPicture( poc, pcListPic, DETAILS );
+
+          // write output
+          if( ! pcListPic->empty())
+          {
+            PicList::iterator iterPic   = pcListPic->begin();
+            int numPicsNotYetDisplayed = 0;
+            int dpbFullness = 0;
+            const SPS* activeSPS = (pcListPic->front()->cs->sps);
+            uint32_t maxNrSublayers = activeSPS->getMaxTLayers();
+            uint32_t maxNumReorderPicsHighestTid = activeSPS->getMaxNumReorderPics(maxNrSublayers-1);
+            uint32_t maxDecPicBufferingHighestTid =  activeSPS->getMaxDecPicBuffering(maxNrSublayers-1);
+            const VPS* referredVPS = pcListPic->front()->cs->vps;
+
+            if( referredVPS != nullptr && referredVPS->m_numLayersInOls[referredVPS->m_targetOlsIdx] > 1 )
+            {
+              maxNumReorderPicsHighestTid = referredVPS->getMaxNumReorderPics( maxNrSublayers - 1 );
+              maxDecPicBufferingHighestTid = referredVPS->getMaxDecPicBuffering( maxNrSublayers - 1 );
+            }
+
+            while (iterPic != pcListPic->end())
+            {
+              Picture* pcCurPic = *(iterPic);
+              if(pcCurPic->neededForOutput && pcCurPic->getPOC() > iPOCLastDisplay)
+              {
+                numPicsNotYetDisplayed++;
+                dpbFullness++;
+              }
+              else if(pcCurPic->referenced)
+              {
+                dpbFullness++;
+              }
+              iterPic++;
+            }
+
+            iterPic = pcListPic->begin();
+
+            if (numPicsNotYetDisplayed>2)
+            {
+              iterPic++;
+            }
+
+            Picture* pcCurPic = *(iterPic);
+            if( numPicsNotYetDisplayed>2 && pcCurPic->fieldPic ) //Field Decoding
+            {
+              THROW( "no field coding support ");
+            }
+            else if( !pcCurPic->fieldPic ) //Frame Decoding
+            {
+              iterPic = pcListPic->begin();
+
+              while (iterPic != pcListPic->end())
+              {
+                pcCurPic = *(iterPic);
+
+                if(pcCurPic->neededForOutput && pcCurPic->getPOC() > iPOCLastDisplay &&
+                  (numPicsNotYetDisplayed >  maxNumReorderPicsHighestTid || dpbFullness > maxDecPicBufferingHighestTid))
+                {
+                  numPicsNotYetDisplayed--;
+                  if( ! pcCurPic->referenced )
+                  {
+                    dpbFullness--;
+                  }
+                  // update POC of display order
+                  iPOCLastDisplay = pcCurPic->getPOC();
+
+                  // erase non-referenced picture in the reference picture list after display
+                  if( ! pcCurPic->referenced && pcCurPic->reconstructed )
+                  {
+                    pcCurPic->reconstructed = false;
+                  }
+                  pcCurPic->neededForOutput = false;
+                }
+
+                iterPic++;
+              }
+            }
+          }
+
+          pcDecLib->updateAssociatedIRAP();
+          pcDecLib->updatePrevGDRInSameLayer();
+          pcDecLib->updatePrevIRAPAndGDRSubpic();
+          // LMCS APS will be assigned later in LMCS initialization step
+          pcEncPic->cs->picHeader->setLmcsAPS( nullptr );
+          if( bitstreamFile )
+          {
+            pcDecLib->resetAccessUnitNals();
+            pcDecLib->resetAccessUnitApsNals();
+          }
+        }
+        loopFiltered[nalu.m_nuhLayerId] = (nalu.m_nalUnitType == NAL_UNIT_EOS);
+        if( nalu.m_nalUnitType == NAL_UNIT_EOS )
+        {
+          pcDecLib->setFirstSliceInSequence(true, nalu.m_nuhLayerId);
+        }
+
+      }
+      else if ((bNewPicture || !*bitstreamFile || nalu.m_nalUnitType == NAL_UNIT_EOS) && pcDecLib->getFirstSliceInSequence(nalu.m_nuhLayerId))
+      {
+        pcDecLib->setFirstSliceInPicture( true );
+      }
+    }
+  }
+
+  if( !bRet )
+  {
+    CHECK( bDecodeUntilPocFound, " decoding failed - check decodeBitstream2 parameter File: " << bitstreamFileName.c_str() );
+    if( pcDecLib )
+    {
+      pcDecLib->destroy();
+      pcDecLib->deletePicBuffer();
+      delete pcDecLib;
+      pcDecLib = nullptr;
+    }
+    bFirstCall   = true;
+    for (int i = 0; i < MAX_VPS_LAYERS; i++)
+    {
+      loopFiltered[i] = false;
+    }
+    iPOCLastDisplay = -MAX_INT;
+
+    if( bytestream )
+    {
+      delete bytestream;
+      bytestream = nullptr;
+    }
+
+    if( bitstreamFile )
+    {
+      delete bitstreamFile;
+      bitstreamFile = nullptr;
+    }
+  }
+
+  return bRet;
+}
+
+
+//! \ingroup DecoderLib
+//! \{
+
+DecLib::DecLib()
+  : m_maxRefPicNum(0)
+  , m_isFirstGeneralHrd(true)
+  , m_prevGeneralHrdParams()
+  , m_latestDRAPPOC(MAX_INT)
+  , m_latestEDRAPPOC(MAX_INT)
+  , m_latestEDRAPIndicationLeadingPicturesDecodableFlag(false)
+  , m_associatedIRAPDecodingOrderNumber{ 0 }
+  , m_decodingOrderCounter(0)
+  , m_puCounter(0)
+  , m_seiInclusionFlag(false)
+  , m_pocRandomAccess(MAX_INT)
+  , m_lastRasPoc(MAX_INT)
+  , m_cListPic()
+  , m_parameterSetManager()
+  , m_apcSlicePilot(nullptr)
+  , m_SEIs()
+  , m_sdiSEIInFirstAU(nullptr)
+  , m_maiSEIInFirstAU(nullptr)
+  , m_mvpSEIInFirstAU(nullptr)
+  , m_cIntraPred()
+  , m_cInterPred()
+  , m_cTrQuant()
+  , m_cSliceDecoder()
+  , m_cTrQuantScalingList()
+  , m_cCuDecoder()
+  , m_HLSReader()
+  , m_seiReader()
+  , m_deblockingFilter()
+  , m_cSAO()
+  , m_cReshaper()
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+  , m_cacheModel()
+#endif
+  , m_pcPic(nullptr)
+  , m_prevLayerID(MAX_INT)
+  , m_prevPOC(MAX_INT)
+  , m_prevPicPOC(MAX_INT)
+  , m_prevTid0POC(0)
+  , m_bFirstSliceInPicture(true)
+  , m_firstPictureInSequence(true)
+  , m_grainCharacteristic()
+  , m_grainBuf()
+  , m_colourTranfParams()
+  , m_firstSliceInBitstream(true)
+  , m_isFirstAuInCvs(true)
+  , m_prevSliceSkipped(false)
+  , m_skippedPOC(MAX_INT)
+  , m_skippedLayerID(MAX_INT)
+  , m_lastPOCNoOutputPriorPics(-1)
+  , m_isNoOutputPriorPics(false)
+  , m_lastNoOutputBeforeRecoveryFlag{ false }
+  , m_sliceLmcsApsId(-1)
+  , m_pDecodedSEIOutputStream(nullptr)
+  , m_audIrapOrGdrAuFlag(false)
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+  , m_decoded360SeiDumpFileName()
+#endif
+  , m_decodedPictureHashSEIEnabled(false)
+  , m_numberOfChecksumErrorsDetected(0)
+  , m_warningMessageSkipPicture(false)
+  , m_prefixSEINALUs()
+  , m_debugPOC(-1)
+  , m_debugCTU(-1)
+  , m_opi(nullptr)
+  , m_mTidExternalSet(false)
+  , m_mTidOpiSet(false)
+  , m_tOlsIdxTidExternalSet(false)
+  , m_tOlsIdxTidOpiSet(false)
+  , m_vps(nullptr)
+  , m_maxDecSubPicIdx(0)
+  , m_maxDecSliceAddrInSubPic(-1)
+  , m_clsVPSid(0)
+#if GDR_ENABLED
+  , m_lastGdrPoc (-1)
+#endif
+  , m_targetSubPicIdx(0)
+  , m_dci(nullptr)
+{
+#if ENABLE_SIMD_OPT_BUFFER
+  g_pelBufOP.initPelBufOpsX86();
+#endif
+  memset(m_prevEOS, false, sizeof(m_prevEOS));
+  memset(m_accessUnitEos, false, sizeof(m_accessUnitEos));
+  std::fill_n(m_prevGDRInSameLayerPOC, MAX_VPS_LAYERS, -MAX_INT);
+  std::fill_n(m_prevGDRInSameLayerRecoveryPOC, MAX_VPS_LAYERS, -MAX_INT);
+  std::fill_n(m_firstSliceInSequence, MAX_VPS_LAYERS, true);
+  std::fill_n(m_pocCRA, MAX_VPS_LAYERS, -MAX_INT);
+  std::fill_n(m_accessUnitSpsNumSubpic, MAX_VPS_LAYERS, 1);
+  for (int i = 0; i < MAX_VPS_LAYERS; i++)
+  {
+    m_associatedIRAPType[i] = NAL_UNIT_INVALID;
+    std::fill_n(m_prevGDRSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
+    std::fill_n(m_prevIRAPSubpicPOC[i], MAX_NUM_SUB_PICS, -MAX_INT);
+    memset(m_prevIRAPSubpicDecOrderNo[i], 0, sizeof(int)*MAX_NUM_SUB_PICS);
+    std::fill_n(m_prevIRAPSubpicType[i], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
+  }
+}
+
+DecLib::~DecLib()
+{
+  resetAccessUnitSeiNalus();
+  resetPictureSeiNalus();
+  resetPrefixSeiNalus();
+
+  if (m_sdiSEIInFirstAU != nullptr)
+  {
+    delete m_sdiSEIInFirstAU;
+  }
+  m_sdiSEIInFirstAU = nullptr;
+  if (m_maiSEIInFirstAU != nullptr)
+  {
+    delete m_maiSEIInFirstAU;
+  }
+  m_maiSEIInFirstAU = nullptr;
+  if (m_mvpSEIInFirstAU != nullptr)
+  {
+    delete m_mvpSEIInFirstAU;
+  }
+  m_mvpSEIInFirstAU = nullptr;
+}
+
+void DecLib::create()
+{
+  m_apcSlicePilot = new Slice;
+  m_uiSliceSegmentIdx = 0;
+}
+
+void DecLib::destroy()
+{
+  delete m_apcSlicePilot;
+  m_apcSlicePilot = nullptr;
+
+  if( m_dci )
+  {
+    delete m_dci;
+    m_dci = nullptr;
+  }
+
+  if (m_opi)
+  {
+    delete m_opi;
+    m_opi = nullptr;
+  }
+
+  m_cSliceDecoder.destroy();
+}
+
+void DecLib::init(
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+  const std::string& cacheCfgFileName
+#endif
+)
+{
+  m_cSliceDecoder.init( &m_CABACDecoder, &m_cCuDecoder );
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+  m_cacheModel.create( cacheCfgFileName );
+  m_cacheModel.clear( );
+  m_cInterPred.cacheAssign( &m_cacheModel );
+#endif
+  DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 1 ) );
+}
+
+void DecLib::deletePicBuffer ( )
+{
+  PicList::iterator  iterPic   = m_cListPic.begin();
+  int                size      = int(m_cListPic.size());
+
+  for (int i = 0; i < size; i++)
+  {
+    Picture* pcPic = *(iterPic++);
+    pcPic->destroy();
+
+    delete pcPic;
+    pcPic = nullptr;
+  }
+  m_cALF.destroy();
+  m_cSAO.destroy();
+  m_deblockingFilter.destroy();
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+  m_cacheModel.reportSequence( );
+  m_cacheModel.destroy( );
+#endif
+  m_cCuDecoder.destoryDecCuReshaprBuf();
+  m_cReshaper.destroy();
+}
+
+Picture* DecLib::xGetNewPicBuffer( const SPS &sps, const PPS &pps, const uint32_t temporalLayer, const int layerId )
+{
+  Picture * pcPic = nullptr;
+  // getMaxDecPicBuffering() has space for the picture currently being decoded
+  m_maxRefPicNum = (m_vps == nullptr || m_vps->m_numLayersInOls[m_vps->m_targetOlsIdx] == 1)
+                     ? sps.getMaxDecPicBuffering(temporalLayer)
+                     : m_vps->getMaxDecPicBuffering(temporalLayer);
+  if (m_cListPic.size() < (uint32_t) m_maxRefPicNum)
+  {
+    pcPic = new Picture();
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+    pcPic->create(sps.getChromaFormatIdc(), Size(pps.getPicWidthInLumaSamples(), pps.getPicHeightInLumaSamples()),
+      sps.getMaxCUWidth(), sps.getMaxCUWidth() + PIC_MARGIN, true, layerId, getShutterFilterFlag() );
+#else
+    pcPic->create( sps.getChromaFormatIdc(), Size( pps.getPicWidthInLumaSamples(), pps.getPicHeightInLumaSamples() ), sps.getMaxCUWidth(), sps.getMaxCUWidth() + PIC_MARGIN, true, layerId );
+#endif
+
+    m_cListPic.push_back( pcPic );
+
+    return pcPic;
+  }
+
+  bool bBufferIsAvailable = false;
+  for(auto * p: m_cListPic)
+  {
+    pcPic = p;  // workaround because range-based for-loops don't work with existing variables
+    if ( pcPic->reconstructed == false && ! pcPic->neededForOutput )
+    {
+      pcPic->neededForOutput = false;
+      bBufferIsAvailable = true;
+      break;
+    }
+
+    if( ! pcPic->referenced  && ! pcPic->neededForOutput )
+    {
+      pcPic->neededForOutput = false;
+      pcPic->reconstructed = false;
+      bBufferIsAvailable = true;
+      break;
+    }
+  }
+
+  if( ! bBufferIsAvailable )
+  {
+    //There is no room for this picture, either because of faulty encoder or dropped NAL. Extend the buffer.
+    m_maxRefPicNum++;
+
+    pcPic = new Picture();
+
+    m_cListPic.push_back( pcPic );
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+    pcPic->create(sps.getChromaFormatIdc(), Size(pps.getPicWidthInLumaSamples(), pps.getPicHeightInLumaSamples()), sps.getMaxCUWidth(), sps.getMaxCUWidth() + PIC_MARGIN, true, layerId, getShutterFilterFlag());
+#else
+    pcPic->create( sps.getChromaFormatIdc(), Size( pps.getPicWidthInLumaSamples(), pps.getPicHeightInLumaSamples() ), sps.getMaxCUWidth(), sps.getMaxCUWidth() + PIC_MARGIN, true, layerId );
+#endif
+  }
+  else
+  {
+    if( !pcPic->Y().Size::operator==( Size( pps.getPicWidthInLumaSamples(), pps.getPicHeightInLumaSamples() ) ) || pps.pcv->maxCUWidth != sps.getMaxCUWidth() || pps.pcv->maxCUHeight != sps.getMaxCUHeight() || pcPic->layerId != layerId )
+    {
+      pcPic->destroy();
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+      pcPic->create( sps.getChromaFormatIdc(), Size( pps.getPicWidthInLumaSamples(), pps.getPicHeightInLumaSamples() ), sps.getMaxCUWidth(), sps.getMaxCUWidth() + PIC_MARGIN, true, layerId, getShutterFilterFlag());
+#else
+      pcPic->create( sps.getChromaFormatIdc(), Size( pps.getPicWidthInLumaSamples(), pps.getPicHeightInLumaSamples() ), sps.getMaxCUWidth(), sps.getMaxCUWidth() + PIC_MARGIN, true, layerId );
+#endif
+    }
+  }
+
+  pcPic->setBorderExtension( false );
+  pcPic->neededForOutput = false;
+  pcPic->reconstructed = false;
+
+  return pcPic;
+}
+
+
+void DecLib::executeLoopFilters()
+{
+  if( !m_pcPic )
+  {
+    return; // nothing to deblock
+  }
+
+  m_pcPic->cs->slice->startProcessingTimer();
+
+  CodingStructure& cs = *m_pcPic->cs;
+
+  if (cs.sps->getUseLmcs() && cs.picHeader->getLmcsEnabledFlag())
+  {
+    const PreCalcValues &pcv = *cs.pcv;
+    for (uint32_t yPos = 0; yPos < pcv.lumaHeight; yPos += pcv.maxCUHeight)
+    {
+      for (uint32_t xPos = 0; xPos < pcv.lumaWidth; xPos += pcv.maxCUWidth)
+      {
+        const CodingUnit *cu = cs.getCU(Position(xPos, yPos), ChannelType::LUMA);
+        if (cu->slice->getLmcsEnabledFlag())
+        {
+          const uint32_t width  = (xPos + pcv.maxCUWidth > pcv.lumaWidth) ? (pcv.lumaWidth - xPos) : pcv.maxCUWidth;
+          const uint32_t height = (yPos + pcv.maxCUHeight > pcv.lumaHeight) ? (pcv.lumaHeight - yPos) : pcv.maxCUHeight;
+          const UnitArea area(cs.area.chromaFormat, Area(xPos, yPos, width, height));
+          cs.getRecoBuf(area).get(COMPONENT_Y).rspSignal(m_cReshaper.getInvLUT());
+        }
+      }
+    }
+    m_cReshaper.setRecReshaped(false);
+    m_cSAO.setReshaper(&m_cReshaper);
+  }
+#if GREEN_METADATA_SEI_ENABLED
+  FeatureCounterStruct initValues;
+  cs.m_featureCounter =  initValues;
+#endif
+  // deblocking filter
+  m_deblockingFilter.deblockingFilterPic( cs );
+  CS::setRefinedMotionField(cs);
+  if( cs.sps->getSAOEnabledFlag() )
+  {
+    m_cSAO.SAOProcess( cs, cs.picture->getSAO() );
+  }
+
+  if( cs.sps->getALFEnabledFlag() )
+  {
+    m_cALF.getCcAlfFilterParam() = cs.slice->m_ccAlfFilterParam;
+    // ALF decodes the differentially coded coefficients and stores them in the parameters structure.
+    // Code could be restructured to do directly after parsing. So far we just pass a fresh non-const
+    // copy in case the APS gets used more than once.
+    m_cALF.ALFProcess(cs);
+  }
+
+#if GREEN_METADATA_SEI_ENABLED
+  m_featureCounter.addSAO(cs.m_featureCounter);
+  m_featureCounter.addALF(cs.m_featureCounter);
+  m_featureCounter.addBoundaryStrengths(cs.m_featureCounter);
+#endif
+  for (int i = 0; i < cs.pps->getNumSubPics() && m_targetSubPicIdx; i++)
+  {
+    // keep target subpic samples untouched, for other subpics mask their output sample value to 0
+    int targetSubPicIdx = m_targetSubPicIdx - 1;
+    if (i != targetSubPicIdx)
+    {
+      SubPic SubPicNoUse = cs.pps->getSubPics()[i];
+      uint32_t left  = SubPicNoUse.getSubPicLeft();
+      uint32_t right = SubPicNoUse.getSubPicRight();
+      uint32_t top   = SubPicNoUse.getSubPicTop();
+      uint32_t bottom= SubPicNoUse.getSubPicBottom();
+      for (uint32_t row = top; row <= bottom; row++)
+      {
+        for (uint32_t col = left; col <= right; col++)
+        {
+          cs.getRecoBuf().Y().at(col, row) = 0;
+          // for test only, hard coding using 4:2:0 chroma format
+          cs.getRecoBuf().Cb().at(col>>1, row>>1) = 0;
+          cs.getRecoBuf().Cr().at(col>>1, row>>1) = 0;
+        }
+      }
+    }
+  }
+
+  m_pcPic->cs->slice->stopProcessingTimer();
+}
+
+#if JVET_AC0074_USE_OF_NNPFC_FOR_PIC_RATE_UPSAMPLING
+void DecLib::applyNnPostFilter()
+{
+  if(m_cListPic.empty())
+  {
+    return;
+  }
+  m_nnPostFiltering.filterPictures(m_cListPic);
+}
+#endif
+
+void DecLib::finishPictureLight(int& poc, PicList*& rpcListPic )
+{
+  Slice*  pcSlice = m_pcPic->cs->slice;
+
+  m_pcPic->neededForOutput = (pcSlice->getPicHeader()->getPicOutputFlag() ? true : false);
+
+  const VPS *vps = pcSlice->getVPS();
+  if (vps != nullptr)
+  {
+    if (!vps->getEachLayerIsAnOlsFlag())
+    {
+      const int layerId        = pcSlice->getNalUnitLayerId();
+      const int generalLayerId = vps->getGeneralLayerIdx(layerId);
+      bool      layerIsOutput  = true;
+
+      if (vps->getOlsModeIdc() == 0)
+      {
+        layerIsOutput = generalLayerId == vps->m_targetOlsIdx;
+      }
+      else if (vps->getOlsModeIdc() == 1)
+      {
+        layerIsOutput = generalLayerId <= vps->m_targetOlsIdx;
+      }
+      else if (vps->getOlsModeIdc() == 2)
+      {
+        layerIsOutput = vps->getOlsOutputLayerFlag(vps->m_targetOlsIdx, generalLayerId);
+      }
+      if (!layerIsOutput)
+      {
+        m_pcPic->neededForOutput = false;
+      }
+    }
+  }
+  m_pcPic->reconstructed = true;
+
+  Slice::sortPicList( m_cListPic ); // sorting for application output
+  poc                 = pcSlice->getPOC();
+  rpcListPic          = &m_cListPic;
+  m_puCounter++;
+}
+
+void DecLib::finishPicture(int &poc, PicList *&rpcListPic, MsgLevel msgl, bool associatedWithNewClvs)
+{
+#if RExt__DECODER_DEBUG_TOOL_STATISTICS
+  CodingStatistics::StatTool& s = CodingStatistics::GetStatisticTool( STATS__TOOL_TOTAL_FRAME );
+  s.count++;
+  s.pixels = s.count * m_pcPic->Y().width * m_pcPic->Y().height;
+#endif
+
+  Slice*  pcSlice = m_pcPic->cs->slice;
+  m_prevPicPOC = pcSlice->getPOC();
+#if GREEN_METADATA_SEI_ENABLED
+  m_featureCounter.height = m_pcPic->Y().height;
+  m_featureCounter.width = m_pcPic->Y().width;
+#endif
+  
+  char c = (pcSlice->isIntra() ? 'I' : pcSlice->isInterP() ? 'P' : 'B');
+  if (!m_pcPic->referenced)
+  {
+    c += 32;  // tolower
+  }
+
+  if (pcSlice->isDRAP())
+  {
+    c = 'D';
+  }
+  if (pcSlice->getEdrapRapId() > 0)
+  {
+    c = 'E';
+  }
+
+  //-- For time output for each slice
+  msg( msgl, "POC %4d LId: %2d TId: %1d ( %s, %c-SLICE, QP%3d ) ", pcSlice->getPOC(), pcSlice->getPic()->layerId,
+         pcSlice->getTLayer(),
+         nalUnitTypeToString(pcSlice->getNalUnitType()),
+         c,
+         pcSlice->getSliceQp() );
+  msg( msgl, "[DT %6.3f] ", pcSlice->getProcessingTime() );
+
+  for (int refList = 0; refList < 2; refList++)
+  {
+    msg(msgl, "[L%d", refList);
+    for (int refIndex = 0; refIndex < pcSlice->getNumRefIdx(RefPicList(refList)); refIndex++)
+    {
+      const ScalingRatio &scaleRatio = pcSlice->getScalingRatio(RefPicList(refList), refIndex);
+
+      if (pcSlice->getPicHeader()->getEnableTMVPFlag() && pcSlice->getColFromL0Flag() == bool(1 - refList)
+          && pcSlice->getColRefIdx() == refIndex)
+      {
+        if (scaleRatio != SCALE_1X)
+        {
+          msg(msgl, " %dc(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC(RefPicList(refList), refIndex),
+              double(scaleRatio.x) / (1 << ScalingRatio::BITS), double(scaleRatio.y) / (1 << ScalingRatio::BITS));
+        }
+        else
+        {
+          msg(msgl, " %dc", pcSlice->getRefPOC(RefPicList(refList), refIndex));
+        }
+      }
+      else
+      {
+        if (scaleRatio != SCALE_1X)
+        {
+          msg(msgl, " %d(%1.2lfx, %1.2lfx)", pcSlice->getRefPOC(RefPicList(refList), refIndex),
+              double(scaleRatio.x) / (1 << ScalingRatio::BITS), double(scaleRatio.y) / (1 << ScalingRatio::BITS));
+        }
+        else
+        {
+          msg(msgl, " %d", pcSlice->getRefPOC(RefPicList(refList), refIndex));
+        }
+      }
+
+      if (pcSlice->getRefPOC(RefPicList(refList), refIndex) == pcSlice->getPOC())
+      {
+        msg(msgl, ".%d", pcSlice->getRefPic(RefPicList(refList), refIndex)->layerId);
+      }
+    }
+    msg( msgl, "] ");
+  }
+  if (m_decodedPictureHashSEIEnabled)
+  {
+    SEIMessages                  pictureHashes = getSeisByType(m_pcPic->SEIs, SEI::PayloadType::DECODED_PICTURE_HASH);
+    const SEIDecodedPictureHash *hash =
+      (pictureHashes.size() > 0) ? (SEIDecodedPictureHash *) *(pictureHashes.begin()) : nullptr;
+    if (pictureHashes.size() > 1)
+    {
+      msg( WARNING, "Warning: Got multiple decoded picture hash SEI messages. Using first.");
+    }
+    m_numberOfChecksumErrorsDetected += calcAndPrintHashStatus(((const Picture*) m_pcPic)->getRecoBuf(), hash, pcSlice->getSPS()->getBitDepths(), msgl);
+
+    SEIMessages scalableNestingSeis = getSeisByType(m_pcPic->SEIs, SEI::PayloadType::SCALABLE_NESTING);
+    for (auto seiIt : scalableNestingSeis)
+    {
+      SEIScalableNesting *nestingSei = dynamic_cast<SEIScalableNesting*>(seiIt);
+      if (nestingSei->m_snSubpicFlag)
+      {
+        uint32_t subpicId = nestingSei->m_snSubpicId.front();
+        SEIMessages nestedPictureHashes =
+          getSeisByType(nestingSei->m_nestedSEIs, SEI::PayloadType::DECODED_PICTURE_HASH);
+        for (auto decPicHash : nestedPictureHashes)
+        {
+          const SubPic& subpic = pcSlice->getPPS()->getSubPic(subpicId);
+          const UnitArea area = UnitArea(pcSlice->getSPS()->getChromaFormatIdc(), Area(subpic.getSubPicLeft(), subpic.getSubPicTop(), subpic.getSubPicWidthInLumaSample(), subpic.getSubPicHeightInLumaSample()));
+          PelUnitBuf recoBuf = m_pcPic->cs->getRecoBuf(area);
+          m_numberOfChecksumErrorsDetected += calcAndPrintHashStatus(recoBuf, dynamic_cast<SEIDecodedPictureHash*>(decPicHash), pcSlice->getSPS()->getBitDepths(), msgl);
+        }
+      }
+    }
+  }
+
+  msg( msgl, "\n");
+
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+  m_cacheModel.reportFrame();
+  m_cacheModel.accumulateFrame();
+  m_cacheModel.clear();
+#endif
+
+  m_pcPic->neededForOutput = (pcSlice->getPicHeader()->getPicOutputFlag() ? true : false);
+  if (associatedWithNewClvs && m_pcPic->neededForOutput)
+  {
+    if (!pcSlice->getPPS()->getMixedNaluTypesInPicFlag() && pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL)
+    {
+      m_pcPic->neededForOutput = false;
+    }
+    else if (pcSlice->getPPS()->getMixedNaluTypesInPicFlag())
+    {
+      bool isRaslPic = true;
+      for (int i = 0; isRaslPic && i < m_pcPic->numSlices; i++)
+      {
+        if (!(pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_RADL))
+        {
+          isRaslPic = false;
+        }
+      }
+      if (isRaslPic)
+      {
+        m_pcPic->neededForOutput = false;
+      }
+    }
+  }
+
+  const VPS *vps = pcSlice->getVPS();
+  if (vps != nullptr)
+  {
+    if (!vps->getEachLayerIsAnOlsFlag())
+    {
+      const int layerId        = pcSlice->getNalUnitLayerId();
+      const int generalLayerId = vps->getGeneralLayerIdx(layerId);
+      bool      layerIsOutput  = true;
+
+      if (vps->getOlsModeIdc() == 0)
+      {
+        layerIsOutput = generalLayerId == vps->m_targetOlsIdx;
+      }
+      else if (vps->getOlsModeIdc() == 1)
+      {
+        layerIsOutput = generalLayerId <= vps->m_targetOlsIdx;
+      }
+      else if (vps->getOlsModeIdc() == 2)
+      {
+        layerIsOutput = vps->getOlsOutputLayerFlag(vps->m_targetOlsIdx, generalLayerId);
+      }
+      if (!layerIsOutput)
+      {
+        m_pcPic->neededForOutput = false;
+      }
+    }
+  }
+  m_pcPic->reconstructed = true;
+
+  // process buffered suffix APS NALUs
+  processSuffixApsNalus();
+
+  Slice::sortPicList( m_cListPic ); // sorting for application output
+  poc                 = pcSlice->getPOC();
+  rpcListPic          = &m_cListPic;
+  m_bFirstSliceInPicture  = true; // TODO: immer true? hier ist irgendwas faul
+  m_maxDecSubPicIdx = 0;
+  m_maxDecSliceAddrInSubPic = -1;
+
+  m_pcPic->destroyTempBuffers();
+  m_pcPic->cs->destroyCoeffs();
+  m_pcPic->cs->releaseIntermediateData();
+#if !GDR_ENABLED
+  m_pcPic->cs->picHeader->initPicHeader();
+#endif
+  m_puCounter++;
+}
+
+void DecLib::checkNoOutputPriorPics (PicList* pcListPic)
+{
+  if (!pcListPic || !m_isNoOutputPriorPics)
+  {
+    return;
+  }
+
+  PicList::iterator  iterPic   = pcListPic->begin();
+
+  while (iterPic != pcListPic->end())
+  {
+    Picture* pcPicTmp = *(iterPic++);
+    if (m_lastPOCNoOutputPriorPics != pcPicTmp->getPOC())
+    {
+      pcPicTmp->neededForOutput = false;
+    }
+  }
+}
+
+void DecLib::xUpdateRasInit(Slice* slice)
+{
+  slice->setPendingRasInit( false );
+  if ( slice->getPOC() > m_lastRasPoc )
+  {
+    m_lastRasPoc = MAX_INT;
+    slice->setPendingRasInit( true );
+  }
+  if ( slice->isIRAP() )
+  {
+    m_lastRasPoc = slice->getPOC();
+  }
+}
+
+void DecLib::xCreateLostPicture( int iLostPoc, const int layerId )
+{
+  msg( INFO, "\ninserting lost poc : %d\n",iLostPoc);
+  Picture *cFillPic = xGetNewPicBuffer( *( m_parameterSetManager.getFirstSPS() ), *( m_parameterSetManager.getFirstPPS() ), 0, layerId );
+
+  CHECK( !cFillPic->slices.size(), "No slices in picture" );
+
+  cFillPic->slices[0]->initSlice();
+
+  PicList::iterator iterPic = m_cListPic.begin();
+  int closestPoc = 1000000;
+  while ( iterPic != m_cListPic.end())
+  {
+    Picture * rpcPic = *(iterPic++);
+    if(abs(rpcPic->getPOC() -iLostPoc)<closestPoc&&abs(rpcPic->getPOC() -iLostPoc)!=0&&rpcPic->getPOC()!=m_apcSlicePilot->getPOC())
+    {
+      closestPoc=abs(rpcPic->getPOC() -iLostPoc);
+    }
+  }
+  iterPic = m_cListPic.begin();
+  while ( iterPic != m_cListPic.end())
+  {
+    Picture *rpcPic = *(iterPic++);
+    if(abs(rpcPic->getPOC() -iLostPoc)==closestPoc&&rpcPic->getPOC()!=m_apcSlicePilot->getPOC())
+    {
+      msg( INFO, "copying picture %d to %d (%d)\n",rpcPic->getPOC() ,iLostPoc,m_apcSlicePilot->getPOC());
+      cFillPic->getRecoBuf().copyFrom( rpcPic->getRecoBuf() );
+      break;
+    }
+  }
+
+//  for(int ctuRsAddr=0; ctuRsAddr<cFillPic->getNumberOfCtusInFrame(); ctuRsAddr++)  { cFillPic->getCtu(ctuRsAddr)->initCtu(cFillPic, ctuRsAddr); }
+  cFillPic->referenced = true;
+  cFillPic->slices[0]->setPOC(iLostPoc);
+  xUpdatePreviousTid0POC(cFillPic->slices[0]);
+  cFillPic->reconstructed = true;
+  cFillPic->neededForOutput = true;
+  if(m_pocRandomAccess == MAX_INT)
+  {
+    m_pocRandomAccess = iLostPoc;
+  }
+}
+
+void  DecLib::xCreateUnavailablePicture( const PPS *pps, const int iUnavailablePoc, const bool longTermFlag, const int temporalId, const int layerId, const bool interLayerRefPicFlag )
+{
+  msg(INFO, "Note: Inserting unavailable POC : %d\n", iUnavailablePoc);
+  auto const sps = m_parameterSetManager.getSPS(pps->getSPSId());
+  Picture* cFillPic = xGetNewPicBuffer( *sps, *pps, 0, layerId );
+
+  cFillPic->cs      = new CodingStructure(g_xuPool);
+  cFillPic->cs->sps = sps;
+  cFillPic->cs->pps = pps;
+  cFillPic->cs->vps = m_parameterSetManager.getVPS(sps->getVPSId());
+  cFillPic->cs->create(cFillPic->cs->sps->getChromaFormatIdc(), Area(0, 0, cFillPic->cs->pps->getPicWidthInLumaSamples(), cFillPic->cs->pps->getPicHeightInLumaSamples()), true, (bool)(cFillPic->cs->sps->getPLTMode()));
+  cFillPic->allocateNewSlice();
+  cFillPic->m_chromaFormatIdc = sps->getChromaFormatIdc();
+  cFillPic->m_bitDepths = sps->getBitDepths();
+
+  cFillPic->slices[0]->initSlice();
+
+  cFillPic->setDecodingOrderNumber(0);
+  cFillPic->subLayerNonReferencePictureDueToSTSA = false;
+  cFillPic->unscaledPic = cFillPic;
+
+  uint32_t yFill = 1 << (sps->getBitDepth(ChannelType::LUMA) - 1);
+  uint32_t cFill = 1 << (sps->getBitDepth(ChannelType::CHROMA) - 1);
+  cFillPic->getRecoBuf().Y().fill(yFill);
+  cFillPic->getRecoBuf().Cb().fill(cFill);
+  cFillPic->getRecoBuf().Cr().fill(cFill);
+
+  //  for(int ctuRsAddr=0; ctuRsAddr<cFillPic->getNumberOfCtusInFrame(); ctuRsAddr++)  { cFillPic->getCtu(ctuRsAddr)->initCtu(cFillPic, ctuRsAddr); }
+  cFillPic->referenced = true;
+  cFillPic->interLayerRefPicFlag = interLayerRefPicFlag;
+  cFillPic->longTerm = longTermFlag;
+  cFillPic->slices[0]->setPOC(iUnavailablePoc);
+  cFillPic->poc = iUnavailablePoc;
+  if( (cFillPic->slices[0]->getTLayer() == 0) && (cFillPic->slices[0]->getNalUnitType() != NAL_UNIT_CODED_SLICE_RASL) && (cFillPic->slices[0]->getNalUnitType() != NAL_UNIT_CODED_SLICE_RADL) )
+  {
+    m_prevTid0POC = cFillPic->slices[0]->getPOC();
+  }
+
+  cFillPic->reconstructed = true;
+  cFillPic->neededForOutput = false;
+  // picture header is not derived for generated reference picture
+  cFillPic->slices[0]->setPicHeader( nullptr );
+  cFillPic->temporalId = temporalId;
+  cFillPic->nonReferencePictureFlag = false;
+  cFillPic->slices[0]->setPPS( pps );
+
+  if (m_pocRandomAccess == MAX_INT)
+  {
+    m_pocRandomAccess = iUnavailablePoc;
+  }
+}
+
+void DecLib::checkPicTypeAfterEos()
+{
+  int layerId = m_pcPic->slices[0]->getNalUnitLayerId();
+  if (m_prevEOS[layerId])
+  {
+    bool isIrapOrGdrPu = !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag() && ( m_pcPic->slices[0]->isIRAP() || m_pcPic->slices[0]->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR );
+    CHECK(!isIrapOrGdrPu, "when present, the next PU of a particular layer after an EOS NAL unit that belongs to the same layer shall be an IRAP or GDR PU");
+
+    m_prevEOS[layerId] = false;
+  }
+}
+
+void DecLib::checkLayerIdIncludedInCvss()
+{
+  if (m_accessUnitPicInfo.empty())
+  {
+    // don't try to access, if there are no entries (e.g. bitstreams ends after skipping leading pictures)
+    return;
+  }
+  if ((getVPS()->getMaxLayers() == 1 || m_audIrapOrGdrAuFlag) && (m_isFirstAuInCvs || m_accessUnitPicInfo.begin()->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP || m_accessUnitPicInfo.begin()->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL))
+  {
+    // store layerIDs in the first AU
+    m_firstAccessUnitPicInfo.assign(m_accessUnitPicInfo.begin(), m_accessUnitPicInfo.end());
+  }
+  else
+  {
+    // check whether the layerIDs in an AU are included in the layerIDs of the first AU
+    for (auto pic = m_accessUnitPicInfo.begin(); pic != m_accessUnitPicInfo.end(); pic++)
+    {
+      bool layerIdFind;
+      if ( m_firstAccessUnitPicInfo.size() == 0 )
+      {
+        msg( NOTICE, "Note: checkIncludedInFirstAu(), m_firstAccessUnitPicInfo.size() is 0.\n");
+        continue;
+      }
+      for (auto picFirst = m_firstAccessUnitPicInfo.begin(); picFirst != m_firstAccessUnitPicInfo.end(); picFirst++)
+      {
+        layerIdFind = pic->m_nuhLayerId == picFirst->m_nuhLayerId ? true : false;
+        if (layerIdFind)
+        {
+          break;
+        }
+      }
+      CHECK(!layerIdFind, "each picture in an AU in a CVS shall have nuh_layer_id equal to the nuh_layer_id of one of the pictures present in the first AU of the CVS");
+    }
+
+
+    // check whether the layerID of EOS_NUT is included in the layerIDs of the first AU
+    for (int i = 0; i < getVPS()->getMaxLayers(); i++)
+    {
+      int eosLayerId = getVPS()->getLayerId(i);
+      if (m_accessUnitEos[eosLayerId])
+      {
+        bool eosLayerIdFind;
+        for (auto picFirst = m_firstAccessUnitPicInfo.begin(); picFirst != m_firstAccessUnitPicInfo.end(); picFirst++)
+        {
+          eosLayerIdFind = eosLayerId == picFirst->m_nuhLayerId ? true : false;
+          if (eosLayerIdFind)
+          {
+            break;
+          }
+        }
+        CHECK(!eosLayerIdFind, "When nal_unit_type is equal to EOS_NUT, nuh_layer_id shall be equal to one of the nuh_layer_id values of the layers present in the CVS");
+      }
+    }
+  }
+}
+
+void DecLib::resetIsFirstAuInCvs()
+{
+  // update the value of m_isFirstAuInCvs for the next AU according to NAL_UNIT_EOS in each layer
+  for (auto pic = m_accessUnitPicInfo.begin(); pic != m_accessUnitPicInfo.end(); pic++)
+  {
+    m_isFirstAuInCvs = m_accessUnitEos[pic->m_nuhLayerId] ? true : false;
+    if (!m_isFirstAuInCvs)
+    {
+      break;
+    }
+  }
+}
+
+void DecLib::CheckNoOutputPriorPicFlagsInAccessUnit()
+{
+  if (m_accessUnitNoOutputPriorPicFlags.size() > 1)
+  {
+    bool anchor = m_accessUnitNoOutputPriorPicFlags[0];
+    bool isDiffFlagsInAu = std::find(m_accessUnitNoOutputPriorPicFlags.begin(), m_accessUnitNoOutputPriorPicFlags.end(), !anchor) != m_accessUnitNoOutputPriorPicFlags.end();
+    CHECK(isDiffFlagsInAu, "The value of no_output_of_prior_pics_flag, when present, is required to be the same for all pictures in an AU");
+  }
+}
+
+void DecLib::checkTidLayerIdInAccessUnit()
+{
+  int firstPicTid = m_accessUnitPicInfo.begin()->m_temporalId;
+  int firstPicLayerId = m_accessUnitPicInfo.begin()->m_nuhLayerId;
+
+  bool isPicTidInAuSame = true;
+  bool isSeiTidInAuSameAsAuTid = true;
+  bool isFdNaluLayerIdSameAsVclNaluLayerId = true;
+  bool isFdTidInAuSameAsAuTid = true;
+
+  for (auto pic = m_accessUnitPicInfo.begin(); pic != m_accessUnitPicInfo.end(); pic++)
+  {
+    if (pic->m_temporalId != firstPicTid)
+    {
+      isPicTidInAuSame = false;
+      break;
+    }
+  }
+  CHECK(!isPicTidInAuSame, "All pictures in an AU shall have the same value of TemporalId");
+
+  for (auto tid = m_accessUnitSeiTids.begin(); tid != m_accessUnitSeiTids.end(); tid++)
+  {
+    if ((*tid) != firstPicTid)
+    {
+      isSeiTidInAuSameAsAuTid = false;
+      break;
+    }
+  }
+  CHECK(!isSeiTidInAuSameAsAuTid, "The TemporalId of an SEI NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
+
+  for (auto tempNalu = m_accessUnitNals.begin(); tempNalu != m_accessUnitNals.end(); tempNalu++)
+  {
+    if ((tempNalu->m_nalUnitType == NAL_UNIT_FD) && (tempNalu->m_nuhLayerId != firstPicLayerId))
+    {
+      isFdNaluLayerIdSameAsVclNaluLayerId = false;
+      break;
+    }
+  }
+  CHECK(!isFdNaluLayerIdSameAsVclNaluLayerId, "The nuh_layer_id of a filler data NAL unit shall be equal to the nuh_layer_id of associated VCL NAL unit");
+
+  for (auto tempNalu = m_accessUnitNals.begin(); tempNalu != m_accessUnitNals.end(); tempNalu++)
+  {
+    if ((tempNalu->m_nalUnitType == NAL_UNIT_FD) && (tempNalu->m_temporalId != firstPicTid))
+    {
+      isFdTidInAuSameAsAuTid = false;
+      break;
+    }
+  }
+  CHECK(!isFdTidInAuSameAsAuTid, "The TemporalId of a filler data NAL unit shall be equal to the TemporalId of the AU containing the NAL unit");
+}
+
+void DecLib::checkSEIInAccessUnit()
+{
+  int olsIdxIncludeAllLayes = -1;
+  bool isNonNestedSliFound = false;
+
+  bool bSdiPresentInAu = false;
+  bool bAuxSEIsBeforeSdiSEIPresent[4] = { false, false, false, false };
+  for (auto &sei : m_accessUnitSeiPayLoadTypes)
+  {
+    enum NalUnitType         naluType = std::get<0>(sei);
+    enum SEI::PayloadType payloadType = std::get<2>(sei);
+    if (naluType == NAL_UNIT_PREFIX_SEI
+        && ((payloadType == SEI::PayloadType::BUFFERING_PERIOD || payloadType == SEI::PayloadType::PICTURE_TIMING
+             || payloadType == SEI::PayloadType::DECODING_UNIT_INFO
+             || payloadType == SEI::PayloadType::SUBPICTURE_LEVEL_INFO)))
+    {
+      bool olsIncludeAllLayersFind = false;
+      for (int i = 0; i < m_vps->getNumOutputLayerSets(); i++)
+      {
+        for (auto pic = m_firstAccessUnitPicInfo.begin(); pic != m_firstAccessUnitPicInfo.end(); pic++)
+        {
+          int targetLayerId = pic->m_nuhLayerId;
+          for (int j = 0; j < m_vps->getNumLayersInOls(i); j++)
+          {
+            olsIncludeAllLayersFind = m_vps->getLayerIdInOls(i, j) == targetLayerId ? true : false;
+            if (olsIncludeAllLayersFind)
+            {
+              break;
+            }
+          }
+          if (!olsIncludeAllLayersFind)
+          {
+            break;
+          }
+        }
+        if (olsIncludeAllLayersFind)
+        {
+          olsIdxIncludeAllLayes = i;
+          if (payloadType == SEI::PayloadType::SUBPICTURE_LEVEL_INFO)
+          {
+            isNonNestedSliFound = true;
+          }
+          break;
+        }
+      }
+      CHECK(!olsIncludeAllLayersFind, "When there is no OLS that includes all layers in the current CVS in the entire bitstream, there shall be no non-scalable-nested SEI message with payloadType equal to 0 (BP), 1 (PT), 130 (DUI), or 203 (SLI)");
+    }
+    if (payloadType == SEI::PayloadType::SCALABILITY_DIMENSION_INFO)
+    {
+      bSdiPresentInAu = true;
+    }
+    else if (payloadType == SEI::PayloadType::MULTIVIEW_ACQUISITION_INFO && !bSdiPresentInAu)
+    {
+      bAuxSEIsBeforeSdiSEIPresent[0] = true;
+    }
+    else if (payloadType == SEI::PayloadType::ALPHA_CHANNEL_INFO && !bSdiPresentInAu)
+    {
+      bAuxSEIsBeforeSdiSEIPresent[1] = true;
+    }
+    else if (payloadType == SEI::PayloadType::DEPTH_REPRESENTATION_INFO && !bSdiPresentInAu)
+    {
+      bAuxSEIsBeforeSdiSEIPresent[2] = true;
+    }
+    else if (payloadType == SEI::PayloadType::MULTIVIEW_VIEW_POSITION && !bSdiPresentInAu)
+    {
+      bAuxSEIsBeforeSdiSEIPresent[3] = true;
+    }
+  }
+
+  CHECK(bSdiPresentInAu && bAuxSEIsBeforeSdiSEIPresent[0], "When an AU contains both an SDI SEI message and an MAI SEI message, the SDI SEI message shall precede the MAI SEI message in decoding order.");
+  CHECK(bSdiPresentInAu && bAuxSEIsBeforeSdiSEIPresent[1], "When an AU contains both an SDI SEI message with sdi_aux_id[i] equal to 1 for at least one value of i and an ACI SEI message, the SDI SEI message shall precede the ACI SEI message in decoding order.");
+  CHECK(bSdiPresentInAu && bAuxSEIsBeforeSdiSEIPresent[2], "When an AU contains both an SDI SEI message with sdi_aux_id[i] equal to 2 for at least one value of i and a DRI SEI message, the SDI SEI message shall precede the DRI SEI message in decoding order.");
+
+  if (m_isFirstAuInCvs)
+  {
+    // when a non-nested SLI SEI shows up, check sps_num_subpics_minus1 for the OLS contains all layers with multiple subpictures per picture
+    if (isNonNestedSliFound)
+    {
+      checkMultiSubpicNum(olsIdxIncludeAllLayes);
+    }
+
+    // when a nested SLI SEI shows up, loop over all applicable OLSs, and for layers in the each applicable OLS, check sps_num_subpics_minus1 for these layers with multiple subpictures per picture
+    for (auto sliInfo = m_accessUnitNestedSliSeiInfo.begin(); sliInfo != m_accessUnitNestedSliSeiInfo.end(); sliInfo++)
+    {
+      if (sliInfo->m_nestedSliPresent)
+      {
+        for (uint32_t olsIdxNestedSei = 0; olsIdxNestedSei < sliInfo->m_numOlssNestedSli; olsIdxNestedSei++)
+        {
+          int olsIdx = sliInfo->m_olsIdxNestedSLI[olsIdxNestedSei];
+          checkMultiSubpicNum(olsIdx);
+        }
+      }
+    }
+  }
+}
+
+void DecLib::checkMultiSubpicNum(int olsIdx)
+{
+  int multiSubpicNum = 0;
+  for (int layerIdx = 0; layerIdx < m_vps->getNumLayersInOls(olsIdx); layerIdx++)
+  {
+    uint32_t layerId = m_vps->getLayerIdInOls(olsIdx, layerIdx);
+    if (m_accessUnitSpsNumSubpic[layerId] > 1)
+    {
+      if (multiSubpicNum == 0)
+      {
+        multiSubpicNum = m_accessUnitSpsNumSubpic[layerId];
+      }
+      CHECK(multiSubpicNum != m_accessUnitSpsNumSubpic[layerId], "When an SLI SEI message is present for a CVS, the value of sps_num_subpics_minus1 shall be the same for all the SPSs referenced by the pictures in the layers with multiple subpictures per picture.")
+    }
+  }
+}
+
+#define SEI_REPETITION_CONSTRAINT_LIST_SIZE  21
+
+/**
+ - Count the number of identical SEI messages in the current picture
+ */
+void DecLib::checkSeiInPictureUnit()
+{
+  std::vector<std::tuple<int, uint32_t, uint8_t*>> seiList;
+
+  // payload types subject to constrained SEI repetition
+  int picUnitRepConSeiList[SEI_REPETITION_CONSTRAINT_LIST_SIZE] = { 0, 1, 19, 45, 129, 132, 133, 137, 144, 145, 147, 148, 149, 150, 153, 154, 155, 156, 168, 203, 204};
+
+  // extract SEI messages from NAL units
+  for (auto &sei : m_pictureSeiNalus)
+  {
+    InputBitstream bs = sei->getBitstream();
+
+    do
+    {
+      int payloadType = 0;
+      uint32_t val = 0;
+
+      do
+      {
+        bs.readByte(val);
+        payloadType += val;
+      } while (val==0xFF);
+
+      uint32_t payloadSize = 0;
+      do
+      {
+        bs.readByte(val);
+        payloadSize += val;
+      } while (val==0xFF);
+
+      uint8_t *payload = new uint8_t[payloadSize];
+      for (uint32_t i = 0; i < payloadSize; i++)
+      {
+        bs.readByte(val);
+        payload[i] = (uint8_t)val;
+      }
+      seiList.push_back(std::tuple<int, uint32_t, uint8_t*>(payloadType, payloadSize, payload));
+    }
+    while (bs.getNumBitsLeft() > 8);
+  }
+
+  // count repeated messages in list
+  for (uint32_t i = 0; i < seiList.size(); i++)
+  {
+    int      k, count = 1;
+    int      payloadType1 = std::get<0>(seiList[i]);
+    uint32_t payloadSize1 = std::get<1>(seiList[i]);
+    uint8_t  *payload1    = std::get<2>(seiList[i]);
+
+    // only consider SEI payload types in the PicUnitRepConSeiList
+    for(k=0; k<SEI_REPETITION_CONSTRAINT_LIST_SIZE; k++)
+    {
+      if(payloadType1 == picUnitRepConSeiList[k])
+      {
+        break;
+      }
+    }
+    if(k >= SEI_REPETITION_CONSTRAINT_LIST_SIZE)
+    {
+      continue;
+    }
+
+    // compare current SEI message with remaining messages in the list
+    for (uint32_t j = i+1; j < seiList.size(); j++)
+    {
+      int      payloadType2 = std::get<0>(seiList[j]);
+      uint32_t payloadSize2 = std::get<1>(seiList[j]);
+      uint8_t  *payload2    = std::get<2>(seiList[j]);
+
+      // check for identical SEI type, size, and payload
+      if(payloadType1 == payloadType2 && payloadSize1 == payloadSize2)
+      {
+        if(memcmp(payload1, payload2, payloadSize1*sizeof(uint8_t)) == 0)
+        {
+          count++;
+        }
+      }
+    }
+    CHECK(count > 4, "There shall be less than or equal to 4 identical sei_payload( ) syntax structures within a picture unit.");
+  }
+
+  // free SEI message list memory
+  for (uint32_t i = 0; i < seiList.size(); i++)
+  {
+    uint8_t *payload = std::get<2>(seiList[i]);
+    delete[] payload;
+  }
+  seiList.clear();
+}
+
+/**
+ - Reset list of SEI NAL units from the current picture
+ */
+void DecLib::resetPictureSeiNalus()
+{
+  while (!m_pictureSeiNalus.empty())
+  {
+    delete m_pictureSeiNalus.front();
+    m_pictureSeiNalus.pop_front();
+  }
+}
+
+/**
+ - Reset list of Prefix SEI NAL units from the current picture
+ */
+void DecLib::resetPrefixSeiNalus()
+{
+  while (!m_prefixSEINALUs.empty())
+  {
+    delete m_prefixSEINALUs.front();
+    m_prefixSEINALUs.pop_front();
+  }
+}
+
+void DecLib::checkSeiContentInAccessUnit()
+{
+  if (m_accessUnitSeiNalus.empty())
+  {
+    return;
+  }
+  std::vector<SeiPayload> seiList;   // payloadType, olsId, isNestedSEI, payloadSize, payload, duiIdx, subPicId
+
+  // get the OLSs that cover all layers
+  std::vector<uint32_t> olsIds;
+  for (uint32_t i = 0; i < m_vps->getNumOutputLayerSets(); i++)
+  {
+    bool olsIncludeAllLayersFind = false;
+    for (auto pic = m_firstAccessUnitPicInfo.begin(); pic != m_firstAccessUnitPicInfo.end(); pic++)
+    {
+      int targetLayerId = pic->m_nuhLayerId;
+      for (int j = 0; j < m_vps->getNumLayersInOls(i); j++)
+      {
+        olsIncludeAllLayersFind = m_vps->getLayerIdInOls(i, j) == targetLayerId ? true : false;
+        if (olsIncludeAllLayersFind)
+        {
+          break;
+        }
+      }
+      if (!olsIncludeAllLayersFind)
+      {
+        break;
+      }
+    }
+    if (olsIncludeAllLayersFind)
+    {
+      olsIds.push_back(i);
+    }
+  }
+
+  // extract SEI messages from NAL units
+  for (auto &sei : m_accessUnitSeiNalus)
+  {
+    InputBitstream bs = sei->getBitstream();
+
+    do
+    {
+      int      payloadTypeVal = 0;
+      uint32_t payloadLayerId = sei->m_nuhLayerId;
+      uint32_t val = 0;
+
+      do
+      {
+        bs.readByte(val);
+        payloadTypeVal += val;
+      } while (val==0xFF);
+
+      auto payloadType = SEI::PayloadType(payloadTypeVal);
+
+      if (payloadType == SEI::PayloadType::USER_DATA_REGISTERED_ITU_T_T35
+          || payloadType == SEI::PayloadType::USER_DATA_UNREGISTERED)
+      {
+        break;
+      }
+
+      uint32_t payloadSize = 0;
+      do
+      {
+        bs.readByte(val);
+        payloadSize += val;
+      } while (val==0xFF);
+
+      if (payloadType != SEI::PayloadType::SCALABLE_NESTING)
+      {
+        if (payloadType == SEI::PayloadType::BUFFERING_PERIOD || payloadType == SEI::PayloadType::PICTURE_TIMING
+            || payloadType == SEI::PayloadType::DECODING_UNIT_INFO
+            || payloadType == SEI::PayloadType::SUBPICTURE_LEVEL_INFO)
+        {
+          uint8_t *payload = new uint8_t[payloadSize];
+          int duiIdx = 0;
+          if (payloadType == SEI::PayloadType::DECODING_UNIT_INFO)
+          {
+            m_seiReader.getSEIDecodingUnitInfoDuiIdx(&bs, sei->m_nalUnitType, payloadLayerId, m_HRD, payloadSize, duiIdx);
+          }
+          for (uint32_t i = 0; i < payloadSize; i++)
+          {
+            bs.readByte(val);
+            payload[i] = (uint8_t)val;
+          }
+          for (uint32_t i = 0; i < olsIds.size(); i++)
+          {
+            if (i == 0)
+            {
+              seiList.push_back(SeiPayload{ payloadType, olsIds.at(i), false, payloadSize, payload, duiIdx, 0 });
+            }
+            else
+            {
+              uint8_t *payloadTemp = new uint8_t[payloadSize];
+              memcpy(payloadTemp, payload, payloadSize *sizeof(uint8_t));
+              seiList.push_back(SeiPayload{ payloadType, olsIds.at(i), false, payloadSize, payloadTemp, duiIdx, 0 });
+            }
+          }
+        }
+        else
+        {
+          uint8_t *payload = new uint8_t[payloadSize];
+          for (uint32_t i = 0; i < payloadSize; i++)
+          {
+            bs.readByte(val);
+            payload[i] = (uint8_t)val;
+          }
+          seiList.push_back(SeiPayload{ payloadType, payloadLayerId, false, payloadSize, payload, 0, 0 });
+        }
+      }
+      else
+      {
+        const SPS *sps = m_parameterSetManager.getActiveSPS();
+        const VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
+        m_seiReader.parseAndExtractSEIScalableNesting(&bs, sei->m_nalUnitType, payloadLayerId, vps, sps, m_HRD, payloadSize, &seiList);
+      }
+    }
+    while (bs.getNumBitsLeft() > 8);
+  }
+
+  // check contents of the repeated messages in list
+  for (uint32_t i = 0; i < seiList.size(); i++)
+  {
+    SEI::PayloadType payloadType1    = seiList[i].payloadType;
+    int              payLoadLayerId1 = seiList[i].payloadLayerId;
+    bool             payLoadNested1  = seiList[i].payloadNested;
+    uint32_t         payloadSize1    = seiList[i].payloadSize;
+    uint8_t         *payload1        = seiList[i].payload;
+    int              duiIdx1         = seiList[i].duiIdx;
+    int              subPicId1       = seiList[i].subpicId;
+
+    // compare current SEI message with remaining messages in the list
+    for (uint32_t j = i+1; j < seiList.size(); j++)
+    {
+      SEI::PayloadType payloadType2    = seiList[j].payloadType;
+      int              payLoadLayerId2 = seiList[j].payloadLayerId;
+      bool             payLoadNested2  = seiList[j].payloadNested;
+      uint32_t         payloadSize2    = seiList[j].payloadSize;
+      uint8_t         *payload2        = seiList[j].payload;
+      int              duiIdx2         = seiList[j].duiIdx;
+      int              subPicId2       = seiList[j].subpicId;
+
+      // check for identical SEI type, olsId or layerId, size, payload, duiIdx, and subPicId
+      if (payloadType1 == SEI::PayloadType::BUFFERING_PERIOD || payloadType1 == SEI::PayloadType::PICTURE_TIMING
+          || payloadType1 == SEI::PayloadType::DECODING_UNIT_INFO
+          || payloadType1 == SEI::PayloadType::SUBPICTURE_LEVEL_INFO)
+      {
+        CHECK((payloadType1 == payloadType2) && (payLoadLayerId1 == payLoadLayerId2) && (duiIdx1 == duiIdx2) && (subPicId1 == subPicId2) && ((payloadSize1 != payloadSize2) || memcmp(payload1, payload2, payloadSize1*sizeof(uint8_t))), "When there are multiple SEI messages with a particular value of payloadType not equal to 133 that are associated with a particular AU or DU and apply to a particular OLS or layer, regardless of whether some or all of these SEI messages are scalable-nested, the SEI messages shall have the same SEI payload content.");
+      }
+      else
+      {
+        bool sameLayer = false;
+        if (!payLoadNested1 && !payLoadNested2)
+        {
+          sameLayer = (payLoadLayerId1 == payLoadLayerId2);
+        }
+        else if (payLoadNested1 && payLoadNested2)
+        {
+          sameLayer = true;
+        }
+        else
+        {
+          sameLayer = payLoadNested1 ? payLoadLayerId2 >= payLoadLayerId1 : payLoadLayerId1 >= payLoadLayerId2;
+        }
+        CHECK(payloadType1 == payloadType2 && sameLayer && (duiIdx1 == duiIdx2) && (subPicId1 == subPicId2)  && ((payloadSize1 != payloadSize2) || memcmp(payload1, payload2, payloadSize1*sizeof(uint8_t))), "When there are multiple SEI messages with a particular value of payloadType not equal to 133 that are associated with a particular AU or DU and apply to a particular OLS or layer, regardless of whether some or all of these SEI messages are scalable-nested, the SEI messages shall have the same SEI payload content.");
+      }
+    }
+  }
+
+  // free SEI message list memory
+  for (uint32_t i = 0; i < seiList.size(); i++)
+  {
+    uint8_t *payload = seiList[i].payload;
+    delete[] payload;
+  }
+  seiList.clear();
+}
+
+/**
+ - Reset list of SEI NAL units from the current access unit
+ */
+void DecLib::resetAccessUnitSeiNalus()
+{
+  while (!m_accessUnitSeiNalus.empty())
+  {
+    delete m_accessUnitSeiNalus.front();
+    m_accessUnitSeiNalus.pop_front();
+  }
+}
+
+/**
+ - Process buffered list of suffix APS NALUs
+ */
+void DecLib::processSuffixApsNalus()
+{
+  while (!m_suffixApsNalus.empty())
+  {
+    xDecodeAPS(*m_suffixApsNalus.front());
+    delete m_suffixApsNalus.front();
+    m_suffixApsNalus.pop_front();
+  }
+}
+
+/**
+ - Determine if the first VCL NAL unit of a picture is also the first VCL NAL of an Access Unit
+ */
+bool DecLib::isSliceNaluFirstInAU( bool newPicture, InputNALUnit &nalu )
+{
+  // can only be the start of an AU if this is the start of a new picture
+  if( newPicture == false )
+  {
+    return false;
+  }
+
+  // should only be called for slice NALU types
+  if( nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_TRAIL &&
+      nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_STSA &&
+      nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_RASL &&
+      nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_RADL &&
+      nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_IDR_W_RADL &&
+      nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_IDR_N_LP &&
+      nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_CRA &&
+      nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_GDR )
+  {
+    return false;
+  }
+
+
+  // check for layer ID less than or equal to previous picture's layer ID
+  if( nalu.m_nuhLayerId <= m_prevLayerID )
+  {
+    return true;
+  }
+
+  // get slice POC
+  m_apcSlicePilot->setPicHeader( &m_picHeader );
+  m_apcSlicePilot->initSlice();
+  InputBitstream bs(nalu.getBitstream());   // create copy
+  m_HLSReader.setBitstream(&bs);
+  m_HLSReader.getSlicePoc( m_apcSlicePilot, &m_picHeader, &m_parameterSetManager, m_prevTid0POC );
+
+  // check for different POC
+  return (m_apcSlicePilot->getPOC() != m_prevPOC);
+}
+
+void DecLib::checkAPSInPictureUnit()
+{
+  bool firstVCLFound = false;
+  bool suffixAPSFound = false;
+  for (auto &nalu : m_pictureUnitNals)
+  {
+    if (NALUnit::isVclNalUnitType(nalu))
+    {
+      firstVCLFound = true;
+      CHECK( suffixAPSFound, "When any suffix APS NAL units are present in a PU, they shall follow the last VCL unit of the PU" );
+    }
+    else if (nalu == NAL_UNIT_PREFIX_APS)
+    {
+      CHECK( firstVCLFound, "When any prefix APS NAL units are present in a PU, they shall precede the first VCL unit of the PU");
+    }
+    else if (nalu == NAL_UNIT_SUFFIX_APS)
+    {
+      suffixAPSFound = true;
+    }
+  }
+}
+
+void activateAPS(PicHeader* picHeader, Slice* pSlice, ParameterSetManager& parameterSetManager, APS** apss, APS*& lmcsAPS, APS*& scalingListAPS)
+{
+  const SPS *sps = parameterSetManager.getSPS(picHeader->getSPSId());
+  //luma APSs
+  if (pSlice->getAlfEnabledFlag(COMPONENT_Y))
+  {
+    for (int i = 0; i < pSlice->getAlfApsIdsLuma().size(); i++)
+    {
+      int apsId = pSlice->getAlfApsIdsLuma()[i];
+      APS *aps   = parameterSetManager.getAPS(apsId, ApsType::ALF);
+
+      if (aps)
+      {
+        apss[apsId] = aps;
+        if (false == parameterSetManager.activateAPS(apsId, ApsType::ALF))
+        {
+          THROW("APS activation failed!");
+        }
+
+        CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+        //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
+
+        CHECK(!isChromaEnabled(sps->getChromaFormatIdc()) && aps->chromaPresentFlag,
+              "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an ApsType::ALF shall be "
+              "equal to 0");
+
+        CHECK(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
+      }
+    }
+  }
+
+  if (pSlice->getAlfEnabledFlag(COMPONENT_Cb)||pSlice->getAlfEnabledFlag(COMPONENT_Cr) )
+  {
+    //chroma APS
+    int apsId = pSlice->getAlfApsIdChroma();
+    APS *aps   = parameterSetManager.getAPS(apsId, ApsType::ALF);
+    if (aps)
+    {
+      apss[apsId] = aps;
+      if (false == parameterSetManager.activateAPS(apsId, ApsType::ALF))
+      {
+        THROW("APS activation failed!");
+      }
+
+      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
+
+      CHECK(((sps->getCCALFEnabledFlag() == false) && (aps->getCcAlfAPSParam().newCcAlfFilter[0] || aps->getCcAlfAPSParam().newCcAlfFilter[1])), "When sps_ccalf_enabled_flag is 0, the values of alf_cc_cb_filter_signal_flag and alf_cc_cr_filter_signal_flag shall be equal to 0");
+    }
+  }
+
+  CcAlfFilterParam &filterParam = pSlice->m_ccAlfFilterParam;
+  // cleanup before copying
+  for ( int filterIdx = 0; filterIdx < MAX_NUM_CC_ALF_FILTERS; filterIdx++ )
+  {
+    memset( filterParam.ccAlfCoeff[COMPONENT_Cb - 1][filterIdx], 0, sizeof(filterParam.ccAlfCoeff[COMPONENT_Cb - 1][filterIdx]) );
+    memset( filterParam.ccAlfCoeff[COMPONENT_Cr - 1][filterIdx], 0, sizeof(filterParam.ccAlfCoeff[COMPONENT_Cr - 1][filterIdx]) );
+  }
+  memset( filterParam.ccAlfFilterIdxEnabled[COMPONENT_Cb - 1], false, sizeof(filterParam.ccAlfFilterIdxEnabled[COMPONENT_Cb - 1]) );
+  memset( filterParam.ccAlfFilterIdxEnabled[COMPONENT_Cr - 1], false, sizeof(filterParam.ccAlfFilterIdxEnabled[COMPONENT_Cr - 1]) );
+
+  if(pSlice->getCcAlfCbEnabledFlag())
+  {
+    int apsId = pSlice->getCcAlfCbApsId();
+    APS *aps   = parameterSetManager.getAPS(apsId, ApsType::ALF);
+    if(aps)
+    {
+      apss[apsId] = aps;
+      if (false == parameterSetManager.activateAPS(apsId, ApsType::ALF))
+      {
+        THROW("APS activation failed!");
+      }
+
+      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
+
+      filterParam.ccAlfFilterCount[COMPONENT_Cb - 1] = aps->getCcAlfAPSParam().ccAlfFilterCount[COMPONENT_Cb - 1];
+      for (int filterIdx=0; filterIdx < filterParam.ccAlfFilterCount[COMPONENT_Cb - 1]; filterIdx++ )
+      {
+        filterParam.ccAlfFilterIdxEnabled[COMPONENT_Cb - 1][filterIdx] = aps->getCcAlfAPSParam().ccAlfFilterIdxEnabled[COMPONENT_Cb - 1][filterIdx];
+        memcpy(filterParam.ccAlfCoeff[COMPONENT_Cb - 1][filterIdx], aps->getCcAlfAPSParam().ccAlfCoeff[COMPONENT_Cb - 1][filterIdx], sizeof(aps->getCcAlfAPSParam().ccAlfCoeff[COMPONENT_Cb - 1][filterIdx]));
+      }
+    }
+    else
+    {
+      THROW("CC ALF Cb APS not available!");
+    }
+  }
+
+  if(pSlice->getCcAlfCrEnabledFlag())
+  {
+    int apsId = pSlice->getCcAlfCrApsId();
+    APS *aps   = parameterSetManager.getAPS(apsId, ApsType::ALF);
+    if(aps)
+    {
+      apss[apsId] = aps;
+      if (false == parameterSetManager.activateAPS(apsId, ApsType::ALF))
+      {
+        THROW("APS activation failed!");
+      }
+
+      CHECK( aps->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
+
+      filterParam.ccAlfFilterCount[COMPONENT_Cr - 1] = aps->getCcAlfAPSParam().ccAlfFilterCount[COMPONENT_Cr - 1];
+      for (int filterIdx=0; filterIdx < filterParam.ccAlfFilterCount[COMPONENT_Cr - 1]; filterIdx++ )
+      {
+        filterParam.ccAlfFilterIdxEnabled[COMPONENT_Cr - 1][filterIdx] = aps->getCcAlfAPSParam().ccAlfFilterIdxEnabled[COMPONENT_Cr - 1][filterIdx];
+        memcpy(filterParam.ccAlfCoeff[COMPONENT_Cr - 1][filterIdx], aps->getCcAlfAPSParam().ccAlfCoeff[COMPONENT_Cr - 1][filterIdx], sizeof(aps->getCcAlfAPSParam().ccAlfCoeff[COMPONENT_Cr - 1][filterIdx]));
+      }
+    }
+    else
+    {
+      THROW("CC ALF Cr APS not available!");
+    }
+  }
+
+  if (picHeader->getLmcsEnabledFlag() && lmcsAPS == nullptr)
+  {
+    lmcsAPS = parameterSetManager.getAPS(picHeader->getLmcsAPSId(), ApsType::LMCS);
+    CHECK(lmcsAPS == nullptr, "No LMCS APS present");
+    if (lmcsAPS)
+    {
+      parameterSetManager.clearAPSChangedFlag(picHeader->getLmcsAPSId(), ApsType::LMCS);
+      if (false == parameterSetManager.activateAPS(picHeader->getLmcsAPSId(), ApsType::LMCS))
+      {
+        THROW("LMCS APS activation failed!");
+      }
+
+      CHECK(!isChromaEnabled(sps->getChromaFormatIdc()) && lmcsAPS->chromaPresentFlag,
+            "When ChromaArrayType is equal to 0, the value of aps_chroma_present_flag of an ApsType::LMCS shall be "
+            "equal to 0");
+
+      CHECK(lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 < 0
+              || lmcsAPS->getReshaperAPSInfo().maxNbitsNeededDeltaCW - 1 > sps->getBitDepth(ChannelType::LUMA) - 2,
+            "The value of lmcs_delta_cw_prec_minus1 of an ApsType::LMCS shall be in the range of 0 to BitDepth 2, "
+            "inclusive");
+
+      CHECK( lmcsAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
+    }
+  }
+  picHeader->setLmcsAPS(lmcsAPS);
+
+  if( picHeader->getExplicitScalingListEnabledFlag() && scalingListAPS == nullptr)
+  {
+    scalingListAPS = parameterSetManager.getAPS(picHeader->getScalingListAPSId(), ApsType::SCALING_LIST);
+    CHECK( scalingListAPS == nullptr, "No SCALING LIST APS present" );
+    if( scalingListAPS )
+    {
+      parameterSetManager.clearAPSChangedFlag(picHeader->getScalingListAPSId(), ApsType::SCALING_LIST);
+      if (false == parameterSetManager.activateAPS(picHeader->getScalingListAPSId(), ApsType::SCALING_LIST))
+      {
+        THROW( "SCALING LIST APS activation failed!" );
+      }
+
+      CHECK((!isChromaEnabled(sps->getChromaFormatIdc()) && scalingListAPS->chromaPresentFlag)
+              || (isChromaEnabled(sps->getChromaFormatIdc()) && !scalingListAPS->chromaPresentFlag),
+            "The value of aps_chroma_present_flag of the APS NAL unit having aps_params_type equal to SCALING_APS and "
+            "adaptation_parameter_set_id equal to ph_scaling_list_aps_id shall be equal to ChromaArrayType  = =  0 ? 0 "
+            ": 1");
+
+      CHECK( scalingListAPS->getTemporalId() > pSlice->getTLayer(), "TemporalId shall be less than or equal to the TemporalId of the coded slice NAL unit" );
+      //ToDO: APS NAL unit containing the APS RBSP shall have nuh_layer_id either equal to the nuh_layer_id of a coded slice NAL unit that referrs it, or equal to the nuh_layer_id of a direct dependent layer of the layer containing a coded slice NAL unit that referrs it.
+    }
+  }
+  picHeader->setScalingListAPS(scalingListAPS);
+}
+
+void DecLib::checkParameterSetsInclusionSEIconstraints(const InputNALUnit nalu)
+{
+  const PPS* pps = m_pcPic->cs->pps;
+  const APS* lmcsAPS = m_pcPic->cs->lmcsAps;
+  const APS* scalinglistAPS = m_pcPic->cs->scalinglistAps;
+  APS** apss = m_parameterSetManager.getAPSs();
+
+  CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+        pps->getTemporalId() == nalu.m_temporalId &&
+        pps->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
+
+  for (int i = 0; i < ALF_CTB_MAX_NUM_APS; i++)
+  {
+    if (apss[i] != nullptr)
+    {
+      CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+            apss[i]->getTemporalId() == nalu.m_temporalId &&
+            apss[i]->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
+    }
+  }
+  if (lmcsAPS != nullptr)
+  {
+    CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+          lmcsAPS->getTemporalId() == nalu.m_temporalId &&
+          lmcsAPS->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
+  }
+  if (scalinglistAPS != nullptr)
+  {
+    CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA &&
+          scalinglistAPS->getTemporalId() == nalu.m_temporalId &&
+          scalinglistAPS->getPuCounter() > m_puCounter, "Violating Parameter Sets Inclusion Indication SEI constraint");
+  }
+}
+
+void DecLib::xActivateParameterSets( const InputNALUnit nalu )
+{
+  const int layerId = nalu.m_nuhLayerId;
+  if (m_bFirstSliceInPicture)
+  {
+    APS** apss = m_parameterSetManager.getAPSs();
+    memset(apss, 0, sizeof(*apss) * ALF_CTB_MAX_NUM_APS);
+    const PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId()); // this is a temporary PPS object. Do not store this value
+    CHECK(pps == 0, "Referred to PPS not present");
+
+    const SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());             // this is a temporary SPS object. Do not store this value
+    CHECK(sps == 0, "Referred to SPS not present");
+
+    const VPS *vps = m_parameterSetManager.getVPS( sps->getVPSId() );
+    CHECK(vps == 0, "Referred to VPS not present");
+
+    if( nullptr != pps->pcv )
+    {
+      delete m_parameterSetManager.getPPS( m_picHeader.getPPSId() )->pcv;
+    }
+    m_parameterSetManager.getPPS( m_picHeader.getPPSId() )->pcv = new PreCalcValues( *sps, *pps, false );
+    m_parameterSetManager.clearSPSChangedFlag(sps->getSPSId());
+    m_parameterSetManager.clearPPSChangedFlag(pps->getPPSId());
+
+    if (false == m_parameterSetManager.activatePPS(m_picHeader.getPPSId(),m_apcSlicePilot->isIRAP()))
+    {
+      THROW("Parameter set activation failed!");
+    }
+
+    // update the stored VPS to the actually referred to VPS
+    m_vps = m_parameterSetManager.getVPS(sps->getVPSId());
+    if(sps->getVPSId() == 0)
+    {
+      //No VPS in bitstream: set defaults values of variables in VPS to the ones signalled in SPS
+      m_vps->setMaxSubLayers( sps->getMaxTLayers() );
+      m_vps->setLayerId( 0, sps->getLayerId() );
+      m_vps->deriveOutputLayerSets();
+    }
+    else
+    {
+      //VPS in the bitstream: check that SPS and VPS signalling are compatible
+      CHECK(sps->getMaxTLayers() > m_vps->getMaxSubLayers(), "The SPS signals more temporal sub-layers than allowed by the VPS");
+    }
+
+    m_parameterSetManager.getApsMap(ApsType::ALF)->clearActive();
+    for (int i = 0; i < ALF_CTB_MAX_NUM_APS; i++)
+    {
+      APS *aps = m_parameterSetManager.getAPS(i, ApsType::ALF);
+      if (aps)
+      {
+        m_parameterSetManager.clearAPSChangedFlag(i, ApsType::ALF);
+      }
+    }
+    APS* lmcsAPS = nullptr;
+    APS* scalinglistAPS = nullptr;
+    activateAPS(&m_picHeader, m_apcSlicePilot, m_parameterSetManager, apss, lmcsAPS, scalinglistAPS);
+
+    if (((vps != nullptr) && (vps->getVPSGeneralHrdParamsPresentFlag())) || (sps->getGeneralHrdParametersPresentFlag()))
+    {
+      const GeneralHrdParams *generalHrdParams = (sps->getGeneralHrdParametersPresentFlag()
+          ? sps->getGeneralHrdParameters()
+          : vps->getGeneralHrdParameters());
+      m_HRD.setGeneralHrdParameters(*generalHrdParams);
+    }
+
+    xParsePrefixSEImessages();
+
+#if RExt__HIGH_BIT_DEPTH_SUPPORT==0
+    if (sps->getSpsRangeExtension().getExtendedPrecisionProcessingFlag() || sps->getBitDepth(ChannelType::LUMA) > 12
+        || sps->getBitDepth(ChannelType::CHROMA) > 12)
+    {
+      THROW("High bit depth support must be enabled at compile-time in order to decode this bitstream\n");
+    }
+#endif
+
+    m_apcSlicePilot->applyReferencePictureListBasedMarking(m_cListPic, m_apcSlicePilot->getRpl(REF_PIC_LIST_0),
+                                                           m_apcSlicePilot->getRpl(REF_PIC_LIST_1), layerId, *pps);
+
+    //  Get a new picture buffer. This will also set up m_pcPic, and therefore give us a SPS and PPS pointer that we can use.
+    m_pcPic = xGetNewPicBuffer( *sps, *pps, m_apcSlicePilot->getTLayer(), layerId );
+
+    m_pcPic->finalInit( vps, *sps, *pps, &m_picHeader, apss, lmcsAPS, scalinglistAPS );
+#if GDR_ENABLED
+    m_apcSlicePilot->setPicHeader(m_pcPic->cs->picHeader);
+#endif
+
+    m_pcPic->createGrainSynthesizer(m_firstPictureInSequence, &m_grainCharacteristic, &m_grainBuf,
+                                    pps->getPicWidthInLumaSamples(), pps->getPicHeightInLumaSamples(),
+                                    sps->getChromaFormatIdc(), sps->getBitDepth(ChannelType::LUMA));
+    m_pcPic->createColourTransfProcessor(m_firstPictureInSequence, &m_colourTranfParams, &m_invColourTransfBuf,
+                                         pps->getPicWidthInLumaSamples(), pps->getPicHeightInLumaSamples(),
+                                         sps->getChromaFormatIdc(), sps->getBitDepth(ChannelType::LUMA));
+    m_firstPictureInSequence = false;
+    m_pcPic->createTempBuffers( m_pcPic->cs->pps->pcv->maxCUWidth );
+    m_pcPic->cs->createCoeffs((bool)m_pcPic->cs->sps->getPLTMode());
+
+    m_pcPic->allocateNewSlice();
+    // make the slice-pilot a real slice, and set up the slice-pilot for the next slice
+    CHECK(m_pcPic->slices.size() != (m_uiSliceSegmentIdx + 1), "Invalid number of slices");
+    m_apcSlicePilot = m_pcPic->swapSliceObject(m_apcSlicePilot, m_uiSliceSegmentIdx);
+
+    // we now have a real slice:
+    Slice *pSlice = m_pcPic->slices[m_uiSliceSegmentIdx];
+#if GDR_ENABLED
+    pSlice->setPicHeader(m_pcPic->cs->picHeader);
+#endif
+
+    // Update the PPS and SPS pointers with the ones of the picture.
+    pps=pSlice->getPPS();
+    sps=pSlice->getSPS();
+
+    // fix Parameter Sets, now that we have the real slice
+    m_pcPic->cs->slice = pSlice;
+    m_pcPic->cs->sps   = sps;
+    m_pcPic->cs->pps   = pps;
+    m_pcPic->cs->vps = vps;
+
+    memcpy(m_pcPic->cs->alfApss, apss, sizeof(m_pcPic->cs->alfApss));
+    m_pcPic->cs->lmcsAps = lmcsAPS;
+    m_pcPic->cs->scalinglistAps = scalinglistAPS;
+
+    m_pcPic->cs->pcv   = pps->pcv;
+
+    // Initialise the various objects for the new set of settings
+    const int maxDepth = floorLog2(sps->getMaxCUWidth()) - pps->pcv->minCUWidthLog2;
+    const uint32_t log2SaoOffsetScaleLuma =
+      (uint32_t) std::max(0, sps->getBitDepth(ChannelType::LUMA) - MAX_SAO_TRUNCATED_BITDEPTH);
+    const uint32_t log2SaoOffsetScaleChroma =
+      (uint32_t) std::max(0, sps->getBitDepth(ChannelType::CHROMA) - MAX_SAO_TRUNCATED_BITDEPTH);
+    m_cSAO.create( pps->getPicWidthInLumaSamples(), pps->getPicHeightInLumaSamples(),
+                   sps->getChromaFormatIdc(),
+                   sps->getMaxCUWidth(), sps->getMaxCUHeight(),
+                   maxDepth,
+                   log2SaoOffsetScaleLuma, log2SaoOffsetScaleChroma );
+    m_deblockingFilter.create(maxDepth);
+    m_cIntraPred.init(sps->getChromaFormatIdc(), sps->getBitDepth(ChannelType::LUMA));
+    m_cInterPred.init( &m_cRdCost, sps->getChromaFormatIdc(), sps->getMaxCUHeight() );
+    if (sps->getUseLmcs())
+    {
+      m_cReshaper.createDec(sps->getBitDepth(ChannelType::LUMA));
+    }
+
+    bool isField = false;
+    bool isTopField = false;
+
+    if(!m_SEIs.empty())
+    {
+      // Check if any new Frame Field Info SEI has arrived
+      SEIMessages frameFieldSEIs = getSeisByType(m_SEIs, SEI::PayloadType::FRAME_FIELD_INFO);
+      if (frameFieldSEIs.size()>0)
+      {
+        SEIFrameFieldInfo* ff = (SEIFrameFieldInfo*) *(frameFieldSEIs.begin());
+        isField    = ff->m_fieldPicFlag;
+        isTopField = isField && (!ff->m_bottomFieldFlag);
+      }
+      SEIMessages inclusionSEIs = getSeisByType(m_SEIs, SEI::PayloadType::PARAMETER_SETS_INCLUSION_INDICATION);
+      const SEIParameterSetsInclusionIndication *inclusion =
+        (inclusionSEIs.size() > 0) ? (SEIParameterSetsInclusionIndication *) *(inclusionSEIs.begin()) : nullptr;
+      if (inclusion != nullptr)
+      {
+        m_seiInclusionFlag = inclusion->m_selfContainedClvsFlag;
+      }
+    }
+    if (m_seiInclusionFlag)
+    {
+      checkParameterSetsInclusionSEIconstraints(nalu);
+    }
+
+    //Set Field/Frame coding mode
+    m_pcPic->fieldPic = isField;
+    m_pcPic->topField = isTopField;
+
+    // transfer any SEI messages that have been received to the picture
+    m_pcPic->SEIs = m_SEIs;
+    m_SEIs.clear();
+
+    // Recursive structure
+    m_cCuDecoder.init( &m_cTrQuant, &m_cIntraPred, &m_cInterPred );
+    if (sps->getUseLmcs())
+    {
+      m_cCuDecoder.initDecCuReshaper(&m_cReshaper, sps->getChromaFormatIdc());
+    }
+    m_cTrQuant.init(m_cTrQuantScalingList.getQuant(), sps->getMaxTbSize(), false, false, false, false);
+
+    // RdCost
+    m_cRdCost.setCostMode ( COST_STANDARD_LOSSY ); // not used in decoder side RdCost stuff -> set to default
+
+    m_cSliceDecoder.create();
+
+    if( sps->getALFEnabledFlag() )
+    {
+      const int maxDepth = floorLog2(sps->getMaxCUWidth()) - sps->getLog2MinCodingBlockSize();
+      m_cALF.create(pps->getPicWidthInLumaSamples(), pps->getPicHeightInLumaSamples(), sps->getChromaFormatIdc(),
+                    sps->getMaxCUWidth(), sps->getMaxCUHeight(), maxDepth, sps->getBitDepths());
+    }
+    pSlice->m_ccAlfFilterControl[0] = m_cALF.getCcAlfControlIdc(COMPONENT_Cb);
+    pSlice->m_ccAlfFilterControl[1] = m_cALF.getCcAlfControlIdc(COMPONENT_Cr);
+  }
+  else
+  {
+    // make the slice-pilot a real slice, and set up the slice-pilot for the next slice
+    m_pcPic->allocateNewSlice();
+    CHECK(m_pcPic->slices.size() != (size_t)(m_uiSliceSegmentIdx + 1), "Invalid number of slices");
+    m_apcSlicePilot = m_pcPic->swapSliceObject(m_apcSlicePilot, m_uiSliceSegmentIdx);
+
+    Slice *pSlice = m_pcPic->slices[m_uiSliceSegmentIdx]; // we now have a real slice.
+
+    const SPS *sps = pSlice->getSPS();
+    const PPS *pps = pSlice->getPPS();
+    APS** apss = pSlice->getAlfAPSs();
+    APS *lmcsAPS = m_picHeader.getLmcsAPS();
+    APS *scalinglistAPS = m_picHeader.getScalingListAPS();
+
+    // fix Parameter Sets, now that we have the real slice
+    m_pcPic->cs->slice = pSlice;
+    m_pcPic->cs->sps   = sps;
+    m_pcPic->cs->pps   = pps;
+    memcpy(m_pcPic->cs->alfApss, apss, sizeof(m_pcPic->cs->alfApss));
+    m_pcPic->cs->lmcsAps = lmcsAPS;
+    m_pcPic->cs->scalinglistAps = scalinglistAPS;
+
+    m_pcPic->cs->pcv   = pps->pcv;
+
+    // check that the current active PPS has not changed...
+    if (m_parameterSetManager.getSPSChangedFlag(sps->getSPSId()) )
+    {
+      EXIT("Error - a new SPS has been decoded while processing a picture");
+    }
+    if (m_parameterSetManager.getPPSChangedFlag(pps->getPPSId()) )
+    {
+      EXIT("Error - a new PPS has been decoded while processing a picture");
+    }
+    for (int i = 0; i < ALF_CTB_MAX_NUM_APS; i++)
+    {
+      APS *aps = m_parameterSetManager.getAPS(i, ApsType::ALF);
+      if (aps && m_parameterSetManager.getAPSChangedFlag(i, ApsType::ALF))
+      {
+        EXIT("Error - a new APS has been decoded while processing a picture");
+      }
+    }
+
+    if (lmcsAPS && m_parameterSetManager.getAPSChangedFlag(lmcsAPS->getAPSId(), ApsType::LMCS))
+    {
+      EXIT("Error - a new LMCS APS has been decoded while processing a picture");
+    }
+    if (scalinglistAPS && m_parameterSetManager.getAPSChangedFlag(scalinglistAPS->getAPSId(), ApsType::SCALING_LIST))
+    {
+      EXIT( "Error - a new SCALING LIST APS has been decoded while processing a picture" );
+    }
+
+    activateAPS(&m_picHeader, pSlice, m_parameterSetManager, apss, lmcsAPS, scalinglistAPS);
+
+    m_pcPic->cs->lmcsAps = lmcsAPS;
+    m_pcPic->cs->scalinglistAps = scalinglistAPS;
+
+    xParsePrefixSEImessages();
+
+    // Check if any new SEI has arrived
+    if (!m_SEIs.empty())
+    {
+      // Currently only decoding Unit SEI message occurring between VCL NALUs copied
+      SEIMessages &picSEI            = m_pcPic->SEIs;
+      SEIMessages  decodingUnitInfos = extractSeisByType(picSEI, SEI::PayloadType::DECODING_UNIT_INFO);
+      picSEI.insert(picSEI.end(), decodingUnitInfos.begin(), decodingUnitInfos.end());
+      deleteSEIs(m_SEIs);
+    }
+    if (m_seiInclusionFlag)
+    {
+      checkParameterSetsInclusionSEIconstraints(nalu);
+    }
+  }
+  xCheckParameterSetConstraints(layerId);
+}
+
+void DecLib::xCheckParameterSetConstraints(const int layerId)
+{
+  // Conformance checks
+  Slice *slice = m_pcPic->slices[m_uiSliceSegmentIdx];
+  const SPS *sps = slice->getSPS();
+  const PPS *pps = slice->getPPS();
+  const VPS *vps = slice->getVPS();
+
+  if (sps->getVPSId() && (vps != nullptr))
+  {
+    bool setVpsId = true;
+    int checkLayer = 0;
+    while (checkLayer <= layerId)
+    {
+      if (!m_firstSliceInSequence[checkLayer++])
+      {
+        setVpsId = false;
+      }
+    }
+    if (setVpsId)
+    {
+      m_clsVPSid = sps->getVPSId();
+    }
+    CHECK(m_clsVPSid != sps->getVPSId(), "The value of sps_video_parameter_set_id shall be the same in all SPSs that are referred to by CLVSs in a CVS.");
+  }
+
+  if (((vps!=nullptr)&&(vps->getVPSGeneralHrdParamsPresentFlag()))||(sps->getGeneralHrdParametersPresentFlag()))
+  {
+    if (((vps != nullptr) && (vps->getVPSGeneralHrdParamsPresentFlag())) && (sps->getGeneralHrdParametersPresentFlag()))
+    {
+      CHECK(!(*vps->getGeneralHrdParameters() == *sps->getGeneralHrdParameters()), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
+    }
+    if (!m_isFirstGeneralHrd)
+    {
+      CHECK(!(m_prevGeneralHrdParams == (sps->getGeneralHrdParametersPresentFlag() ? *sps->getGeneralHrdParameters() : *vps->getGeneralHrdParameters())), "It is a requirement of bitstream conformance that the content of the general_hrd_parameters( ) syntax structure present in any VPSs or SPSs in the bitstream shall be identical");
+    }
+    m_prevGeneralHrdParams = (sps->getGeneralHrdParametersPresentFlag() ? *sps->getGeneralHrdParameters() : *vps->getGeneralHrdParameters());
+  }
+  m_isFirstGeneralHrd = false;
+  static std::unordered_map<int, int> m_clvssSPSid;
+
+  if( slice->isClvssPu() && m_bFirstSliceInPicture )
+  {
+    m_clvssSPSid[layerId] = pps->getSPSId();
+  }
+
+  CHECK( m_clvssSPSid[layerId] != pps->getSPSId(), "The value of pps_seq_parameter_set_id shall be the same in all PPSs that are referred to by coded pictures in a CLVS" );
+
+  CHECK(sps->getGDREnabledFlag() == false && m_picHeader.getGdrPicFlag(), "When sps_gdr_enabled_flag is equal to 0, the value of ph_gdr_pic_flag shall be equal to 0 ");
+  if( !sps->getUseWP() )
+  {
+    CHECK( pps->getUseWP(), "When sps_weighted_pred_flag is equal to 0, the value of pps_weighted_pred_flag shall be equal to 0." );
+  }
+
+  if( !sps->getUseWPBiPred() )
+  {
+    CHECK( pps->getWPBiPred(), "When sps_weighted_bipred_flag is equal to 0, the value of pps_weighted_bipred_flag shall be equal to 0." );
+  }
+
+  const int minCuSize = 1 << sps->getLog2MinCodingBlockSize();
+  CHECK( ( pps->getPicWidthInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
+  CHECK( ( pps->getPicHeightInLumaSamples() % ( std::max( 8, minCuSize) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
+  if (!sps->getResChangeInClvsEnabledFlag())
+  {
+    CHECK(pps->getPicWidthInLumaSamples() != sps->getMaxPicWidthInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_width_in_luma_samples shall be equal to sps_pic_width_max_in_luma_samples.");
+    CHECK(pps->getPicHeightInLumaSamples() != sps->getMaxPicHeightInLumaSamples(), "When sps_res_change_in_clvs_allowed_flag equal to 0, the value of pps_pic_height_in_luma_samples shall be equal to sps_pic_height_max_in_luma_samples.");
+  }
+  if (sps->getResChangeInClvsEnabledFlag())
+  {
+    CHECK(sps->getSubPicInfoPresentFlag() != 0, "When sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0.");
+  }
+  CHECK(sps->getResChangeInClvsEnabledFlag() && sps->getVirtualBoundariesPresentFlag(), "when the value of sps_res_change_in_clvs_allowed_flag is equal to 1, the value of sps_virtual_boundaries_present_flag shall be equal to 0");
+
+  if( sps->getCTUSize() + 2 * ( 1 << sps->getLog2MinCodingBlockSize() ) > pps->getPicWidthInLumaSamples() )
+  {
+    CHECK( pps->getWrapAroundEnabledFlag(), "Wraparound shall be disabled when the value of ( CtbSizeY / MinCbSizeY + 1) is greater than or equal to ( pps_pic_width_in_luma_samples / MinCbSizeY - 1 )" );
+  }
+
+  if( vps != nullptr && vps->m_numOutputLayersInOls[vps->m_targetOlsIdx] > 1 )
+  {
+    CHECK( sps->getMaxPicWidthInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).width, "sps_pic_width_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_width[ i ]" );
+    CHECK( sps->getMaxPicHeightInLumaSamples() > vps->getOlsDpbPicSize( vps->m_targetOlsIdx ).height, "sps_pic_height_max_in_luma_samples shall be less than or equal to the value of vps_ols_dpb_pic_height[ i ]" );
+    CHECK( sps->getChromaFormatIdc() > vps->getOlsDpbChromaFormatIdc( vps->m_targetOlsIdx ), "sps_chroma_format_idc shall be less than or equal to the value of vps_ols_dpb_chroma_format[ i ]");
+    CHECK((sps->getBitDepth(ChannelType::LUMA) - 8) > vps->getOlsDpbBitDepthMinus8(vps->m_targetOlsIdx),
+          "sps_bitdepth_minus8 shall be less than or equal to the value of vps_ols_dpb_bitdepth_minus8[ i ]");
+  }
+
+  static std::unordered_map<int, ChromaFormat> m_layerChromaFormat;
+  static std::unordered_map<int, int> m_layerBitDepth;
+
+  if (vps != nullptr && vps->getMaxLayers() > 1)
+  {
+    int curLayerIdx = vps->getGeneralLayerIdx(layerId);
+    ChromaFormat curLayerChromaFormat = sps->getChromaFormatIdc();
+    int curLayerBitDepth     = sps->getBitDepth(ChannelType::LUMA);
+
+    if( slice->isClvssPu() && m_bFirstSliceInPicture )
+    {
+      m_layerChromaFormat[curLayerIdx] = curLayerChromaFormat;
+      m_layerBitDepth[curLayerIdx] = curLayerBitDepth;
+    }
+    else
+    {
+      CHECK(m_layerChromaFormat[curLayerIdx] != curLayerChromaFormat, "Different chroma format in the same layer.");
+      CHECK(m_layerBitDepth[curLayerIdx] != curLayerBitDepth, "Different bit-depth in the same layer.");
+    }
+
+    for (int i = 0; i < curLayerIdx; i++)
+    {
+      if (vps->getDirectRefLayerFlag(curLayerIdx, i))
+      {
+        ChromaFormat refLayerChromaFormat = m_layerChromaFormat[i];
+        CHECK(curLayerChromaFormat != refLayerChromaFormat, "The chroma formats of the current layer and the reference layer are different");
+        int refLayerBitDepth = m_layerBitDepth[i];
+        CHECK(curLayerBitDepth != refLayerBitDepth, "The bit-depth of the current layer and the reference layer are different");
+        if (vps->getMaxTidIlRefPicsPlus1(curLayerIdx, i) == 0 && pps->getMixedNaluTypesInPicFlag())
+        {
+          for (int j = 0; j < m_uiSliceSegmentIdx; j++)
+          {
+            Slice* preSlice = m_pcPic->slices[j];
+            CHECK( (preSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || preSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP || preSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA), "mixed IRAP and non-IRAP NAL units in the picture when sps_video_parameter_set_id is greater than 0 and vps_max_tid_il_ref_pics_plus1[i][j] is equal to 0");
+          }
+        }
+      }
+    }
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getOneTilePerPicConstraintFlag())
+  {
+    CHECK(pps->getNumTiles() != 1, "When one_tile_per_pic_constraint_flag is equal to 1, each picture shall contain only one tile");
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerPicConstraintFlag())
+  {
+    CHECK( pps->getRectSliceFlag() && pps->getNumSlicesInPic() != 1, "When one_slice_per_pic_constraint_flag is equal to 1 and if pps_rect_slice_flag is equal to 1, the value of pps_num_slices_in_pic_minus1 shall be equal to 0");
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoRprConstraintFlag())
+  {
+    CHECK(sps->getRprEnabledFlag(), "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, the value of sps_ref_pic_resampling_enabled_flag shall be equal to 0");
+  }
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoResChangeInClvsConstraintFlag())
+  {
+    CHECK(sps->getResChangeInClvsEnabledFlag(), "When gci_no_res_change_in_clvs_constraint_flag is equal to 1, the value of sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoIdrRplConstraintFlag())
+  {
+    CHECK(sps->getIDRRefParamListPresent(), "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0")
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoMixedNaluTypesInPicConstraintFlag())
+  {
+    CHECK(pps->getMixedNaluTypesInPicFlag(), "When gci_no_mixed_nalu_types_in_pic_constraint_flag equal to 1, the value of pps_mixed_nalu_types_in_pic_flag shall be equal to 0")
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoGdrConstraintFlag())
+  {
+    CHECK(sps->getGDREnabledFlag(), "gci_no_gdr_constraint_flag equal to 1 specifies that sps_gdr_enabled_flag for all pictures in OlsInScope shall be equal to 0");
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoRectSliceConstraintFlag())
+  {
+    CHECK(pps->getRectSliceFlag(), "When gci_no_rectangular_slice_constraint_flag equal to 1, the value of pps_rect_slice_flag shall be equal to 0")
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerSubpicConstraintFlag())
+  {
+    CHECK(!(pps->getSingleSlicePerSubPicFlag()), "When gci_one_slice_per_subpic_constraint_flag equal to 1, the value of pps_single_slice_per_subpic_flag shall be equal to 1")
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoSubpicInfoConstraintFlag())
+  {
+    CHECK(sps->getSubPicInfoPresentFlag(), "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0")
+  }
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoMttConstraintFlag())
+  {
+    CHECK((sps->getMaxMTTHierarchyDepth() || sps->getMaxMTTHierarchyDepthI() || sps->getMaxMTTHierarchyDepthIChroma()), "When gci_no_mtt_constraint_flag is equal to 1, the values of sps_max_mtt_hierarchy_depth_intra_slice_luma, sps_max_mtt_hierarchy_depth_inter_slice and sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be equal to 0");
+  }
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoWeightedPredictionConstraintFlag())
+  {
+    CHECK((sps->getUseWP() || sps->getUseWPBiPred()), "When gci_no_weighted_prediction_constraint_flag is equal to 1, the values of sps_weighted_pred_flag and sps_weighted_bipred_flag shall be equal to 0");
+  }
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoChromaQpOffsetConstraintFlag())
+  {
+    CHECK((pps->getCuChromaQpOffsetListEnabledFlag()), "When gci_no_ChromaQpOffset_constraint_flag is equal to 1, the values of pps_cu_chroma_qp_offset_list_enabled_flag shall be equal to 0");
+  }
+
+  CHECK(sps->getCTUSize() > (1 << sps->getProfileTierLevel()->getConstraintInfo()->getMaxLog2CtuSizeConstraintIdc()), "The CTU size specified by sps_log2_ctu_size_minus5 shall not exceed the constraint specified by gci_three_minus_max_log2_ctu_size_constraint_idc");
+
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getNoLumaTransformSize64ConstraintFlag())
+  {
+    CHECK(sps->getLog2MaxTbSize() != 5, "When gci_no_luma_transform_size_64_constraint_flag is equal to 1, the value of sps_max_luma_transform_size_64_flag shall be equal to 0");
+  }
+
+  if (sps->getMaxPicWidthInLumaSamples() == pps->getPicWidthInLumaSamples() &&
+      sps->getMaxPicHeightInLumaSamples() == pps->getPicHeightInLumaSamples())
+  {
+    const Window& spsConfWin = sps->getConformanceWindow();
+    const Window& ppsConfWin = pps->getConformanceWindow();
+    CHECK(spsConfWin.getWindowLeftOffset() != ppsConfWin.getWindowLeftOffset(), "When picture size is equal to maximum picutre size, conformance window left offset in SPS and PPS shall be equal");
+    CHECK(spsConfWin.getWindowRightOffset() != ppsConfWin.getWindowRightOffset(), "When picture size is equal to maximum picutre size, conformance window right offset in SPS and PPS shall be equal");
+    CHECK(spsConfWin.getWindowTopOffset() != ppsConfWin.getWindowTopOffset(), "When picture size is equal to maximum picutre size, conformance window top offset in SPS and PPS shall be equal");
+    CHECK(spsConfWin.getWindowBottomOffset() != ppsConfWin.getWindowBottomOffset(), "When picture size is equal to maximum picutre size, conformance window bottom offset in SPS and PPS shall be equal");
+  }
+  int levelIdcSps = int(sps->getProfileTierLevel()->getLevelIdc());
+  int maxLevelIdxDci = 0;
+  if (m_dci)
+  {
+    for (int i = 0; i < m_dci->getNumPTLs(); i++)
+    {
+      if (maxLevelIdxDci < int(m_dci->getProfileTierLevel(i).getLevelIdc()))
+      {
+        maxLevelIdxDci = int(m_dci->getProfileTierLevel(i).getLevelIdc());
+      }
+    }
+    CHECK(levelIdcSps > maxLevelIdxDci, "max level signaled in the DCI shall not be less than the level signaled in the SPS");
+  }
+
+
+  if( slice->getPicHeader()->getGdrOrIrapPicFlag() && !slice->getPicHeader()->getGdrPicFlag() && ( !vps || vps->getIndependentLayerFlag( vps->getGeneralLayerIdx( layerId ) ) ) )
+  {
+    CHECK( slice->getPicHeader()->getPicInterSliceAllowedFlag(),
+      "When ph_gdr_or_irap_pic_flag is equal to 1 and ph_gdr_pic_flag is equal to 0 and vps_independent_layer_flag[ GeneralLayerIdx[ nuh_layer_id ] ] is equal to 1, ph_inter_slice_allowed_flag shall be equal to 0" );
+  }
+
+  if( sps->getVPSId() && vps->m_numLayersInOls[vps->m_targetOlsIdx] == 1 )
+  {
+    CHECK( !sps->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is greater than 0 and there is an OLS that contains only one layer with nuh_layer_id equal to the nuh_layer_id of the SPS, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+  }
+
+  const ProfileTierLevel &ptl = vps && vps->getNumLayersInOls(vps->m_targetOlsIdx) > 1
+      ? vps->getProfileTierLevel(vps->getOlsPtlIdx(vps->m_targetOlsIdx))
+      : *sps->getProfileTierLevel();
+
+  ProfileTierLevelFeatures ptlFeatures;
+  ptlFeatures.extractPTLInformation(ptl);
+  const ProfileFeatures *profileFeatures = ptlFeatures.getProfileFeatures();
+  if (profileFeatures != nullptr)
+  {
+    CHECK(sps->getBitDepth(ChannelType::LUMA) > profileFeatures->maxBitDepth, "Bit depth exceeds profile limit");
+    CHECK(sps->getChromaFormatIdc() > profileFeatures->maxChromaFormat, "Chroma format exceeds profile limit");
+  }
+  else
+  {
+    CHECK(sps->getProfileTierLevel()->getProfileIdc() != Profile::NONE, "Unknown profile");
+    msg(WARNING, "Warning: Profile set to none or unknown value\n");
+  }
+  const TierLevelFeatures *tierLevelFeatures = ptlFeatures.getTierLevelFeatures();
+  if (tierLevelFeatures != nullptr)
+  {
+    CHECK(pps->getNumTileColumns() > tierLevelFeatures->maxTileCols,
+          "Number of tile columns signaled in PPS exceeds level limit");
+    CHECK(pps->getNumTiles() > tierLevelFeatures->maxTilesPerAu, "Number of tiles signaled in PPS exceeds level limit");
+  }
+  else if (profileFeatures != nullptr)
+  {
+    CHECK(sps->getProfileTierLevel()->getLevelIdc() == Level::LEVEL15_5, "Cannot use level 15.5 with given profile");
+    CHECK(sps->getProfileTierLevel()->getLevelIdc() != Level::NONE, "Unknown level");
+    msg(WARNING, "Warning: Level set to none, invalid or unknown value\n");
+  }
+}
+
+
+void DecLib::xParsePrefixSEIsForUnknownVCLNal()
+{
+  while (!m_prefixSEINALUs.empty())
+  {
+    // do nothing?
+    msg( NOTICE, "Discarding Prefix SEI associated with unknown VCL NAL unit.\n");
+    delete m_prefixSEINALUs.front();
+    m_prefixSEINALUs.pop_front();
+  }
+  // TODO: discard following suffix SEIs as well?
+}
+
+
+void DecLib::xParsePrefixSEImessages()
+{
+  while (!m_prefixSEINALUs.empty())
+  {
+    InputNALUnit &nalu=*m_prefixSEINALUs.front();
+    m_accessUnitSeiNalus.push_back(new InputNALUnit(nalu));
+    m_accessUnitSeiTids.push_back(nalu.m_temporalId);
+    const SPS *sps = m_parameterSetManager.getActiveSPS();
+    const VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
+    const bool seiMessageRead = m_seiReader.parseSEImessage( &(nalu.getBitstream()), m_SEIs, nalu.m_nalUnitType, nalu.m_nuhLayerId, nalu.m_temporalId, vps, sps, m_HRD, m_pDecodedSEIOutputStream );
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+    m_seiCfgDump.write360SeiDump( m_decoded360SeiDumpFileName, m_SEIs, sps );
+#endif
+    if (seiMessageRead)
+    {
+      m_accessUnitSeiPayLoadTypes.push_back(std::tuple<NalUnitType, int, SEI::PayloadType>(nalu.m_nalUnitType, nalu.m_nuhLayerId, m_SEIs.back()->payloadType()));
+    }
+    delete m_prefixSEINALUs.front();
+    m_prefixSEINALUs.pop_front();
+  }
+  xCheckPrefixSEIMessages(m_SEIs);
+  SEIMessages scalableNestingSEIs = getSeisByType(m_SEIs, SEI::PayloadType::SCALABLE_NESTING);
+  if (scalableNestingSEIs.size())
+  {
+    SEIScalableNesting *nestedSei = (SEIScalableNesting*)scalableNestingSEIs.front();
+    SEIMessages         nestedSliSei = getSeisByType(nestedSei->m_nestedSEIs, SEI::PayloadType::SUBPICTURE_LEVEL_INFO);
+    if (nestedSliSei.size() > 0)
+    {
+      AccessUnitNestedSliSeiInfo sliSeiInfo;
+      sliSeiInfo.m_nestedSliPresent = true;
+      sliSeiInfo.m_numOlssNestedSli = nestedSei->m_snNumOlssMinus1 + 1;
+      for (uint32_t olsIdxNestedSei = 0; olsIdxNestedSei <= nestedSei->m_snNumOlssMinus1; olsIdxNestedSei++)
+      {
+        sliSeiInfo.m_olsIdxNestedSLI[olsIdxNestedSei] = nestedSei->m_snOlsIdx[olsIdxNestedSei];
+      }
+      m_accessUnitNestedSliSeiInfo.push_back(sliSeiInfo);
+    }
+  }
+  xCheckDUISEIMessages(m_SEIs);
+}
+
+void DecLib::xCheckPrefixSEIMessages( SEIMessages& prefixSEIs )
+{
+  SEIMessages picTimingSEIs  = getSeisByType(prefixSEIs, SEI::PayloadType::PICTURE_TIMING);
+  SEIMessages frameFieldSEIs = getSeisByType(prefixSEIs, SEI::PayloadType::FRAME_FIELD_INFO);
+
+  if (!picTimingSEIs.empty() && !frameFieldSEIs.empty())
+  {
+    SEIPictureTiming  *pt = (SEIPictureTiming*)  picTimingSEIs.front();
+    SEIFrameFieldInfo *ff = (SEIFrameFieldInfo*) frameFieldSEIs.front();
+    if( pt->m_ptDisplayElementalPeriodsMinus1 != ff->m_displayElementalPeriodsMinus1 )
+    {
+      msg( WARNING, "Warning: ffi_display_elemental_periods_minus1 is different in picture timing and frame field information SEI messages!");
+    }
+  }
+  if ((getVPS()->getMaxLayers() == 1 || m_audIrapOrGdrAuFlag) && (m_isFirstAuInCvs || m_accessUnitPicInfo.begin()->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP || m_accessUnitPicInfo.begin()->m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || ((m_accessUnitPicInfo.begin()->m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA || m_accessUnitPicInfo.begin()->m_nalUnitType == NAL_UNIT_CODED_SLICE_GDR) && m_lastNoOutputBeforeRecoveryFlag[m_accessUnitPicInfo.begin()->m_nuhLayerId])) && m_accessUnitPicInfo.size() == 1)
+  {
+    if (m_sdiSEIInFirstAU != nullptr)
+    {
+      delete m_sdiSEIInFirstAU;
+    }
+    m_sdiSEIInFirstAU = nullptr;
+    if (m_maiSEIInFirstAU != nullptr)
+    {
+      delete m_maiSEIInFirstAU;
+    }
+    m_maiSEIInFirstAU = nullptr;
+    if (m_mvpSEIInFirstAU != nullptr)
+    {
+      delete m_mvpSEIInFirstAU;
+    }
+    m_mvpSEIInFirstAU    = nullptr;
+    SEIMessages sdiSEIs  = getSeisByType(prefixSEIs, SEI::PayloadType::SCALABILITY_DIMENSION_INFO);
+    if (!sdiSEIs.empty())
+    {
+      SEIScalabilityDimensionInfo *sdi = (SEIScalabilityDimensionInfo*)sdiSEIs.front();
+      m_sdiSEIInFirstAU = new SEIScalabilityDimensionInfo(*sdi);
+      if (sdiSEIs.size() > 1)
+      {
+        for (SEIMessages::const_iterator it=sdiSEIs.begin(); it!=sdiSEIs.end(); it++)
+        {
+          CHECK(!m_sdiSEIInFirstAU->isSDISameContent((SEIScalabilityDimensionInfo*)*it), "All SDI SEI messages in a CVS shall have the same content.")
+        }
+      }
+    }
+    SEIMessages maiSEIs = getSeisByType(prefixSEIs, SEI::PayloadType::MULTIVIEW_ACQUISITION_INFO);
+    if (!maiSEIs.empty())
+    {
+      SEIMultiviewAcquisitionInfo *mai = (SEIMultiviewAcquisitionInfo*)maiSEIs.front();
+      m_maiSEIInFirstAU = new SEIMultiviewAcquisitionInfo(*mai);
+      if (maiSEIs.size() > 1)
+      {
+        for (SEIMessages::const_iterator it=maiSEIs.begin(); it!=maiSEIs.end(); it++)
+        {
+          CHECK(!m_maiSEIInFirstAU->isMAISameContent((SEIMultiviewAcquisitionInfo*)*it), "All MAI SEI messages in a CVS shall have the same content.")
+        }
+      }
+    }
+    SEIMessages mvpSEIs = getSeisByType(prefixSEIs, SEI::PayloadType::MULTIVIEW_VIEW_POSITION);
+    if (!mvpSEIs.empty())
+    {
+      SEIMultiviewViewPosition *mvp = (SEIMultiviewViewPosition*)mvpSEIs.front();
+      m_mvpSEIInFirstAU = new SEIMultiviewViewPosition(*mvp);
+      if (mvpSEIs.size() > 1)
+      {
+        for (SEIMessages::const_iterator it = mvpSEIs.begin(); it != mvpSEIs.end(); it++)
+        {
+          CHECK(!m_mvpSEIInFirstAU->isMVPSameContent((SEIMultiviewViewPosition*)*it), "All MVP SEI messages in a CVS shall have the same content.")
+        }
+      }
+    }
+  }
+  else
+  {
+    SEIMessages sdiSEIs = getSeisByType(prefixSEIs, SEI::PayloadType::SCALABILITY_DIMENSION_INFO);
+    CHECK(!m_sdiSEIInFirstAU && !sdiSEIs.empty(), "When an SDI SEI message is present in any AU of a CVS, an SDI SEI message shall be present for the first AU of the CVS.");
+    if (!sdiSEIs.empty())
+    {
+      for (SEIMessages::const_iterator it=sdiSEIs.begin(); it!=sdiSEIs.end(); it++)
+      {
+        CHECK(!m_sdiSEIInFirstAU->isSDISameContent((SEIScalabilityDimensionInfo*)*it), "All SDI SEI messages in a CVS shall have the same content.")
+      }
+    }
+    SEIMessages maiSEIs = getSeisByType(prefixSEIs, SEI::PayloadType::MULTIVIEW_ACQUISITION_INFO);
+    CHECK(!m_maiSEIInFirstAU && !maiSEIs.empty(), "When an MAI SEI message is present in any AU of a CVS, an MAI SEI message shall be present for the first AU of the CVS.");
+    if (!maiSEIs.empty())
+    {
+      for (SEIMessages::const_iterator it=maiSEIs.begin(); it!=maiSEIs.end(); it++)
+      {
+        CHECK(!m_maiSEIInFirstAU->isMAISameContent((SEIMultiviewAcquisitionInfo*)*it), "All MAI SEI messages in a CVS shall have the same content.")
+      }
+    }
+    SEIMessages mvpSEIs = getSeisByType(prefixSEIs, SEI::PayloadType::MULTIVIEW_VIEW_POSITION);
+    CHECK(!m_mvpSEIInFirstAU && !mvpSEIs.empty(), "When an MVP SEI message is present in any AU of a CVS, an MVP SEI message shall be present for the first AU of the CVS.");
+    if (!mvpSEIs.empty())
+    {
+      for (SEIMessages::const_iterator it = mvpSEIs.begin(); it != mvpSEIs.end(); it++)
+      {
+        CHECK(!m_mvpSEIInFirstAU->isMVPSameContent((SEIMultiviewViewPosition*)*it), "All MVP SEI messages in a CVS shall have the same content.")
+      }
+    }
+  }
+
+  for (SEIMessages::const_iterator it=prefixSEIs.begin(); it!=prefixSEIs.end(); it++)
+  {
+    if ((*it)->payloadType() == SEI::PayloadType::MULTIVIEW_ACQUISITION_INFO)
+    {
+      CHECK(!m_sdiSEIInFirstAU, "When a CVS does not contain an SDI SEI message, the CVS shall not contain an MAI SEI message.");
+      SEIMultiviewAcquisitionInfo *maiSei = (SEIMultiviewAcquisitionInfo*)*it;
+      CHECK(m_sdiSEIInFirstAU->m_sdiNumViews - 1 != maiSei->m_maiNumViewsMinus1, "The value of num_views_minus1 shall be equal to NumViews - 1");
+    }
+    else if ((*it)->payloadType() == SEI::PayloadType::ALPHA_CHANNEL_INFO)
+    {
+      CHECK(!m_sdiSEIInFirstAU, "When a CVS does not contain an SDI SEI message with sdi_aux_id[i] equal to 1 for at least one value of i, no picture in the CVS shall be associated with an ACI SEI message.");
+    }
+    else if ((*it)->payloadType() == SEI::PayloadType::DEPTH_REPRESENTATION_INFO)
+    {
+      CHECK(!m_sdiSEIInFirstAU, "When a CVS does not contain an SDI SEI message with sdi_aux_id[i] equal to 2 for at least one value of i, no picture in the CVS shall be associated with a DRI SEI message.");
+    }
+    else if ((*it)->payloadType() == SEI::PayloadType::MULTIVIEW_VIEW_POSITION)
+    {
+      CHECK(!m_sdiSEIInFirstAU, "When a CVS does not contain an SDI SEI message, the CVS shall not contain an MVP SEI message.");
+      SEIMultiviewViewPosition *mvpSei = (SEIMultiviewViewPosition*)*it;
+      CHECK(m_sdiSEIInFirstAU->m_sdiNumViews - 1 != mvpSei->m_mvpNumViewsMinus1, "The value of num_views_minus1 shall be equal to NumViews - 1");
+    }
+  }
+}
+
+void DecLib::xCheckDUISEIMessages(SEIMessages &prefixSEIs)
+{
+  SEIMessages BPSEIs  = getSeisByType(prefixSEIs, SEI::PayloadType::BUFFERING_PERIOD);
+  SEIMessages DUISEIs = getSeisByType(prefixSEIs, SEI::PayloadType::DECODING_UNIT_INFO);
+  if (BPSEIs.empty())
+  {
+    return;
+  }
+  else
+  {
+    bool duDelayFlag = false;
+
+    SEIBufferingPeriod *bp = (SEIBufferingPeriod *) BPSEIs.front();
+    if (bp->m_bpDecodingUnitHrdParamsPresentFlag)
+    {
+      if (!bp->m_decodingUnitDpbDuParamsInPicTimingSeiFlag)
+      {
+        if (DUISEIs.empty())
+        {
+          return;
+        }
+        for (auto it = DUISEIs.cbegin(); it != DUISEIs.cend(); ++it)
+        {
+          const SEIDecodingUnitInfo *dui = (const SEIDecodingUnitInfo *) *it;
+          if (dui->m_picSptDpbOutputDuDelay != -1)
+          {
+            duDelayFlag = true;
+            break;
+          }
+        }
+        CHECK(duDelayFlag == false, "At least one DUI SEI should have dui->m_picSptDpbOutputDuDelay not equal to -1")
+      }
+    }
+  }
+}
+
+
+void DecLib::xDecodePicHeader( InputNALUnit& nalu )
+{
+  m_HLSReader.setBitstream( &nalu.getBitstream() );
+  m_HLSReader.parsePictureHeader( &m_picHeader, &m_parameterSetManager, true );
+  m_picHeader.setValid();
+}
+
+bool DecLib::getMixedNaluTypesInPicFlag()
+{
+  if (!m_picHeader.isValid())
+  {
+    return false;
+  }
+
+  PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
+  CHECK(pps == 0, "No PPS present");
+
+  return pps->getMixedNaluTypesInPicFlag();
+}
+
+bool DecLib::xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDisplay )
+{
+  m_apcSlicePilot->setPicHeader( &m_picHeader );
+  m_apcSlicePilot->initSlice(); // the slice pilot is an object to prepare for a new slice
+                                // it is not associated with picture, sps or pps structures.
+
+  Picture* scaledRefPic[MAX_NUM_REF] = {};
+
+  if (m_bFirstSliceInPicture)
+  {
+    m_uiSliceSegmentIdx = 0;
+  }
+  else
+  {
+    CHECK(nalu.m_nalUnitType != m_pcPic->slices[m_uiSliceSegmentIdx - 1]->getNalUnitType() && !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag(), "If pps_mixed_nalu_types_in_pic_flag is equal to 0, the value of NAL unit type shall be the same for all coded slice NAL units of a picture");
+    m_apcSlicePilot->copySliceInfo( m_pcPic->slices[m_uiSliceSegmentIdx-1] );
+  }
+
+  m_apcSlicePilot->setNalUnitType(nalu.m_nalUnitType);
+  m_apcSlicePilot->setNalUnitLayerId(nalu.m_nuhLayerId);
+  m_apcSlicePilot->setTLayer(nalu.m_temporalId);
+
+  for( auto& naluTemporalId : m_accessUnitNals )
+  {
+    if (
+      naluTemporalId.m_nalUnitType != NAL_UNIT_OPI &&
+      naluTemporalId.m_nalUnitType != NAL_UNIT_DCI
+      && naluTemporalId.m_nalUnitType != NAL_UNIT_VPS
+      && naluTemporalId.m_nalUnitType != NAL_UNIT_SPS
+      && naluTemporalId.m_nalUnitType != NAL_UNIT_EOS
+      && naluTemporalId.m_nalUnitType != NAL_UNIT_EOB)
+
+    {
+      CHECK( naluTemporalId.m_temporalId < nalu.m_temporalId, "TemporalId shall be greater than or equal to the TemporalId of the layer access unit containing the NAL unit" );
+    }
+  }
+
+  if (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_GDR)
+  {
+    CHECK(nalu.m_temporalId != 0, "Current GDR picture has TemporalId not equal to 0");
+  }
+
+  m_HLSReader.setBitstream( &nalu.getBitstream() );
+  m_apcSlicePilot->m_ccAlfFilterParam = m_cALF.getCcAlfFilterParam();
+  m_HLSReader.parseSliceHeader( m_apcSlicePilot, &m_picHeader, &m_parameterSetManager, m_prevTid0POC, m_prevPicPOC );
+
+  if (m_picHeader.getGdrOrIrapPicFlag() && m_bFirstSliceInPicture)
+  {
+    m_accessUnitNoOutputPriorPicFlags.push_back(m_apcSlicePilot->getNoOutputOfPriorPicsFlag());
+  }
+
+  if (m_picHeader.getGdrPicFlag() && m_prevGDRInSameLayerPOC[nalu.m_nuhLayerId] == -MAX_INT ) // Only care about recovery POC if it is the first coded GDR picture in the layer
+  {
+    m_prevGDRInSameLayerRecoveryPOC[nalu.m_nuhLayerId] = m_apcSlicePilot->getPOC() + m_picHeader.getRecoveryPocCnt();
+  }
+
+  PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
+  CHECK(pps == 0, "No PPS present");
+  SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
+  CHECK(sps == 0, "No SPS present");
+  VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
+
+
+  if (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA && vps != nullptr && (vps->getIndependentLayerFlag(vps->getGeneralLayerIdx(nalu.m_nuhLayerId)) == 1))
+  {
+    CHECK(nalu.m_temporalId == 0, "TemporalID of STSA picture shall not be zero in independent layers");
+  }
+
+  int currSubPicIdx = pps->getSubPicIdxFromSubPicId( m_apcSlicePilot->getSliceSubPicId() );
+  int currSliceAddr = m_apcSlicePilot->getSliceID();
+  for(int sp = 0; sp < currSubPicIdx; sp++)
+  {
+    currSliceAddr -= pps->getSubPic(sp).getNumSlicesInSubPic();
+  }
+  CHECK( currSubPicIdx < m_maxDecSubPicIdx, "Error in the order of coded slice NAL units of subpictures" );
+  CHECK( currSubPicIdx == m_maxDecSubPicIdx && currSliceAddr <= m_maxDecSliceAddrInSubPic, "Error in the order of coded slice NAL units within a subpicture" );
+  if( currSubPicIdx == m_maxDecSubPicIdx )
+  {
+    m_maxDecSliceAddrInSubPic = currSliceAddr;
+  }
+  if( currSubPicIdx > m_maxDecSubPicIdx )
+  {
+    m_maxDecSubPicIdx = currSubPicIdx;
+    m_maxDecSliceAddrInSubPic = currSliceAddr;
+  }
+  if ((sps->getVPSId() == 0) && (m_prevLayerID != MAX_INT))
+  {
+    CHECK(m_prevLayerID != nalu.m_nuhLayerId, "All VCL NAL unit in the CVS shall have the same value of nuh_layer_id "
+                                              "when sps_video_parameter_set_id is equal to 0");
+  }
+  CHECK((sps->getVPSId() > 0) && (vps == 0), "Invalid VPS");
+
+  const ProfileTierLevel &profileTierLevel = (vps == nullptr || vps->getNumLayersInOls(vps->m_targetOlsIdx) == 1)
+    ? *sps->getProfileTierLevel()
+    : vps->getProfileTierLevel(vps->getOlsPtlIdx(vps->m_targetOlsIdx));
+
+  if ((profileTierLevel.getMultiLayerEnabledFlag() == 0) && (m_prevLayerID != MAX_INT))
+  {
+    CHECK(m_prevLayerID != nalu.m_nuhLayerId, "All slices in OlsInScope shall have the same value of nuh_layer_id when ptl_multilayer_enabled_flag is equal to 0" );
+  }
+
+  if( vps != nullptr && !vps->getIndependentLayerFlag( vps->getGeneralLayerIdx( nalu.m_nuhLayerId ) ) )
+  {
+    bool pocIsSet = false;
+    for(auto auNALit=m_accessUnitPicInfo.begin(); auNALit != m_accessUnitPicInfo.end();auNALit++)
+    {
+      for (int refIdx = 0; refIdx < m_apcSlicePilot->getNumRefIdx(REF_PIC_LIST_0) && !pocIsSet; refIdx++)
+      {
+        if (m_apcSlicePilot->getRefPic(REF_PIC_LIST_0, refIdx)
+            && m_apcSlicePilot->getRefPic(REF_PIC_LIST_0, refIdx)->getPOC() == (*auNALit).m_POC)
+        {
+          m_apcSlicePilot->setPOC(m_apcSlicePilot->getRefPic(REF_PIC_LIST_0, refIdx)->getPOC());
+          pocIsSet = true;
+        }
+      }
+      for (int refIdx = 0; refIdx < m_apcSlicePilot->getNumRefIdx(REF_PIC_LIST_1) && !pocIsSet; refIdx++)
+      {
+        if (m_apcSlicePilot->getRefPic(REF_PIC_LIST_1, refIdx)
+            && m_apcSlicePilot->getRefPic(REF_PIC_LIST_1, refIdx)->getPOC() == (*auNALit).m_POC)
+        {
+          m_apcSlicePilot->setPOC(m_apcSlicePilot->getRefPic(REF_PIC_LIST_1, refIdx)->getPOC());
+          pocIsSet = true;
+        }
+      }
+    }
+  }
+
+  // update independent slice index
+  uint32_t uiIndependentSliceIdx = 0;
+  if (!m_bFirstSliceInPicture)
+  {
+    uiIndependentSliceIdx = m_pcPic->slices[m_uiSliceSegmentIdx-1]->getIndependentSliceIdx();
+    uiIndependentSliceIdx++;
+  }
+  m_apcSlicePilot->setIndependentSliceIdx(uiIndependentSliceIdx);
+
+#if K0149_BLOCK_STATISTICS
+  writeBlockStatisticsHeader(sps);
+#endif
+
+  DTRACE_UPDATE( g_trace_ctx, std::make_pair( "poc", m_apcSlicePilot->getPOC() ) );
+
+
+  xUpdatePreviousTid0POC(m_apcSlicePilot);
+
+  m_apcSlicePilot->setPrevGDRInSameLayerPOC(m_prevGDRInSameLayerPOC[nalu.m_nuhLayerId]);
+  m_apcSlicePilot->setAssociatedIRAPPOC(m_pocCRA[nalu.m_nuhLayerId]);
+  m_apcSlicePilot->setAssociatedIRAPType(m_associatedIRAPType[nalu.m_nuhLayerId]);
+
+  if( m_apcSlicePilot->getRapPicFlag() || m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR )
+  {
+    // Derive NoOutputBeforeRecoveryFlag
+    if( !pps->getMixedNaluTypesInPicFlag() )
+    {
+      if( m_firstSliceInSequence[nalu.m_nuhLayerId] )
+      {
+        m_picHeader.setNoOutputBeforeRecoveryFlag( true );
+      }
+      else if( m_apcSlicePilot->getIdrPicFlag() )
+      {
+        m_picHeader.setNoOutputBeforeRecoveryFlag( true );
+      }
+      else if( m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )
+      {
+        m_picHeader.setNoOutputBeforeRecoveryFlag( m_picHeader.getHandleCraAsCvsStartFlag() );
+      }
+      else if( m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR )
+      {
+        m_picHeader.setNoOutputBeforeRecoveryFlag( m_picHeader.getHandleGdrAsCvsStartFlag() );
+      }
+    }
+    else
+    {
+      m_picHeader.setNoOutputBeforeRecoveryFlag( false );
+    }
+
+    if (m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA || m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR)
+    {
+      m_lastNoOutputBeforeRecoveryFlag[nalu.m_nuhLayerId] = m_picHeader.getNoOutputBeforeRecoveryFlag();
+    }
+
+    if (m_apcSlicePilot->getNoOutputOfPriorPicsFlag())
+    {
+      m_lastPOCNoOutputPriorPics = m_apcSlicePilot->getPOC();
+      m_isNoOutputPriorPics = true;
+    }
+    else
+    {
+      m_isNoOutputPriorPics = false;
+    }
+  }
+
+  if (m_bFirstSliceInPicture && m_apcSlicePilot->getPOC() != m_prevPOC
+      && (m_apcSlicePilot->getRapPicFlag() || m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR)
+      && m_picHeader.getNoOutputBeforeRecoveryFlag()
+      && getNoOutputPriorPicsFlag())
+  {
+    checkNoOutputPriorPics(&m_cListPic);
+    setNoOutputPriorPicsFlag(false);
+  }
+
+  //For inference of PicOutputFlag
+  if( !pps->getMixedNaluTypesInPicFlag() && ( m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL ) )
+  {
+    if( m_lastNoOutputBeforeRecoveryFlag[nalu.m_nuhLayerId] )
+    {
+      m_picHeader.setPicOutputFlag(false);
+    }
+  }
+
+  {
+    PPS *pps = m_parameterSetManager.getPPS(m_picHeader.getPPSId());
+    CHECK(pps == 0, "No PPS present");
+    SPS *sps = m_parameterSetManager.getSPS(pps->getSPSId());
+    CHECK(sps == 0, "No SPS present");
+    if (sps->getVPSId() > 0)
+    {
+      VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
+      CHECK(vps == 0, "No VPS present");
+      bool isCurLayerNotOutput = true;
+      for (int i = 0; i < vps->getNumLayersInOls(vps->m_targetOlsIdx); i++)
+      {
+        if( vps->getLayerIdInOls(vps->m_targetOlsIdx, i) == nalu.m_nuhLayerId )
+        {
+          isCurLayerNotOutput = false;
+          break;
+        }
+      }
+
+      if(isCurLayerNotOutput)
+      {
+        m_picHeader.setPicOutputFlag(false);
+      }
+    }
+  }
+
+  //Reset POC MSB when CRA or GDR has NoOutputBeforeRecoveryFlag equal to 1
+  if (!pps->getMixedNaluTypesInPicFlag() && (m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA || m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR) && m_lastNoOutputBeforeRecoveryFlag[nalu.m_nuhLayerId])
+  {
+    int iMaxPOClsb = 1 << sps->getBitsForPOC();
+    m_apcSlicePilot->setPOC( m_apcSlicePilot->getPOC() & (iMaxPOClsb - 1) );
+    m_lastPOCNoOutputPriorPics = m_apcSlicePilot->getPOC();
+    xUpdatePreviousTid0POC(m_apcSlicePilot);
+  }
+
+  AccessUnitPicInfo picInfo;
+  picInfo.m_nalUnitType = nalu.m_nalUnitType;
+  picInfo.m_nuhLayerId  = nalu.m_nuhLayerId;
+  picInfo.m_temporalId  = nalu.m_temporalId;
+  picInfo.m_POC         = m_apcSlicePilot->getPOC();
+  m_accessUnitPicInfo.push_back(picInfo);
+
+  // Skip pictures due to random access
+
+  if (isRandomAccessSkipPicture(iSkipFrame, iPOCLastDisplay, pps->getMixedNaluTypesInPicFlag(), nalu.m_nuhLayerId))
+  {
+    m_prevSliceSkipped = true;
+    m_skippedPOC = m_apcSlicePilot->getPOC();
+    m_skippedLayerID = nalu.m_nuhLayerId;
+
+    // reset variables for bitstream conformance tests
+    resetAccessUnitNals();
+    resetAccessUnitApsNals();
+    resetAccessUnitPicInfo();
+    resetPictureUnitNals();
+    resetPrefixSeiNalus();
+    m_maxDecSubPicIdx = 0;
+    m_maxDecSliceAddrInSubPic = -1;
+    return false;
+  }
+  // Skip TFD pictures associated with BLA/BLANT pictures
+
+  // clear previous slice skipped flag
+  m_prevSliceSkipped = false;
+
+  //we should only get a different poc for a new picture (with CTU address==0)
+  if (m_apcSlicePilot->getPOC() != m_prevPOC && !m_firstSliceInSequence[nalu.m_nuhLayerId] && (m_apcSlicePilot->getFirstCtuRsAddrInSlice() != 0))
+  {
+    msg( WARNING, "Warning, the first slice of a picture might have been lost!\n");
+  }
+  m_prevLayerID = nalu.m_nuhLayerId;
+
+  // leave when a new picture is found
+  if(m_apcSlicePilot->getFirstCtuRsAddrInSlice() == 0 && !m_bFirstSliceInPicture)
+  {
+    if (m_prevPOC >= m_pocRandomAccess)
+    {
+      DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 0 ) );
+      m_prevPOC = m_apcSlicePilot->getPOC();
+      return true;
+    }
+    m_prevPOC = m_apcSlicePilot->getPOC();
+  }
+  else
+  {
+    DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 1 ) );
+  }
+
+  //detect lost reference picture and insert copy of earlier frame.
+  {
+    int lostPoc;
+    int refPicIndex;
+    for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+    {
+      const ReferencePictureList *rpl = m_apcSlicePilot->getRpl(l);
+
+      while ((lostPoc = m_apcSlicePilot->checkThatAllRefPicsAreAvailable(m_cListPic, rpl, 0, true, &refPicIndex,
+                                                                         m_apcSlicePilot->getNumRefIdx(l)))
+             > 0)
+      {
+        if (!pps->getMixedNaluTypesInPicFlag()
+            && ((m_apcSlicePilot->isIDRorBLA() && (sps->getIDRRefParamListPresent() || pps->getRplInfoInPhFlag()))
+                || ((m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR
+                     || m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA)
+                    && m_picHeader.getNoOutputBeforeRecoveryFlag())))
+        {
+          if (!rpl->isInterLayerRefPic(refPicIndex))
+          {
+            xCreateUnavailablePicture(pps, lostPoc, rpl->isRefPicLongterm(refPicIndex), m_apcSlicePilot->getTLayer(),
+                                      m_apcSlicePilot->getNalUnitLayerId(), rpl->isInterLayerRefPic(refPicIndex));
+          }
+        }
+        else
+        {
+          xCreateLostPicture(lostPoc - 1, m_apcSlicePilot->getPic()->layerId);
+        }
+      }
+    }
+  }
+
+  m_prevPOC = m_apcSlicePilot->getPOC();
+
+  if (m_bFirstSliceInPicture)
+  {
+    xUpdateRasInit(m_apcSlicePilot);
+  }
+
+  // actual decoding starts here
+  xActivateParameterSets( nalu );
+
+  m_firstSliceInSequence[nalu.m_nuhLayerId] = false;
+  m_firstSliceInBitstream  = false;
+
+  Slice* pcSlice = m_pcPic->slices[m_uiSliceSegmentIdx];
+  m_pcPic->numSlices = m_uiSliceSegmentIdx + 1;
+  pcSlice->setPic( m_pcPic );
+  m_pcPic->poc         = pcSlice->getPOC();
+  m_pcPic->referenced  = true;
+  m_pcPic->temporalId  = nalu.m_temporalId;
+  m_pcPic->layerId     = nalu.m_nuhLayerId;
+  m_pcPic->subLayerNonReferencePictureDueToSTSA = false;
+
+  if (pcSlice->getSPS()->getSpsRangeExtension().getRrcRiceExtensionEnableFlag())
+  {
+    int bitDepth  = pcSlice->getSPS()->getBitDepth(ChannelType::LUMA);
+    int baseLevel = (bitDepth > 12) ? (pcSlice->isIntra() ? 5 : 2 * 5 ) : (pcSlice->isIntra() ? 2 * 5 : 3 * 5);
+    pcSlice->setRiceBaseLevel(baseLevel);
+  }
+  else
+  {
+    pcSlice->setRiceBaseLevel(4);
+  }
+
+  if (pcSlice->getSPS()->getProfileTierLevel()->getConstraintInfo()->getNoApsConstraintFlag())
+  {
+    bool flag = pcSlice->getSPS()->getCCALFEnabledFlag() || pcSlice->getPicHeader()->getNumAlfApsIdsLuma() || pcSlice->getPicHeader()->getAlfEnabledFlag(COMPONENT_Cb) || pcSlice->getPicHeader()->getAlfEnabledFlag(COMPONENT_Cr);
+    CHECK(flag, "When no_aps_constraint_flag is equal to 1, the values of ph_num_alf_aps_ids_luma, sh_num_alf_aps_ids_luma, ph_alf_cb_flag, ph_alf_cr_flag, sh_alf_cb_flag, sh_alf_cr_flag, and sps_ccalf_enabled_flag shall all be equal to 0")
+  }
+  if( pcSlice->getNalUnitLayerId() != pcSlice->getSPS()->getLayerId() )
+  {
+    CHECK( pcSlice->getSPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of SPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+    CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of SPS and layer Id of current slice are different" );
+    for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
+    {
+      bool isCurrLayerInOls = false;
+      bool isRefLayerInOls = false;
+      int j = pcSlice->getVPS()->getNumLayersInOls(i) - 1;
+      for (; j >= 0; j--)
+      {
+        if( pcSlice->getVPS()->getLayerIdInOls(i, j) == pcSlice->getNalUnitLayerId() )
+        {
+          isCurrLayerInOls = true;
+        }
+        if( pcSlice->getVPS()->getLayerIdInOls(i, j) == pcSlice->getSPS()->getLayerId() )
+        {
+          isRefLayerInOls = true;
+        }
+      }
+      CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to SPS in layer B, all OLS that contains layer A shall also contains layer B" );
+    }
+  }
+  if( pcSlice->getNalUnitLayerId() != pcSlice->getPPS()->getLayerId() )
+  {
+    CHECK( pcSlice->getPPS()->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of PPS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+    CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of PPS and layer Id of current slice are different" );
+    for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
+    {
+      bool isCurrLayerInOls = false;
+      bool isRefLayerInOls = false;
+      int j = pcSlice->getVPS()->getNumLayersInOls(i) - 1;
+      for (; j >= 0; j--)
+      {
+        if( pcSlice->getVPS()->getLayerIdInOls(i, j) == pcSlice->getNalUnitLayerId() )
+        {
+          isCurrLayerInOls = true;
+        }
+        if( pcSlice->getVPS()->getLayerIdInOls(i, j) == pcSlice->getPPS()->getLayerId() )
+        {
+          isRefLayerInOls = true;
+        }
+      }
+      CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to PPS in layer B, all OLS that contains layer A shall also contains layer B" );
+    }
+  }
+
+  if (m_bFirstSliceInPicture)
+  {
+    m_pcPic->setDecodingOrderNumber(m_decodingOrderCounter);
+    m_decodingOrderCounter++;
+    m_pcPic->setPictureType(nalu.m_nalUnitType);
+    checkPicTypeAfterEos();
+    // store sub-picture numbers, sizes, and locations with a picture
+    pcSlice->getPic()->subPictures.clear();
+
+    for( int subPicIdx = 0; subPicIdx < sps->getNumSubPics(); subPicIdx++ )
+    {
+      pcSlice->getPic()->subPictures.push_back( pps->getSubPic( subPicIdx ) );
+    }
+    pcSlice->getPic()->numSlices = pps->getNumSlicesInPic();
+    pcSlice->getPic()->sliceSubpicIdx.clear();
+#if GDR_ENABLED
+    const int curPoc = pcSlice->getPOC();
+    const PicHeader *picHeader = pcSlice->getPicHeader();
+
+    if (picHeader->getGdrPicFlag())
+    {
+      setLastGdrPoc(curPoc);
+      setLastGdrRecoveryPocCnt(pcSlice->getPicHeader()->getRecoveryPocCnt());
+    }
+
+    const int recoveryPocCnt = getLastGdrRecoveryPocCnt();
+
+    pcSlice->getPic()->gdrParam.inGdrInterval = (getLastGdrPoc() > 0 && (getLastGdrPoc() <= curPoc) && (curPoc < (getLastGdrPoc() + recoveryPocCnt)));
+  #endif
+
+  #if GDR_DEC_TRACE
+    printf("-gdr_pic_flag:%d\n", picHeader->getGdrPicFlag() ? 1 : 0);
+    printf("-recovery_poc_cnt:%d\n", picHeader->getRecoveryPocCnt());
+  #if GDR_ENABLED
+    printf("-inGdrInterval:%d\n", pcSlice->getPic()->gdrParam.inGdrInterval);
+  #endif
+
+    printf("-lmcs_enable : %d\n", picHeader->getLmcsEnabledFlag() ? 1 : 0);
+    printf("-lmcs_chroma : %d\n", picHeader->getLmcsChromaResidualScaleFlag() ? 1 : 0);
+#endif
+  }
+  pcSlice->getPic()->sliceSubpicIdx.push_back(pps->getSubPicIdxFromSubPicId(pcSlice->getSliceSubPicId()));
+  pcSlice->checkCRA(pcSlice->getRpl(REF_PIC_LIST_0), pcSlice->getRpl(REF_PIC_LIST_1), m_pocCRA[nalu.m_nuhLayerId],
+                    m_checkCRAFlags[nalu.m_nuhLayerId], m_cListPic);
+  pcSlice->constructRefPicList(m_cListPic);
+  pcSlice->setPrevGDRSubpicPOC(m_prevGDRSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
+  pcSlice->setPrevIRAPSubpicPOC(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId][currSubPicIdx]);
+  pcSlice->setPrevIRAPSubpicType(m_prevIRAPSubpicType[nalu.m_nuhLayerId][currSubPicIdx]);
+  pcSlice->checkSubpicTypeConstraints(m_cListPic, pcSlice->getRpl(REF_PIC_LIST_0), pcSlice->getRpl(REF_PIC_LIST_1),
+                                      m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId][currSubPicIdx]);
+  pcSlice->checkRPL(pcSlice->getRpl(REF_PIC_LIST_0), pcSlice->getRpl(REF_PIC_LIST_1),
+                    m_associatedIRAPDecodingOrderNumber[nalu.m_nuhLayerId], m_cListPic);
+  pcSlice->checkSTSA(m_cListPic);
+  if (m_pcPic->cs->vps && !m_pcPic->cs->vps->getIndependentLayerFlag(m_pcPic->cs->vps->getGeneralLayerIdx(nalu.m_nuhLayerId)) && m_pcPic->cs->pps->getNumSubPics() > 1)
+  {
+    CU::checkConformanceILRP(pcSlice);
+  }
+
+  pcSlice->scaleRefPicList( scaledRefPic, m_pcPic->cs->picHeader, m_parameterSetManager.getAPSs(), m_picHeader.getLmcsAPS(), m_picHeader.getScalingListAPS(), true );
+
+  if (!pcSlice->isIntra())
+  {
+    bool lowDelay = true;
+    int  currPoc  = pcSlice->getPOC();
+    int  refIdx   = 0;
+
+    for (refIdx = 0; refIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_0) && lowDelay; refIdx++)
+    {
+      if (pcSlice->getRefPic(REF_PIC_LIST_0, refIdx)->getPOC() > currPoc)
+      {
+        lowDelay = false;
+      }
+    }
+    if (pcSlice->isInterB())
+    {
+      for (refIdx = 0; refIdx < pcSlice->getNumRefIdx(REF_PIC_LIST_1) && lowDelay; refIdx++)
+      {
+        if (pcSlice->getRefPic(REF_PIC_LIST_1, refIdx)->getPOC() > currPoc)
+        {
+          lowDelay = false;
+        }
+      }
+    }
+
+    pcSlice->setCheckLDC(lowDelay);
+  }
+
+  if (pcSlice->getSPS()->getUseSMVD() && pcSlice->getCheckLDC() == false
+      && pcSlice->getPicHeader()->getMvdL1ZeroFlag() == false)
+  {
+    int currPOC = pcSlice->getPOC();
+
+    int forwardPOC  = currPOC;
+    int backwardPOC = currPOC;
+    int ref         = 0;
+    int refIdx0     = -1;
+    int refIdx1     = -1;
+
+    // search nearest forward POC in List 0
+    for (ref = 0; ref < pcSlice->getNumRefIdx(REF_PIC_LIST_0); ref++)
+    {
+      int        poc           = pcSlice->getRefPic(REF_PIC_LIST_0, ref)->getPOC();
+      const bool isRefLongTerm = pcSlice->getRefPic(REF_PIC_LIST_0, ref)->longTerm;
+      if (poc < currPOC && (poc > forwardPOC || refIdx0 == -1) && !isRefLongTerm)
+      {
+        forwardPOC = poc;
+        refIdx0    = ref;
+      }
+    }
+
+    // search nearest backward POC in List 1
+    for (ref = 0; ref < pcSlice->getNumRefIdx(REF_PIC_LIST_1); ref++)
+    {
+      int        poc           = pcSlice->getRefPic(REF_PIC_LIST_1, ref)->getPOC();
+      const bool isRefLongTerm = pcSlice->getRefPic(REF_PIC_LIST_1, ref)->longTerm;
+      if (poc > currPOC && (poc < backwardPOC || refIdx1 == -1) && !isRefLongTerm)
+      {
+        backwardPOC = poc;
+        refIdx1     = ref;
+      }
+    }
+
+    if (!(forwardPOC < currPOC && backwardPOC > currPOC))
+    {
+      forwardPOC  = currPOC;
+      backwardPOC = currPOC;
+      refIdx0     = -1;
+      refIdx1     = -1;
+
+      // search nearest backward POC in List 0
+      for ( ref = 0; ref < pcSlice->getNumRefIdx( REF_PIC_LIST_0 ); ref++ )
+      {
+        int poc = pcSlice->getRefPic( REF_PIC_LIST_0, ref )->getPOC();
+        const bool isRefLongTerm = pcSlice->getRefPic(REF_PIC_LIST_0, ref)->longTerm;
+        if (poc > currPOC && (poc < backwardPOC || refIdx0 == -1) && !isRefLongTerm)
+        {
+          backwardPOC = poc;
+          refIdx0 = ref;
+        }
+      }
+
+      // search nearest forward POC in List 1
+      for ( ref = 0; ref < pcSlice->getNumRefIdx( REF_PIC_LIST_1 ); ref++ )
+      {
+        int poc = pcSlice->getRefPic( REF_PIC_LIST_1, ref )->getPOC();
+        const bool isRefLongTerm = pcSlice->getRefPic(REF_PIC_LIST_1, ref)->longTerm;
+        if (poc < currPOC && (poc > forwardPOC || refIdx1 == -1) && !isRefLongTerm)
+        {
+          forwardPOC = poc;
+          refIdx1 = ref;
+        }
+      }
+    }
+
+    if (forwardPOC < currPOC && backwardPOC > currPOC)
+    {
+      pcSlice->setBiDirPred(true, refIdx0, refIdx1);
+    }
+    else
+    {
+      pcSlice->setBiDirPred( false, -1, -1 );
+    }
+  }
+  else
+  {
+    pcSlice->setBiDirPred(false, -1, -1);
+  }
+
+  //---------------
+  pcSlice->setRefPOCList();
+
+  NalUnitInfo naluInfo;
+  naluInfo.m_nalUnitType     = nalu.m_nalUnitType;
+  naluInfo.m_nuhLayerId      = nalu.m_nuhLayerId;
+  naluInfo.m_firstCTUinSlice = pcSlice->getFirstCtuRsAddrInSlice();
+  naluInfo.m_POC             = pcSlice->getPOC();
+  xCheckMixedNalUnit(pcSlice, sps, nalu);
+  m_nalUnitInfo[naluInfo.m_nuhLayerId].push_back(naluInfo);
+  SEIMessages drapSEIs = getSeisByType(m_pcPic->SEIs, SEI::PayloadType::DEPENDENT_RAP_INDICATION);
+  if (!drapSEIs.empty())
+  {
+    msg(NOTICE, "Dependent RAP indication SEI decoded\n");
+    m_latestDRAPPOC = pcSlice->getPOC();
+    pcSlice->setDRAP(true);
+  }
+  pcSlice->setLatestDRAPPOC(m_latestDRAPPOC);
+  pcSlice->checkConformanceForDRAP(nalu.m_temporalId);
+  if (pcSlice->isIntra())
+  {
+    pcSlice->getPic()->setEdrapRapId(0);
+  }
+  SEIMessages edrapSEIs = getSeisByType(m_pcPic->SEIs, SEI::PayloadType::EXTENDED_DRAP_INDICATION);
+  if (!edrapSEIs.empty())
+  {
+    msg(NOTICE, "Extended DRAP indication SEI decoded\n");
+    SEIExtendedDrapIndication *seiEdrap = (SEIExtendedDrapIndication *) edrapSEIs.front();
+    pcSlice->setEdrapRapId(seiEdrap->m_edrapIndicationRapIdMinus1 + 1);
+    pcSlice->getPic()->setEdrapRapId(seiEdrap->m_edrapIndicationRapIdMinus1 + 1);
+    pcSlice->setEdrapNumRefRapPics(seiEdrap->m_edrapIndicationNumRefRapPicsMinus1 + 1);
+    for (int i = 0; i < pcSlice->getEdrapNumRefRapPics(); i++)
+    {
+      pcSlice->addEdrapRefRapIds(seiEdrap->m_edrapIndicationRefRapId[i]);
+    }
+    m_latestEDRAPIndicationLeadingPicturesDecodableFlag = seiEdrap->m_edrapIndicationLeadingPicturesDecodableFlag;
+    m_latestEDRAPPOC = pcSlice->getPOC();
+  }
+  pcSlice->setLatestEDRAPPOC(m_latestEDRAPPOC);
+  pcSlice->setLatestEdrapLeadingPicDecodableFlag(m_latestEDRAPIndicationLeadingPicturesDecodableFlag);
+  pcSlice->checkConformanceForEDRAP(nalu.m_temporalId);
+
+  Quant *quant = m_cTrQuant.getQuant();
+
+  if (pcSlice->getExplicitScalingListUsed())
+  {
+    APS* scalingListAPS = pcSlice->getPicHeader()->getScalingListAPS();
+    if( pcSlice->getNalUnitLayerId() != scalingListAPS->getLayerId() )
+    {
+      CHECK( scalingListAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+      CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+      for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
+      {
+        bool isCurrLayerInOls = false;
+        bool isRefLayerInOls = false;
+        for( int j = pcSlice->getVPS()->getNumLayersInOls(i) - 1; j >= 0; j-- )
+        {
+          if( pcSlice->getVPS()->getLayerIdInOls(i, j) == pcSlice->getNalUnitLayerId() )
+          {
+            isCurrLayerInOls = true;
+          }
+          if( pcSlice->getVPS()->getLayerIdInOls(i, j) == scalingListAPS->getLayerId() )
+          {
+            isRefLayerInOls = true;
+          }
+        }
+        CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+      }
+    }
+    ScalingList scalingList = scalingListAPS->getScalingList();
+    quant->setScalingListDec(scalingList);
+    quant->setUseScalingList(true);
+  }
+  else
+  {
+    quant->setUseScalingList( false );
+  }
+
+  if (pcSlice->getSPS()->getUseLmcs())
+  {
+    if (m_bFirstSliceInPicture)
+    {
+      m_sliceLmcsApsId = -1;
+    }
+    if (pcSlice->getLmcsEnabledFlag())
+    {
+      APS* lmcsAPS = pcSlice->getPicHeader()->getLmcsAPS();
+      if (m_sliceLmcsApsId == -1)
+      {
+        m_sliceLmcsApsId = lmcsAPS->getAPSId();
+      }
+      else
+      {
+        CHECK(lmcsAPS->getAPSId() != m_sliceLmcsApsId, "same APS ID shall be used for all slices in one picture");
+      }
+      if( pcSlice->getNalUnitLayerId() != lmcsAPS->getLayerId() )
+      {
+        CHECK( lmcsAPS->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK( pcSlice->getSPS()->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        for (int i = 0; i < pcSlice->getVPS()->getNumOutputLayerSets(); i++ )
+        {
+          bool isCurrLayerInOls = false;
+          bool isRefLayerInOls = false;
+          for( int j = pcSlice->getVPS()->getNumLayersInOls(i) - 1; j >= 0; j-- )
+          {
+            if( pcSlice->getVPS()->getLayerIdInOls(i, j) == pcSlice->getNalUnitLayerId() )
+            {
+              isCurrLayerInOls = true;
+            }
+            if( pcSlice->getVPS()->getLayerIdInOls(i, j) == lmcsAPS->getLayerId() )
+            {
+              isRefLayerInOls = true;
+            }
+          }
+          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+        }
+      }
+      SliceReshapeInfo& sInfo = lmcsAPS->getReshaperAPSInfo();
+      SliceReshapeInfo& tInfo = m_cReshaper.getSliceReshaperInfo();
+      tInfo.reshaperModelMaxBinIdx = sInfo.reshaperModelMaxBinIdx;
+      tInfo.reshaperModelMinBinIdx = sInfo.reshaperModelMinBinIdx;
+      memcpy(tInfo.reshaperModelBinCWDelta, sInfo.reshaperModelBinCWDelta, sizeof(int)*(PIC_CODE_CW_BINS));
+      tInfo.maxNbitsNeededDeltaCW = sInfo.maxNbitsNeededDeltaCW;
+      tInfo.chrResScalingOffset = sInfo.chrResScalingOffset;
+      tInfo.setUseSliceReshaper(pcSlice->getLmcsEnabledFlag());
+      tInfo.setSliceReshapeChromaAdj(pcSlice->getPicHeader()->getLmcsChromaResidualScaleFlag());
+      tInfo.setSliceReshapeModelPresentFlag(true);
+    }
+    else
+    {
+      SliceReshapeInfo& tInfo = m_cReshaper.getSliceReshaperInfo();
+      tInfo.setUseSliceReshaper(false);
+      tInfo.setSliceReshapeChromaAdj(false);
+      tInfo.setSliceReshapeModelPresentFlag(false);
+    }
+    if (pcSlice->getLmcsEnabledFlag())
+    {
+      m_cReshaper.constructReshaper();
+    }
+    else
+    {
+      m_cReshaper.setReshapeFlag(false);
+    }
+    if ((pcSlice->getSliceType() == I_SLICE) && m_cReshaper.getSliceReshaperInfo().getUseSliceReshaper())
+    {
+      m_cReshaper.setCTUFlag(false);
+      m_cReshaper.setRecReshaped(true);
+    }
+    else
+    {
+      if (m_cReshaper.getSliceReshaperInfo().getUseSliceReshaper())
+      {
+        m_cReshaper.setCTUFlag(true);
+        m_cReshaper.setRecReshaped(true);
+      }
+      else
+      {
+        m_cReshaper.setCTUFlag(false);
+        m_cReshaper.setRecReshaped(false);
+      }
+    }
+    m_cReshaper.setVPDULoc(-1, -1);
+  }
+  else
+  {
+    m_cReshaper.setCTUFlag(false);
+    m_cReshaper.setRecReshaped(false);
+  }
+
+#if GDR_LEAK_TEST
+  if (m_gdrPocRandomAccess == pcSlice->getPOC())
+  {
+    for (int e = 0; e < 2; e++)
+    {
+      for (int ridx = 0; ridx < pcSlice->getNumRefIdx((RefPicList)e); ridx++)
+      {
+        Picture *pic = pcSlice->getRefPic((RefPicList)e, ridx);
+        if (pic)
+        {
+          CodingStructure& cs = *pic->cs;
+          cs.getRecoBuf().Y().fill(0 * 4); // for 8-bit sequence
+          cs.getRecoBuf().Cb().fill(0 * 4);
+          cs.getRecoBuf().Cr().fill(0 * 4);
+          cs.getMotionBuf().memset(0);    // clear MV storage
+        }
+      }
+    }
+  }
+#endif // GDR_LEAK_TEST
+#if GREEN_METADATA_SEI_ENABLED
+  pcSlice->setFeatureCounter(this->m_featureCounter);
+#endif
+  //  Decode a picture
+  // m_cSliceDecoder.deSliceAndSkip( pcSlice, &( nalu.getBitstream() ) );
+  m_cSliceDecoder.decompressSlice( pcSlice, &( nalu.getBitstream() ), ( m_pcPic->poc == getDebugPOC() ? getDebugCTU() : -1 ) );
+#if GREEN_METADATA_SEI_ENABLED
+  this->m_featureCounter = pcSlice->getFeatureCounter();
+#endif
+  
+  m_bFirstSliceInPicture = false;
+  m_uiSliceSegmentIdx++;
+
+  pcSlice->freeScaledRefPicList( scaledRefPic );
+
+  return false;
+}
+
+void DecLib::updatePrevGDRInSameLayer()
+{
+  const NalUnitType pictureType = m_pcPic->getPictureType();
+
+  if (pictureType == NAL_UNIT_CODED_SLICE_GDR && !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag())
+  {
+    m_prevGDRInSameLayerPOC[m_pcPic->layerId] = m_pcPic->getPOC();
+  }
+}
+
+void DecLib::updateAssociatedIRAP()
+{
+  const NalUnitType pictureType = m_pcPic->getPictureType();
+
+  if ((pictureType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || pictureType == NAL_UNIT_CODED_SLICE_IDR_N_LP || pictureType == NAL_UNIT_CODED_SLICE_CRA) && !m_pcPic->cs->pps->getMixedNaluTypesInPicFlag())
+  {
+    m_associatedIRAPDecodingOrderNumber[m_pcPic->layerId] = m_pcPic->getDecodingOrderNumber();
+    m_pocCRA[m_pcPic->layerId] = m_pcPic->getPOC();
+    m_checkCRAFlags[m_pcPic->layerId].clear();
+    m_associatedIRAPType[m_pcPic->layerId] = pictureType;
+  }
+}
+
+void DecLib::updatePrevIRAPAndGDRSubpic()
+{
+  for (int j = 0; j < m_uiSliceSegmentIdx; j++)
+  {
+    Slice* pcSlice = m_pcPic->slices[j];
+    const int subpicIdx = pcSlice->getPPS()->getSubPicIdxFromSubPicId(pcSlice->getSliceSubPicId());
+    if (pcSlice->getCtuAddrInSlice(0) == m_pcPic->cs->pps->getSubPic(subpicIdx).getFirstCTUInSubPic())
+    {
+      const NalUnitType subpicType = pcSlice->getNalUnitType();
+      if (subpicType == NAL_UNIT_CODED_SLICE_IDR_W_RADL || subpicType == NAL_UNIT_CODED_SLICE_IDR_N_LP || subpicType == NAL_UNIT_CODED_SLICE_CRA)
+      {
+        m_prevIRAPSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
+        m_prevIRAPSubpicType[m_pcPic->layerId][subpicIdx] = subpicType;
+        m_prevIRAPSubpicDecOrderNo[m_pcPic->layerId][subpicIdx] = m_pcPic->getDecodingOrderNumber();
+      }
+      else if (subpicType == NAL_UNIT_CODED_SLICE_GDR)
+      {
+        m_prevGDRSubpicPOC[m_pcPic->layerId][subpicIdx] = m_pcPic->getPOC();
+      }
+    }
+  }
+}
+
+void DecLib::xDecodeOPI( InputNALUnit& nalu )
+{
+  m_opi = new OPI();
+  m_HLSReader.setBitstream( &nalu.getBitstream() );
+
+  CHECK( nalu.m_temporalId, "The value of TemporalId of OPI NAL units shall be equal to 0" );
+
+  m_HLSReader.parseOPI( m_opi );
+}
+
+void DecLib::xDecodeVPS( InputNALUnit& nalu )
+{
+  VPS* vps = new VPS();
+  m_HLSReader.setBitstream( &nalu.getBitstream() );
+
+  CHECK( nalu.m_temporalId, "The value of TemporalId of VPS NAL units shall be equal to 0" );
+
+  m_HLSReader.parseVPS( vps );
+
+  // storeVPS may directly delete the new VPS in case it is a repetition. Need to retrieve proper initialized memory back
+  int vpsID = vps->getVPSId();
+  m_parameterSetManager.storeVPS( vps, nalu.getBitstream().getFifo());
+
+  if (m_vps==nullptr)
+  {
+    // m_vps is used for conformance checks. Unless a VPS is referred to, just set the first one we received
+    // repeated parameter sets may be deleted, set a valid VPS pointer back from parameter set manager
+    m_vps = m_parameterSetManager.getVPS(vpsID);
+  }
+}
+
+void DecLib::xDecodeDCI(InputNALUnit& nalu)
+{
+  m_HLSReader.setBitstream(&nalu.getBitstream());
+
+  CHECK(nalu.m_temporalId, "The value of TemporalId of DCI NAL units shall be equal to 0");
+  if (!m_dci)
+  {
+    m_dci = new DCI;
+    m_HLSReader.parseDCI(m_dci);
+  }
+  else
+  {
+    DCI dupDCI;
+    m_HLSReader.parseDCI(&dupDCI);
+    CHECK( !m_dci->IsIndenticalDCI(dupDCI), "Two signaled DCIs are different");
+  }
+}
+
+void DecLib::xDecodeSPS( InputNALUnit& nalu )
+{
+  SPS* sps = new SPS();
+  m_HLSReader.setBitstream( &nalu.getBitstream() );
+
+  CHECK( nalu.m_temporalId, "The value of TemporalId of SPS NAL units shall be equal to 0" );
+
+  m_HLSReader.parseSPS( sps );
+  sps->setLayerId( nalu.m_nuhLayerId );
+  DTRACE( g_trace_ctx, D_QP_PER_CTU, "CTU Size: %dx%d", sps->getMaxCUWidth(), sps->getMaxCUHeight() );
+  m_accessUnitSpsNumSubpic[nalu.m_nuhLayerId] = sps->getNumSubPics();
+  m_parameterSetManager.storeSPS( sps, nalu.getBitstream().getFifo() );
+}
+
+void DecLib::xDecodePPS( InputNALUnit& nalu )
+{
+  PPS* pps = new PPS();
+  m_HLSReader.setBitstream( &nalu.getBitstream() );
+  m_HLSReader.parsePPS( pps );
+  pps->setLayerId( nalu.m_nuhLayerId );
+  pps->setTemporalId( nalu.m_temporalId );
+  pps->setPuCounter( m_puCounter );
+  m_parameterSetManager.storePPS( pps, nalu.getBitstream().getFifo() );
+}
+
+void DecLib::xDecodeAPS(InputNALUnit& nalu)
+{
+  APS* aps = new APS();
+  m_HLSReader.setBitstream(&nalu.getBitstream());
+  m_HLSReader.parseAPS(aps);
+  aps->setTemporalId(nalu.m_temporalId);
+  aps->setLayerId( nalu.m_nuhLayerId );
+  aps->setHasPrefixNalUnitType( nalu.m_nalUnitType == NAL_UNIT_PREFIX_APS );
+  aps->setPuCounter( m_puCounter );
+  m_parameterSetManager.checkAuApsContent(aps, m_accessUnitApsNals[aps->getAPSType()]);
+  if( m_apsMapEnc )
+  {
+    APS* apsEnc = new APS();
+    *apsEnc = *aps;
+    (*m_apsMapEnc)[aps->getAPSType()].storePS(apsEnc->getAPSId(), apsEnc);
+  }
+
+  if( nalu.m_nalUnitType == NAL_UNIT_SUFFIX_APS && m_prevSliceSkipped )
+  {
+    m_accessUnitApsNals[aps->getAPSType()].pop_back();
+  }
+
+  // aps will be deleted if it was already stored (and did not changed),
+  // thus, storing it must be last action.
+  m_parameterSetManager.storeAPS(aps, nalu.getBitstream().getFifo());
+}
+
+bool DecLib::decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, int iTargetOlsIdx)
+{
+  bool ret;
+  // ignore all NAL units of layers > 0
+  if( (nalu.m_nalUnitType != NAL_UNIT_SUFFIX_APS       &&
+       nalu.m_nalUnitType != NAL_UNIT_EOS              &&
+       nalu.m_nalUnitType != NAL_UNIT_EOB              &&
+       nalu.m_nalUnitType != NAL_UNIT_SUFFIX_SEI       &&
+       nalu.m_nalUnitType != NAL_UNIT_FD               &&
+       nalu.m_nalUnitType != NAL_UNIT_RESERVED_NVCL_27 &&
+       nalu.m_nalUnitType != NAL_UNIT_UNSPECIFIED_30   &&
+       nalu.m_nalUnitType != NAL_UNIT_UNSPECIFIED_31)  ||
+       !m_prevSliceSkipped )
+  {
+    AccessUnitInfo auInfo;
+    auInfo.m_nalUnitType = nalu.m_nalUnitType;
+    auInfo.m_nuhLayerId = nalu.m_nuhLayerId;
+    auInfo.m_temporalId = nalu.m_temporalId;
+    m_accessUnitNals.push_back(auInfo);
+    m_pictureUnitNals.push_back( nalu.m_nalUnitType );
+  }
+  switch (nalu.m_nalUnitType)
+  {
+  case NAL_UNIT_VPS:
+    xDecodeVPS(nalu);
+    if (getTOlsIdxExternalFlag())
+    {
+      m_vps->m_targetOlsIdx = iTargetOlsIdx;
+    }
+    else if (getTOlsIdxOpiFlag())
+    {
+      m_vps->m_targetOlsIdx = m_opi->getOpiOlsIdx();
+    }
+    else
+    {
+      m_vps->m_targetOlsIdx = m_vps->deriveTargetOLSIdx();
+    }
+    return false;
+  case NAL_UNIT_OPI: xDecodeOPI(nalu); return false;
+  case NAL_UNIT_DCI: xDecodeDCI(nalu); return false;
+  case NAL_UNIT_SPS: xDecodeSPS(nalu); return false;
+
+  case NAL_UNIT_PPS: xDecodePPS(nalu); return false;
+
+  case NAL_UNIT_PH: xDecodePicHeader(nalu); return !m_bFirstSliceInPicture;
+
+  case NAL_UNIT_PREFIX_APS: xDecodeAPS(nalu); return false;
+
+  case NAL_UNIT_SUFFIX_APS:
+    if (m_prevSliceSkipped)
+    {
+      xDecodeAPS(nalu);
+    }
+    else
+    {
+      m_suffixApsNalus.push_back(new InputNALUnit(nalu));
+    }
+    return false;
+
+  case NAL_UNIT_PREFIX_SEI:
+    // Buffer up prefix SEI messages until SPS of associated VCL is known.
+    m_prefixSEINALUs.push_back(new InputNALUnit(nalu));
+    m_pictureSeiNalus.push_back(new InputNALUnit(nalu));
+    return false;
+
+  case NAL_UNIT_SUFFIX_SEI:
+    if (m_pcPic)
+    {
+      if (m_prevSliceSkipped)
+      {
+        msg(NOTICE, "Note: received suffix SEI but current picture is skipped.\n");
+        return false;
+      }
+      m_pictureSeiNalus.push_back(new InputNALUnit(nalu));
+      m_accessUnitSeiNalus.push_back(new InputNALUnit(nalu));
+      m_accessUnitSeiTids.push_back(nalu.m_temporalId);
+      const SPS *sps = m_parameterSetManager.getActiveSPS();
+      const VPS *vps = m_parameterSetManager.getVPS(sps->getVPSId());
+      const bool seiMessageRead = m_seiReader.parseSEImessage(&(nalu.getBitstream()), m_pcPic->SEIs, nalu.m_nalUnitType, nalu.m_nuhLayerId,
+                                                              nalu.m_temporalId, vps, sps, m_HRD, m_pDecodedSEIOutputStream);
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+      m_seiCfgDump.write360SeiDump(m_decoded360SeiDumpFileName, m_pcPic->SEIs, sps);
+#endif
+      if (seiMessageRead)
+      {
+        m_accessUnitSeiPayLoadTypes.push_back(std::tuple<NalUnitType, int, SEI::PayloadType>(
+          nalu.m_nalUnitType, nalu.m_nuhLayerId, m_pcPic->SEIs.back()->payloadType()));
+      }
+    }
+    else
+    {
+      msg(NOTICE, "Note: received suffix SEI but no picture currently active.\n");
+    }
+    return false;
+
+  case NAL_UNIT_CODED_SLICE_TRAIL:
+  case NAL_UNIT_CODED_SLICE_STSA:
+  case NAL_UNIT_CODED_SLICE_IDR_W_RADL:
+  case NAL_UNIT_CODED_SLICE_IDR_N_LP:
+  case NAL_UNIT_CODED_SLICE_CRA:
+  case NAL_UNIT_CODED_SLICE_GDR:
+  case NAL_UNIT_CODED_SLICE_RADL:
+  case NAL_UNIT_CODED_SLICE_RASL: ret = xDecodeSlice(nalu, iSkipFrame, iPOCLastDisplay); return ret;
+
+  case NAL_UNIT_EOS:
+    m_associatedIRAPType[nalu.m_nuhLayerId]            = NAL_UNIT_INVALID;
+    m_pocCRA[nalu.m_nuhLayerId]                        = -MAX_INT;
+    m_checkCRAFlags[nalu.m_nuhLayerId].clear();
+    m_prevGDRInSameLayerPOC[nalu.m_nuhLayerId]         = -MAX_INT;
+    m_prevGDRInSameLayerRecoveryPOC[nalu.m_nuhLayerId] = -MAX_INT;
+    std::fill_n(m_prevGDRSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
+    std::fill_n(m_prevIRAPSubpicPOC[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, -MAX_INT);
+    memset(m_prevIRAPSubpicDecOrderNo[nalu.m_nuhLayerId], 0, sizeof(int) * MAX_NUM_SUB_PICS);
+    std::fill_n(m_prevIRAPSubpicType[nalu.m_nuhLayerId], MAX_NUM_SUB_PICS, NAL_UNIT_INVALID);
+    m_pocRandomAccess                  = MAX_INT;
+    m_prevLayerID                      = MAX_INT;
+    m_prevPOC                          = -MAX_INT;
+    m_prevSliceSkipped                 = false;
+    m_skippedPOC                       = 0;
+    m_accessUnitEos[nalu.m_nuhLayerId] = true;
+    m_prevEOS[nalu.m_nuhLayerId]       = true;
+    return false;
+
+  case NAL_UNIT_ACCESS_UNIT_DELIMITER:
+  {
+    AUDReader audReader;
+    uint32_t  picType;
+    audReader.parseAccessUnitDelimiter(&(nalu.getBitstream()), m_audIrapOrGdrAuFlag, picType);
+    return !m_bFirstSliceInPicture;
+  }
+
+  case NAL_UNIT_EOB: return false;
+
+  case NAL_UNIT_FD:
+  {
+    FDReader fdReader;
+    uint32_t fdSize;
+    fdReader.parseFillerData(&(nalu.getBitstream()), fdSize);
+    msg(NOTICE, "Note: found NAL_UNIT_FD with %u bytes payload.\n", fdSize);
+    return false;
+  }
+
+  case NAL_UNIT_RESERVED_IRAP_VCL_11:
+    msg(NOTICE, "Note: found reserved VCL NAL unit.\n");
+    xParsePrefixSEIsForUnknownVCLNal();
+    return false;
+  case NAL_UNIT_RESERVED_VCL_4:
+  case NAL_UNIT_RESERVED_VCL_5:
+  case NAL_UNIT_RESERVED_VCL_6:
+  case NAL_UNIT_RESERVED_NVCL_26:
+  case NAL_UNIT_RESERVED_NVCL_27: msg(NOTICE, "Note: found reserved NAL unit.\n"); return false;
+  case NAL_UNIT_UNSPECIFIED_28:
+  case NAL_UNIT_UNSPECIFIED_29:
+  case NAL_UNIT_UNSPECIFIED_30:
+  case NAL_UNIT_UNSPECIFIED_31: msg(NOTICE, "Note: found unspecified NAL unit.\n"); return false;
+  default: THROW("Invalid NAL unit type"); break;
+  }
+
+  return false;
+}
+
+
+/** Function for checking if picture should be skipped because of random access. This function checks the skipping of pictures in the case of -s option random access.
+ *  All pictures prior to the random access point indicated by the counter iSkipFrame are skipped.
+ *  It also checks the type of Nal unit type at the random access point.
+ *  If the random access point is CRA/CRANT/BLA/BLANT, TFD pictures with POC less than the POC of the random access point are skipped.
+ *  If the random access point is IDR all pictures after the random access point are decoded.
+ *  If the random access point is none of the above, a warning is issues, and decoding of pictures with POC
+ *  equal to or greater than the random access point POC is attempted. For non IDR/CRA/BLA random
+ *  access point there is no guarantee that the decoder will not crash.
+ */
+bool DecLib::isRandomAccessSkipPicture( int& iSkipFrame, int& iPOCLastDisplay, bool mixedNaluInPicFlag, uint32_t layerId )
+{
+  if( (iSkipFrame > 0) &&
+      (m_apcSlicePilot->getFirstCtuRsAddrInSlice() == 0 && layerId == 0) &&
+      (m_skippedPOC != MAX_INT) && (m_skippedLayerID != MAX_INT))
+  {
+    // When skipFrame count greater than 0, and current frame is not the first frame of sequence, decrement skipFrame count.
+    // If skipFrame count is still greater than 0, the current frame will be skipped.
+    iSkipFrame--;
+  }
+
+  if (iSkipFrame)
+  {
+    iSkipFrame--;   // decrement the counter
+    m_maxDecSubPicIdx = 0;
+    m_maxDecSliceAddrInSubPic = -1;
+    return true;
+  }
+  else if ( m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP )
+  {
+    m_pocRandomAccess = -MAX_INT; // no need to skip the reordered pictures in IDR, they are decodable.
+  }
+  else if (m_pocRandomAccess == MAX_INT) // start of random access point, m_pocRandomAccess has not been set yet.
+  {
+    if (m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA || m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR )
+    {
+      // set the POC random access since we need to skip the reordered pictures in the case of CRA/CRANT/BLA/BLANT.
+      m_pocRandomAccess = m_apcSlicePilot->getPOC();
+    }
+    else
+    {
+      if(!m_warningMessageSkipPicture)
+      {
+        msg( WARNING, "Warning: This is not a valid random access point and the data is discarded until the first CRA or GDR picture\n");
+        m_warningMessageSkipPicture = true;
+      }
+      iSkipFrame--;
+      m_maxDecSubPicIdx = 0;
+      m_maxDecSliceAddrInSubPic = -1;
+      return true;
+    }
+  }
+  // skip the reordered pictures, if necessary
+  else if (m_apcSlicePilot->getPOC() < m_pocRandomAccess &&
+      (m_apcSlicePilot->getNalUnitType() == NAL_UNIT_CODED_SLICE_RASL ||
+       mixedNaluInPicFlag))
+  {
+    iPOCLastDisplay++;
+    iSkipFrame--;
+    m_maxDecSubPicIdx = 0;
+    m_maxDecSliceAddrInSubPic = -1;
+    return true;
+  }
+  // if we reach here, then the picture is not skipped.
+  return false;
+}
+
+void DecLib::checkNalUnitConstraints( uint32_t naluType )
+{
+  if (m_parameterSetManager.getActiveSPS() != nullptr
+      && m_parameterSetManager.getActiveSPS()->getProfileTierLevel() != nullptr)
+  {
+    const ConstraintInfo *cInfo = m_parameterSetManager.getActiveSPS()->getProfileTierLevel()->getConstraintInfo();
+    xCheckNalUnitConstraintFlags( cInfo, naluType );
+  }
+}
+
+void DecLib::xCheckNalUnitConstraintFlags( const ConstraintInfo *cInfo, uint32_t naluType )
+{
+  if (cInfo != nullptr)
+  {
+    CHECK(cInfo->getNoTrailConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_TRAIL,
+      "Non-conforming bitstream. no_trail_constraint_flag is equal to 1 but bitstream contains NAL unit of type TRAIL_NUT.");
+    CHECK(cInfo->getNoStsaConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_STSA,
+      "Non-conforming bitstream. no_stsa_constraint_flag is equal to 1 but bitstream contains NAL unit of type STSA_NUT.");
+    CHECK(cInfo->getNoRaslConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RASL,
+      "Non-conforming bitstream. no_rasl_constraint_flag is equal to 1 but bitstream contains NAL unit of type RASL_NUT.");
+    CHECK(cInfo->getNoRadlConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_RADL,
+      "Non-conforming bitstream. no_radl_constraint_flag is equal to 1 but bitstream contains NAL unit of type RADL_NUT.");
+    CHECK(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_W_RADL),
+      "Non-conforming bitstream. no_idr_constraint_flag is equal to 1 but bitstream contains NAL unit of type IDR_W_RADL.");
+    CHECK(cInfo->getNoIdrConstraintFlag() && (naluType == NAL_UNIT_CODED_SLICE_IDR_N_LP),
+      "Non-conforming bitstream. no_idr_constraint_flag is equal to 1 but bitstream contains NAL unit of type IDR_N_LP.");
+    CHECK(cInfo->getNoCraConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_CRA,
+      "Non-conforming bitstream. no_cra_constraint_flag is equal to 1 but bitstream contains NAL unit of type CRA_NUT.");
+    CHECK(cInfo->getNoGdrConstraintFlag() && naluType == NAL_UNIT_CODED_SLICE_GDR,
+      "Non-conforming bitstream. no_gdr_constraint_flag is equal to 1 but bitstream contains NAL unit of type GDR_NUT.");
+    CHECK(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_PREFIX_APS,
+      "Non-conforming bitstream. no_aps_constraint_flag is equal to 1 but bitstream contains NAL unit of type APS_PREFIX_NUT.");
+    CHECK(cInfo->getNoApsConstraintFlag() && naluType == NAL_UNIT_SUFFIX_APS,
+      "Non-conforming bitstream. no_aps_constraint_flag is equal to 1 but bitstream contains NAL unit of type APS_SUFFIX_NUT.");
+  }
+}
+
+void DecLib::xCheckMixedNalUnit(Slice* pcSlice, SPS *sps, InputNALUnit &nalu)
+{
+  if (pcSlice->getPPS()->getMixedNaluTypesInPicFlag())
+  {
+    CHECK(pcSlice->getPPS()->getNumSlicesInPic() < 2, "mixed nal unit type picture, but with less than 2 slices");
+
+    CHECK( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR, "picture with mixed NAL unit type cannot have GDR slice");
+
+    //Check that if current slice is IRAP type, the other type of NAL can only be TRAIL_NUT
+    if( pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA )
+    {
+      for( int i = 0; i < m_uiSliceSegmentIdx; i++ )
+      {
+        Slice* PreSlice = m_pcPic->slices[i];
+        CHECK( (pcSlice->getNalUnitType() != PreSlice->getNalUnitType()) && (PreSlice->getNalUnitType() != NAL_UNIT_CODED_SLICE_TRAIL), "In a mixed NAL unt type picture, an IRAP slice can be mixed with Trail slice(s) only");
+      }
+    }
+
+    // if this is the last slice of the picture, check whether that there are at least two different NAL unit types in the picture
+    if (pcSlice->getPPS()->getNumSlicesInPic() == (m_uiSliceSegmentIdx + 1))
+    {
+      bool hasDiffTypes = false;
+      for( int i = 1; !hasDiffTypes && i <= m_uiSliceSegmentIdx; i++ )
+      {
+        Slice* slice1 = m_pcPic->slices[i-1];
+        Slice* slice2 = m_pcPic->slices[i];
+        if( slice1->getNalUnitType() != slice2->getNalUnitType())
+        {
+          hasDiffTypes = true;
+        }
+      }
+      CHECK( !hasDiffTypes, "VCL NAL units of the picture shall have two or more different nal_unit_type values");
+    }
+  }
+  else // all slices shall have the same nal unit type
+  {
+    bool sameNalUnitType = true;
+    for (int i = 0; i < m_uiSliceSegmentIdx; i++)
+    {
+      Slice *PreSlice = m_pcPic->slices[i];
+      if (PreSlice->getNalUnitType() != pcSlice->getNalUnitType())
+      {
+        sameNalUnitType = false;
+      }
+    }
+    CHECK(!sameNalUnitType, "pps_mixed_nalu_types_in_pic_flag is zero, but have different nal unit types");
+  }
+}
+/**
+- lookahead through next NAL units to determine if current NAL unit is the first NAL unit in a new picture
+*/
+bool DecLib::isNewPicture(std::ifstream *bitstreamFile, class InputByteStream *bytestream)
+{
+  bool ret = false;
+  bool finished = false;
+
+  // cannot be a new picture if there haven't been any slices yet
+  if(getFirstSliceInPicture())
+  {
+    return false;
+  }
+
+  // save stream position for backup
+#if RExt__DECODER_DEBUG_STATISTICS
+  CodingStatistics::CodingStatisticsData* backupStats = new CodingStatistics::CodingStatisticsData(CodingStatistics::GetStatistics());
+  std::streampos location = bitstreamFile->tellg() - std::streampos(bytestream->getNumBufferedBytes());
+#else
+  std::streampos location = bitstreamFile->tellg();
+#endif
+
+  // look ahead until picture start location is determined
+  while (!finished && !!(*bitstreamFile))
+  {
+    AnnexBStats stats = AnnexBStats();
+    InputNALUnit nalu;
+    byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
+    if (nalu.getBitstream().getFifo().empty())
+    {
+      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+    }
+    else
+    {
+      // get next NAL unit type
+      read(nalu);
+      switch (nalu.m_nalUnitType)
+      {
+      // NUT that indicate the start of a new picture
+      case NAL_UNIT_ACCESS_UNIT_DELIMITER:
+      case NAL_UNIT_OPI:
+      case NAL_UNIT_DCI:
+      case NAL_UNIT_VPS:
+      case NAL_UNIT_SPS:
+      case NAL_UNIT_PPS:
+      case NAL_UNIT_PH:
+        ret = true;
+        finished = true;
+        break;
+
+      // NUT that may be the start of a new picture - check first bit in slice header
+      case NAL_UNIT_CODED_SLICE_TRAIL:
+      case NAL_UNIT_CODED_SLICE_STSA:
+      case NAL_UNIT_CODED_SLICE_RASL:
+      case NAL_UNIT_CODED_SLICE_RADL:
+      case NAL_UNIT_RESERVED_VCL_4:
+      case NAL_UNIT_RESERVED_VCL_5:
+      case NAL_UNIT_RESERVED_VCL_6:
+      case NAL_UNIT_CODED_SLICE_IDR_W_RADL:
+      case NAL_UNIT_CODED_SLICE_IDR_N_LP:
+      case NAL_UNIT_CODED_SLICE_CRA:
+      case NAL_UNIT_CODED_SLICE_GDR:
+      case NAL_UNIT_RESERVED_IRAP_VCL_11:
+        ret = checkPictureHeaderInSliceHeaderFlag(nalu);
+        finished = true;
+        break;
+
+      // NUT that are not the start of a new picture
+      case NAL_UNIT_EOS:
+      case NAL_UNIT_EOB:
+      case NAL_UNIT_SUFFIX_APS:
+      case NAL_UNIT_SUFFIX_SEI:
+      case NAL_UNIT_FD:
+        ret = false;
+        finished = true;
+        break;
+
+      // NUT that might indicate the start of a new picture - keep looking
+      case NAL_UNIT_PREFIX_APS:
+      case NAL_UNIT_PREFIX_SEI:
+      case NAL_UNIT_RESERVED_NVCL_26:
+      case NAL_UNIT_RESERVED_NVCL_27:
+      case NAL_UNIT_UNSPECIFIED_28:
+      case NAL_UNIT_UNSPECIFIED_29:
+      case NAL_UNIT_UNSPECIFIED_30:
+      case NAL_UNIT_UNSPECIFIED_31:
+      default:
+        break;
+      }
+    }
+  }
+
+  // restore previous stream location - minus 3 due to the need for the annexB parser to read three extra bytes
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  bitstreamFile->clear();
+  bitstreamFile->seekg(location);
+  bytestream->reset();
+  CodingStatistics::SetStatistics(*backupStats);
+  delete backupStats;
+#else
+  bitstreamFile->clear();
+  bitstreamFile->seekg(location-std::streamoff(3));
+  bytestream->reset();
+#endif
+
+  // return TRUE if next NAL unit is the start of a new picture
+  return ret;
+}
+
+/**
+- lookahead through next NAL units to determine if current NAL unit is the first NAL unit in a new access unit
+*/
+bool DecLib::isNewAccessUnit( bool newPicture, std::ifstream *bitstreamFile, class InputByteStream *bytestream )
+{
+  bool ret = false;
+  bool finished = false;
+
+  // can only be the start of an AU if this is the start of a new picture
+  if( newPicture == false )
+  {
+    return false;
+  }
+
+  // save stream position for backup
+#if RExt__DECODER_DEBUG_STATISTICS
+  CodingStatistics::CodingStatisticsData* backupStats = new CodingStatistics::CodingStatisticsData(CodingStatistics::GetStatistics());
+  std::streampos location = bitstreamFile->tellg() - std::streampos(bytestream->getNumBufferedBytes());
+#else
+  std::streampos location = bitstreamFile->tellg();
+#endif
+
+  // look ahead until access unit start location is determined
+  while (!finished && !!(*bitstreamFile))
+  {
+    AnnexBStats stats = AnnexBStats();
+    InputNALUnit nalu;
+    byteStreamNALUnit(*bytestream, nalu.getBitstream().getFifo(), stats);
+    if (nalu.getBitstream().getFifo().empty())
+    {
+      msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+    }
+    else
+    {
+      // get next NAL unit type
+      read(nalu);
+      switch (nalu.m_nalUnitType)
+      {
+      // AUD always indicates the start of a new access unit
+      case NAL_UNIT_ACCESS_UNIT_DELIMITER:
+        ret = true;
+        finished = true;
+        break;
+
+      // slice types - check layer ID and POC
+      case NAL_UNIT_CODED_SLICE_TRAIL:
+      case NAL_UNIT_CODED_SLICE_STSA:
+      case NAL_UNIT_CODED_SLICE_RASL:
+      case NAL_UNIT_CODED_SLICE_RADL:
+      case NAL_UNIT_CODED_SLICE_IDR_W_RADL:
+      case NAL_UNIT_CODED_SLICE_IDR_N_LP:
+      case NAL_UNIT_CODED_SLICE_CRA:
+      case NAL_UNIT_CODED_SLICE_GDR:
+        ret = isSliceNaluFirstInAU( newPicture, nalu );
+        finished = true;
+        break;
+
+      // NUT that are not the start of a new access unit
+      case NAL_UNIT_EOS:
+      case NAL_UNIT_EOB:
+      case NAL_UNIT_SUFFIX_APS:
+      case NAL_UNIT_SUFFIX_SEI:
+      case NAL_UNIT_FD:
+        ret = false;
+        finished = true;
+        break;
+
+      // all other NUT - keep looking to find first VCL
+      default:
+        break;
+      }
+    }
+  }
+
+  // restore previous stream location
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  bitstreamFile->clear();
+  bitstreamFile->seekg(location);
+  bytestream->reset();
+  CodingStatistics::SetStatistics(*backupStats);
+  delete backupStats;
+#else
+  bitstreamFile->clear();
+  bitstreamFile->seekg(location);
+  bytestream->reset();
+#endif
+
+  // return TRUE if next NAL unit is the start of a new picture
+  return ret;
+}
+//! \}
diff --git a/source/Lib/SkipLib/DecLib.h b/source/Lib/SkipLib/DecLib.h
new file mode 100644
index 00000000..f156339b
--- /dev/null
+++ b/source/Lib/SkipLib/DecLib.h
@@ -0,0 +1,412 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     DecLib.h
+    \brief    decoder class (header)
+*/
+
+#ifndef __DECLIB__
+#define __DECLIB__
+
+#include "DecSlice.h"
+#include "CABACReader.h"
+#include "VLCReader.h"
+#include "SEIread.h"
+#include "CacheModel.h"
+
+#include "CommonLib/CommonDef.h"
+#include "CommonLib/Picture.h"
+#include "CommonLib/TrQuant.h"
+#include "CommonLib/InterPrediction.h"
+#include "CommonLib/IntraPrediction.h"
+#include "CommonLib/DeblockingFilter.h"
+#include "CommonLib/AdaptiveLoopFilter.h"
+#include "CommonLib/SEI.h"
+#include "CommonLib/Unit.h"
+#include "CommonLib/Reshape.h"
+#if JVET_AC0074_USE_OF_NNPFC_FOR_PIC_RATE_UPSAMPLING
+#include "CommonLib/SEINeuralNetworkPostFiltering.h"
+#endif
+
+class InputNALUnit;
+
+//! \ingroup DecoderLib
+//! \{
+
+bool tryDecodePicture(Picture *pcPic, const int expectedPoc, const std::string &bitstreamFileName,
+                      EnumArray<ParameterSetMap<APS>, ApsType> *apsMap = nullptr, bool bDecodeUntilPocFound = false,
+                      int debugCTU = -1, int debugPOC = -1);
+// Class definition
+// ====================================================================================================================
+
+/// decoder class
+class DecLib
+{
+private:
+  int                     m_maxRefPicNum;
+  bool m_isFirstGeneralHrd;
+  GeneralHrdParams        m_prevGeneralHrdParams;
+
+  int                     m_prevGDRInSameLayerPOC[MAX_VPS_LAYERS]; ///< POC number of the latest GDR picture
+  int                     m_prevGDRInSameLayerRecoveryPOC[MAX_VPS_LAYERS]; ///< Recovery POC number of the latest GDR picture
+  NalUnitType             m_associatedIRAPType[MAX_VPS_LAYERS]; ///< NAL unit type of the previous IRAP picture
+  int                     m_pocCRA[MAX_VPS_LAYERS];             ///< POC number of the previous CRA picture
+  CheckCRAFlags           m_checkCRAFlags[MAX_VPS_LAYERS];
+  int                     m_latestDRAPPOC;
+  int                     m_latestEDRAPPOC;
+  bool                    m_latestEDRAPIndicationLeadingPicturesDecodableFlag;
+  int                     m_associatedIRAPDecodingOrderNumber[MAX_VPS_LAYERS]; ///< Decoding order number of the previous IRAP picture
+  int                     m_decodingOrderCounter;
+  int                     m_puCounter;
+  bool                    m_seiInclusionFlag;
+  int                     m_prevGDRSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+  int                     m_prevIRAPSubpicPOC[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+  NalUnitType             m_prevIRAPSubpicType[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+  int                     m_prevIRAPSubpicDecOrderNo[MAX_VPS_LAYERS][MAX_NUM_SUB_PICS];
+  int                     m_pocRandomAccess;   ///< POC number of the random access point (the first IDR or CRA picture)
+  int                     m_lastRasPoc;
+  bool                    m_prevEOS[MAX_VPS_LAYERS];
+
+  PicList                 m_cListPic;         //  Dynamic buffer
+  ParameterSetManager     m_parameterSetManager;  // storage for parameter sets
+  PicHeader               m_picHeader;            // picture header
+  Slice*                  m_apcSlicePilot;
+
+
+  SEIMessages             m_SEIs; ///< List of SEI messages that have been received before the first slice and between slices, excluding prefix SEIs...
+  SEIScalabilityDimensionInfo* m_sdiSEIInFirstAU;
+  SEIMultiviewAcquisitionInfo* m_maiSEIInFirstAU;
+  SEIMultiviewViewPosition*    m_mvpSEIInFirstAU;
+
+  // functional classes
+  IntraPrediction         m_cIntraPred;
+  InterPrediction         m_cInterPred;
+  TrQuant                 m_cTrQuant;
+  DecSlice                m_cSliceDecoder;
+  TrQuant                 m_cTrQuantScalingList;
+  DecCu                   m_cCuDecoder;
+  HLSyntaxReader          m_HLSReader;
+  CABACDecoder            m_CABACDecoder;
+  SEIReader               m_seiReader;
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+  SeiCfgFileDump          m_seiCfgDump;
+#endif
+  DeblockingFilter        m_deblockingFilter;
+  SampleAdaptiveOffset    m_cSAO;
+  AdaptiveLoopFilter      m_cALF;
+  Reshape                 m_cReshaper;                        ///< reshaper class
+  HRD                     m_HRD;
+  // decoder side RD cost computation
+  RdCost                  m_cRdCost;                      ///< RD cost computation class
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+  CacheModel              m_cacheModel;
+#endif
+  bool isRandomAccessSkipPicture(int& iSkipFrame, int& iPOCLastDisplay, bool mixedNaluInPicFlag, uint32_t layerId);
+  Picture*                m_pcPic;
+  uint32_t                m_uiSliceSegmentIdx;
+  uint32_t                m_prevLayerID;
+  int                     m_prevPOC;
+  int                     m_prevPicPOC;
+  int                     m_prevTid0POC;
+  bool                    m_bFirstSliceInPicture;
+  bool                    m_firstPictureInSequence;
+  SEIFilmGrainSynthesizer m_grainCharacteristic;
+  PelStorage              m_grainBuf;
+  SEIColourTransformApply m_colourTranfParams;
+  PelStorage              m_invColourTransfBuf;
+  bool                    m_firstSliceInSequence[MAX_VPS_LAYERS];
+  bool                    m_firstSliceInBitstream;
+  bool                    m_isFirstAuInCvs;
+  bool                    m_accessUnitEos[MAX_VPS_LAYERS];
+  bool                    m_prevSliceSkipped;
+  int                     m_skippedPOC;
+  uint32_t                m_skippedLayerID;
+  int                     m_lastPOCNoOutputPriorPics;
+  bool                    m_isNoOutputPriorPics;
+  bool                    m_lastNoOutputBeforeRecoveryFlag[MAX_VPS_LAYERS];    //value of variable NoOutputBeforeRecoveryFlag of the assocated CRA/GDR pic
+  int                     m_sliceLmcsApsId;         //value of LmcsApsId, constraint is same id for all slices in one picture
+  std::ostream           *m_pDecodedSEIOutputStream;
+  uint32_t                m_audIrapOrGdrAuFlag;
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+  std::string             m_decoded360SeiDumpFileName;
+#endif
+
+  int                     m_decodedPictureHashSEIEnabled;  ///< Checksum(3)/CRC(2)/MD5(1)/disable(0) acting on decoded picture hash SEI message
+  uint32_t                m_numberOfChecksumErrorsDetected;
+
+  bool                    m_warningMessageSkipPicture;
+
+  std::list<InputNALUnit*> m_prefixSEINALUs; /// Buffered up prefix SEI NAL Units.
+#if JVET_Z0120_SII_SEI_PROCESSING
+  bool                                m_ShutterFilterEnable;          ///< enable Post-processing with Shutter Interval SEI
+#endif
+  int                     m_debugPOC;
+  int                     m_debugCTU;
+
+  struct AccessUnitInfo
+  {
+    NalUnitType     m_nalUnitType; ///< nal_unit_type
+    uint32_t        m_temporalId;  ///< temporal_id
+    uint32_t        m_nuhLayerId;  ///< nuh_layer_id
+  };
+  std::vector<AccessUnitInfo> m_accessUnitNals;
+  struct AccessUnitPicInfo
+  {
+    NalUnitType     m_nalUnitType; ///< nal_unit_type
+    uint32_t        m_temporalId;  ///< temporal_id
+    uint32_t        m_nuhLayerId;  ///< nuh_layer_id
+    int             m_POC;
+  };
+  std::vector<AccessUnitPicInfo> m_accessUnitPicInfo;
+  std::vector<AccessUnitPicInfo> m_firstAccessUnitPicInfo;
+  struct AccessUnitNestedSliSeiInfo
+  {
+    bool m_nestedSliPresent;
+    uint32_t m_numOlssNestedSli;
+    uint32_t m_olsIdxNestedSLI[MAX_NUM_OLSS];
+  };
+  std::vector<AccessUnitNestedSliSeiInfo> m_accessUnitNestedSliSeiInfo;
+  int m_accessUnitSpsNumSubpic[MAX_VPS_LAYERS];
+  struct NalUnitInfo
+  {
+    NalUnitType     m_nalUnitType; ///< nal_unit_type
+    uint32_t        m_nuhLayerId;  ///< nuh_layer_id
+    uint32_t        m_firstCTUinSlice; /// the first CTU in slice, specified with raster scan order ctu address
+    int             m_POC;             /// the picture order
+  };
+  std::vector<NalUnitInfo> m_nalUnitInfo[MAX_VPS_LAYERS];
+  EnumArray<std::vector<int>, ApsType> m_accessUnitApsNals;
+  std::vector<int> m_accessUnitSeiTids;
+  std::vector<bool> m_accessUnitNoOutputPriorPicFlags;
+
+  // NAL unit type, layer ID, and SEI payloadType
+  std::vector<std::tuple<NalUnitType, int, SEI::PayloadType>> m_accessUnitSeiPayLoadTypes;
+
+  std::vector<NalUnitType> m_pictureUnitNals;
+  std::list<InputNALUnit *> m_pictureSeiNalus;
+  std::list<InputNALUnit *> m_suffixApsNalus;
+  std::list<InputNALUnit*> m_accessUnitSeiNalus;
+
+  OPI*                    m_opi;
+  bool                    m_mTidExternalSet;
+  bool                    m_mTidOpiSet;
+  bool                    m_tOlsIdxTidExternalSet;
+  bool                    m_tOlsIdxTidOpiSet;
+  VPS*                    m_vps;
+  int                     m_maxDecSubPicIdx;
+  int                     m_maxDecSliceAddrInSubPic;
+  int                     m_clsVPSid;
+
+#if GDR_ENABLED
+  int m_lastGdrPoc;
+  int m_lastGdrRecoveryPocCnt;
+#endif
+#if JVET_AC0074_USE_OF_NNPFC_FOR_PIC_RATE_UPSAMPLING
+  SEINeuralNetworkPostFiltering m_nnPostFiltering;
+#endif
+
+public:
+  int                     m_targetSubPicIdx;
+
+  DCI*                    m_dci;
+  EnumArray<ParameterSetMap<APS>, ApsType> *m_apsMapEnc = nullptr;
+#if GDR_LEAK_TEST
+public:
+  int                     m_gdrPocRandomAccess;
+#endif // GDR_LEAK_TEST
+
+public:
+  DecLib();
+  virtual ~DecLib();
+
+  void  create  ();
+  void  destroy ();
+
+  void  setDecodedPictureHashSEIEnabled(int enabled) { m_decodedPictureHashSEIEnabled=enabled; }
+
+  void  init(
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+    const std::string& cacheCfgFileName
+#endif
+  );
+  bool  decode(InputNALUnit& nalu, int& iSkipFrame, int& iPOCLastDisplay, int iTargetOlsIdx);
+  void  deletePicBuffer();
+
+  void  executeLoopFilters();
+  void finishPicture(int &poc, PicList *&rpcListPic, MsgLevel msgl = INFO, bool associatedWithNewClvs = false);
+  void  finishPictureLight(int& poc, PicList*& rpcListPic );
+  void  checkNoOutputPriorPics (PicList* rpcListPic);
+  void  checkNalUnitConstraints( uint32_t naluType );
+  void  checkPicTypeAfterEos();
+  void  updateAssociatedIRAP();
+  void  updatePrevGDRInSameLayer();
+  void  updatePrevIRAPAndGDRSubpic();
+  bool  getGDRRecoveryPocReached()          { return ( m_pcPic->getPOC() >= m_prevGDRInSameLayerRecoveryPOC[m_pcPic->layerId] ); }
+
+  bool  getNoOutputPriorPicsFlag () const   { return m_isNoOutputPriorPics; }
+  void  setNoOutputPriorPicsFlag (bool val) { m_isNoOutputPriorPics = val; }
+  void  setFirstSliceInPicture (bool val)  { m_bFirstSliceInPicture = val; }
+  bool  getFirstSliceInPicture () const  { return m_bFirstSliceInPicture; }
+  bool  getFirstSliceInSequence(int layerId) const { return m_firstSliceInSequence[layerId]; }
+  void  setFirstSliceInSequence(bool val, int layerId) { m_firstSliceInSequence[layerId] = val; }
+  void  setDecodedSEIMessageOutputStream(std::ostream *pOpStream) { m_pDecodedSEIOutputStream = pOpStream; }
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+  void  setDecoded360SEIMessageFileName(std::string &Dump360SeiFileName) { m_decoded360SeiDumpFileName = Dump360SeiFileName; }
+#endif
+  uint32_t  getNumberOfChecksumErrorsDetected() const { return m_numberOfChecksumErrorsDetected; }
+
+#if GDR_ENABLED
+  void setLastGdrPoc(int poc) { m_lastGdrPoc = poc;  }
+  int  getLastGdrPoc()        { return m_lastGdrPoc; }
+  void setLastGdrRecoveryPocCnt(int recoveryPocCnt) { m_lastGdrRecoveryPocCnt = recoveryPocCnt; }
+  int  getLastGdrRecoveryPocCnt()                     { return m_lastGdrRecoveryPocCnt; }
+#endif
+
+  int  getDebugCTU( )               const { return m_debugCTU; }
+  void setDebugCTU( int debugCTU )        { m_debugCTU = debugCTU; }
+  int  getDebugPOC( )               const { return m_debugPOC; };
+  void setDebugPOC( int debugPOC )        { m_debugPOC = debugPOC; };
+  void resetAccessUnitNals()              { m_accessUnitNals.clear();    }
+  void resetAccessUnitPicInfo()           { m_accessUnitPicInfo.clear(); }
+  void resetAccessUnitApsNals()
+  {
+    for (auto &nals: m_accessUnitApsNals)
+    {
+      nals.clear();
+    }
+  }
+  void resetAccessUnitSeiTids()           { m_accessUnitSeiTids.clear(); }
+  void resetAudIrapOrGdrAuFlag()          { m_audIrapOrGdrAuFlag = false; }
+  void resetAccessUnitEos()               { memset(m_accessUnitEos, false, sizeof(m_accessUnitEos)); }
+  void checkTidLayerIdInAccessUnit();
+  void resetAccessUnitSeiPayLoadTypes()   { m_accessUnitSeiPayLoadTypes.clear(); }
+  void checkSEIInAccessUnit();
+  void checkSeiContentInAccessUnit();
+  void resetAccessUnitSeiNalus();
+  void checkLayerIdIncludedInCvss();
+  void CheckNoOutputPriorPicFlagsInAccessUnit();
+  void resetAccessUnitNoOutputPriorPicFlags() { m_accessUnitNoOutputPriorPicFlags.clear(); }
+  void checkMultiSubpicNum(int olsIdx);
+  void resetAccessUnitNestedSliSeiInfo()  { m_accessUnitNestedSliSeiInfo.clear(); }
+  void resetIsFirstAuInCvs();
+  void checkSeiInPictureUnit();
+  void resetPictureSeiNalus();
+  void resetPrefixSeiNalus();
+  bool isSliceNaluFirstInAU( bool newPicture, InputNALUnit &nalu );
+  void processSuffixApsNalus();
+
+  void checkAPSInPictureUnit();
+  void resetPictureUnitNals() { m_pictureUnitNals.clear(); }
+
+  const VPS* getVPS()                     { return m_vps; }
+  void deriveTargetOutputLayerSet( const int targetOlsIdx ) { if( m_vps != nullptr ) m_vps->deriveTargetOutputLayerSet( targetOlsIdx ); }
+
+  void  initScalingList()
+  {
+    m_cTrQuantScalingList.init(nullptr, MAX_TB_SIZEY, false, false, false, false);
+  }
+
+  void  setAPSMapEnc(EnumArray<ParameterSetMap<APS>, ApsType> *apsMap) { m_apsMapEnc = apsMap; }
+  bool  isNewPicture( std::ifstream *bitstreamFile, class InputByteStream *bytestream );
+  bool  isNewAccessUnit( bool newPicture, std::ifstream *bitstreamFile, class InputByteStream *bytestream );
+
+  bool      getHTidExternalSetFlag()               const { return m_mTidExternalSet; }
+  void      setHTidExternalSetFlag(bool mTidExternalSet)  { m_mTidExternalSet = mTidExternalSet; }
+  bool      getHTidOpiSetFlag()               const { return m_mTidOpiSet; }
+  void      setHTidOpiSetFlag(bool mTidOpiSet)  { m_mTidOpiSet = mTidOpiSet; }
+  bool      getTOlsIdxExternalFlag()               const { return m_tOlsIdxTidExternalSet; }
+  void      setTOlsIdxExternalFlag (bool tOlsIdxExternalSet)  { m_tOlsIdxTidExternalSet = tOlsIdxExternalSet; }
+  bool      getTOlsIdxOpiFlag()               const { return m_tOlsIdxTidOpiSet; }
+  void      setTOlsIdxOpiFlag(bool tOlsIdxOpiSet)  { m_tOlsIdxTidOpiSet = tOlsIdxOpiSet; }
+  const OPI* getOPI()                     { return m_opi; }
+
+  bool      getMixedNaluTypesInPicFlag();
+#if GREEN_METADATA_SEI_ENABLED
+  FeatureCounterStruct m_featureCounter;
+  bool m_GMFAFramewise;
+  std::string   m_GMFAFile;
+  void setFeatureCounter (FeatureCounterStruct b ) {m_featureCounter = b;}
+  FeatureCounterStruct getFeatureCounter (){return m_featureCounter;}
+  void setGMFAFile(std::string b){m_GMFAFile = b;}
+  void setFeatureAnalysisFramewise(bool b){m_GMFAFramewise = b;}
+#endif
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+  bool  getShutterFilterFlag()        const { return m_ShutterFilterEnable; }
+  void  setShutterFilterFlag(bool value) { m_ShutterFilterEnable = value; }
+#endif
+
+#if JVET_AC0074_USE_OF_NNPFC_FOR_PIC_RATE_UPSAMPLING
+  void applyNnPostFilter();
+#endif
+
+
+protected:
+  void  xUpdateRasInit(Slice* slice);
+
+  Picture * xGetNewPicBuffer( const SPS &sps, const PPS &pps, const uint32_t temporalLayer, const int layerId );
+  void  xCreateLostPicture( int iLostPOC, const int layerId );
+  void  xCreateUnavailablePicture( const PPS *pps, const int iUnavailablePoc, const bool longTermFlag, const int temporalId, const int layerId, const bool interLayerRefPicFlag );
+  void  checkParameterSetsInclusionSEIconstraints(const InputNALUnit nalu);
+  void  xActivateParameterSets( const InputNALUnit nalu );
+  void  xCheckParameterSetConstraints( const int layerId );
+  void      xDecodePicHeader( InputNALUnit& nalu );
+  bool      xDecodeSlice(InputNALUnit &nalu, int &iSkipFrame, int iPOCLastDisplay);
+  void      xDecodeOPI( InputNALUnit& nalu );
+  void      xDecodeVPS( InputNALUnit& nalu );
+  void      xDecodeDCI( InputNALUnit& nalu );
+  void      xDecodeSPS( InputNALUnit& nalu );
+  void      xDecodePPS( InputNALUnit& nalu );
+  void      xDecodeAPS(InputNALUnit& nalu);
+  void      xUpdatePreviousTid0POC(Slice *pSlice)
+  {
+    if( (pSlice->getTLayer() == 0) && (pSlice->getNalUnitType() != NAL_UNIT_CODED_SLICE_RASL) && (pSlice->getNalUnitType() != NAL_UNIT_CODED_SLICE_RADL) && !pSlice->getPicHeader()->getNonReferencePictureFlag() )
+    {
+      m_prevTid0POC = pSlice->getPOC();
+    }
+  }
+  void      xParsePrefixSEImessages();
+  void      xParsePrefixSEIsForUnknownVCLNal();
+  void      xCheckPrefixSEIMessages( SEIMessages& prefixSEIs );
+  void      xCheckDUISEIMessages(SEIMessages &prefixSEIs);
+
+
+  void  xCheckNalUnitConstraintFlags( const ConstraintInfo *cInfo, uint32_t naluType );
+  void     xCheckMixedNalUnit(Slice* pcSlice, SPS *sps, InputNALUnit &nalu);
+};// END CLASS DEFINITION DecLib
+
+
+//! \}
+
+#endif // __DECTOP__
+
diff --git a/source/Lib/SkipLib/DecSlice.cpp b/source/Lib/SkipLib/DecSlice.cpp
new file mode 100644
index 00000000..7221227d
--- /dev/null
+++ b/source/Lib/SkipLib/DecSlice.cpp
@@ -0,0 +1,343 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     DecSlice.cpp
+    \brief    slice decoder class
+*/
+
+#include "DecSlice.h"
+#include "CommonLib/UnitTools.h"
+#include "CommonLib/dtrace_next.h"
+
+#include <vector>
+
+//! \ingroup DecoderLib
+//! \{
+
+//////////////////////////////////////////////////////////////////////
+// Construction/Destruction
+//////////////////////////////////////////////////////////////////////
+
+DecSlice::DecSlice()
+{
+}
+
+DecSlice::~DecSlice()
+{
+}
+
+void DecSlice::create()
+{
+}
+
+void DecSlice::destroy()
+{
+}
+
+void DecSlice::init( CABACDecoder* cabacDecoder, DecCu* pcCuDecoder )
+{
+  m_CABACDecoder    = cabacDecoder;
+  m_pcCuDecoder     = pcCuDecoder;
+}
+
+
+void DecSlice::decompressSlice( Slice* slice, InputBitstream* bitstream, int debugCTU )
+{
+  //-- For time output for each slice
+  slice->startProcessingTimer();
+
+  const SPS*     sps          = slice->getSPS();
+  Picture*       pic          = slice->getPic();
+  CABACReader   &cabacReader  = *m_CABACDecoder->getCABACReader(BpmType::STD);
+
+  // setup coding structure
+  CodingStructure& cs = *pic->cs;
+  cs.slice            = slice;
+  cs.sps              = sps;
+  cs.pps              = slice->getPPS();
+  memcpy(cs.alfApss, slice->getAlfAPSs(), sizeof(cs.alfApss));
+
+  cs.lmcsAps          = slice->getPicHeader()->getLmcsAPS();
+  cs.scalinglistAps   = slice->getPicHeader()->getScalingListAPS();
+
+  cs.pcv              = slice->getPPS()->pcv;
+  cs.chromaQpAdj      = 0;
+
+  cs.picture->resizeSAO(cs.pcv->sizeInCtus, 0);
+
+  cs.resetPrevPLT(cs.prevPLT);
+
+  if (slice->getFirstCtuRsAddrInSlice() == 0)
+  {
+    cs.picture->resizeAlfData(cs.pcv->sizeInCtus);
+  }
+
+  const unsigned numSubstreams = slice->getNumberOfSubstreamSizes() + 1;
+
+  // init each couple {EntropyDecoder, Substream}
+  // Table of extracted substreams.
+  std::vector<InputBitstream*> ppcSubstreams( numSubstreams );
+  OutputBitstream outputBitStream;
+  for( unsigned idx = 0; idx < numSubstreams; idx++ )
+  {
+    ppcSubstreams[idx] = bitstream->extractSubstream( idx+1 < numSubstreams ? ( slice->getSubstreamSize(idx) << 3 ) : bitstream->getNumBitsLeft() );
+    std::vector<uint8_t> fifo = ppcSubstreams[idx]->getFifo();
+    std::cout << "\n fifo " << idx << " size: " << fifo.size();
+  }
+
+
+  const unsigned  widthInCtus             = cs.pcv->widthInCtus;
+  const bool     wavefrontsEnabled           = cs.sps->getEntropyCodingSyncEnabledFlag();
+  const bool     entryPointPresent           = cs.sps->getEntryPointsPresentFlag();
+
+  cabacReader.initBitstream( ppcSubstreams[0] );
+  cabacReader.initCtxModels( *slice );
+
+  // Quantization parameter
+  pic->m_prevQP.fill(slice->getSliceQp());
+  CHECK(pic->m_prevQP[ChannelType::LUMA] == std::numeric_limits<int>::max(), "Invalid previous QP");
+
+  DTRACE( g_trace_ctx, D_HEADER, "=========== POC: %d ===========\n", slice->getPOC() );
+
+
+  if( slice->getSliceType() != I_SLICE && slice->getRefPic( REF_PIC_LIST_0, 0 )->subPictures.size() > 1 )
+  {
+    clipMv = clipMvInSubpic;
+  }
+  else
+  {
+    clipMv = clipMvInPic;
+  }
+  // for every CTU in the slice segment...
+  unsigned subStrmId = 0;
+
+  for( unsigned ctuIdx = 0; ctuIdx < slice->getNumCtuInSlice(); ctuIdx++ )
+  {
+    const unsigned  ctuRsAddr       = slice->getCtuAddrInSlice(ctuIdx);
+    const unsigned  ctuXPosInCtus   = ctuRsAddr % widthInCtus;
+    const unsigned  ctuYPosInCtus   = ctuRsAddr / widthInCtus;
+    const unsigned  tileColIdx      = slice->getPPS()->ctuToTileCol( ctuXPosInCtus );
+    const unsigned  tileRowIdx      = slice->getPPS()->ctuToTileRow( ctuYPosInCtus );
+    const unsigned  tileXPosInCtus  = slice->getPPS()->getTileColumnBd( tileColIdx );
+    const unsigned  tileYPosInCtus  = slice->getPPS()->getTileRowBd( tileRowIdx );
+    const unsigned  tileColWidth    = slice->getPPS()->getTileColumnWidth( tileColIdx );
+    const unsigned  tileRowHeight   = slice->getPPS()->getTileRowHeight( tileRowIdx );
+    const unsigned  tileIdx         = slice->getPPS()->getTileIdx( ctuXPosInCtus, ctuYPosInCtus);
+    const unsigned  maxCUSize             = sps->getMaxCUWidth();
+    Position pos( ctuXPosInCtus*maxCUSize, ctuYPosInCtus*maxCUSize) ;
+    UnitArea ctuArea(cs.area.chromaFormat, Area( pos.x, pos.y, maxCUSize, maxCUSize ) );
+    const SubPic &curSubPic = slice->getPPS()->getSubPicFromPos(pos);
+    // padding/restore at slice level
+    if (slice->getPPS()->getNumSubPics()>=2 && curSubPic.getTreatedAsPicFlag() && ctuIdx==0)
+    {
+      int subPicX      = (int)curSubPic.getSubPicLeft();
+      int subPicY      = (int)curSubPic.getSubPicTop();
+      int subPicWidth  = (int)curSubPic.getSubPicWidthInLumaSample();
+      int subPicHeight = (int)curSubPic.getSubPicHeightInLumaSample();
+      for (int rlist = REF_PIC_LIST_0; rlist < NUM_REF_PIC_LIST_01; rlist++)
+      {
+        int n = slice->getNumRefIdx((RefPicList)rlist);
+        for (int idx = 0; idx < n; idx++)
+        {
+          Picture *refPic = slice->getRefPic((RefPicList)rlist, idx);
+
+          if( !refPic->getSubPicSaved() && refPic->subPictures.size() > 1 )
+          {
+            refPic->saveSubPicBorder(refPic->getPOC(), subPicX, subPicY, subPicWidth, subPicHeight);
+            refPic->extendSubPicBorder(refPic->getPOC(), subPicX, subPicY, subPicWidth, subPicHeight);
+            refPic->setSubPicSaved(true);
+          }
+        }
+      }
+    }
+
+    DTRACE_UPDATE( g_trace_ctx, std::make_pair( "ctu", ctuRsAddr ) );
+
+    cabacReader.initBitstream( ppcSubstreams[subStrmId] );
+
+    // set up CABAC contexts' state for this CTU
+    if( ctuXPosInCtus == tileXPosInCtus && ctuYPosInCtus == tileYPosInCtus )
+    {
+      if( ctuIdx != 0 ) // if it is the first CTU, then the entropy coder has already been reset
+      {
+        cabacReader.initCtxModels( *slice );
+        cs.resetPrevPLT(cs.prevPLT);
+      }
+      pic->m_prevQP.fill(slice->getSliceQp());
+    }
+    else if( ctuXPosInCtus == tileXPosInCtus && wavefrontsEnabled )
+    {
+      // Synchronize cabac probabilities with top CTU if it's available and at the start of a line.
+      if( ctuIdx != 0 ) // if it is the first CTU, then the entropy coder has already been reset
+      {
+        cabacReader.initCtxModels( *slice );
+        cs.resetPrevPLT(cs.prevPLT);
+      }
+      if (cs.getCURestricted(pos.offset(0, -1), pos, slice->getIndependentSliceIdx(), tileIdx, ChannelType::LUMA))
+      {
+        // Top is available, so use it.
+        cabacReader.getCtx() = m_entropyCodingSyncContextState;
+        cabacReader.getCtx().riceStatReset(
+          slice->getSPS()->getBitDepth(ChannelType::LUMA),
+          slice->getSPS()->getSpsRangeExtension().getPersistentRiceAdaptationEnabledFlag());
+        cs.setPrevPLT(m_palettePredictorSyncState);
+      }
+      pic->m_prevQP.fill(slice->getSliceQp());
+    }
+
+    bool updateBcwCodingOrder = cs.slice->getSliceType() == B_SLICE && ctuIdx == 0;
+    if(updateBcwCodingOrder)
+    {
+      resetBcwCodingOrder(true, cs);
+    }
+
+    if ((cs.slice->getSliceType() != I_SLICE || cs.sps->getIBCFlag()) && ctuXPosInCtus == tileXPosInCtus)
+    {
+      cs.motionLut.lut.resize(0);
+      cs.motionLut.lutIbc.resize(0);
+      cs.resetIBCBuffer = true;
+    }
+
+    if( !cs.slice->isIntra() )
+    {
+      pic->mctsInfo.init( &cs, getCtuAddr( ctuArea.lumaPos(), *( cs.pcv ) ) );
+    }
+
+    if( ctuRsAddr == debugCTU )
+    {
+      break;
+    }
+    cabacReader.coding_tree_unit( cs, ctuArea, pic->m_prevQP, ctuRsAddr );
+
+    m_pcCuDecoder->decompressCtu( cs, ctuArea );
+#if GREEN_METADATA_SEI_ENABLED
+    FeatureCounterStruct featureCounter = slice->getFeatureCounter();
+    countFeatures( featureCounter, cs,ctuArea);
+    slice->setFeatureCounter(featureCounter);
+#endif
+    
+    if( ctuXPosInCtus == tileXPosInCtus && wavefrontsEnabled )
+    {
+      m_entropyCodingSyncContextState = cabacReader.getCtx();
+      cs.storePrevPLT(m_palettePredictorSyncState);
+    }
+
+
+    if( ctuIdx == slice->getNumCtuInSlice()-1 )
+    {
+      unsigned binVal = cabacReader.terminating_bit();
+      CHECK( !binVal, "Expecting a terminating bit" );
+#if DECODER_CHECK_SUBSTREAM_AND_SLICE_TRAILING_BYTES
+      cabacReader.remaining_bytes( false );
+#endif
+    }
+    else if( ( ctuXPosInCtus + 1 == tileXPosInCtus + tileColWidth ) &&
+             ( ctuYPosInCtus + 1 == tileYPosInCtus + tileRowHeight || wavefrontsEnabled ) )
+    {
+      // The sub-stream/stream should be terminated after this CTU.
+      // (end of slice-segment, end of tile, end of wavefront-CTU-row)
+      unsigned binVal = cabacReader.terminating_bit();
+      CHECK( !binVal, "Expecting a terminating bit" );
+      if( entryPointPresent )
+      {
+#if DECODER_CHECK_SUBSTREAM_AND_SLICE_TRAILING_BYTES
+        cabacReader.remaining_bytes( true );
+#endif
+        subStrmId++;
+      }
+    }
+    if (slice->getPPS()->getNumSubPics() >= 2 && curSubPic.getTreatedAsPicFlag() && ctuIdx == (slice->getNumCtuInSlice() - 1))
+    // for last Ctu in the slice
+    {
+      int subPicX = (int)curSubPic.getSubPicLeft();
+      int subPicY = (int)curSubPic.getSubPicTop();
+      int subPicWidth = (int)curSubPic.getSubPicWidthInLumaSample();
+      int subPicHeight = (int)curSubPic.getSubPicHeightInLumaSample();
+      for (int rlist = REF_PIC_LIST_0; rlist < NUM_REF_PIC_LIST_01; rlist++)
+      {
+        int n = slice->getNumRefIdx((RefPicList)rlist);
+        for (int idx = 0; idx < n; idx++)
+        {
+          Picture *refPic = slice->getRefPic((RefPicList)rlist, idx);
+          if (refPic->getSubPicSaved())
+          {
+            refPic->restoreSubPicBorder(refPic->getPOC(), subPicX, subPicY, subPicWidth, subPicHeight);
+            refPic->setSubPicSaved(false);
+          }
+        }
+      }
+    }
+  }
+  
+#if GREEN_METADATA_SEI_ENABLED
+  FeatureCounterStruct featureCounter = slice->getFeatureCounter();
+  featureCounter.baseQP[slice->getSliceQpBase()] ++;
+  if (featureCounter.isYUV400 == -1)
+  {
+    featureCounter.isYUV400 = sps->getChromaFormatIdc() == ChromaFormat::_400 ? 1 : 0;
+    featureCounter.isYUV420 = sps->getChromaFormatIdc() == ChromaFormat::_420 ? 1 : 0;
+    featureCounter.isYUV422 = sps->getChromaFormatIdc() == ChromaFormat::_422 ? 1 : 0;
+    featureCounter.isYUV444 = sps->getChromaFormatIdc() == ChromaFormat::_444 ? 1 : 0;
+  }
+  
+  if (featureCounter.is8bit == -1)
+  {
+    featureCounter.is8bit  = (sps->getBitDepth(ChannelType::LUMA) == 8) ? 1 : 0;
+    featureCounter.is10bit = (sps->getBitDepth(ChannelType::LUMA) == 10) ? 1 : 0;
+    featureCounter.is12bit = (sps->getBitDepth(ChannelType::LUMA) == 12) ? 1 : 0;
+  }
+  
+  if (slice->getSliceType() == B_SLICE)
+  {
+    featureCounter.bSlices++;
+  }
+  else if (slice->getSliceType() == P_SLICE)
+  {
+    featureCounter.pSlices++;
+  }
+  else
+  {
+    featureCounter.iSlices++;
+  }
+  slice->setFeatureCounter(featureCounter);
+#endif
+  
+  // deallocate all created substreams, including internal buffers.
+  for( auto substr: ppcSubstreams )
+  {
+    delete substr;
+  }
+  slice->stopProcessingTimer();
+}
+
+//! \}
diff --git a/source/Lib/SkipLib/DecSlice.h b/source/Lib/SkipLib/DecSlice.h
new file mode 100644
index 00000000..acefcc51
--- /dev/null
+++ b/source/Lib/SkipLib/DecSlice.h
@@ -0,0 +1,80 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     DecSlice.h
+    \brief    slice decoder class (header)
+*/
+
+#ifndef __DECSLICE__
+#define __DECSLICE__
+
+#pragma once
+
+#include "CommonLib/CommonDef.h"
+#include "CommonLib/BitStream.h"
+#include "DecCu.h"
+#include "CABACReader.h"
+
+//! \ingroup DecoderLib
+//! \{
+
+// ====================================================================================================================
+// Class definition
+// ====================================================================================================================
+
+/// slice decoder class
+class DecSlice
+{
+private:
+  // access channel
+  CABACDecoder*   m_CABACDecoder;
+  DecCu*          m_pcCuDecoder;
+
+  Ctx             m_entropyCodingSyncContextState;      ///< context storage for state of contexts at the wavefront/WPP/entropy-coding-sync second CTU of tile-row
+  PLTBuf          m_palettePredictorSyncState;      /// palette predictor storage at wavefront/WPP
+
+public:
+  DecSlice();
+  virtual ~DecSlice();
+
+  void  init              ( CABACDecoder* cabacDecoder, DecCu* pcMbDecoder );
+  void  create            ();
+  void  destroy           ();
+
+  void  decompressSlice   ( Slice* slice, InputBitstream* bitstream, int debugCTU );
+};
+
+//! \}
+
+#endif
+
diff --git a/source/Lib/SkipLib/NALread.cpp b/source/Lib/SkipLib/NALread.cpp
new file mode 100644
index 00000000..7a39ed13
--- /dev/null
+++ b/source/Lib/SkipLib/NALread.cpp
@@ -0,0 +1,177 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ \file     NALread.cpp
+ \brief    reading functionality for NAL units
+ */
+
+
+#include <vector>
+#include <algorithm>
+#include <ostream>
+
+#include "NALread.h"
+
+#include "CommonLib/NAL.h"
+#include "CommonLib/BitStream.h"
+#include "CommonLib/Rom.h"
+#include "CommonLib/dtrace_next.h"
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#include "CommonLib/CodingStatistics.h"
+#endif
+
+//! \ingroup DecoderLib
+//! \{
+static void convertPayloadToRBSP(std::vector<uint8_t> &nalUnitBuf, InputBitstream *bitstream, bool isVclNalUnit)
+{
+  uint32_t zeroCount = 0;
+  std::vector<uint8_t>::iterator it_read, it_write;
+
+  uint32_t pos = 0;
+  bitstream->clearEmulationPreventionByteLocation();
+  for (it_read = it_write = nalUnitBuf.begin(); it_read != nalUnitBuf.end(); it_read++, it_write++, pos++)
+  {
+    CHECK(zeroCount >= 2 && *it_read < 0x03, "Zero count is '2' and read value is small than '3'");
+    if (zeroCount == 2 && *it_read == 0x03)
+    {
+      bitstream->pushEmulationPreventionByteLocation( pos );
+      pos++;
+      it_read++;
+      zeroCount = 0;
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+      CodingStatistics::IncrementStatisticEP(STATS__EMULATION_PREVENTION_3_BYTES, 8, 0);
+#endif
+      if (it_read == nalUnitBuf.end())
+      {
+        break;
+      }
+      CHECK(*it_read > 0x03, "Read a value bigger than '3'");
+    }
+    zeroCount = (*it_read == 0x00) ? zeroCount+1 : 0;
+    *it_write = *it_read;
+  }
+  CHECK(zeroCount != 0, "Zero count not '0'");
+
+  if (isVclNalUnit)
+  {
+    // Remove cabac_zero_word from payload if present
+    int n = 0;
+
+    while (it_write[-1] == 0x00)
+    {
+      it_write--;
+      n++;
+    }
+
+    if (n > 0)
+    {
+      msg( NOTICE, "\nDetected %d instances of cabac_zero_word\n", n/2);
+    }
+  }
+
+  nalUnitBuf.resize(it_write - nalUnitBuf.begin());
+}
+
+#if ENABLE_TRACING
+static void xTraceNalUnitHeader(InputNALUnit& nalu)
+{
+  DTRACE( g_trace_ctx, D_NALUNITHEADER, "*********** NAL UNIT (%s) ***********\n", nalUnitTypeToString(nalu.m_nalUnitType) );
+  bool zeroTidRequiredFlag = 0;
+  if ((nalu.m_nalUnitType >= 16) && (nalu.m_nalUnitType <= 31))
+  {
+    zeroTidRequiredFlag = 1;
+  }
+  DTRACE( g_trace_ctx, D_NALUNITHEADER, "%-50s u(%d)  : %u\n", "zero_tid_required_flag", 1, zeroTidRequiredFlag );
+  DTRACE( g_trace_ctx, D_NALUNITHEADER, "%-50s u(%d)  : %u\n", "nuh_temporal_id_plus1", 3, nalu.m_temporalId + 1 );
+  DTRACE( g_trace_ctx, D_NALUNITHEADER, "%-50s u(%d)  : %u\n", "nal_unit_type_lsb", 4, (nalu.m_nalUnitType) - (zeroTidRequiredFlag << 4));
+  DTRACE( g_trace_ctx, D_NALUNITHEADER, "%-50s u(%d)  : %u\n", "nuh_layer_id_plus1", 7, nalu.m_nuhLayerId+1);
+  DTRACE( g_trace_ctx, D_NALUNITHEADER, "%-50s u(%d)  : %u\n", "nuh_reserved_zero_bit", 1, 0 );
+}
+#endif
+
+void readNalUnitHeader(InputNALUnit& nalu)
+{
+  InputBitstream& bs = nalu.getBitstream();
+
+  nalu.m_forbiddenZeroBit   = bs.read(1);                 // forbidden zero bit
+  nalu.m_nuhReservedZeroBit = bs.read(1);                 // nuh_reserved_zero_bit
+  nalu.m_nuhLayerId         = bs.read(6);                 // nuh_layer_id
+  CHECK(nalu.m_nuhLayerId > 55, "The value of nuh_layer_id shall be in the range of 0 to 55, inclusive");
+  nalu.m_nalUnitType        = (NalUnitType) bs.read(5);   // nal_unit_type
+  nalu.m_temporalId         = bs.read(3) - 1;             // nuh_temporal_id_plus1
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP(STATS__NAL_UNIT_HEADER_BITS, 1+3+4+7+1, 0);
+#endif
+
+#if ENABLE_TRACING
+  xTraceNalUnitHeader(nalu);
+#endif
+
+  // only check these rules for base layer
+  if (nalu.m_nuhLayerId == 0)
+  {
+    if ( nalu.m_temporalId )
+    {
+    }
+    else
+    {
+      CHECK(nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA
+        , "When NAL unit type is equal to STSA_NUT, TemporalId shall not be equal to 0");
+    }
+  }
+}
+/**
+ * create a NALunit structure with given header values and storage for
+ * a bitstream
+ */
+void read(InputNALUnit& nalu)
+{
+  InputBitstream &bitstream = nalu.getBitstream();
+  std::vector<uint8_t> &nalUnitBuf = bitstream.getFifo();
+  // perform anti-emulation prevention
+  const NalUnitType nut = (NalUnitType)(nalUnitBuf[1] >> 3);
+  convertPayloadToRBSP(nalUnitBuf, &bitstream, nut <= NAL_UNIT_RESERVED_IRAP_VCL_11);
+  bitstream.resetToStart();
+  readNalUnitHeader(nalu);
+}
+
+bool checkPictureHeaderInSliceHeaderFlag(InputNALUnit& nalu)
+{
+  InputBitstream& bitstream = nalu.getBitstream();
+  CHECK(bitstream.getByteLocation() != 2, "The picture_header_in_slice_header_flag is the first bit after the NAL unit header");
+  return (bool)bitstream.read(1);
+}
+//! \}
diff --git a/source/Lib/SkipLib/NALread.h b/source/Lib/SkipLib/NALread.h
new file mode 100644
index 00000000..fbb22826
--- /dev/null
+++ b/source/Lib/SkipLib/NALread.h
@@ -0,0 +1,73 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ \file     NALread.h
+ \brief    reading functionality for NAL units
+ */
+
+#pragma once
+
+#ifndef __NALREAD__
+#define __NALREAD__
+
+#include "CommonLib/CommonDef.h"
+#include "CommonLib/BitStream.h"
+#include "CommonLib/NAL.h"
+
+//! \ingroup DecoderLib
+//! \{
+
+/**
+ * A convenience wrapper to NALUnit that also provides a
+ * bitstream object.
+ */
+class InputNALUnit : public NALUnit
+{
+  private:
+    InputBitstream m_bitstream;
+
+  public:
+    InputNALUnit(const InputNALUnit &src) : NALUnit(src), m_bitstream(src.m_bitstream){};
+    InputNALUnit() : NALUnit(NAL_UNIT_INVALID), m_bitstream(){};
+    virtual ~InputNALUnit() { }
+    const InputBitstream &getBitstream() const { return m_bitstream; }
+    InputBitstream       &getBitstream() { return m_bitstream; }
+};
+
+void read(InputNALUnit& nalu);
+void readNalUnitHeader(InputNALUnit& nalu);
+bool checkPictureHeaderInSliceHeaderFlag(InputNALUnit & nalu);
+//! \}
+
+#endif
diff --git a/source/Lib/SkipLib/SEIread.cpp b/source/Lib/SkipLib/SEIread.cpp
new file mode 100644
index 00000000..54ede8ae
--- /dev/null
+++ b/source/Lib/SkipLib/SEIread.cpp
@@ -0,0 +1,3302 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ \file     SEIread.cpp
+ \brief    reading funtionality for SEI messages
+ */
+
+#include "CommonLib/CommonDef.h"
+#include "CommonLib/BitStream.h"
+#include "CommonLib/SEI.h"
+#include "CommonLib/Slice.h"
+#include "VLCReader.h"
+#include "SEIread.h"
+#include "CommonLib/Picture.h"
+#include "CommonLib/dtrace_next.h"
+#include <iomanip>
+
+
+//! \ingroup DecoderLib
+//! \{
+
+void SEIReader::sei_read_scode(std::ostream *pOS, uint32_t length, int& code, const char *pSymbolName)
+{
+  xReadSCode(length, code, pSymbolName);
+  if (pOS)
+  {
+    (*pOS) << "  " << std::setw(55) << pSymbolName << ": " << code << "\n";
+  }
+}
+
+void SEIReader::sei_read_code(std::ostream *pOS, uint32_t length, uint32_t &ruiCode, const char *pSymbolName)
+{
+  xReadCode(length, ruiCode, pSymbolName);
+  if (pOS)
+  {
+    (*pOS) << "  " << std::setw(55) << pSymbolName << ": " << ruiCode << "\n";
+  }
+}
+
+void SEIReader::sei_read_uvlc(std::ostream *pOS, uint32_t& ruiCode, const char *pSymbolName)
+{
+  xReadUvlc(ruiCode, pSymbolName);
+  if (pOS)
+  {
+    (*pOS) << "  " << std::setw(55) << pSymbolName << ": " << ruiCode << "\n";
+  }
+}
+
+void SEIReader::sei_read_svlc(std::ostream *pOS, int& ruiCode, const char *pSymbolName)
+{
+  xReadSvlc(ruiCode, pSymbolName);
+  if (pOS)
+  {
+    (*pOS) << "  " << std::setw(55) << pSymbolName << ": " << ruiCode << "\n";
+  }
+}
+
+void SEIReader::sei_read_flag(std::ostream *pOS, uint32_t& ruiCode, const char *pSymbolName)
+{
+  xReadFlag(ruiCode, pSymbolName);
+  if (pOS)
+  {
+    (*pOS) << "  " << std::setw(55) << pSymbolName << ": " << (ruiCode?1:0) << "\n";
+  }
+}
+
+void SEIReader::sei_read_string(std::ostream* os, std::string& code, const char* symbolName)
+{
+  xReadString(code, symbolName);
+  if (os)
+  {
+    (*os) << "  " << std::setw(55) << symbolName << ": " << code << "\n";
+  }
+}
+
+
+static inline void output_sei_message_header(SEI &sei, std::ostream *pDecodedMessageOutputStream, uint32_t payloadSize)
+{
+  if (pDecodedMessageOutputStream)
+  {
+    std::string seiMessageHdr(SEI::getSEIMessageString(sei.payloadType())); seiMessageHdr+=" SEI message";
+    (*pDecodedMessageOutputStream) << std::setfill('-') << std::setw((int) seiMessageHdr.size()) << "-"
+                                   << std::setfill(' ') << "\n"
+                                   << seiMessageHdr << " (" << payloadSize << " bytes)"
+                                   << "\n";
+  }
+}
+
+/**
+ * unmarshal a single SEI message from bitstream bs
+ */
+ // note: for independent parsing no parameter set should not be required here
+bool SEIReader::parseSEImessage(InputBitstream* bs, SEIMessages& seis, const NalUnitType nalUnitType, const uint32_t nuh_layer_id, const uint32_t temporalId, const VPS *vps, const SPS *sps, HRD &hrd, std::ostream *pDecodedMessageOutputStream)
+{
+  SEIMessages   seiListInCurNalu;
+  setBitstream(bs);
+  CHECK(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
+
+  bool atLeastOneSeiMessageRead = false;
+
+  do
+  {
+    const bool seiMessageRead = xReadSEImessage(seis, nalUnitType, nuh_layer_id, temporalId, vps, sps, hrd, pDecodedMessageOutputStream);
+    if (seiMessageRead)
+    {
+      seiListInCurNalu.push_back(seis.back());
+      atLeastOneSeiMessageRead = true;
+    }
+    /* SEI messages are an integer number of bytes, something has failed
+    * in the parsing if bitstream not byte-aligned */
+    CHECK(m_pcBitstream->getNumBitsUntilByteAligned(), "Bitstream not aligned");
+  }
+  while (m_pcBitstream->getNumBitsLeft() > 8);
+
+  const SEIMessages fillerData = getSeisByType(seiListInCurNalu, SEI::PayloadType::FILLER_PAYLOAD);
+  CHECK(fillerData.size() > 0 && fillerData.size() != seiListInCurNalu.size(), "When an SEI NAL unit contains an SEI message with payloadType equal to filler payload, the SEI NAL unit shall not contain any other SEI message with payloadType not equal to filler payload");
+  const SEIMessages pictureTiming = getSeisByType(seiListInCurNalu, SEI::PayloadType::PICTURE_TIMING);
+  CHECK(hrd.getGeneralHrdParameters().getGeneralSamePicTimingInAllOlsFlag() && pictureTiming.size() > 0 && pictureTiming.size() != seiListInCurNalu.size(),
+        "When general_same_pic_timing_in_all_ols_flag is equal to 1 [...], and when an SEI NAL unit contains a non-scalable-nested SEI message with "
+        "payloadType equal to 1 (PT), the SEI NAL unit shall not contain any other SEI message with payloadType not equal 1.");
+
+  xReadRbspTrailingBits();
+
+  return atLeastOneSeiMessageRead;
+}
+
+void SEIReader::parseAndExtractSEIScalableNesting(InputBitstream *bs, const NalUnitType nalUnitType,
+                                                  const uint32_t nuh_layer_id, const VPS *vps, const SPS *sps, HRD &hrd,
+                                                  uint32_t payloadSize, std::vector<SeiPayload> *seiList)
+{
+  SEI *sei = nullptr;
+  sei = new SEIScalableNesting;
+  setBitstream(bs);
+  xParseSEIScalableNestingBinary((SEIScalableNesting &) *sei, nalUnitType, nuh_layer_id, payloadSize, vps, sps, hrd,
+                                 nullptr, seiList);
+  int payloadBitsRemaining = getBitstream()->getNumBitsLeft();
+  if (payloadBitsRemaining) /* more_data_in_payload() */
+  {
+    for (; payloadBitsRemaining > 9; payloadBitsRemaining--)
+    {
+      uint32_t reservedPayloadExtensionData;
+      sei_read_code(nullptr, 1, reservedPayloadExtensionData, "reserved_payload_extension_data");
+    }
+
+    /* 2 */
+    int finalBits = getBitstream()->peekBits(payloadBitsRemaining);
+    int finalPayloadBits = 0;
+    for (int mask = 0xff; finalBits & (mask >> finalPayloadBits); finalPayloadBits++)
+    {
+      continue;
+    }
+
+    /* 3 */
+    for (; payloadBitsRemaining > 9 - finalPayloadBits; payloadBitsRemaining--)
+    {
+      uint32_t reservedPayloadExtensionData;
+      sei_read_flag ( 0, reservedPayloadExtensionData, "reserved_payload_extension_data");
+    }
+
+    uint32_t dummy;
+    sei_read_flag( 0, dummy, "payload_bit_equal_to_one"); payloadBitsRemaining--;
+    while (payloadBitsRemaining)
+    {
+      sei_read_flag( 0, dummy, "payload_bit_equal_to_zero"); payloadBitsRemaining--;
+    }
+  }
+  delete sei;
+}
+
+void SEIReader::getSEIDecodingUnitInfoDuiIdx(InputBitstream* bs, const NalUnitType nalUnitType, const uint32_t nuh_layer_id, HRD &hrd, uint32_t payloadSize, int& duiIdx)
+{
+  const SEIBufferingPeriod *bp = nullptr;
+  bp = hrd.getBufferingPeriodSEI();
+  if (!bp)
+  {
+    // msg( WARNING, "Warning: Found Decoding unit information SEI message, but no active buffering period is available. Ignoring.");
+  }
+  else
+  {
+    InputBitstream bs2(*bs);
+    setBitstream(&bs2);
+    SEI *sei = nullptr;
+    sei = new SEIDecodingUnitInfo;
+    xParseSEIDecodingUnitInfo((SEIDecodingUnitInfo &) *sei, payloadSize, *bp, nuh_layer_id, nullptr);
+    duiIdx = ((SEIDecodingUnitInfo&)*sei).m_decodingUnitIdx;
+    delete sei;
+    setBitstream(bs);
+  }
+}
+
+bool SEIReader::xReadSEImessage(SEIMessages& seis, const NalUnitType nalUnitType, const uint32_t nuh_layer_id, const uint32_t temporalId, const VPS *vps, const SPS *sps, HRD &hrd, std::ostream *pDecodedMessageOutputStream)
+{
+#if ENABLE_TRACING
+  xTraceSEIHeader();
+#endif
+  int payloadType = 0;
+  uint32_t val = 0;
+
+  do
+  {
+    sei_read_code(nullptr, 8, val, "payload_type");
+    payloadType += val;
+  } while (val==0xFF);
+
+  uint32_t payloadSize = 0;
+  do
+  {
+    sei_read_code(nullptr, 8, val, "payload_size");
+    payloadSize += val;
+  } while (val==0xFF);
+
+#if ENABLE_TRACING
+  xTraceSEIMessageType((SEI::PayloadType)payloadType);
+#endif
+
+  /* extract the payload for this single SEI message.
+   * This allows greater safety in erroneous parsing of an SEI message
+   * from affecting subsequent messages.
+   * After parsing the payload, bs needs to be restored as the primary
+   * bitstream.
+   */
+  InputBitstream *bs = getBitstream();
+  setBitstream(bs->extractSubstream(payloadSize * 8));
+
+  SEI                      *sei = nullptr;
+  const SEIBufferingPeriod *bp  = nullptr;
+
+  if(nalUnitType == NAL_UNIT_PREFIX_SEI)
+  {
+    switch (SEI::PayloadType(payloadType))
+    {
+    case SEI::PayloadType::FILLER_PAYLOAD:
+      sei = new SEIFillerPayload;
+      xParseSEIFillerPayload((SEIFillerPayload&) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::USER_DATA_UNREGISTERED:
+      sei = new SEIuserDataUnregistered;
+      xParseSEIuserDataUnregistered((SEIuserDataUnregistered&) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::DECODING_UNIT_INFO:
+      bp = hrd.getBufferingPeriodSEI();
+      if (!bp)
+      {
+        msg( WARNING, "Warning: Found Decoding unit information SEI message, but no active buffering period is available. Ignoring.");
+      }
+      else
+      {
+        sei = new SEIDecodingUnitInfo;
+        xParseSEIDecodingUnitInfo((SEIDecodingUnitInfo&) *sei, payloadSize, *bp, temporalId, pDecodedMessageOutputStream);
+      }
+      break;
+    case SEI::PayloadType::BUFFERING_PERIOD:
+      sei = new SEIBufferingPeriod;
+      xParseSEIBufferingPeriod((SEIBufferingPeriod&) *sei, payloadSize, pDecodedMessageOutputStream);
+      hrd.setBufferingPeriodSEI((SEIBufferingPeriod*) sei);
+      break;
+    case SEI::PayloadType::PICTURE_TIMING:
+      bp = hrd.getBufferingPeriodSEI();
+      if (!bp)
+      {
+        msg(WARNING,
+            "Warning: Found Picture timing SEI message, but no active buffering period is available. Ignoring.");
+      }
+      else
+      {
+        sei = new SEIPictureTiming;
+        xParseSEIPictureTiming((SEIPictureTiming &) *sei, payloadSize, temporalId, *bp, pDecodedMessageOutputStream);
+        hrd.setPictureTimingSEI((SEIPictureTiming *) sei);
+      }
+      break;
+    case SEI::PayloadType::SCALABLE_NESTING:
+      sei = new SEIScalableNesting;
+      xParseSEIScalableNesting((SEIScalableNesting &) *sei, nalUnitType, nuh_layer_id, payloadSize, vps, sps, hrd,
+                               pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::FRAME_FIELD_INFO:
+      sei = new SEIFrameFieldInfo;
+      xParseSEIFrameFieldinfo((SEIFrameFieldInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::DEPENDENT_RAP_INDICATION:
+      sei = new SEIDependentRAPIndication;
+      xParseSEIDependentRAPIndication((SEIDependentRAPIndication &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::EXTENDED_DRAP_INDICATION:
+      sei = new SEIExtendedDrapIndication;
+      xParseSEIExtendedDrapIndication((SEIExtendedDrapIndication &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::FRAME_PACKING:
+      sei = new SEIFramePacking;
+      xParseSEIFramePacking((SEIFramePacking &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::DISPLAY_ORIENTATION:
+      sei = new SEIDisplayOrientation;
+      xParseSEIDisplayOrientation((SEIDisplayOrientation &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::ANNOTATED_REGIONS:
+      sei = new SEIAnnotatedRegions;
+      xParseSEIAnnotatedRegions((SEIAnnotatedRegions &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::PARAMETER_SETS_INCLUSION_INDICATION:
+      sei = new SEIParameterSetsInclusionIndication;
+      xParseSEIParameterSetsInclusionIndication((SEIParameterSetsInclusionIndication &) *sei, payloadSize,
+                                                pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::MASTERING_DISPLAY_COLOUR_VOLUME:
+      sei = new SEIMasteringDisplayColourVolume;
+      xParseSEIMasteringDisplayColourVolume((SEIMasteringDisplayColourVolume &) *sei, payloadSize,
+                                            pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::ALTERNATIVE_TRANSFER_CHARACTERISTICS:
+      sei = new SEIAlternativeTransferCharacteristics;
+      xParseSEIAlternativeTransferCharacteristics((SEIAlternativeTransferCharacteristics &) *sei, payloadSize,
+                                                  pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::EQUIRECTANGULAR_PROJECTION:
+      sei = new SEIEquirectangularProjection;
+      xParseSEIEquirectangularProjection((SEIEquirectangularProjection &) *sei, payloadSize,
+                                         pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SPHERE_ROTATION:
+      sei = new SEISphereRotation;
+      xParseSEISphereRotation((SEISphereRotation &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::OMNI_VIEWPORT:
+      sei = new SEIOmniViewport;
+      xParseSEIOmniViewport((SEIOmniViewport &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::REGION_WISE_PACKING:
+      sei = new SEIRegionWisePacking;
+      xParseSEIRegionWisePacking((SEIRegionWisePacking &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::GENERALIZED_CUBEMAP_PROJECTION:
+      sei = new SEIGeneralizedCubemapProjection;
+      xParseSEIGeneralizedCubemapProjection((SEIGeneralizedCubemapProjection &) *sei, payloadSize,
+                                            pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SCALABILITY_DIMENSION_INFO:
+      sei = new SEIScalabilityDimensionInfo;
+      xParseSEIScalabilityDimensionInfo((SEIScalabilityDimensionInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::GREEN_METADATA:
+      sei = new SEIGreenMetadataInfo;
+      xParseSEIGreenMetadataInfo((SEIGreenMetadataInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::MULTIVIEW_ACQUISITION_INFO:
+      sei = new SEIMultiviewAcquisitionInfo;
+      xParseSEIMultiviewAcquisitionInfo((SEIMultiviewAcquisitionInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::MULTIVIEW_VIEW_POSITION:
+      sei = new SEIMultiviewViewPosition;
+      xParseSEIMultiviewViewPosition((SEIMultiviewViewPosition &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::ALPHA_CHANNEL_INFO:
+      sei = new SEIAlphaChannelInfo;
+      xParseSEIAlphaChannelInfo((SEIAlphaChannelInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::DEPTH_REPRESENTATION_INFO:
+      sei = new SEIDepthRepresentationInfo;
+      xParseSEIDepthRepresentationInfo((SEIDepthRepresentationInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SUBPICTURE_LEVEL_INFO:
+      sei = new SEISubpicureLevelInfo;
+      xParseSEISubpictureLevelInfo((SEISubpicureLevelInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SAMPLE_ASPECT_RATIO_INFO:
+      sei = new SEISampleAspectRatioInfo;
+      xParseSEISampleAspectRatioInfo((SEISampleAspectRatioInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::USER_DATA_REGISTERED_ITU_T_T35:
+      sei = new SEIUserDataRegistered;
+      xParseSEIUserDataRegistered((SEIUserDataRegistered &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::FILM_GRAIN_CHARACTERISTICS:
+      sei = new SEIFilmGrainCharacteristics;
+      xParseSEIFilmGrainCharacteristics((SEIFilmGrainCharacteristics &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::CONTENT_LIGHT_LEVEL_INFO:
+      sei = new SEIContentLightLevelInfo;
+      xParseSEIContentLightLevelInfo((SEIContentLightLevelInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::AMBIENT_VIEWING_ENVIRONMENT:
+      sei = new SEIAmbientViewingEnvironment;
+      xParseSEIAmbientViewingEnvironment((SEIAmbientViewingEnvironment &) *sei, payloadSize,
+                                         pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::CONTENT_COLOUR_VOLUME:
+      sei = new SEIContentColourVolume;
+      xParseSEIContentColourVolume((SEIContentColourVolume &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::COLOUR_TRANSFORM_INFO:
+      sei = new SEIColourTransformInfo;
+      xParseSEIColourTransformInfo((SEIColourTransformInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SEI_MANIFEST:
+      sei = new SEIManifest;
+      xParseSEISEIManifest((SEIManifest&) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SEI_PREFIX_INDICATION:
+      sei = new SEIPrefixIndication;
+      xParseSEISEIPrefixIndication((SEIPrefixIndication&) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::CONSTRAINED_RASL_ENCODING:
+      sei = new SEIConstrainedRaslIndication;
+      xParseSEIConstrainedRaslIndication((SEIConstrainedRaslIndication &) *sei, payloadSize,
+                                         pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SHUTTER_INTERVAL_INFO:
+      sei = new SEIShutterIntervalInfo;
+      xParseSEIShutterInterval((SEIShutterIntervalInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::NEURAL_NETWORK_POST_FILTER_CHARACTERISTICS:
+      sei = new SEINeuralNetworkPostFilterCharacteristics;
+      xParseSEINNPostFilterCharacteristics((SEINeuralNetworkPostFilterCharacteristics &) *sei, payloadSize, sps,
+                                           pDecodedMessageOutputStream);
+        
+        
+      nnpfcValues.push_back(((SEINeuralNetworkPostFilterCharacteristics*)sei)->m_id);
+      break;
+    case SEI::PayloadType::NEURAL_NETWORK_POST_FILTER_ACTIVATION:
+      sei = new SEINeuralNetworkPostFilterActivation;
+      xParseSEINNPostFilterActivation((SEINeuralNetworkPostFilterActivation &) *sei, payloadSize,
+                                      pDecodedMessageOutputStream);
+      nnpfcProcessed = false;
+      CHECK(nnpfcValues.size() == 0, "At leaset one NNPFC SEI message should precede NNPFA")
+      for(int i=0; i<nnpfcValues.size(); ++i)
+      {
+        if(((SEINeuralNetworkPostFilterCharacteristics*)sei)->m_id == nnpfcValues[i])
+        {
+          nnpfcProcessed = true;
+        }
+      }
+      CHECK(!nnpfcProcessed, "No NNPFC, no NNPFA")
+      nnpfcProcessed = false;
+      break;
+    case SEI::PayloadType::PHASE_INDICATION:
+      sei = new SEIPhaseIndication;
+      xParseSEIPhaseIndication((SEIPhaseIndication &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SEI_PROCESSING_ORDER:
+      sei = new SEIProcessingOrderInfo;
+      xParseSEIProcessingOrder((SEIProcessingOrderInfo &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::POST_FILTER_HINT:
+      sei = new SEIPostFilterHint;
+      xParseSEIPostFilterHint((SEIPostFilterHint &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    default:
+      for (uint32_t i = 0; i < payloadSize; i++)
+      {
+        uint32_t seiByte;
+        sei_read_code(nullptr, 8, seiByte, "unknown prefix SEI payload byte");
+      }
+      msg(WARNING, "Unknown prefix SEI message (payloadType = %d) was found!\n", payloadType);
+      if (pDecodedMessageOutputStream)
+      {
+        (*pDecodedMessageOutputStream) << "Unknown prefix SEI message (payloadType = " << payloadType
+                                       << ") was found!\n";
+      }
+      break;
+    }
+  }
+  else
+  {
+    switch (SEI::PayloadType(payloadType))
+    {
+    case SEI::PayloadType::USER_DATA_UNREGISTERED:
+      sei = new SEIuserDataUnregistered;
+      xParseSEIuserDataUnregistered((SEIuserDataUnregistered &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::DECODED_PICTURE_HASH:
+      sei = new SEIDecodedPictureHash;
+      xParseSEIDecodedPictureHash((SEIDecodedPictureHash &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::SCALABLE_NESTING:
+      sei = new SEIScalableNesting;
+      xParseSEIScalableNesting((SEIScalableNesting &) *sei, nalUnitType, nuh_layer_id, payloadSize, vps, sps, hrd,
+                               pDecodedMessageOutputStream);
+      break;
+    case SEI::PayloadType::FILLER_PAYLOAD:
+      sei = new SEIFillerPayload;
+      xParseSEIFillerPayload((SEIFillerPayload &) *sei, payloadSize, pDecodedMessageOutputStream);
+      break;
+    default:
+      for (uint32_t i = 0; i < payloadSize; i++)
+      {
+        uint32_t seiByte;
+        sei_read_code(nullptr, 8, seiByte, "unknown suffix SEI payload byte");
+      }
+      msg(WARNING, "Unknown suffix SEI message (payloadType = %d) was found!\n", payloadType);
+      if (pDecodedMessageOutputStream)
+      {
+        (*pDecodedMessageOutputStream) << "Unknown suffix SEI message (payloadType = " << payloadType
+                                       << ") was found!\n";
+      }
+      break;
+    }
+  }
+
+  if (sei != nullptr)
+  {
+    seis.push_back(sei);
+  }
+
+  /* By definition the underlying bitstream terminates in a byte-aligned manner.
+   * 1. Extract all bar the last MIN(bitsremaining,nine) bits as reserved_payload_extension_data
+   * 2. Examine the final 8 bits to determine the payload_bit_equal_to_one marker
+   * 3. Extract the remainingreserved_payload_extension_data bits.
+   *
+   * If there are fewer than 9 bits available, extract them.
+   */
+  int payloadBitsRemaining = getBitstream()->getNumBitsLeft();
+  if (payloadBitsRemaining) /* more_data_in_payload() */
+  {
+    for (; payloadBitsRemaining > 9; payloadBitsRemaining--)
+    {
+      uint32_t reservedPayloadExtensionData;
+      sei_read_code ( pDecodedMessageOutputStream, 1, reservedPayloadExtensionData, "reserved_payload_extension_data");
+    }
+
+    /* 2 */
+    int finalBits = getBitstream()->peekBits(payloadBitsRemaining);
+    int finalPayloadBits = 0;
+    for (int mask = 0xff; finalBits & (mask >> finalPayloadBits); finalPayloadBits++)
+    {
+      continue;
+    }
+
+    /* 3 */
+    for (; payloadBitsRemaining > 9 - finalPayloadBits; payloadBitsRemaining--)
+    {
+      uint32_t reservedPayloadExtensionData;
+      sei_read_flag ( 0, reservedPayloadExtensionData, "reserved_payload_extension_data");
+    }
+
+    uint32_t dummy;
+    sei_read_flag( 0, dummy, "payload_bit_equal_to_one"); payloadBitsRemaining--;
+    while (payloadBitsRemaining)
+    {
+      sei_read_flag( 0, dummy, "payload_bit_equal_to_zero"); payloadBitsRemaining--;
+    }
+  }
+
+  /* restore primary bitstream for sei_message */
+  delete getBitstream();
+  setBitstream(bs);
+
+  return sei != nullptr;
+}
+
+void SEIReader::xParseSEIFillerPayload(SEIFillerPayload &sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  for (uint32_t i = 0; i < payloadSize; i++)
+  {
+    uint32_t val;
+    sei_read_code( nullptr, 8, val, "ff_byte");
+    CHECK(val != 0xff, "ff_byte shall be a byte having the value 0xFF");
+  }
+}
+
+/**
+ * parse bitstream bs and unpack a user_data_unregistered SEI message
+ * of payloasSize bytes into sei.
+ */
+
+void SEIReader::xParseSEIuserDataUnregistered(SEIuserDataUnregistered &sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  CHECK(payloadSize < ISO_IEC_11578_LEN, "Payload too small");
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  for (uint32_t i = 0; i < ISO_IEC_11578_LEN; i++)
+  {
+    sei_read_code( pDecodedMessageOutputStream, 8, val, "uuid_iso_iec_11578");
+    sei.uuid_iso_iec_11578[i] = val;
+  }
+
+  sei.userDataLength = payloadSize - ISO_IEC_11578_LEN;
+  if (!sei.userDataLength)
+  {
+    sei.userData = 0;
+    return;
+  }
+
+  sei.userData = new uint8_t[sei.userDataLength];
+  for (uint32_t i = 0; i < sei.userDataLength; i++)
+  {
+    sei_read_code(nullptr, 8, val, "user_data_payload_byte");
+    sei.userData[i] = val;
+  }
+  if (pDecodedMessageOutputStream)
+  {
+    (*pDecodedMessageOutputStream) << "  User data payload size: " << sei.userDataLength << "\n";
+  }
+}
+
+void SEIReader::xParseSEIShutterInterval(SEIShutterIntervalInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  int32_t i;
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  sei_read_code(pDecodedMessageOutputStream, 32, val, "sii_time_scale");                      sei.m_siiTimeScale = val;
+  sei_read_flag(pDecodedMessageOutputStream, val, "fixed_shutter_interval_within_clvs_flag"); sei.m_siiFixedSIwithinCLVS = val;
+  if (sei.m_siiFixedSIwithinCLVS)
+  {
+    sei_read_code(pDecodedMessageOutputStream, 32, val, "sii_num_units_in_shutter_interval");   sei.m_siiNumUnitsInShutterInterval = val;
+  }
+  else
+  {
+    sei_read_code(pDecodedMessageOutputStream, 3, val, "sii_max_sub_layers_minus1 ");          sei.m_siiMaxSubLayersMinus1 = val;
+    sei.m_siiSubLayerNumUnitsInSI.resize(sei.m_siiMaxSubLayersMinus1 + 1);
+    for (i = 0; i <= sei.m_siiMaxSubLayersMinus1; i++)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 32, val, "sub_layer_num_units_in_shutter_interval[ i ]");
+      sei.m_siiSubLayerNumUnitsInSI[i] = val;
+    }
+  }
+}
+
+void SEIReader::xParseSEIProcessingOrder(SEIProcessingOrderInfo& sei, uint32_t payloadSize, std::ostream *decodedMessageOutputStream)
+{
+  uint32_t i,b;
+#if JVET_AC0058_SEI
+  uint32_t numMaxSeiMessages, val;
+#else
+  uint32_t NumSEIMessages, val;
+#endif
+  output_sei_message_header(sei, decodedMessageOutputStream, payloadSize);
+
+#if JVET_AC0058_SEI
+  //Since each entry is at least 4 bytes (2 byte "sei_payloadType" + 2 byte "sei_payloadOrder"),
+  //the maximum number of entry is payloadSize/4
+  numMaxSeiMessages = payloadSize / 4;
+  sei.m_posPayloadType.resize(numMaxSeiMessages);
+  sei.m_posProcessingOrder.resize(numMaxSeiMessages);
+  sei.m_posPrefixByte.resize(numMaxSeiMessages);
+  for (i = 0, b = 0; b < payloadSize; i++, b += 4)
+  {
+    sei_read_code(decodedMessageOutputStream, 16, val, "po_sei_payload_type[i]");
+    sei.m_posPayloadType[i] = val;
+    if (sei.m_posPayloadType[i] == (uint16_t)SEI::PayloadType::USER_DATA_REGISTERED_ITU_T_T35)
+    {
+      sei_read_code(decodedMessageOutputStream, 8, val, "po_num_t35_byte[i]");
+      sei.m_posPrefixByte[i].resize(val);
+      b ++;
+      for (uint32_t j = 0; j < sei.m_posPrefixByte[i].size(); j++)
+      {
+        sei_read_code(decodedMessageOutputStream, 8, val, "po_t35_byte[i][j]");
+        sei.m_posPrefixByte[i][j] = val;
+      }
+      b += (uint32_t)sei.m_posPrefixByte[i].size();
+    }
+    sei_read_code(decodedMessageOutputStream, 16, val, "po_sei_processing_order[i]");
+    sei.m_posProcessingOrder[i] = val;
+  }
+  // resize vectors to match the number of valid entries
+  sei.m_posPayloadType.resize(i);
+  sei.m_posProcessingOrder.resize(i);
+  sei.m_posPrefixByte.resize(i);
+#else
+  // Here payload is in Bytes, Since "sei_payloadType" is 2 Bytes + "sei_payloadOrder" is 1 Byte so total = 3 Bytes
+  // To get Number of SEI messages, just do payloadSize/3
+  NumSEIMessages = payloadSize / 3;
+  sei.m_posPayloadType.resize(NumSEIMessages);
+  sei.m_posProcessingOrder.resize(NumSEIMessages);
+  for(i=0,b=0; b < payloadSize; i++,b+=3)
+  {
+    sei_read_code(decodedMessageOutputStream, 16, val, "sei_payloadType[i]");
+    sei.m_posPayloadType[i] = val;
+    sei_read_code(decodedMessageOutputStream, 16, val, "sei_processingOrder[i]");
+    sei.m_posProcessingOrder[i] = val;
+  }
+#endif
+  CHECK(i<2, "An SEI processing order SEI message shall contain at least two pairs sei_payloadType[i] and sei_processingOrder[i]");
+}
+
+/**
+ * parse bitstream bs and unpack a decoded picture hash SEI message
+ * of payloadSize bytes into sei.
+ */
+void SEIReader::xParseSEIDecodedPictureHash(SEIDecodedPictureHash& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t bytesRead = 0;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  uint32_t val;
+  sei_read_code( pDecodedMessageOutputStream, 8, val, "dph_sei_hash_type");
+  sei.method = static_cast<HashType>(val); bytesRead++;
+  sei_read_code( pDecodedMessageOutputStream, 1, val, "dph_sei_single_component_flag");
+  sei.singleCompFlag = val;
+  sei_read_code( pDecodedMessageOutputStream, 7, val, "dph_sei_reserved_zero_7bits");
+  bytesRead++;
+  uint32_t expectedSize =
+    (sei.singleCompFlag ? 1 : 3) * (sei.method == HashType::MD5 ? 16 : (sei.method == HashType::CRC ? 2 : 4));
+  CHECK ((payloadSize - bytesRead) != expectedSize, "The size of the decoded picture hash does not match the expected size.");
+
+  const char *traceString="\0";
+  switch (sei.method)
+  {
+  case HashType::MD5:
+    traceString = "picture_md5";
+    break;
+  case HashType::CRC:
+    traceString = "picture_crc";
+    break;
+  case HashType::CHECKSUM:
+    traceString = "picture_checksum";
+    break;
+  default:
+    THROW("Unknown hash type");
+    break;
+  }
+
+  if (pDecodedMessageOutputStream)
+  {
+    (*pDecodedMessageOutputStream) << "  " << std::setw(55) << traceString << ": " << std::hex << std::setfill('0');
+  }
+
+  sei.m_pictureHash.hash.clear();
+  for(;bytesRead < payloadSize; bytesRead++)
+  {
+    sei_read_code(nullptr, 8, val, traceString);
+    sei.m_pictureHash.hash.push_back((uint8_t)val);
+    if (pDecodedMessageOutputStream)
+    {
+      (*pDecodedMessageOutputStream) << std::setw(2) << val;
+    }
+  }
+
+  if (pDecodedMessageOutputStream)
+  {
+    (*pDecodedMessageOutputStream) << std::dec << std::setfill(' ') << "\n";
+  }
+}
+
+void SEIReader::xParseSEIScalableNesting(SEIScalableNesting& sei, const NalUnitType nalUnitType, const uint32_t nuhLayerId, uint32_t payloadSize, const VPS* vps, const SPS* sps, HRD &hrd, std::ostream* decodedMessageOutputStream)
+{
+  uint32_t symbol;
+  SEIMessages seis;
+  output_sei_message_header(sei, decodedMessageOutputStream, payloadSize);
+
+  sei_read_flag(decodedMessageOutputStream, symbol, "sn_ols_flag"); sei.m_snOlsFlag = symbol;
+  sei_read_flag(decodedMessageOutputStream, symbol, "sn_subpic_flag"); sei.m_snSubpicFlag = symbol;
+  if (sei.m_snOlsFlag)
+  {
+    sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_olss_minus1"); sei.m_snNumOlssMinus1 = symbol;
+    for (uint32_t i = 0; i <= sei.m_snNumOlssMinus1; i++)
+    {
+      sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_ols_idx_delta_minus1[i]"); sei.m_snOlsIdxDeltaMinus1[i] = symbol;
+    }
+    for (uint32_t i = 0; i <= sei.m_snNumOlssMinus1; i++)
+    {
+      if (i == 0)
+      {
+        sei.m_snOlsIdx[i] = sei.m_snOlsIdxDeltaMinus1[i];
+      }
+      else
+      {
+        sei.m_snOlsIdx[i] = sei.m_snOlsIdxDeltaMinus1[i] + sei.m_snOlsIdxDeltaMinus1[i - 1] + 1;
+      }
+    }
+    if (vps && vps->getVPSId() != 0)
+    {
+      uint32_t lowestLayerId = MAX_UINT;
+      for (uint32_t olsIdxForSEI = 0; olsIdxForSEI <= sei.m_snNumOlssMinus1; olsIdxForSEI++)
+      {
+        int olsIdx = sei.m_snOlsIdx[olsIdxForSEI];
+        for (int layerIdx = 0; layerIdx < vps->getNumLayersInOls(olsIdx); layerIdx++)
+        {
+          if (lowestLayerId > vps->getLayerIdInOls(olsIdx, layerIdx))
+          {
+            lowestLayerId = vps->getLayerIdInOls(olsIdx, layerIdx);
+          }
+        }
+      }
+      CHECK(lowestLayerId!= nuhLayerId, "nuh_layer_id is not equal to the lowest layer among Olss that the scalable SEI applies");
+    }
+  }
+  else
+  {
+    sei_read_flag(decodedMessageOutputStream, symbol, "sn_all_layers_flag"); sei.m_snAllLayersFlag = symbol;
+    if (!sei.m_snAllLayersFlag)
+    {
+      sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_layers_minus1"); sei.m_snNumLayersMinus1 = symbol;
+      sei.m_snLayerId[0] = nuhLayerId;
+      for (uint32_t i = 1; i <= sei.m_snNumLayersMinus1; i++)
+      {
+        sei_read_code(decodedMessageOutputStream, 6, symbol, "sn_layer_id[i]"); sei.m_snLayerId[i] = symbol;
+      }
+    }
+  }
+  if (sei.m_snSubpicFlag)
+  {
+    sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_subpics_minus1"); sei.m_snNumSubpics = symbol + 1;
+    sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_subpic_id_len_minus1"); sei.m_snSubpicIdLen = symbol + 1;
+    sei.m_snSubpicId.resize(sei.m_snNumSubpics);
+    for (uint32_t i = 0; i < sei.m_snNumSubpics; i++)
+    {
+      sei_read_code(decodedMessageOutputStream, sei.m_snSubpicIdLen, symbol, "sn_subpic_id[i]"); sei.m_snSubpicId[i] = symbol;
+    }
+  }
+
+  sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_seis_minus1"); sei.m_snNumSEIs = symbol + 1;
+  CHECK (sei.m_snNumSEIs > 64, "The value of sn_num_seis_minus1 shall be in the range of 0 to 63");
+
+  // byte alignment
+  while (m_pcBitstream->getNumBitsRead() % 8 != 0)
+  {
+    sei_read_flag(decodedMessageOutputStream, symbol, "sn_zero_bit");
+  }
+
+  // read nested SEI messages
+  for (int32_t i=0; i<sei.m_snNumSEIs; i++)
+  {
+    SEIMessages tmpSEIs;
+    const bool seiMessageRead = xReadSEImessage(tmpSEIs, nalUnitType, nuhLayerId, 0, vps, sps, m_nestedHrd, decodedMessageOutputStream);
+    if (seiMessageRead)
+    {
+      if (tmpSEIs.front()->payloadType() == SEI::PayloadType::BUFFERING_PERIOD)
+      {
+        SEIBufferingPeriod *bp = (SEIBufferingPeriod*)tmpSEIs.front();
+        m_nestedHrd.setBufferingPeriodSEI(bp);
+        const SEIBufferingPeriod *nonNestedBp = hrd.getBufferingPeriodSEI();
+        if (nonNestedBp)
+        {
+          checkBPSyntaxElementLength(nonNestedBp, bp);
+        }
+      }
+      sei.m_nestedSEIs.push_back(tmpSEIs.front());
+      tmpSEIs.clear();
+    }
+  }
+
+  const GeneralHrdParams *generalHrd = vps && vps->getVPSGeneralHrdParamsPresentFlag()
+    ? vps->getGeneralHrdParameters()
+    : sps->getGeneralHrdParametersPresentFlag()
+      ? sps->getGeneralHrdParameters()
+      : nullptr;
+  
+  xCheckScalableNestingConstraints(sei, nalUnitType, generalHrd);
+
+  if (decodedMessageOutputStream)
+  {
+    (*decodedMessageOutputStream) << "End of scalable nesting SEI message\n";
+  }
+}
+
+
+void SEIReader::xParseSEIGreenMetadataInfo(SEIGreenMetadataInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t code;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  sei_read_code(pDecodedMessageOutputStream, 8, code, "green_metadata_type");
+  sei.m_greenMetadataType = code;
+  printf("GREEN MPEG Output: \n");
+  printf("Metadata Type: %i\n", sei.m_greenMetadataType);
+
+  switch (sei.m_greenMetadataType)
+  {
+  case 0:
+    sei_read_code(pDecodedMessageOutputStream, 4, code, "period_type");
+    sei.m_periodType = code;
+    sei_read_code(pDecodedMessageOutputStream, 3, code, "granularity_type");
+    sei.m_greenMetadataGranularityType = code;
+    sei_read_code(pDecodedMessageOutputStream, 1, code, "extended_representation_flag");
+    sei.m_greenMetadataExtendedRepresentation = code;
+
+    printf ("Period Type: %i\n",sei.m_periodType);
+    printf ("Granularity Type: %i\n",sei.m_greenMetadataGranularityType);
+    printf ("Extended Representation Flag Type: %i\n",sei.m_greenMetadataExtendedRepresentation);
+
+    if (sei.m_periodType == 2)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 16, code, "num_seconds");
+      sei.m_numSeconds = code;
+      printf ("Number of Seconds: %i\n",sei.m_numSeconds);
+    }
+    else if (sei.m_periodType == 3)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 16, code, "num_pictures");
+      sei.m_numPictures = code;
+      printf ("Number of Pictures: %i\n",sei.m_numPictures);
+    }
+
+    if (sei.m_greenMetadataGranularityType == 0)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_non_zero_blocks_area");
+      sei.m_greenComplexityMetrics.portionNonZeroBlocksArea = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_non_zero_transform_coefficients_area");
+      sei.m_greenComplexityMetrics.portionNonZeroTransformCoefficientsArea = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_intra_predicted_blocks_area");
+      sei.m_greenComplexityMetrics.portionIntraPredictedBlocksArea = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_deblocking_instances");
+      sei.m_greenComplexityMetrics.portionDeblockingInstances = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_alf_instances");
+      sei.m_greenComplexityMetrics.portionAlfInstances = code;
+
+      printf ("Portion Non Zero Blocks Area: %i\n",sei.m_greenComplexityMetrics.portionNonZeroBlocksArea);
+      printf ("Portion Non Zero Transform Coefficients Area: %i\n",sei.m_greenComplexityMetrics.portionNonZeroTransformCoefficientsArea);
+      printf ("Portion Intra Predicted Blocks Area: %i\n",sei.m_greenComplexityMetrics.portionIntraPredictedBlocksArea);
+      printf ("Portion Deblocking Instances: %i\n",sei.m_greenComplexityMetrics.portionDeblockingInstances);
+      printf ("Portion ALF Instances: %i\n",sei.m_greenComplexityMetrics.portionAlfInstances);
+
+      if(sei.m_greenMetadataExtendedRepresentation == 1)
+      {
+        if(sei.m_greenComplexityMetrics.portionNonZeroBlocksArea != 0)
+        {
+          sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_non_zero_4_8_16_blocks_area");
+          sei.m_greenComplexityMetrics.portionNonZero_4_8_16BlocksArea = code;
+          sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_non_zero_32_64_128_blocks_area");
+          sei.m_greenComplexityMetrics.portionNonZero_32_64_128BlocksArea = code;
+          sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_non_zero_256_512_1024_blocks_area");
+          sei.m_greenComplexityMetrics.portionNonZero_256_512_1024BlocksArea = code;
+          sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_non_zero_2048_4096_blocks_area");
+          sei.m_greenComplexityMetrics.portionNonZero_2048_4096BlocksArea = code;
+          printf ("Portion Non Zero 4/8/16 Blocks Area: %i\n",sei.m_greenComplexityMetrics.portionNonZero_4_8_16BlocksArea);
+          printf ("Portion Non Zero 32/64/128 Blocks Area: %i\n",sei.m_greenComplexityMetrics.portionNonZero_32_64_128BlocksArea);
+          printf ("Portion Non Zero 256/512/1024 Blocks Area: %i\n",sei.m_greenComplexityMetrics.portionNonZero_256_512_1024BlocksArea);
+          printf ("Portion Non Zero 2048/4096 Blocks Area: %i\n",sei.m_greenComplexityMetrics.portionNonZero_2048_4096BlocksArea);
+        }
+
+        if(sei.m_greenComplexityMetrics.portionIntraPredictedBlocksArea < 255)
+        {
+          sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_bi_and_gpm_predicted_blocks_area");
+          sei.m_greenComplexityMetrics.portionBiAndGpmPredictedBlocksArea = code;
+          sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_bdof_blocks_area");
+          sei.m_greenComplexityMetrics.portionBdofBlocksArea = code;
+          printf ("Portion BI and GPM Predicted Blocks Area: %i\n",sei.m_greenComplexityMetrics.portionBiAndGpmPredictedBlocksArea);
+          printf ("Portion BDOF Blocks Area: %i\n",sei.m_greenComplexityMetrics.portionBdofBlocksArea);
+        }
+
+        sei_read_code(pDecodedMessageOutputStream, 8, code, "portion_sao_instances");
+        sei.m_greenComplexityMetrics.portionSaoInstances = code;
+        printf ("Portion SAO Instances: %i\n",sei.m_greenComplexityMetrics.portionSaoInstances);
+      }
+    }
+    break;
+  case 1:
+    sei_read_code(pDecodedMessageOutputStream, 16, code, "xsd_subpic_number_minus1");
+    sei.m_xsdSubpicNumberMinus1 = code;
+    printf("XSD Subpic Number of Metrics: %i\n", sei.m_xsdSubpicNumberMinus1 + 1);
+
+    int xsdSubpicIdc;
+    int xsdMetricNumberMinus1;
+
+    for (int i = 0; i <= sei.m_xsdSubpicNumberMinus1; i++)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 16, code, "xsd_subpic_idc[i]");
+      xsdSubpicIdc = code;
+      printf("XSD Subpic Idc[i]: %i\n", xsdSubpicIdc);
+
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "xsd_metric_number_minus1[i]");
+      xsdMetricNumberMinus1 = code;
+      printf("XSD Metric Number Minus1[i]: %i\n", xsdMetricNumberMinus1);
+
+      int xsdMetricType;
+      int xsdMetricValue;
+      for (int j = 0; j <= xsdMetricNumberMinus1; j++)
+      {
+        sei_read_code(pDecodedMessageOutputStream, 8, code, "xsd_metric_type[i][j]");
+        xsdMetricType = code;
+
+        sei_read_code(pDecodedMessageOutputStream, 16, code, "xsd_metric_value[i][j]");
+        xsdMetricValue = code;
+
+        switch (xsdMetricType)
+        {
+        case 0: //PSNR
+          sei.m_xsdMetricValuePSNR = code;
+          printf("PSNR value: %0.2f\n", (double(xsdMetricValue)/100.0));
+          break;
+        case 1: //SSIM
+          sei.m_xsdMetricValueSSIM = code;
+          printf("SSIM value: %0.2f\n", double(xsdMetricValue/100.0));
+          break;
+        case 2:  //W-PSNR
+          sei.m_xsdMetricValueWPSNR = code;
+          printf("W-PSNR value: %0.2f\n", double(xsdMetricValue/100.0));
+          break;
+        case 3: //WS-PSNR
+          sei.m_xsdMetricValueWSPSNR = code;
+          printf("WS-PSNR value: %0.2f\n", double(xsdMetricValue/100.0));
+          break;
+        default: //User Defined
+          break;
+        }
+      }
+    }
+    break;
+  }
+}
+
+void SEIReader::xParseSEIScalableNestingBinary(SEIScalableNesting &sei, const NalUnitType nalUnitType,
+                                               const uint32_t nuhLayerId, uint32_t payloadSize, const VPS *vps,
+                                               const SPS *sps, HRD &hrd, std::ostream *decodedMessageOutputStream,
+                                               std::vector<SeiPayload> *seiList)
+{
+  uint32_t symbol;
+  SEIMessages seis;
+  output_sei_message_header(sei, decodedMessageOutputStream, payloadSize);
+
+  sei_read_flag(decodedMessageOutputStream, symbol, "sn_ols_flag"); sei.m_snOlsFlag = symbol;
+  sei_read_flag(decodedMessageOutputStream, symbol, "sn_subpic_flag"); sei.m_snSubpicFlag = symbol;
+  if (sei.m_snOlsFlag)
+  {
+    sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_olss_minus1"); sei.m_snNumOlssMinus1 = symbol;
+    for (uint32_t i = 0; i <= sei.m_snNumOlssMinus1; i++)
+    {
+      sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_ols_idx_delta_minus1[i]"); sei.m_snOlsIdxDeltaMinus1[i] = symbol;
+    }
+    for (uint32_t i = 0; i <= sei.m_snNumOlssMinus1; i++)
+    {
+      if (i == 0)
+      {
+        sei.m_snOlsIdx[i] = sei.m_snOlsIdxDeltaMinus1[i];
+      }
+      else
+      {
+        sei.m_snOlsIdx[i] = sei.m_snOlsIdxDeltaMinus1[i] + sei.m_snOlsIdxDeltaMinus1[i - 1] + 1;
+      }
+    }
+    if (vps && vps->getVPSId() != 0)
+    {
+      uint32_t lowestLayerId = MAX_UINT;
+      for (uint32_t olsIdxForSEI = 0; olsIdxForSEI <= sei.m_snNumOlssMinus1; olsIdxForSEI++)
+      {
+        int olsIdx = sei.m_snOlsIdx[olsIdxForSEI];
+        for (int layerIdx = 0; layerIdx < vps->getNumLayersInOls(olsIdx); layerIdx++)
+        {
+          if (lowestLayerId > vps->getLayerIdInOls(olsIdx, layerIdx))
+          {
+            lowestLayerId = vps->getLayerIdInOls(olsIdx, layerIdx);
+          }
+        }
+      }
+      CHECK(lowestLayerId!= nuhLayerId, "nuh_layer_id is not equal to the lowest layer among Olss that the scalable SEI applies");
+    }
+  }
+  else
+  {
+    sei_read_flag(decodedMessageOutputStream, symbol, "sn_all_layers_flag"); sei.m_snAllLayersFlag = symbol;
+    if (!sei.m_snAllLayersFlag)
+    {
+      sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_layers_minus1"); sei.m_snNumLayersMinus1 = symbol;
+      sei.m_snLayerId[0] = nuhLayerId;
+      for (uint32_t i = 1; i <= sei.m_snNumLayersMinus1; i++)
+      {
+        sei_read_code(decodedMessageOutputStream, 6, symbol, "sn_layer_id[i]"); sei.m_snLayerId[i] = symbol;
+      }
+    }
+  }
+  if (sei.m_snSubpicFlag)
+  {
+    sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_subpics_minus1"); sei.m_snNumSubpics = symbol + 1;
+    sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_subpic_id_len_minus1"); sei.m_snSubpicIdLen = symbol + 1;
+    sei.m_snSubpicId.resize(sei.m_snNumSubpics);
+    for (uint32_t i = 0; i < sei.m_snNumSubpics; i++)
+    {
+      sei_read_code(decodedMessageOutputStream, sei.m_snSubpicIdLen, symbol, "sn_subpic_id[i]"); sei.m_snSubpicId[i] = symbol;
+    }
+  }
+
+  sei_read_uvlc(decodedMessageOutputStream, symbol, "sn_num_seis_minus1"); sei.m_snNumSEIs = symbol + 1;
+  CHECK (sei.m_snNumSEIs > 64, "The value of sn_num_seis_minus1 shall be in the range of 0 to 63");
+
+  // byte alignment
+  while (m_pcBitstream->getNumBitsRead() % 8 != 0)
+  {
+    sei_read_flag(decodedMessageOutputStream, symbol, "sn_zero_bit");
+  }
+
+  // above codes are exactly same as those in xParseSEIScalableNesting()
+  // read and save nested SEI messages in binary form
+  for (int32_t i=0; i<sei.m_snNumSEIs; i++)
+  {
+    int      payloadTypeVal = 0;
+    uint32_t val = 0;
+    do
+    {
+      sei_read_code(nullptr, 8, val, "payload_type");
+      payloadTypeVal += val;
+    } while (val==0xFF);
+
+    auto payloadType = SEI::PayloadType(payloadTypeVal);
+
+    uint32_t payloadSize = 0;
+    do
+    {
+      sei_read_code(nullptr, 8, val, "payload_size");
+      payloadSize += val;
+    } while (val==0xFF);
+
+    uint8_t *payload = new uint8_t[payloadSize];
+    int duiIdx = 0;
+    if (SEI::PayloadType(payloadType) == SEI::PayloadType::DECODING_UNIT_INFO)
+    {
+      const SEIBufferingPeriod *bp = nullptr;
+      bp = hrd.getBufferingPeriodSEI();
+      if (!bp)
+      {
+        //msg( WARNING, "Warning: Found Decoding unit information SEI message, but no active buffering period is available. Ignoring.");
+      }
+      else
+      {
+        InputBitstream *bs = getBitstream();
+        InputBitstream bs2(*bs);
+        setBitstream(&bs2);
+        SEI *sei = nullptr;
+        sei = new SEIDecodingUnitInfo;
+        xParseSEIDecodingUnitInfo((SEIDecodingUnitInfo &) *sei, payloadSize, *bp, nuhLayerId, nullptr);
+        duiIdx = ((SEIDecodingUnitInfo&)*sei).m_decodingUnitIdx;
+        delete sei;
+        setBitstream(bs);
+      }
+    }
+    uint32_t numSubPics = sei.m_snSubpicFlag ? sei.m_snNumSubpics : 1;
+    for (uint32_t j = 0; j < payloadSize; j++)
+    {
+      sei_read_code(nullptr, 8, val, "payload_content");
+      payload[j] = (uint8_t)val;
+    }
+    if (sei.m_snOlsFlag)
+    {
+      for (uint32_t j = 0; j <= sei.m_snNumOlssMinus1; j++)
+      {
+        for (uint32_t k = 0; k < numSubPics; k++)
+        {
+          if (j == 0 && k == 0)
+          {
+            seiList->push_back(SeiPayload{ payloadType, sei.m_snOlsIdx[j], false, payloadSize, payload, duiIdx,
+                                           sei.m_snSubpicFlag ? sei.m_snSubpicId[k] : 0 });
+          }
+          else
+          {
+            uint8_t *payloadTemp = new uint8_t[payloadSize];
+            memcpy(payloadTemp, payload, payloadSize *sizeof(uint8_t));
+            seiList->push_back(SeiPayload{ payloadType, sei.m_snOlsIdx[j], false, payloadSize, payloadTemp, duiIdx,
+                                           sei.m_snSubpicFlag ? sei.m_snSubpicId[k] : 0 });
+          }
+        }
+      }
+    }
+    else if (sei.m_snAllLayersFlag)
+    {
+      for (uint32_t k = 0; k < numSubPics; k++)
+      {
+        if (k == 0)
+        {
+          seiList->push_back(SeiPayload{ payloadType, nuhLayerId, true, payloadSize, payload, duiIdx,
+                                         sei.m_snSubpicFlag ? sei.m_snSubpicId[k] : 0 });
+        }
+        else
+        {
+          uint8_t *payloadTemp = new uint8_t[payloadSize];
+          memcpy(payloadTemp, payload, payloadSize *sizeof(uint8_t));
+          seiList->push_back(
+            SeiPayload{ payloadType, nuhLayerId, true, payloadSize, payloadTemp, duiIdx, sei.m_snSubpicId[k] });
+        }
+      }
+    }
+    else // !sei.m_snOlsFlag && !sei.m_snAllLayersFlag
+    {
+      for (uint32_t j = 0; j <= sei.m_snNumLayersMinus1; j++)
+      {
+        for (uint32_t k = 0; k < numSubPics; k++)
+        {
+          if (j == 0 && k == 0)
+          {
+            seiList->push_back(SeiPayload{ payloadType, sei.m_snLayerId[j], false, payloadSize, payload, duiIdx,
+                                           sei.m_snSubpicFlag ? sei.m_snSubpicId[k] : 0 });
+          }
+          else
+          {
+            uint8_t *payloadTemp = new uint8_t[payloadSize];
+            memcpy(payloadTemp, payload, payloadSize *sizeof(uint8_t));
+            seiList->push_back(SeiPayload{ payloadType, sei.m_snLayerId[j], false, payloadSize, payloadTemp, duiIdx,
+                                           sei.m_snSubpicFlag ? sei.m_snSubpicId[k] : 0 });
+          }
+        }
+      }
+    }
+  }
+}
+
+void SEIReader::xCheckScalableNestingConstraints(const SEIScalableNesting& sei, const NalUnitType nalUnitType, const GeneralHrdParams* generalHrd)
+{
+  const std::vector<SEI::PayloadType> vclAssociatedSeiList{
+    SEI::PayloadType::FILLER_PAYLOAD,
+    SEI::PayloadType::FILM_GRAIN_CHARACTERISTICS,
+    SEI::PayloadType::FRAME_PACKING,
+    SEI::PayloadType::PARAMETER_SETS_INCLUSION_INDICATION,
+    SEI::PayloadType::MASTERING_DISPLAY_COLOUR_VOLUME,
+    SEI::PayloadType::CONTENT_LIGHT_LEVEL_INFO,
+    SEI::PayloadType::DEPENDENT_RAP_INDICATION,
+    SEI::PayloadType::ALTERNATIVE_TRANSFER_CHARACTERISTICS,
+    SEI::PayloadType::AMBIENT_VIEWING_ENVIRONMENT,
+    SEI::PayloadType::CONTENT_COLOUR_VOLUME,
+    SEI::PayloadType::EQUIRECTANGULAR_PROJECTION,
+    SEI::PayloadType::GENERALIZED_CUBEMAP_PROJECTION,
+    SEI::PayloadType::SPHERE_ROTATION,
+    SEI::PayloadType::REGION_WISE_PACKING,
+    SEI::PayloadType::OMNI_VIEWPORT,
+    SEI::PayloadType::FRAME_FIELD_INFO,
+    SEI::PayloadType::SAMPLE_ASPECT_RATIO_INFO,
+  };
+
+  bool containBPorPTorDUIorSLI = false;
+  bool containNoBPorPTorDUIorSLI = false;
+
+  for (auto nestedsei : sei.m_nestedSEIs)
+  {
+    CHECK(nestedsei->payloadType() == SEI::PayloadType::FILLER_PAYLOAD
+            || nestedsei->payloadType() == SEI::PayloadType::SCALABLE_NESTING,
+          "An SEI message that has payloadType equal to filler payload or scalable nesting shall not be contained in a "
+          "scalable nesting SEI message");
+
+    CHECK(nestedsei->payloadType() == SEI::PayloadType::SCALABILITY_DIMENSION_INFO,
+          "A scalability dimension information SEI message shall not be contained in a scalable nesting SEI message");
+    CHECK(nestedsei->payloadType() == SEI::PayloadType::MULTIVIEW_ACQUISITION_INFO,
+          "A multiview acquisition information SEI message shall not be contained in a scalable nesting SEI message");
+
+    CHECK(nestedsei->payloadType() != SEI::PayloadType::FILLER_PAYLOAD
+            && nestedsei->payloadType() != SEI::PayloadType::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_PREFIX_SEI,
+          "When a scalable nesting SEI message contains an SEI message that has payloadType not equal to filler "
+          "payload or decoded picture hash, the SEI NAL unit containing the scalable nesting SEI message shall have "
+          "nal_unit_type equal to PREFIX_SEI_NUT");
+
+    CHECK(
+      nestedsei->payloadType() == SEI::PayloadType::DECODED_PICTURE_HASH && nalUnitType != NAL_UNIT_SUFFIX_SEI,
+      "When a scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture hash, "
+      "the SEI NAL unit containing the scalable nesting SEI message shall have nal_unit_type equal to SUFFIX_SEI_NUT");
+
+    CHECK(nestedsei->payloadType() == SEI::PayloadType::DECODED_PICTURE_HASH && !sei.m_snSubpicFlag,
+          "When the scalable nesting SEI message contains an SEI message that has payloadType equal to decoded picture "
+          "hash, the value of sn_subpic_flag shall be equal to 1");
+
+    CHECK(nestedsei->payloadType() == SEI::PayloadType::SUBPICTURE_LEVEL_INFO && sei.m_snSubpicFlag,
+          "When the scalable nesting SEI message contains an SEI message that has payloadType equal to SLI, the value "
+          "of sn_subpic_flag shall be equal to 0");
+
+    CHECK(generalHrd && generalHrd->getGeneralSamePicTimingInAllOlsFlag()
+            && nestedsei->payloadType() == SEI::PayloadType::PICTURE_TIMING,
+          "When general_same_pic_timing_in_all_ols_flag is equal to 1, there shall be no SEI NAL unit that contain a "
+          "scalable-nested SEI message with payloadType equal to PT");
+
+    for (int i = 0; i < vclAssociatedSeiList.size(); i++)
+    {
+      CHECK(nestedsei->payloadType() == vclAssociatedSeiList[i] && sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to a value in vclAssociatedSeiList, the value of sn_ols_flag shall be equal to 0");
+    }
+
+    if (nestedsei->payloadType() == SEI::PayloadType::BUFFERING_PERIOD
+        || nestedsei->payloadType() == SEI::PayloadType::PICTURE_TIMING
+        || nestedsei->payloadType() == SEI::PayloadType::DECODING_UNIT_INFO
+        || nestedsei->payloadType() == SEI::PayloadType::SUBPICTURE_LEVEL_INFO)
+    {
+      containBPorPTorDUIorSLI = true;
+      CHECK(!sei.m_snOlsFlag, "When the scalable nesting SEI message contains an SEI message that has payloadType equal to BP, PT, or DUI, or SLI, the value of sn_ols_flag shall be equal to 1");
+    }
+    if (!(nestedsei->payloadType() == SEI::PayloadType::BUFFERING_PERIOD
+          || nestedsei->payloadType() == SEI::PayloadType::PICTURE_TIMING
+          || nestedsei->payloadType() == SEI::PayloadType::DECODING_UNIT_INFO
+          || nestedsei->payloadType() == SEI::PayloadType::SUBPICTURE_LEVEL_INFO))
+    {
+      containNoBPorPTorDUIorSLI = true;
+    }
+  }
+  CHECK(containBPorPTorDUIorSLI && containNoBPorPTorDUIorSLI, "When a scalable nesting SEI message contains a BP, PT, DUI, or SLI SEI message, the scalable nesting SEI message shall not contain any other SEI message with payloadType not equal to BP, PT, DUI, or SLI");
+}
+
+void SEIReader::xParseSEIDecodingUnitInfo(SEIDecodingUnitInfo& sei, uint32_t payloadSize, const SEIBufferingPeriod& bp, const uint32_t temporalId, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  sei_read_uvlc( pDecodedMessageOutputStream, val, "decoding_unit_idx");
+  sei.m_decodingUnitIdx = val;
+
+  if(!bp.m_decodingUnitCpbParamsInPicTimingSeiFlag)
+  {
+    for (int i = temporalId; i <= bp.m_bpMaxSubLayers - 1; i++)
+    {
+      if (i < (bp.m_bpMaxSubLayers - 1))
+      {
+        sei_read_flag( pDecodedMessageOutputStream, val, "dui_sub_layer_delays_present_flag[i]" );
+        sei.m_duiSubLayerDelaysPresentFlag[i] = val;
+      }
+      else
+      {
+        sei.m_duiSubLayerDelaysPresentFlag[i] = 1;
+      }
+      if( sei.m_duiSubLayerDelaysPresentFlag[i] )
+      {
+        sei_read_code( pDecodedMessageOutputStream, bp.getDuCpbRemovalDelayIncrementLength(), val, "du_spt_cpb_removal_delay_increment[i]");
+        sei.m_duSptCpbRemovalDelayIncrement[i] = val;
+      }
+      else
+      {
+        sei.m_duSptCpbRemovalDelayIncrement[i] = 0;
+      }
+    }
+  }
+  else
+  {
+    for( int i = temporalId; i < bp.m_bpMaxSubLayers - 1; i ++ )
+    {
+      sei.m_duSptCpbRemovalDelayIncrement[i] = 0;
+    }
+  }
+
+  if (!bp.m_decodingUnitDpbDuParamsInPicTimingSeiFlag)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, val, "dpb_output_du_delay_present_flag"); sei.m_dpbOutputDuDelayPresentFlag = (val != 0);
+  }
+  else
+  {
+    sei.m_dpbOutputDuDelayPresentFlag = false;
+  }
+  if(sei.m_dpbOutputDuDelayPresentFlag)
+  {
+    sei_read_code( pDecodedMessageOutputStream, bp.getDpbOutputDelayDuLength(), val, "pic_spt_dpb_output_du_delay");
+    if (sei.m_picSptDpbOutputDuDelay != -1)
+       CHECK(sei.m_picSptDpbOutputDuDelay!=val,"When signaled m_picSptDpbOutputDuDelay value must be same for DUs");
+    sei.m_picSptDpbOutputDuDelay = val;
+  }
+}
+
+void SEIReader::xParseSEIBufferingPeriod(SEIBufferingPeriod& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  int i, nalOrVcl;
+  uint32_t code;
+
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag( pDecodedMessageOutputStream, code, "bp_nal_hrd_parameters_present_flag" );               sei.m_bpNalCpbParamsPresentFlag = code;
+  sei_read_flag( pDecodedMessageOutputStream, code, "bp_vcl_hrd_parameters_present_flag" );               sei.m_bpVclCpbParamsPresentFlag = code;
+
+  sei_read_code( pDecodedMessageOutputStream, 5, code, "initial_cpb_removal_delay_length_minus1" );     sei.m_initialCpbRemovalDelayLength = code + 1;
+  sei_read_code( pDecodedMessageOutputStream, 5, code, "cpb_removal_delay_length_minus1" );             sei.m_cpbRemovalDelayLength        = code + 1;
+  sei_read_code( pDecodedMessageOutputStream, 5, code, "dpb_output_delay_length_minus1" );              sei.m_dpbOutputDelayLength         = code + 1;
+  sei_read_flag( pDecodedMessageOutputStream, code, "bp_decoding_unit_hrd_params_present_flag" );       sei.m_bpDecodingUnitHrdParamsPresentFlag = code;
+  if( sei.m_bpDecodingUnitHrdParamsPresentFlag )
+  {
+    sei_read_code( pDecodedMessageOutputStream, 5, code, "du_cpb_removal_delay_increment_length_minus1" );  sei.m_duCpbRemovalDelayIncrementLength = code + 1;
+    sei_read_code( pDecodedMessageOutputStream, 5, code, "dpb_output_delay_du_length_minus1" );             sei.m_dpbOutputDelayDuLength = code + 1;
+    sei_read_flag( pDecodedMessageOutputStream, code, "decoding_unit_cpb_params_in_pic_timing_sei_flag" );  sei.m_decodingUnitCpbParamsInPicTimingSeiFlag = code;
+    sei_read_flag(pDecodedMessageOutputStream, code, "decoding_unit_dpb_du_params_in_pic_timing_sei_flag");  sei.m_decodingUnitDpbDuParamsInPicTimingSeiFlag = code;
+  }
+  else
+  {
+    sei.m_duCpbRemovalDelayIncrementLength = 24;
+    sei.m_dpbOutputDelayDuLength = 24;
+    sei.m_decodingUnitCpbParamsInPicTimingSeiFlag = false;
+    sei.m_decodingUnitDpbDuParamsInPicTimingSeiFlag = false;
+  }
+
+  CHECK(sei.m_altCpbParamsPresentFlag && sei.m_bpDecodingUnitHrdParamsPresentFlag,"When bp_alt_cpb_params_present_flag is equal to 1, the value of bp_du_hrd_params_present_flag shall be equal to 0");
+
+  sei_read_flag( pDecodedMessageOutputStream, code, "concatenation_flag");
+  sei.m_concatenationFlag = code;
+  sei_read_flag ( pDecodedMessageOutputStream, code, "additional_concatenation_info_present_flag");
+  sei.m_additionalConcatenationInfoPresentFlag = code;
+  if (sei.m_additionalConcatenationInfoPresentFlag)
+  {
+    sei_read_code( pDecodedMessageOutputStream, sei.m_initialCpbRemovalDelayLength, code, "max_initial_removal_delay_for_concatenation" );
+    sei.m_maxInitialRemovalDelayForConcatenation = code;
+  }
+
+  sei_read_code( pDecodedMessageOutputStream, ( sei.m_cpbRemovalDelayLength ), code, "au_cpb_removal_delay_delta_minus1" );
+  sei.m_auCpbRemovalDelayDelta = code + 1;
+  sei_read_code(pDecodedMessageOutputStream, 3, code, "bp_max_sub_layers_minus1");
+  sei.m_bpMaxSubLayers = code + 1;
+  if (sei.m_bpMaxSubLayers - 1 > 0)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, code, "cpb_removal_delay_deltas_present_flag");
+    sei.m_cpbRemovalDelayDeltasPresentFlag = code;
+  }
+  else
+  {
+    sei.m_cpbRemovalDelayDeltasPresentFlag = false;
+  }
+  if (sei.m_cpbRemovalDelayDeltasPresentFlag)
+  {
+    sei_read_uvlc( pDecodedMessageOutputStream, code, "num_cpb_removal_delay_deltas_minus1" );
+    CHECK(code>15, "The value of num_cpb_removal_offsets_minus1 shall be in the range of 0 to 15, inclusive.")
+    sei.m_numCpbRemovalDelayDeltas = code + 1;
+    for( i = 0; i < sei.m_numCpbRemovalDelayDeltas; i ++ )
+    {
+      sei_read_code( pDecodedMessageOutputStream, ( sei.m_cpbRemovalDelayLength ), code, "cpb_removal_delay_delta[i]" );
+      sei.m_cpbRemovalDelayDelta[ i ] = code;
+    }
+  }
+  sei_read_uvlc(pDecodedMessageOutputStream, code, "bp_cpb_cnt_minus1");
+  sei.m_bpCpbCnt = code + 1;
+  if (sei.m_bpMaxSubLayers - 1 > 0)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, code, "bp_sublayer_initial_cpb_removal_delay_present_flag");
+    sei.m_sublayerInitialCpbRemovalDelayPresentFlag = code;
+  }
+  else
+  {
+    sei.m_sublayerInitialCpbRemovalDelayPresentFlag = false;
+  }
+  for (i = (sei.m_sublayerInitialCpbRemovalDelayPresentFlag ? 0 : sei.m_bpMaxSubLayers - 1); i < sei.m_bpMaxSubLayers; i++)
+  {
+    for( nalOrVcl = 0; nalOrVcl < 2; nalOrVcl ++ )
+    {
+      if( ( ( nalOrVcl == 0 ) && ( sei.m_bpNalCpbParamsPresentFlag ) ) ||
+         ( ( nalOrVcl == 1 ) && ( sei.m_bpVclCpbParamsPresentFlag ) ) )
+      {
+        for( int j = 0; j < ( sei.m_bpCpbCnt ); j ++ )
+        {
+          sei_read_code( pDecodedMessageOutputStream, sei.m_initialCpbRemovalDelayLength, code, nalOrVcl ? "vcl_initial_cpb_removal_delay[i][j]" : "nal_initial_cpb_removal_delay[i][j]" );
+          sei.m_initialCpbRemovalDelay[i][j][nalOrVcl] = code;
+          sei_read_code( pDecodedMessageOutputStream, sei.m_initialCpbRemovalDelayLength, code, nalOrVcl ? "vcl_initial_cpb_removal_offset[i][j]" : "nal_initial_cpb_removal_offset[i][j]" );
+          sei.m_initialCpbRemovalOffset[i][j][nalOrVcl] = code;
+        }
+      }
+    }
+  }
+  if (sei.m_bpMaxSubLayers-1 > 0)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, code, "bp_sublayer_dpb_output_offsets_present_flag");
+    sei.m_sublayerDpbOutputOffsetsPresentFlag = code;
+  }
+  else
+  {
+    sei.m_sublayerDpbOutputOffsetsPresentFlag = false;
+  }
+  if(sei.m_sublayerDpbOutputOffsetsPresentFlag)
+  {
+    for(int i = 0; i < sei.m_bpMaxSubLayers - 1; i++)
+    {
+      sei_read_uvlc( pDecodedMessageOutputStream, code, "dpb_output_tid_offset[i]" );
+      sei.m_dpbOutputTidOffset[i] = code;
+    }
+    sei.m_dpbOutputTidOffset[sei.m_bpMaxSubLayers-1] = 0;
+  }
+  sei_read_flag(pDecodedMessageOutputStream, code, "bp_alt_cpb_params_present_flag");
+  sei.m_altCpbParamsPresentFlag = code;
+  if (sei.m_altCpbParamsPresentFlag)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, code, "use_alt_cpb_params_flag"); sei.m_useAltCpbParamsFlag = code;
+  }
+}
+
+void SEIReader::xParseSEIPictureTiming(SEIPictureTiming& sei, uint32_t payloadSize, const uint32_t temporalId, const SEIBufferingPeriod& bp, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  uint32_t symbol;
+  sei_read_code( pDecodedMessageOutputStream, bp.m_cpbRemovalDelayLength, symbol, "pt_cpb_removal_delay_minus1[bp_max_sub_layers_minus1]" );
+  sei.m_auCpbRemovalDelay[bp.m_bpMaxSubLayers - 1] = symbol + 1;
+  sei.m_ptSubLayerDelaysPresentFlag[bp.m_bpMaxSubLayers - 1] = true;
+  for (int i = temporalId; i < bp.m_bpMaxSubLayers - 1; i++)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, symbol, "pt_sublayer_delays_present_flag[i]");
+    sei.m_ptSubLayerDelaysPresentFlag[i] = (symbol == 1);
+    if (sei.m_ptSubLayerDelaysPresentFlag[i])
+    {
+      if (bp.m_cpbRemovalDelayDeltasPresentFlag)
+      {
+        sei_read_flag(pDecodedMessageOutputStream, symbol, "pt_cpb_removal_delay_delta_enabled_flag[i]");
+        sei.m_cpbRemovalDelayDeltaEnabledFlag[i] = (symbol == 1);
+      }
+      else
+      {
+        sei.m_cpbRemovalDelayDeltaEnabledFlag[i] = false;
+      }
+      if (sei.m_cpbRemovalDelayDeltaEnabledFlag[i])
+      {
+        if ((bp.m_numCpbRemovalDelayDeltas - 1) > 0)
+        {
+          sei_read_code(pDecodedMessageOutputStream, ceilLog2(bp.m_numCpbRemovalDelayDeltas), symbol, "pt_cpb_removal_delay_delta_idx[i]");
+          sei.m_cpbRemovalDelayDeltaIdx[i] = symbol;
+        }
+        else
+        {
+          sei.m_cpbRemovalDelayDeltaIdx[i] = 0;
+        }
+      }
+      else
+      {
+        sei_read_code(pDecodedMessageOutputStream, bp.m_cpbRemovalDelayLength, symbol, "pt_cpb_removal_delay_minus1[i]");
+        sei.m_auCpbRemovalDelay[i] = symbol + 1;
+      }
+    }
+  }
+  sei_read_code(pDecodedMessageOutputStream, bp.m_dpbOutputDelayLength, symbol, "pt_dpb_output_delay");
+  sei.m_picDpbOutputDelay = symbol;
+
+  if( bp.m_altCpbParamsPresentFlag )
+  {
+    sei_read_flag( pDecodedMessageOutputStream, symbol, "cpb_alt_timing_info_present_flag" ); sei.m_cpbAltTimingInfoPresentFlag = symbol;
+    if( sei.m_cpbAltTimingInfoPresentFlag )
+    {
+      if (bp.m_bpNalCpbParamsPresentFlag)
+      {
+        sei.m_nalCpbAltInitialRemovalDelayDelta.resize(bp.m_bpMaxSubLayers);
+        sei.m_nalCpbAltInitialRemovalOffsetDelta.resize(bp.m_bpMaxSubLayers);
+        for (int i = 0; i <= bp.m_bpMaxSubLayers - 1; ++i)
+        {
+          sei.m_nalCpbAltInitialRemovalDelayDelta[i].resize(bp.m_bpCpbCnt, 0);
+          sei.m_nalCpbAltInitialRemovalOffsetDelta[i].resize(bp.m_bpCpbCnt, 0);
+        }
+        sei.m_nalCpbDelayOffset.resize(bp.m_bpMaxSubLayers, 0);
+        sei.m_nalDpbDelayOffset.resize(bp.m_bpMaxSubLayers, 0);
+        for (int i = (bp.m_sublayerInitialCpbRemovalDelayPresentFlag ? 0 : bp.m_bpMaxSubLayers - 1);
+             i <= bp.m_bpMaxSubLayers - 1; ++i)
+        {
+          for (int j = 0; j < bp.m_bpCpbCnt; j++)
+          {
+            sei_read_code(pDecodedMessageOutputStream, bp.m_initialCpbRemovalDelayLength, symbol,
+                          "nal_cpb_alt_initial_cpb_removal_delay_delta[ i ][ j ]");
+            sei.m_nalCpbAltInitialRemovalDelayDelta[i][j] = symbol;
+            sei_read_code(pDecodedMessageOutputStream, bp.m_initialCpbRemovalDelayLength, symbol,
+                          "nal_cpb_alt_initial_cpb_removal_offset_delta[ i ][ j ]");
+            sei.m_nalCpbAltInitialRemovalOffsetDelta[i][j] = symbol;
+          }
+          sei_read_code(pDecodedMessageOutputStream, bp.m_cpbRemovalDelayLength, sei.m_nalCpbDelayOffset[i],
+                        "nal_cpb_delay_offset[ i ]");
+          sei_read_code(pDecodedMessageOutputStream, bp.m_dpbOutputDelayLength, sei.m_nalDpbDelayOffset[i],
+                        "nal_dpb_delay_offset[ i ]");
+        }
+      }
+
+      if (bp.m_bpVclCpbParamsPresentFlag)
+      {
+        sei.m_vclCpbAltInitialRemovalDelayDelta.resize(bp.m_bpMaxSubLayers);
+        sei.m_vclCpbAltInitialRemovalOffsetDelta.resize(bp.m_bpMaxSubLayers);
+        for (int i = 0; i <= bp.m_bpMaxSubLayers - 1; ++i)
+        {
+          sei.m_vclCpbAltInitialRemovalDelayDelta[i].resize(bp.m_bpCpbCnt, 0);
+          sei.m_vclCpbAltInitialRemovalOffsetDelta[i].resize(bp.m_bpCpbCnt, 0);
+        }
+        sei.m_vclCpbDelayOffset.resize(bp.m_bpMaxSubLayers, 0);
+        sei.m_vclDpbDelayOffset.resize(bp.m_bpMaxSubLayers, 0);
+        for (int i = (bp.m_sublayerInitialCpbRemovalDelayPresentFlag ? 0 : bp.m_bpMaxSubLayers - 1);
+             i <= bp.m_bpMaxSubLayers - 1; ++i)
+        {
+          for (int j = 0; j < bp.m_bpCpbCnt; j++)
+          {
+            sei_read_code(pDecodedMessageOutputStream, bp.m_initialCpbRemovalDelayLength, symbol,
+                          "vcl_cpb_alt_initial_cpb_removal_delay_delta[ i ][ j ]");
+            sei.m_vclCpbAltInitialRemovalDelayDelta[i][j] = symbol;
+            sei_read_code(pDecodedMessageOutputStream, bp.m_initialCpbRemovalDelayLength, symbol,
+                          "vcl_cpb_alt_initial_cpb_removal_offset_delta[ i ][ j ]");
+            sei.m_vclCpbAltInitialRemovalOffsetDelta[i][j] = symbol;
+          }
+          sei_read_code(pDecodedMessageOutputStream, bp.m_cpbRemovalDelayLength, sei.m_vclCpbDelayOffset[i],
+                        "vcl_cpb_delay_offset[ i ]");
+          sei_read_code(pDecodedMessageOutputStream, bp.m_dpbOutputDelayLength, sei.m_vclDpbDelayOffset[i],
+                        "vcl_dpb_delay_offset[ i ]");
+        }
+      }
+    }
+  }
+  else
+  {
+    sei.m_cpbAltTimingInfoPresentFlag = false;
+    sei.m_nalCpbAltInitialRemovalDelayDelta.resize(bp.m_bpMaxSubLayers);
+    sei.m_nalCpbAltInitialRemovalOffsetDelta.resize(bp.m_bpMaxSubLayers);
+    sei.m_nalCpbDelayOffset.resize(bp.m_bpMaxSubLayers, 0);
+    sei.m_nalDpbDelayOffset.resize(bp.m_bpMaxSubLayers, 0);
+    for (int i = (bp.m_sublayerInitialCpbRemovalDelayPresentFlag ? 0 : bp.m_bpMaxSubLayers - 1);
+         i <= bp.m_bpMaxSubLayers - 1; ++i)
+    {
+      sei.m_nalCpbAltInitialRemovalDelayDelta[i].resize(bp.m_bpCpbCnt, 0);
+      sei.m_nalCpbAltInitialRemovalOffsetDelta[i].resize(bp.m_bpCpbCnt, 0);
+    }
+
+    sei.m_vclCpbAltInitialRemovalDelayDelta.resize(bp.m_bpMaxSubLayers);
+    sei.m_vclCpbAltInitialRemovalOffsetDelta.resize(bp.m_bpMaxSubLayers);
+    sei.m_vclCpbDelayOffset.resize(bp.m_bpMaxSubLayers, 0);
+    sei.m_vclDpbDelayOffset.resize(bp.m_bpMaxSubLayers, 0);
+    for (int i = (bp.m_sublayerInitialCpbRemovalDelayPresentFlag ? 0 : bp.m_bpMaxSubLayers - 1);
+         i <= bp.m_bpMaxSubLayers - 1; ++i)
+    {
+      sei.m_vclCpbAltInitialRemovalDelayDelta[i].resize(bp.m_bpCpbCnt, 0);
+      sei.m_vclCpbAltInitialRemovalOffsetDelta[i].resize(bp.m_bpCpbCnt, 0);
+    }
+  }
+
+  if ( bp.m_bpDecodingUnitHrdParamsPresentFlag && bp.m_decodingUnitDpbDuParamsInPicTimingSeiFlag )
+  {
+    sei_read_code( pDecodedMessageOutputStream, bp.getDpbOutputDelayDuLength(), symbol, "pic_dpb_output_du_delay" );
+    sei.m_picDpbOutputDuDelay = symbol;
+  }
+  if( bp.m_bpDecodingUnitHrdParamsPresentFlag && bp.m_decodingUnitCpbParamsInPicTimingSeiFlag )
+  {
+    sei_read_uvlc( pDecodedMessageOutputStream, symbol, "num_decoding_units_minus1" );
+    sei.m_numDecodingUnitsMinus1 = symbol;
+    sei.m_numNalusInDuMinus1.resize(sei.m_numDecodingUnitsMinus1 + 1 );
+    sei.m_duCpbRemovalDelayMinus1.resize( (sei.m_numDecodingUnitsMinus1 + 1) * bp.m_bpMaxSubLayers );
+
+    if (sei.m_numDecodingUnitsMinus1 > 0)
+    {
+      sei_read_flag( pDecodedMessageOutputStream, symbol, "du_common_cpb_removal_delay_flag" );
+      sei.m_duCommonCpbRemovalDelayFlag = symbol;
+      if( sei.m_duCommonCpbRemovalDelayFlag )
+      {
+        for( int i = temporalId; i <= bp.m_bpMaxSubLayers - 1; i ++ )
+        {
+          if( sei.m_ptSubLayerDelaysPresentFlag[i] )
+          {
+            sei_read_code( pDecodedMessageOutputStream, bp.getDuCpbRemovalDelayIncrementLength(), symbol, "du_common_cpb_removal_delay_increment_minus1[i]" );
+            sei.m_duCommonCpbRemovalDelayMinus1[i] = symbol;
+          }
+        }
+      }
+      for( int i = 0; i <= sei.m_numDecodingUnitsMinus1; i ++ )
+      {
+        sei_read_uvlc( pDecodedMessageOutputStream, symbol, "num_nalus_in_du_minus1[i]" );
+        sei.m_numNalusInDuMinus1[i] = symbol;
+        if( !sei.m_duCommonCpbRemovalDelayFlag && i < sei.m_numDecodingUnitsMinus1 )
+        {
+          for( int j = temporalId; j <= bp.m_bpMaxSubLayers - 1; j ++ )
+          {
+            if( sei.m_ptSubLayerDelaysPresentFlag[j] )
+            {
+              sei_read_code( pDecodedMessageOutputStream, bp.getDuCpbRemovalDelayIncrementLength(), symbol, "du_cpb_removal_delay_increment_minus1[i][j]" );
+              sei.m_duCpbRemovalDelayMinus1[i * bp.m_bpMaxSubLayers + j] = symbol;
+            }
+          }
+        }
+      }
+    }
+    else
+    {
+      sei.m_duCommonCpbRemovalDelayFlag = 0;
+    }
+  }
+  sei_read_code( pDecodedMessageOutputStream, 8, symbol,    "pt_display_elemental_periods_minus1" );
+  sei.m_ptDisplayElementalPeriodsMinus1 = symbol;
+}
+
+void SEIReader::xParseSEIAnnotatedRegions(SEIAnnotatedRegions& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+
+  sei_read_flag(pDecodedMessageOutputStream, val, "ar_cancel_flag");                                   sei.m_hdr.m_cancelFlag = val;
+  if (!sei.m_hdr.m_cancelFlag)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, val, "ar_not_optimized_for_viewing_flag");              sei.m_hdr.m_notOptimizedForViewingFlag = val;
+    sei_read_flag(pDecodedMessageOutputStream, val, "ar_true_motion_flag");                            sei.m_hdr.m_trueMotionFlag = val;
+    sei_read_flag(pDecodedMessageOutputStream, val, "ar_occluded_object_flag");                        sei.m_hdr.m_occludedObjectFlag = val; // must be constant
+    sei_read_flag(pDecodedMessageOutputStream, val, "ar_partial_object_flag_present_flag");            sei.m_hdr.m_partialObjectFlagPresentFlag = val; // must be constant
+    sei_read_flag(pDecodedMessageOutputStream, val, "ar_object_label_present_flag");                   sei.m_hdr.m_objectLabelPresentFlag = val;
+    sei_read_flag(pDecodedMessageOutputStream, val, "ar_object_confidence_info_present_flag");         sei.m_hdr.m_objectConfidenceInfoPresentFlag = val; // must be constant
+    if (sei.m_hdr.m_objectConfidenceInfoPresentFlag)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 4, val, "ar_object_confidence_length_minus_1"); sei.m_hdr.m_objectConfidenceLength = (val + 1); // must be constant
+    }
+    if (sei.m_hdr.m_objectLabelPresentFlag)
+    {
+      sei_read_flag(pDecodedMessageOutputStream, val, "ar_object_label_language_present_flag");      sei.m_hdr.m_objectLabelLanguagePresentFlag = val;
+      if (sei.m_hdr.m_objectLabelLanguagePresentFlag)
+      {
+        // byte alignment
+        while (m_pcBitstream->getNumBitsRead() % 8 != 0)
+        {
+          uint32_t code;
+          sei_read_flag(pDecodedMessageOutputStream, code, "ar_bit_equal_to_zero");
+        }
+        sei.m_hdr.m_annotatedRegionsObjectLabelLang.clear();
+        do
+        {
+          sei_read_code(pDecodedMessageOutputStream, 8, val, "ar_label_language");
+          if (val)
+          {
+            assert(sei.m_hdr.m_annotatedRegionsObjectLabelLang.size()<256);
+            sei.m_hdr.m_annotatedRegionsObjectLabelLang.push_back((char)val);
+          }
+        } while (val != '\0');
+      }
+
+      uint32_t numLabelUpdates;
+      sei_read_uvlc(pDecodedMessageOutputStream, numLabelUpdates, "ar_num_label_updates");
+      assert(numLabelUpdates<256);
+
+      sei.m_annotatedLabels.clear();
+      sei.m_annotatedLabels.resize(numLabelUpdates);
+      for (auto it=sei.m_annotatedLabels.begin(); it!=sei.m_annotatedLabels.end(); it++)
+      {
+        SEIAnnotatedRegions::AnnotatedRegionLabel &ar = it->second;
+        sei_read_uvlc(pDecodedMessageOutputStream, val, "ar_label_idx[]");             it->first = val;
+        assert(val<256);
+        sei_read_flag(pDecodedMessageOutputStream, val, "ar_label_cancel_flag");       ar.labelValid = !val;
+        if (ar.labelValid)
+        {
+          ar.label.clear();
+          // byte alignment
+          while (m_pcBitstream->getNumBitsRead() % 8 != 0)
+          {
+            uint32_t code;
+            sei_read_flag(pDecodedMessageOutputStream, code, "ar_bit_equal_to_zero");
+          }
+          do
+          {
+            sei_read_code(pDecodedMessageOutputStream, 8, val, "ar_label[]");
+            if (val)
+            {
+              assert(ar.label.size()<256);
+              ar.label.push_back((char)val);
+            }
+          } while (val != '\0');
+        }
+      }
+    }
+
+    uint32_t numObjUpdates;
+    sei_read_uvlc(pDecodedMessageOutputStream, numObjUpdates, "ar_num_object_updates");
+    assert(numObjUpdates<256);
+    sei.m_annotatedRegions.clear();
+    sei.m_annotatedRegions.resize(numObjUpdates);
+    for (auto it=sei.m_annotatedRegions.begin(); it!=sei.m_annotatedRegions.end(); it++)
+    {
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "ar_object_idx"); it->first=val;
+      assert(val<256);
+      SEIAnnotatedRegions::AnnotatedRegionObject &ar = it->second;
+      sei_read_flag(pDecodedMessageOutputStream, val, "ar_object_cancel_flag");                           ar.objectCancelFlag = val;
+      ar.objectLabelValid=false;
+      ar.boundingBoxValid=false;
+      ar.boundingBoxCancelFlag=true;
+
+      if (!ar.objectCancelFlag)
+      {
+        if (sei.m_hdr.m_objectLabelPresentFlag)
+        {
+          sei_read_flag(pDecodedMessageOutputStream, val, "ar_object_label_update_flag");             ar.objectLabelValid = val;
+          if (ar.objectLabelValid)
+          {
+            sei_read_uvlc(pDecodedMessageOutputStream, val, "ar_object_label_idx");                      ar.objLabelIdx = val;
+            assert(val<256);
+          }
+        }
+        sei_read_flag(pDecodedMessageOutputStream, val, "ar_bounding_box_update_flag");              ar.boundingBoxValid = val;
+        if (ar.boundingBoxValid)
+        {
+          sei_read_flag(pDecodedMessageOutputStream, val, "ar_bounding_box_cancel_flag");             ar.boundingBoxCancelFlag = val;
+          if (!ar.boundingBoxCancelFlag)
+          {
+            sei_read_code(pDecodedMessageOutputStream, 16, val, "ar_bounding_box_top");                      ar.boundingBoxTop = val;
+            sei_read_code(pDecodedMessageOutputStream, 16, val, "ar_bounding_box_left");                     ar.boundingBoxLeft = val;
+            sei_read_code(pDecodedMessageOutputStream, 16, val, "ar_bounding_box_width");                    ar.boundingBoxWidth = val;
+            sei_read_code(pDecodedMessageOutputStream, 16, val, "ar_bounding_box_height");                   ar.boundingBoxHeight = val;
+            if (sei.m_hdr.m_partialObjectFlagPresentFlag)
+            {
+              sei_read_flag(pDecodedMessageOutputStream, val, "ar_partial_object_flag");                ar.partialObjectFlag = val;
+            }
+            if (sei.m_hdr.m_objectConfidenceInfoPresentFlag)
+            {
+              sei_read_code(pDecodedMessageOutputStream, sei.m_hdr.m_objectConfidenceLength, val, "ar_object_confidence"); ar.objectConfidence = val;
+            }
+          }
+        }
+      }
+    }
+  }
+}
+
+void SEIReader::xParseSEIFrameFieldinfo(SEIFrameFieldInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  uint32_t symbol;
+  sei_read_flag( pDecodedMessageOutputStream, symbol,      "ffi_field_pic_flag" );
+  sei.m_fieldPicFlag= symbol;
+  if (sei.m_fieldPicFlag)
+  {
+    sei_read_flag( pDecodedMessageOutputStream, symbol,    "ffi_bottom_field_flag" );
+    sei.m_bottomFieldFlag = symbol;
+    sei_read_flag( pDecodedMessageOutputStream, symbol,    "ffi_pairing_indicated_flag" );
+    sei.m_pairingIndicatedFlag = symbol;
+    if (sei.m_pairingIndicatedFlag)
+    {
+      sei_read_flag( pDecodedMessageOutputStream, symbol,  "ffi_paired_with_next_field_flag" );
+      sei.m_pairedWithNextFieldFlag = symbol;
+    }
+  }
+  else
+  {
+    sei_read_flag( pDecodedMessageOutputStream, symbol,    "ffi_display_fields_from_frame_flag" );
+    sei.m_displayFieldsFromFrameFlag = symbol;
+    if (sei.m_displayFieldsFromFrameFlag)
+    {
+      sei_read_flag( pDecodedMessageOutputStream, symbol,  "ffi_top_field_first_flag" );
+      sei.m_topFieldFirstFlag = symbol;
+    }
+    sei_read_code( pDecodedMessageOutputStream, 8, symbol, "ffi_display_elemental_periods_minus1" );
+    sei.m_displayElementalPeriodsMinus1 = symbol;
+  }
+  sei_read_code( pDecodedMessageOutputStream, 2, symbol,   "ffi_source_scan_type" );
+  sei.m_sourceScanType = symbol;
+  sei_read_flag( pDecodedMessageOutputStream, symbol,      "ffi_duplicate_flag" );
+  sei.m_duplicateFlag = symbol;
+}
+
+void SEIReader::xParseSEIDependentRAPIndication( SEIDependentRAPIndication& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream )
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+}
+
+
+void SEIReader::xParseSEIFramePacking(SEIFramePacking& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_uvlc( pDecodedMessageOutputStream, val, "fp_arrangement_id" );                    sei.m_arrangementId = val;
+  sei_read_flag( pDecodedMessageOutputStream, val, "fp_arrangement_cancel_flag" );           sei.m_arrangementCancelFlag = val;
+
+  if( !sei.m_arrangementCancelFlag )
+  {
+    sei_read_code( pDecodedMessageOutputStream, 7, val, "fp_arrangement_type" );             sei.m_arrangementType = val;
+    CHECK( ( sei.m_arrangementType <= 2 ) || ( sei.m_arrangementType >= 6 ), "Invalid arrangement type" );
+
+    sei_read_flag( pDecodedMessageOutputStream, val, "fp_quincunx_sampling_flag" );          sei.m_quincunxSamplingFlag = val;
+
+    sei_read_code( pDecodedMessageOutputStream, 6, val, "fp_content_interpretation_type" );  sei.m_contentInterpretationType = val;
+    sei_read_flag( pDecodedMessageOutputStream, val, "fp_spatial_flipping_flag" );           sei.m_spatialFlippingFlag = val;
+    sei_read_flag( pDecodedMessageOutputStream, val, "fp_frame0_flipped_flag" );             sei.m_frame0FlippedFlag = val;
+    sei_read_flag( pDecodedMessageOutputStream, val, "fp_field_views_flag" );                sei.m_fieldViewsFlag = val;
+    sei_read_flag( pDecodedMessageOutputStream, val, "fp_current_frame_is_frame0_flag" );    sei.m_currentFrameIsFrame0Flag = val;
+    sei_read_flag( pDecodedMessageOutputStream, val, "fp_frame0_self_contained_flag" );      sei.m_frame0SelfContainedFlag = val;
+    sei_read_flag( pDecodedMessageOutputStream, val, "fp_frame1_self_contained_flag" );      sei.m_frame1SelfContainedFlag = val;
+
+    if ( sei.m_quincunxSamplingFlag == 0 && sei.m_arrangementType != 5)
+    {
+      sei_read_code( pDecodedMessageOutputStream, 4, val, "fp_frame0_grid_position_x" );     sei.m_frame0GridPositionX = val;
+      sei_read_code( pDecodedMessageOutputStream, 4, val, "fp_frame0_grid_position_y" );     sei.m_frame0GridPositionY = val;
+      sei_read_code( pDecodedMessageOutputStream, 4, val, "fp_frame1_grid_position_x" );     sei.m_frame1GridPositionX = val;
+      sei_read_code( pDecodedMessageOutputStream, 4, val, "fp_frame1_grid_position_y" );     sei.m_frame1GridPositionY = val;
+    }
+
+    sei_read_code( pDecodedMessageOutputStream, 8, val, "fp_arrangement_reserved_byte" );    sei.m_arrangementReservedByte = val;
+    sei_read_flag( pDecodedMessageOutputStream, val,  "fp_arrangement_persistence_flag" );   sei.m_arrangementPersistenceFlag = (val != 0);
+  }
+  sei_read_flag( pDecodedMessageOutputStream, val, "fp_upsampled_aspect_ratio_flag" );       sei.m_upsampledAspectRatio = val;
+}
+
+void SEIReader::xParseSEIDisplayOrientation(SEIDisplayOrientation& sei, uint32_t payloadSize, std::ostream* pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag(pDecodedMessageOutputStream, val, "display_orientation_cancel_flag");           sei.m_doCancelFlag = val;
+  if (!sei.m_doCancelFlag)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, val, "display_orientation_persistence_flag");    sei.m_doPersistenceFlag = val;
+    sei_read_code(pDecodedMessageOutputStream, 3, val, "display_orientation_transform_type");   sei.m_doTransformType = val;
+    CHECK((sei.m_doTransformType < 0) || (sei.m_doTransformType > 7), "Invalid transform type");
+  }
+}
+
+void SEIReader::xParseSEIParameterSetsInclusionIndication(SEIParameterSetsInclusionIndication& sei, uint32_t payloadSize, std::ostream* pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header( sei, pDecodedMessageOutputStream, payloadSize );
+
+  sei_read_flag( pDecodedMessageOutputStream, val, "psii_self_contained_clvs_flag" );
+  sei.m_selfContainedClvsFlag = val;
+}
+
+void SEIReader::xParseSEIMasteringDisplayColourVolume(SEIMasteringDisplayColourVolume& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t code;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_code( pDecodedMessageOutputStream, 16, code, "mdcv_display_primaries_x[0]" ); sei.values.primaries[0][0] = code;
+  sei_read_code( pDecodedMessageOutputStream, 16, code, "mdcv_display_primaries_y[0]" ); sei.values.primaries[0][1] = code;
+
+  sei_read_code( pDecodedMessageOutputStream, 16, code, "mdcv_display_primaries_x[1]" ); sei.values.primaries[1][0] = code;
+  sei_read_code( pDecodedMessageOutputStream, 16, code, "mdcv_display_primaries_y[1]" ); sei.values.primaries[1][1] = code;
+
+  sei_read_code( pDecodedMessageOutputStream, 16, code, "mdcv_display_primaries_x[2]" ); sei.values.primaries[2][0] = code;
+  sei_read_code( pDecodedMessageOutputStream, 16, code, "mdcv_display_primaries_y[2]" ); sei.values.primaries[2][1] = code;
+
+
+  sei_read_code( pDecodedMessageOutputStream, 16, code, "mdcv_white_point_x" ); sei.values.whitePoint[0] = code;
+  sei_read_code( pDecodedMessageOutputStream, 16, code, "mdcv_white_point_y" ); sei.values.whitePoint[1] = code;
+
+  sei_read_code( pDecodedMessageOutputStream, 32, code, "mdcv_max_display_mastering_luminance" ); sei.values.maxLuminance = code;
+  sei_read_code( pDecodedMessageOutputStream, 32, code, "mdcv_min_display_mastering_luminance" ); sei.values.minLuminance = code;
+}
+
+void SEIReader::xParseSEIAlternativeTransferCharacteristics(SEIAlternativeTransferCharacteristics& sei, uint32_t payloadSize, std::ostream* pDecodedMessageOutputStream)
+{
+  uint32_t code;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_code(pDecodedMessageOutputStream, 8, code, "preferred_transfer_characteristics"); sei.m_preferredTransferCharacteristics = code;
+}
+void SEIReader::xParseSEIUserDataRegistered(SEIUserDataRegistered& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  uint32_t code;
+  assert(payloadSize>0);
+  sei_read_code(pDecodedMessageOutputStream, 8, code, "itu_t_t35_country_code"); payloadSize--;
+  if (code == 255)
+  {
+    assert(payloadSize>0);
+    sei_read_code(pDecodedMessageOutputStream, 8, code, "itu_t_t35_country_code_extension_byte"); payloadSize--;
+    code += 255;
+  }
+  sei.m_ituCountryCode = code;
+  sei.m_userData.resize(payloadSize);
+  for (uint32_t i = 0; i < sei.m_userData.size(); i++)
+  {
+    sei_read_code(nullptr, 8, code, "itu_t_t35_payload_byte");
+    sei.m_userData[i] = code;
+  }
+  if (pDecodedMessageOutputStream)
+  {
+    (*pDecodedMessageOutputStream) << "  itu_t_t35 payload size: " << sei.m_userData.size() << "\n";
+  }
+}
+
+void SEIReader::xParseSEIFilmGrainCharacteristics(SEIFilmGrainCharacteristics& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t code;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag(pDecodedMessageOutputStream, code, "fg_characteristics_cancel_flag");                sei.m_filmGrainCharacteristicsCancelFlag = code != 0;
+  if (!sei.m_filmGrainCharacteristicsCancelFlag)
+  {
+    sei_read_code(pDecodedMessageOutputStream, 2, code, "fg_model_id");                              sei.m_filmGrainModelId = code;
+    sei_read_flag(pDecodedMessageOutputStream, code, "fg_separate_colour_description_present_flag"); sei.m_separateColourDescriptionPresentFlag = code != 0;
+    if (sei.m_separateColourDescriptionPresentFlag)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 3, code, "fg_bit_depth_luma_minus8");               sei.m_filmGrainBitDepthLumaMinus8 = code;
+      sei_read_code(pDecodedMessageOutputStream, 3, code, "fg_bit_depth_chroma_minus8");             sei.m_filmGrainBitDepthChromaMinus8 = code;
+      sei_read_flag(pDecodedMessageOutputStream, code, "fg_full_range_flag");                        sei.m_filmGrainFullRangeFlag = code != 0;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "fg_colour_primaries");                    sei.m_filmGrainColourPrimaries = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "fg_transfer_characteristics");            sei.m_filmGrainTransferCharacteristics = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "fg_matrix_coeffs");                       sei.m_filmGrainMatrixCoeffs = code;
+    }
+    sei_read_code(pDecodedMessageOutputStream, 2, code, "fg_blending_mode_id");                      sei.m_blendingModeId = code;
+    sei_read_code(pDecodedMessageOutputStream, 4, code, "fg_log2_scale_factor");                     sei.m_log2ScaleFactor = code;
+    for (int c = 0; c<3; c++)
+    {
+      sei_read_flag(pDecodedMessageOutputStream, code, "fg_comp_model_present_flag[c]");             sei.m_compModel[c].presentFlag = code != 0;
+    }
+    for (int c = 0; c<3; c++)
+    {
+      SEIFilmGrainCharacteristics::CompModel &cm = sei.m_compModel[c];
+      if (cm.presentFlag)
+      {
+        sei_read_code(pDecodedMessageOutputStream, 8, code, "fg_num_intensity_intervals_minus1[c]"); cm.numIntensityIntervals = code + 1;
+        sei_read_code(pDecodedMessageOutputStream, 3, code, "fg_num_model_values_minus1[c]");        cm.numModelValues = code + 1;
+        cm.intensityValues.resize(cm.numIntensityIntervals);
+        for (uint32_t interval = 0; interval < cm.numIntensityIntervals; interval++)
+        {
+          SEIFilmGrainCharacteristics::CompModelIntensityValues &cmiv = cm.intensityValues[interval];
+          sei_read_code(pDecodedMessageOutputStream, 8, code, "fg_intensity_interval_lower_bound[c][i]"); cmiv.intensityIntervalLowerBound = code;
+          sei_read_code(pDecodedMessageOutputStream, 8, code, "fg_intensity_interval_upper_bound[c][i]"); cmiv.intensityIntervalUpperBound = code;
+          cmiv.compModelValue.resize(cm.numModelValues);
+          for (uint32_t j = 0; j<cm.numModelValues; j++)
+          {
+            sei_read_svlc(pDecodedMessageOutputStream, cmiv.compModelValue[j], "fg_comp_model_value[c][i]");
+          }
+        }
+      }
+    } // for c
+    sei_read_flag(pDecodedMessageOutputStream, code, "fg_characteristics_persistence_flag");         sei.m_filmGrainCharacteristicsPersistenceFlag = code != 0;
+  } // cancel flag
+}
+
+void SEIReader::xParseSEIContentLightLevelInfo(SEIContentLightLevelInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t code;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_code(pDecodedMessageOutputStream, 16, code, "clli_max_content_light_level");     sei.m_maxContentLightLevel = code;
+  sei_read_code(pDecodedMessageOutputStream, 16, code, "clli_max_pic_average_light_level"); sei.m_maxPicAverageLightLevel = code;
+}
+
+void SEIReader::xParseSEIAmbientViewingEnvironment(SEIAmbientViewingEnvironment& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t code;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_code(pDecodedMessageOutputStream, 32, code, "ambient_illuminance"); sei.m_ambientIlluminance = code;
+  sei_read_code(pDecodedMessageOutputStream, 16, code, "ambient_light_x");     sei.m_ambientLightX = (uint16_t)code;
+  sei_read_code(pDecodedMessageOutputStream, 16, code, "ambient_light_y");     sei.m_ambientLightY = (uint16_t)code;
+}
+
+void SEIReader::xParseSEIColourTransformInfo(SEIColourTransformInfo& sei, uint32_t payloadSize, std::ostream* pDecodedMessageOutputStream)
+{
+  uint32_t code;
+
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_uvlc(pDecodedMessageOutputStream, code, "colour_transform_id");               sei.m_id = code;
+  sei_read_flag(pDecodedMessageOutputStream, code, "colour_transform_cancel_flag");      bool colourTransformCancelFlag = code;
+
+  if (colourTransformCancelFlag == 0)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, code, "colour_transform_persistence_flag");
+    sei_read_flag(pDecodedMessageOutputStream, code, "colour_transform_video_signal_info_present_flag"); sei.m_signalInfoFlag = code;
+
+    if (sei.m_signalInfoFlag)
+    {
+      sei_read_flag(pDecodedMessageOutputStream, code, "colour_transform_full_range_flag");        sei.m_fullRangeFlag = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "colour_transform_primaries");           sei.m_primaries = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "colour_transform_transfer_function");   sei.m_transferFunction = code;
+      sei_read_code(pDecodedMessageOutputStream, 8, code, "colour_transform_matrix_coefficients"); sei.m_matrixCoefs = code;
+    }
+    else
+    {
+      sei.m_fullRangeFlag = 0;
+      sei.m_primaries = 0;
+      sei.m_transferFunction = 0;
+      sei.m_matrixCoefs = 0;
+    }
+    sei_read_code(pDecodedMessageOutputStream, 4, code, "colour_transform_bit_depth_minus8");                       sei.m_bitdepth = 8+code;
+    sei_read_code(pDecodedMessageOutputStream, 3, code, "colour_transform_log2_number_of_points_per_lut_minus1");   sei.m_log2NumberOfPointsPerLut = code + 1;
+    int numLutValues = (1 << sei.m_log2NumberOfPointsPerLut) + 1;
+    sei_read_flag(pDecodedMessageOutputStream, code, "colour_transform_cross_comp_flag");                sei.m_crossComponentFlag = code;
+    sei.m_crossComponentInferred = 0;
+    if (sei.m_crossComponentFlag == true)
+    {
+      sei_read_flag(pDecodedMessageOutputStream, code, "colour_transform_cross_comp_inferred");          sei.m_crossComponentInferred = code;
+    }
+    for (int i = 0; i < MAX_NUM_COMPONENT; i++) {
+      sei.m_lut[i].lutValues.resize(numLutValues);
+    }
+
+    uint16_t lutCodingLength = 2 + sei.m_bitdepth - sei.m_log2NumberOfPointsPerLut;
+    for (uint32_t j = 0; j < numLutValues; j++)
+    {
+      sei_read_code(pDecodedMessageOutputStream, lutCodingLength, code, "colour_transform_lut[0][i]");
+      sei.m_lut[0].lutValues[j] = code;
+    }
+    sei.m_lut[0].numLutValues = numLutValues;
+    sei.m_lut[0].presentFlag = true;
+    if (sei.m_crossComponentFlag == 0 || sei.m_crossComponentInferred == 0)
+    {
+      sei_read_flag(pDecodedMessageOutputStream, code, "colour_transform_number_chroma_lut_minus1");      sei.m_numberChromaLutMinus1 = code;
+      for (uint32_t j = 0; j < numLutValues; j++)
+      {
+        sei_read_code(pDecodedMessageOutputStream, lutCodingLength, code, "colour_transform_lut[1][i]");
+        sei.m_lut[1].lutValues[j] = code;
+        sei.m_lut[2].lutValues[j] = code;
+      }
+      if (sei.m_numberChromaLutMinus1 == 1)
+      {
+        for (uint32_t j = 0; j < numLutValues; j++)
+        {
+          sei_read_code(pDecodedMessageOutputStream, lutCodingLength, code, "colour_transform_lut[2][i]");
+          sei.m_lut[2].lutValues[j] = code;
+        }
+      }
+      sei.m_lut[1].numLutValues = numLutValues;
+      sei.m_lut[2].numLutValues = numLutValues;
+      sei.m_lut[1].presentFlag = true;
+      sei.m_lut[2].presentFlag = true;
+    }
+    else
+    {
+      sei_read_code(pDecodedMessageOutputStream, lutCodingLength, code, "colour_transform_chroma_offset");
+      sei.m_chromaOffset = code;
+    }
+  }
+}
+
+void SEIReader::xParseSEIContentColourVolume(SEIContentColourVolume& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  int i;
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag(pDecodedMessageOutputStream, val, "ccv_cancel_flag");          sei.m_ccvCancelFlag = val;
+  if (!sei.m_ccvCancelFlag)
+  {
+    int iVal;
+    sei_read_flag(pDecodedMessageOutputStream, val, "ccv_persistence_flag");   sei.m_ccvPersistenceFlag = val;
+    sei_read_flag(pDecodedMessageOutputStream, val, "ccv_primaries_present_flag");   sei.m_ccvPrimariesPresentFlag = val;
+    sei_read_flag(pDecodedMessageOutputStream, val, "ccv_min_luminance_value_present_flag");   sei.m_ccvMinLuminanceValuePresentFlag = val;
+    sei_read_flag(pDecodedMessageOutputStream, val, "ccv_max_luminance_value_present_flag");   sei.m_ccvMaxLuminanceValuePresentFlag = val;
+    sei_read_flag(pDecodedMessageOutputStream, val, "ccv_avg_luminance_value_present_flag");   sei.m_ccvAvgLuminanceValuePresentFlag = val;
+
+    if (sei.m_ccvPrimariesPresentFlag)
+    {
+      for (i = 0; i < MAX_NUM_COMPONENT; i++)
+      {
+        sei_read_scode(pDecodedMessageOutputStream, 32, iVal, "ccv_primaries_x[i]");          sei.m_ccvPrimariesX[i] = iVal;
+        sei_read_scode(pDecodedMessageOutputStream, 32, iVal, "ccv_primaries_y[i]");          sei.m_ccvPrimariesY[i] = iVal;
+      }
+    }
+    if (sei.m_ccvMinLuminanceValuePresentFlag)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 32, val, "ccv_min_luminance_value");   sei.m_ccvMinLuminanceValue = val;
+    }
+    if (sei.m_ccvMaxLuminanceValuePresentFlag)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 32, val, "ccv_max_luminance_value");   sei.m_ccvMaxLuminanceValue = val;
+    }
+    if (sei.m_ccvAvgLuminanceValuePresentFlag)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 32, val, "ccv_avg_luminance_value");   sei.m_ccvAvgLuminanceValue = val;
+    }
+  }
+}
+
+void SEIReader::xParseSEIEquirectangularProjection(SEIEquirectangularProjection& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag( pDecodedMessageOutputStream, val,       "erp_cancel_flag" );              sei.m_erpCancelFlag = val;
+  if( !sei.m_erpCancelFlag )
+  {
+    sei_read_flag( pDecodedMessageOutputStream, val,      "erp_persistence_flag"    );     sei.m_erpPersistenceFlag   = val;
+    sei_read_flag( pDecodedMessageOutputStream, val,      "erp_guard_band_flag"     );     sei.m_erpGuardBandFlag     = val;
+    sei_read_code( pDecodedMessageOutputStream, 2, val,   "erp_reserved_zero_2bits" );
+    if ( sei.m_erpGuardBandFlag == 1)
+    {
+      sei_read_code( pDecodedMessageOutputStream, 3, val,     "erp_guard_band_type"       );   sei.m_erpGuardBandType  = val;
+      sei_read_code( pDecodedMessageOutputStream, 8, val,     "erp_left_guard_band_width" );   sei.m_erpLeftGuardBandWidth = val;
+      sei_read_code( pDecodedMessageOutputStream, 8, val,     "erp_right_guard_band_width");   sei.m_erpRightGuardBandWidth = val;
+    }
+  }
+}
+
+void SEIReader::xParseSEISphereRotation(SEISphereRotation& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  int  sval;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  sei_read_flag( pDecodedMessageOutputStream, val,           "sphere_rotation_cancel_flag" );             sei.m_sphereRotationCancelFlag = val;
+  if( !sei.m_sphereRotationCancelFlag )
+  {
+    sei_read_flag ( pDecodedMessageOutputStream,      val,   "sphere_rotation_persistence_flag"    );     sei.m_sphereRotationPersistenceFlag = val;
+    sei_read_code ( pDecodedMessageOutputStream, 6,   val,   "sphere_rotation_reserved_zero_6bits" );
+    sei_read_scode( pDecodedMessageOutputStream, 32, sval,   "sphere_rotation_yaw"                 );     sei.m_sphereRotationYaw = sval;
+    sei_read_scode( pDecodedMessageOutputStream, 32, sval,   "sphere_rotation_pitch"               );     sei.m_sphereRotationPitch = sval;
+    sei_read_scode( pDecodedMessageOutputStream, 32, sval,   "sphere_rotation_roll"                );     sei.m_sphereRotationRoll = sval;
+  }
+}
+
+void SEIReader::xParseSEIOmniViewport(SEIOmniViewport& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t code;
+  int  scode;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  sei_read_code( pDecodedMessageOutputStream, 10, code,        "omni_viewport_id"          );       sei.m_omniViewportId         = code;
+  sei_read_flag( pDecodedMessageOutputStream,     code,        "omni_viewport_cancel_flag" );       sei.m_omniViewportCancelFlag = code;
+  if (!sei.m_omniViewportCancelFlag)
+  {
+    uint32_t numRegions;
+    sei_read_flag( pDecodedMessageOutputStream,    code,       "omni_viewport_persistence_flag" );  sei.m_omniViewportPersistenceFlag = code;
+    sei_read_code( pDecodedMessageOutputStream, 4, numRegions, "omni_viewport_cnt_minus1"       );  numRegions++;
+    sei.m_omniViewportRegions.resize(numRegions);
+    for(uint32_t region=0; region<numRegions; region++)
+    {
+      SEIOmniViewport::OmniViewport &viewport = sei.m_omniViewportRegions[region];
+      sei_read_scode( pDecodedMessageOutputStream, 32, scode,  "omni_viewport_azimuth_centre"   );  viewport.azimuthCentre = scode;
+      sei_read_scode( pDecodedMessageOutputStream, 32, scode,  "omni_viewport_elevation_centre" );  viewport.elevationCentre = scode;
+      sei_read_scode( pDecodedMessageOutputStream, 32, scode,  "omni_viewport_tilt_centre"      );  viewport.tiltCentre = code;
+      sei_read_code( pDecodedMessageOutputStream,  32, code,   "omni_viewport_hor_range"         ); viewport.horRange        = code;
+      sei_read_code( pDecodedMessageOutputStream,  32, code,   "omni_viewport_ver_range"         ); viewport.verRange        = code;
+    }
+  }
+  else
+  {
+    sei.m_omniViewportRegions.clear();
+    sei.m_omniViewportPersistenceFlag=false;
+  }
+}
+
+void SEIReader::xParseSEIRegionWisePacking(SEIRegionWisePacking& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+
+  sei_read_flag( pDecodedMessageOutputStream,           val,      "rwp_cancel_flag" );                       sei.m_rwpCancelFlag = val;
+  if (!sei.m_rwpCancelFlag)
+  {
+    sei_read_flag( pDecodedMessageOutputStream,           val,    "rwp_persistence_flag" );                  sei.m_rwpPersistenceFlag = val;
+    sei_read_flag( pDecodedMessageOutputStream,           val,    "rwp_constituent_picture_matching_flag" ); sei.m_constituentPictureMatchingFlag = val;
+    sei_read_code( pDecodedMessageOutputStream,       5,  val,    "rwp_reserved_zero_5bits" );
+    sei_read_code( pDecodedMessageOutputStream,       8,  val,    "rwp_num_packed_regions" );                sei.m_numPackedRegions = val;
+    sei_read_code( pDecodedMessageOutputStream,       32, val,    "rwp_proj_picture_width" );                sei.m_projPictureWidth = val;
+    sei_read_code( pDecodedMessageOutputStream,       32, val,    "rwp_proj_picture_height" );               sei.m_projPictureHeight = val;
+    sei_read_code( pDecodedMessageOutputStream,       16, val,    "rwp_packed_picture_width" );              sei.m_packedPictureWidth = val;
+    sei_read_code( pDecodedMessageOutputStream,       16, val,    "rwp_packed_picture_height" );             sei.m_packedPictureHeight = val;
+
+    sei.m_rwpTransformType.resize(sei.m_numPackedRegions);
+    sei.m_rwpGuardBandFlag.resize(sei.m_numPackedRegions);
+    sei.m_projRegionWidth.resize(sei.m_numPackedRegions);
+    sei.m_projRegionHeight.resize(sei.m_numPackedRegions);
+    sei.m_rwpProjRegionTop.resize(sei.m_numPackedRegions);
+    sei.m_projRegionLeft.resize(sei.m_numPackedRegions);
+    sei.m_packedRegionWidth.resize(sei.m_numPackedRegions);
+    sei.m_packedRegionHeight.resize(sei.m_numPackedRegions);
+    sei.m_packedRegionTop.resize(sei.m_numPackedRegions);
+    sei.m_packedRegionLeft.resize(sei.m_numPackedRegions);
+    sei.m_rwpLeftGuardBandWidth.resize(sei.m_numPackedRegions);
+    sei.m_rwpRightGuardBandWidth.resize(sei.m_numPackedRegions);
+    sei.m_rwpTopGuardBandHeight.resize(sei.m_numPackedRegions);
+    sei.m_rwpBottomGuardBandHeight.resize(sei.m_numPackedRegions);
+    sei.m_rwpGuardBandNotUsedForPredFlag.resize(sei.m_numPackedRegions);
+    sei.m_rwpGuardBandType.resize(4*sei.m_numPackedRegions);
+
+    for( int i=0; i < sei.m_numPackedRegions; i++ )
+    {
+      sei_read_code( pDecodedMessageOutputStream,     4,  val,    "rwp_reserved_zero_4bits" );
+      sei_read_code( pDecodedMessageOutputStream,     3,  val,    "rwp_transform_type" );                    sei.m_rwpTransformType[i] = val;
+      sei_read_flag( pDecodedMessageOutputStream,         val,    "rwp_guard_band_flag" );                   sei.m_rwpGuardBandFlag[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,     32, val,    "rwp_proj_region_width" );                 sei.m_projRegionWidth[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,     32, val,    "rwp_proj_region_height" );                sei.m_projRegionHeight[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,     32, val,    "rwp_rwp_proj_region_top" );               sei.m_rwpProjRegionTop[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,     32, val,    "rwp_proj_region_left" );                  sei.m_projRegionLeft[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,     16, val,    "rwp_packed_region_width" );               sei.m_packedRegionWidth[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,     16, val,    "rwp_packed_region_height" );              sei.m_packedRegionHeight[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,     16, val,    "rwp_packed_region_top" );                 sei.m_packedRegionTop[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,     16, val,    "rwp_packed_region_left" );                sei.m_packedRegionLeft[i] = val;
+      if( sei.m_rwpGuardBandFlag[i] )
+      {
+        sei_read_code( pDecodedMessageOutputStream,   8,  val,    "rwp_left_guard_band_width" );             sei.m_rwpLeftGuardBandWidth[i] = val;
+        sei_read_code( pDecodedMessageOutputStream,   8,  val,    "rwp_right_guard_band_width" );            sei.m_rwpRightGuardBandWidth[i] = val;
+        sei_read_code( pDecodedMessageOutputStream,   8,  val,    "rwp_top_guard_band_height" );             sei.m_rwpTopGuardBandHeight[i]  = val;
+        sei_read_code( pDecodedMessageOutputStream,   8,  val,    "rwp_bottom_guard_band_height" );          sei. m_rwpBottomGuardBandHeight[i]  = val;
+        sei_read_flag( pDecodedMessageOutputStream,       val,    "rwp_guard_band_not_used_for_pred_flag" ); sei.m_rwpGuardBandNotUsedForPredFlag[i] = val;
+        for( int j=0; j < 4; j++ )
+        {
+          sei_read_code( pDecodedMessageOutputStream, 3,  val,    "rwp_guard_band_type" );                   sei.m_rwpGuardBandType[i*4 + j] = val;
+        }
+        sei_read_code( pDecodedMessageOutputStream,   3,  val,    "rwp_guard_band_reserved_zero_3bits" );
+      }
+    }
+  }
+}
+
+void SEIReader::xParseSEIGeneralizedCubemapProjection(SEIGeneralizedCubemapProjection& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag( pDecodedMessageOutputStream,          val,    "gcmp_cancel_flag" );                      sei.m_gcmpCancelFlag = val;
+  if (!sei.m_gcmpCancelFlag)
+  {
+    sei_read_flag( pDecodedMessageOutputStream,        val,    "gcmp_persistence_flag"    );              sei.m_gcmpPersistenceFlag = val;
+    sei_read_code( pDecodedMessageOutputStream,     3, val,    "gcmp_packing_type" );                     sei.m_gcmpPackingType = val;
+    sei_read_code( pDecodedMessageOutputStream,     2, val,    "gcmp_mapping_function_type"     );        sei.m_gcmpMappingFunctionType = val;
+
+    int numFace = sei.m_gcmpPackingType == 4 || sei.m_gcmpPackingType == 5 ? 5 : 6;
+    sei.m_gcmpFaceIndex.resize(numFace);
+    sei.m_gcmpFaceRotation.resize(numFace);
+    if (sei.m_gcmpMappingFunctionType == 2)
+    {
+      sei.m_gcmpFunctionCoeffU.resize(numFace);
+      sei.m_gcmpFunctionUAffectedByVFlag.resize(numFace);
+      sei.m_gcmpFunctionCoeffV.resize(numFace);
+      sei.m_gcmpFunctionVAffectedByUFlag.resize(numFace);
+    }
+
+    for (int i = 0; i < numFace; i++)
+    {
+      sei_read_code( pDecodedMessageOutputStream,   3, val,    "gcmp_face_index" );                       sei.m_gcmpFaceIndex[i] = val;
+      sei_read_code( pDecodedMessageOutputStream,   2, val,    "gcmp_face_rotation" );                    sei.m_gcmpFaceRotation[i] = val;
+      if (sei.m_gcmpMappingFunctionType == 2)
+      {
+        sei_read_code( pDecodedMessageOutputStream, 7, val,    "gcmp_function_coeff_u" );                 sei.m_gcmpFunctionCoeffU[i] = val;
+        sei_read_flag( pDecodedMessageOutputStream,    val,    "gcmp_function_u_affected_by_v_flag"    ); sei.m_gcmpFunctionUAffectedByVFlag[i] = val;
+        sei_read_code( pDecodedMessageOutputStream, 7, val,    "gcmp_function_coeff_v" );                 sei.m_gcmpFunctionCoeffV[i] = val;
+        sei_read_flag( pDecodedMessageOutputStream,    val,    "gcmp_function_v_affected_by_u_flag"    ); sei.m_gcmpFunctionVAffectedByUFlag[i] = val;
+      }
+    }
+    sei_read_flag( pDecodedMessageOutputStream,        val,    "gcmp_guard_band_flag" );                  sei.m_gcmpGuardBandFlag = val;
+    if (sei.m_gcmpGuardBandFlag)
+    {
+      sei_read_code( pDecodedMessageOutputStream,   3, val,    "gcmp_guard_band_type" );                   sei.m_gcmpGuardBandType = val;
+      sei_read_flag( pDecodedMessageOutputStream,      val,    "gcmp_guard_band_boundary_exterior_flag" ); sei.m_gcmpGuardBandBoundaryExteriorFlag = val;
+      sei_read_code( pDecodedMessageOutputStream,   4, val,    "gcmp_guard_band_samples_minus1" );         sei.m_gcmpGuardBandSamplesMinus1 = val;
+    }
+  }
+}
+
+void SEIReader::xParseSEIScalabilityDimensionInfo(SEIScalabilityDimensionInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+  sei_read_code( pDecodedMessageOutputStream,   6,  val,    "sdi_max_layers_minus1" );            sei.m_sdiMaxLayersMinus1 = val;
+  sei_read_flag( pDecodedMessageOutputStream,       val,    "sdi_multiview_info_flag" );          sei.m_sdiMultiviewInfoFlag = val;
+  sei_read_flag( pDecodedMessageOutputStream,       val,    "sdi_auxiliary_info_flag" );          sei.m_sdiAuxiliaryInfoFlag = val;
+  if (sei.m_sdiMultiviewInfoFlag || sei.m_sdiAuxiliaryInfoFlag)
+  {
+    if (sei.m_sdiMultiviewInfoFlag)
+    {
+      sei_read_code( pDecodedMessageOutputStream, 4, val, "sdi_view_id_len_minus1" ); sei.m_sdiViewIdLenMinus1 = val;
+    }
+    for (int i = 0; i <= sei.m_sdiMaxLayersMinus1; i++)
+    {
+      sei.m_sdiLayerId.resize(sei.m_sdiViewIdLenMinus1 + 1);
+      sei_read_code( pDecodedMessageOutputStream, 6, val, "sdi_layer_id" ); sei.m_sdiLayerId[i] = val;
+      if (sei.m_sdiMultiviewInfoFlag)
+      {
+        sei.m_sdiViewIdVal.resize(sei.m_sdiViewIdLenMinus1 + 1);
+        sei_read_code( pDecodedMessageOutputStream, sei.m_sdiViewIdLenMinus1 + 1, val, "sdi_view_id_val" ); sei.m_sdiViewIdVal[i] = val;
+      }
+      if (sei.m_sdiAuxiliaryInfoFlag)
+      {
+        sei.m_sdiAuxId.resize(sei.m_sdiViewIdLenMinus1 + 1);
+        sei.m_sdiNumAssociatedPrimaryLayersMinus1.resize(sei.m_sdiViewIdLenMinus1 + 1);
+        sei.m_sdiAssociatedPrimaryLayerIdx.resize(sei.m_sdiViewIdLenMinus1 + 1);
+        sei_read_code( pDecodedMessageOutputStream, 8, val, "sdi_aux_id" ); sei.m_sdiAuxId[i] = val;
+        if (sei.m_sdiAuxId[i] > 0)
+        {
+          sei_read_code( pDecodedMessageOutputStream, 6, val, "sdi_num_associated_primary_layers_minus1" ); sei.m_sdiNumAssociatedPrimaryLayersMinus1[i] = val;
+          sei.m_sdiAssociatedPrimaryLayerIdx[i].resize(sei.m_sdiNumAssociatedPrimaryLayersMinus1[i] + 1);
+          for (int j = 0; j <= sei.m_sdiNumAssociatedPrimaryLayersMinus1[i]; j++)
+          {
+            sei_read_code( pDecodedMessageOutputStream, 6, val, "sdi_associated_primary_layer_idx" );
+            sei.m_sdiAssociatedPrimaryLayerIdx[i][j] = val;
+          }
+        }
+      }
+    }
+    sei.m_sdiNumViews = 1;
+    if (sei.m_sdiMultiviewInfoFlag)
+    {
+      for (int i = 1; i <= sei.m_sdiMaxLayersMinus1; i++)
+      {
+        bool newViewFlag = true;
+        for (int j = 0; j < i; j++)
+        {
+          if (sei.m_sdiViewIdVal[i] == sei.m_sdiViewIdVal[j])
+          {
+            newViewFlag = false;
+          }
+        }
+        if (newViewFlag)
+        {
+          sei.m_sdiNumViews++;
+        }
+      }
+    }
+  }
+}
+
+void SEIReader::xParseSEIMultiviewAcquisitionInfo(SEIMultiviewAcquisitionInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+
+  sei_read_flag( pDecodedMessageOutputStream, val, "intrinsic_param_flag" ); sei.m_maiIntrinsicParamFlag = (val == 1);
+  sei_read_flag( pDecodedMessageOutputStream, val, "extrinsic_param_flag" ); sei.m_maiExtrinsicParamFlag = (val == 1);
+  sei_read_uvlc( pDecodedMessageOutputStream, val, "num_views_minus1"     ); sei.m_maiNumViewsMinus1     =  val      ;
+  sei.resizeArrays( );
+  if( sei.m_maiIntrinsicParamFlag )
+  {
+    sei_read_flag( pDecodedMessageOutputStream, val, "intrinsic_params_equal_flag" ); sei.m_maiIntrinsicParamsEqualFlag = (val == 1);
+    sei_read_uvlc( pDecodedMessageOutputStream, val, "prec_focal_length"           ); sei.m_maiPrecFocalLength          =  val      ;
+    sei_read_uvlc( pDecodedMessageOutputStream, val, "prec_principal_point"        ); sei.m_maiPrecPrincipalPoint       =  val      ;
+    sei_read_uvlc( pDecodedMessageOutputStream, val, "prec_skew_factor"            ); sei.m_maiPrecSkewFactor           =  val      ;
+
+    for( int i = 0; i  <=  ( sei.m_maiIntrinsicParamsEqualFlag ? 0 : sei.m_maiNumViewsMinus1 ); i++ )
+    {
+      sei_read_flag( pDecodedMessageOutputStream,                                         val, "sign_focal_length_x"        ); sei.m_maiSignFocalLengthX       [i] = (val == 1);
+      sei_read_code( pDecodedMessageOutputStream, 6,                                      val, "exponent_focal_length_x"    ); sei.m_maiExponentFocalLengthX   [i] =  val      ;
+      sei_read_code( pDecodedMessageOutputStream, sei.getMantissaFocalLengthXLen   ( i ), val, "mantissa_focal_length_x"    ); sei.m_maiMantissaFocalLengthX   [i] =  val      ;
+      sei_read_flag( pDecodedMessageOutputStream,                                         val, "sign_focal_length_y"        ); sei.m_maiSignFocalLengthY       [i] = (val == 1);
+      sei_read_code( pDecodedMessageOutputStream, 6,                                      val, "exponent_focal_length_y"    ); sei.m_maiExponentFocalLengthY   [i] =  val      ;
+      sei_read_code( pDecodedMessageOutputStream, sei.getMantissaFocalLengthYLen   ( i ), val, "mantissa_focal_length_y"    ); sei.m_maiMantissaFocalLengthY   [i] =  val      ;
+      sei_read_flag( pDecodedMessageOutputStream,                                         val, "sign_principal_point_x"     ); sei.m_maiSignPrincipalPointX    [i] = (val == 1);
+      sei_read_code( pDecodedMessageOutputStream, 6,                                      val, "exponent_principal_point_x" ); sei.m_maiExponentPrincipalPointX[i] =  val      ;
+      sei_read_code( pDecodedMessageOutputStream, sei.getMantissaPrincipalPointXLen( i ), val, "mantissa_principal_point_x" ); sei.m_maiMantissaPrincipalPointX[i] =  val      ;
+      sei_read_flag( pDecodedMessageOutputStream,                                         val, "sign_principal_point_y"     ); sei.m_maiSignPrincipalPointY    [i] = (val == 1);
+      sei_read_code( pDecodedMessageOutputStream, 6,                                      val, "exponent_principal_point_y" ); sei.m_maiExponentPrincipalPointY[i] =  val      ;
+      sei_read_code( pDecodedMessageOutputStream, sei.getMantissaPrincipalPointYLen( i ), val, "mantissa_principal_point_y" ); sei.m_maiMantissaPrincipalPointY[i] =  val      ;
+      sei_read_flag( pDecodedMessageOutputStream,                                         val, "sign_skew_factor"           ); sei.m_maiSignSkewFactor         [i] = (val == 1);
+      sei_read_code( pDecodedMessageOutputStream, 6,                                      val, "exponent_skew_factor"       ); sei.m_maiExponentSkewFactor     [i] =  val      ;
+      sei_read_code( pDecodedMessageOutputStream, sei.getMantissaSkewFactorLen     ( i ), val, "mantissa_skew_factor"       ); sei.m_maiMantissaSkewFactor     [i] =  val      ;
+    }
+  }
+  if( sei.m_maiExtrinsicParamFlag )
+  {
+    sei_read_uvlc( pDecodedMessageOutputStream, val, "prec_rotation_param"    ); sei.m_maiPrecRotationParam    = val;
+    sei_read_uvlc( pDecodedMessageOutputStream, val, "prec_translation_param" ); sei.m_maiPrecTranslationParam = val;
+
+    for( int i = 0; i  <=  sei.m_maiNumViewsMinus1; i++ )
+    {
+      for( int j = 0; j  <=  2; j++ )  /* row */
+      {
+        for( int k = 0; k  <=  2; k++ )  /* column */
+        {
+          sei_read_flag( pDecodedMessageOutputStream,                                 val, "sign_r"     ); sei.m_maiSignR    [i][j][k] = (val == 1);
+          sei_read_code( pDecodedMessageOutputStream, 6,                              val, "exponent_r" ); sei.m_maiExponentR[i][j][k] =  val      ;
+          sei_read_code( pDecodedMessageOutputStream, sei.getMantissaRLen( i, j, k ), val, "mantissa_r" ); sei.m_maiMantissaR[i][j][k] =  val      ;
+        }
+        sei_read_flag( pDecodedMessageOutputStream,                              val, "sign_t"     ); sei.m_maiSignT    [i][j] = (val == 1);
+        sei_read_code( pDecodedMessageOutputStream, 6,                           val, "exponent_t" ); sei.m_maiExponentT[i][j] =  val      ;
+        sei_read_code( pDecodedMessageOutputStream, sei.getMantissaTLen( i, j ), val, "mantissa_t" ); sei.m_maiMantissaT[i][j] =  val      ;
+      }
+    }
+  }
+}
+
+void SEIReader::xParseSEIMultiviewViewPosition(SEIMultiviewViewPosition& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_uvlc(pDecodedMessageOutputStream, val, "num_views_minus1"); sei.m_mvpNumViewsMinus1 = val;
+  sei.m_mvpViewPosition.resize(sei.m_mvpNumViewsMinus1 + 1);
+  for (int i = 0; i <= sei.m_mvpNumViewsMinus1; i++)
+  {
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "view_position"); sei.m_mvpViewPosition[i] = val;
+  }
+}
+
+void SEIReader::xParseSEIAlphaChannelInfo(SEIAlphaChannelInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag( pDecodedMessageOutputStream, val, "alpha_channel_cancel_flag" ); sei.m_aciCancelFlag = (val == 1);
+  if( !sei.m_aciCancelFlag )
+  {
+    sei_read_code( pDecodedMessageOutputStream, 3, val, "alpha_channel_use_idc" ); sei.m_aciUseIdc = val;
+    sei_read_code( pDecodedMessageOutputStream, 3, val, "alpha_channel_bit_depth_minus8" ); sei.m_aciBitDepthMinus8 = val;
+    sei_read_code( pDecodedMessageOutputStream, sei.m_aciBitDepthMinus8 + 9, val, "alpha_transparent_value" ); sei.m_aciTransparentValue = val;
+    sei_read_code( pDecodedMessageOutputStream, sei.m_aciBitDepthMinus8 + 9, val, "alpha_opaque_value" ); sei.m_aciOpaqueValue = val;
+    sei_read_flag( pDecodedMessageOutputStream, val, "alpha_channel_incr_flag" ); sei.m_aciIncrFlag = (val == 1);
+    sei_read_flag( pDecodedMessageOutputStream, val, "alpha_channel_clip_flag" ); sei.m_aciClipFlag = (val == 1);
+    if( sei.m_aciClipFlag )
+    {
+      sei_read_flag( pDecodedMessageOutputStream, val, "alpha_channel_clip_type_flag" ); sei.m_aciClipTypeFlag = (val == 1);
+    }
+  }
+}
+
+void SEIReader::xParseSEIDepthRepresentationInfo(SEIDepthRepresentationInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  double zNear,zFar,dMin,dMax;
+  std::vector<int> DepthNonlinearRepresentationModel;
+
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag( pDecodedMessageOutputStream, val, "z_near_flag" );    sei.m_driZNearFlag  = (val == 1);
+  sei_read_flag( pDecodedMessageOutputStream, val, "z_far_flag" );     sei.m_driZFarFlag = (val == 1);
+  sei_read_flag( pDecodedMessageOutputStream, val, "d_min_flag" );     sei.m_driDMinFlag = (val == 1);
+  sei_read_flag( pDecodedMessageOutputStream, val, "d_max_flag" );     sei.m_driDMaxFlag = (val == 1);
+  sei_read_uvlc( pDecodedMessageOutputStream, val, "depth_representation_type" ); sei.m_driDepthRepresentationType = val;
+  if( sei.m_driDMinFlag  ||  sei.m_driDMaxFlag )
+  {
+    sei_read_uvlc( pDecodedMessageOutputStream, val, "disparity_ref_view_id" ); sei.m_driDisparityRefViewId = val;
+  }
+  if( sei.m_driZNearFlag )
+  {
+    xParseSEIDepthRepInfoElement(zNear, pDecodedMessageOutputStream);
+    sei.m_driZNear = zNear;
+  }
+  if( sei.m_driZFarFlag )
+  {
+    xParseSEIDepthRepInfoElement(zFar, pDecodedMessageOutputStream);
+    sei.m_driZFar = zFar;
+  }
+  if( sei.m_driDMinFlag )
+  {
+    xParseSEIDepthRepInfoElement(dMin, pDecodedMessageOutputStream);
+    sei.m_driDMin = dMin;
+  }
+  if( sei.m_driDMaxFlag )
+  {
+    xParseSEIDepthRepInfoElement(dMax, pDecodedMessageOutputStream);
+    sei.m_driDMax = dMax;
+  }
+
+  if( sei.m_driDepthRepresentationType == 3 )
+  {
+    sei_read_uvlc( pDecodedMessageOutputStream, val, "depth_nonlinear_representation_num_minus1" ); sei.m_driDepthNonlinearRepresentationNumMinus1 = val;
+    for( int i = 1; i <= sei.m_driDepthNonlinearRepresentationNumMinus1 + 1; i++ )
+    {
+      sei_read_uvlc(pDecodedMessageOutputStream,val,"DepthNonlinearRepresentationModel" ) ;
+      sei.m_driDepthNonlinearRepresentationModel.push_back(val);
+    }
+  }
+}
+
+void SEIReader::xParseSEIDepthRepInfoElement(double& f,std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  uint32_t x_sign,x_mantissa_len,x_mantissa;
+  int x_exp;
+
+  sei_read_flag(pDecodedMessageOutputStream,     val,"da_sign_flag");  x_sign = val ? 1 : 0 ;
+  sei_read_code(pDecodedMessageOutputStream,  7, val, "da_exponent" );         x_exp = val-31;
+  sei_read_code(pDecodedMessageOutputStream,  5, val, "da_mantissa_len_minus1" );         x_mantissa_len = val+1;
+  sei_read_code(pDecodedMessageOutputStream,  x_mantissa_len, val, "da_mantissa" );         x_mantissa = val;
+  if (x_mantissa_len>=16)
+  {
+    f =1.0 +  (x_mantissa*1.0)/(1u<<(x_mantissa_len-16))/(256.0*256.0 );
+  }
+  else
+  {
+    f =1.0 +  (x_mantissa*1.0)/(1u<<x_mantissa_len);
+  }
+  double m=1.0;
+  int i;
+  if (x_exp<0)
+  {
+    for(i=0;i<-x_exp;i++)
+    {
+      m = m * 2;
+    }
+
+    f = f/m;
+  }
+  else
+  {
+    for(i=0;i<x_exp;i++)
+    {
+      m = m * 2;
+    }
+
+    f= f * m;
+  }
+  if (x_sign==1)
+  {
+    f= -f;
+  }
+}
+
+void SEIReader::xParseSEISubpictureLevelInfo(SEISubpicureLevelInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+  sei_read_code( pDecodedMessageOutputStream,   3,  val,    "sli_num_ref_levels_minus1" );            sei.m_numRefLevels  = val + 1;
+  sei_read_flag( pDecodedMessageOutputStream,       val,    "sli_cbr_constraint_flag" );              sei.m_cbrConstraintFlag = val;
+  sei_read_flag( pDecodedMessageOutputStream,       val,    "sli_explicit_fraction_present_flag" );   sei.m_explicitFractionPresentFlag = val;
+  if (sei.m_explicitFractionPresentFlag)
+  {
+    sei_read_uvlc(pDecodedMessageOutputStream,      val,    "sli_num_subpics_minus1");             sei.m_numSubpics = val + 1;
+    sei_read_code(pDecodedMessageOutputStream,  3,  val,    "sli_max_sublayers_minus1"  );            sei.m_sliMaxSublayers = val + 1;
+    sei_read_flag(pDecodedMessageOutputStream,      val,    "sli_sublayer_info_present_flag");        sei.m_sliSublayerInfoPresentFlag = val;
+    while (!isByteAligned())
+    {
+      sei_read_flag( pDecodedMessageOutputStream,   val,    "sli_alignment_zero_bit" );           CHECK (val != 0, "sli_alignment_zero_bit not equal to zero" );
+    }
+  }
+
+  sei.m_refLevelIdc.resize(sei.m_numRefLevels);
+  sei.m_nonSubpicLayersFraction.resize(sei.m_numRefLevels);
+  // sei parameters initialization
+  for (int i = 0; i < sei.m_numRefLevels; i++)
+  {
+    sei.m_nonSubpicLayersFraction[i].resize(sei.m_sliMaxSublayers);
+    sei.m_refLevelIdc[i].resize(sei.m_sliMaxSublayers);
+    for (int k = 0; k < sei.m_sliMaxSublayers; k++)
+    {
+      sei.m_refLevelIdc[i][k] = Level::LEVEL15_5;
+    }
+  }
+  if (sei.m_explicitFractionPresentFlag)
+  {
+    sei.m_refLevelFraction.resize(sei.m_numRefLevels);
+    for (int i = 0; i < sei.m_numRefLevels; i++)
+    {
+      sei.m_refLevelFraction[i].resize(sei.m_numSubpics);
+      for (int j = 0; j < sei.m_numSubpics; j++)
+      {
+        sei.m_refLevelFraction[i][j].resize(sei.m_sliMaxSublayers);
+        for (int k = 0; k < sei.m_sliMaxSublayers; k++)
+        {
+          sei.m_refLevelFraction[i][j][k] = 0;
+        }
+      }
+    }
+  }
+
+  // parsing
+  for (int k = sei.m_sliSublayerInfoPresentFlag ? 0 : sei.m_sliMaxSublayers - 1; k < sei.m_sliMaxSublayers; k++)
+  {
+    for (int i = 0; i < sei.m_numRefLevels; i++)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 8, val, "sli_non_subpic_layers_fraction[i][k]");    sei.m_nonSubpicLayersFraction[i][k] = (Level::Name) val;
+      sei_read_code(pDecodedMessageOutputStream, 8, val, "sli_ref_level_idc[i][k]");                 sei.m_refLevelIdc[i][k] = (Level::Name) val;
+
+      if (sei.m_explicitFractionPresentFlag)
+      {
+        for (int j = 0; j < sei.m_numSubpics; j++)
+        {
+          sei_read_code(pDecodedMessageOutputStream, 8, val, "sli_ref_level_fraction_minus1[i][j][k]");  sei.m_refLevelFraction[i][j][k] = val;
+        }
+      }
+    }
+  }
+
+  // update the inference of m_refLevelIdc[][] and m_refLevelFraction[][][]
+  if (!sei.m_sliSublayerInfoPresentFlag)
+  {
+    for (int k = sei.m_sliMaxSublayers - 2; k >= 0; k--)
+    {
+      for (int i = 0; i < sei.m_numRefLevels; i++)
+      {
+        sei.m_nonSubpicLayersFraction[i][k] = sei.m_nonSubpicLayersFraction[i][sei.m_sliMaxSublayers - 1];
+        sei.m_refLevelIdc[i][k] = sei.m_refLevelIdc[i][sei.m_sliMaxSublayers - 1];
+        if (sei.m_explicitFractionPresentFlag)
+        {
+          for (int j = 0; j < sei.m_numSubpics; j++)
+          {
+            sei.m_refLevelFraction[i][j][k] = sei.m_refLevelFraction[i][j][sei.m_sliMaxSublayers - 1];
+          }
+        }
+      }
+    }
+  }
+}
+
+void SEIReader::xParseSEISampleAspectRatioInfo(SEISampleAspectRatioInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+
+  sei_read_flag( pDecodedMessageOutputStream,           val,    "sari_cancel_flag" );                      sei.m_sariCancelFlag = val;
+  if (!sei.m_sariCancelFlag)
+  {
+    sei_read_flag( pDecodedMessageOutputStream,         val,    "sari_persistence_flag" );                 sei.m_sariPersistenceFlag = val;
+    sei_read_code( pDecodedMessageOutputStream,     8,  val,    "sari_aspect_ratio_idc" );                 sei.m_sariAspectRatioIdc = val;
+    if (sei.m_sariAspectRatioIdc == 255)
+    {
+      sei_read_code( pDecodedMessageOutputStream,  16,  val,    "sari_sar_width" );                        sei.m_sariSarWidth = val;
+      sei_read_code( pDecodedMessageOutputStream,  16,  val,    "sari_sar_height" );                       sei.m_sariSarHeight = val;
+    }
+  }
+}
+
+void SEIReader::xParseSEIExtendedDrapIndication(SEIExtendedDrapIndication& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  sei_read_code( pDecodedMessageOutputStream, 16, val,        "edrap_rap_id_minus1"          );   sei.m_edrapIndicationRapIdMinus1         = val;
+  sei_read_flag( pDecodedMessageOutputStream,     val,        "edrap_leading_pictures_decodable_flag" );       sei.m_edrapIndicationLeadingPicturesDecodableFlag = val;
+  sei_read_code( pDecodedMessageOutputStream, 12, val,        "edrap_reserved_zero_12bits"          );   sei.m_edrapIndicationReservedZero12Bits = val;
+  sei_read_code( pDecodedMessageOutputStream, 3, val,         "edrap_num_ref_rap_pics_minus1"          );   sei.m_edrapIndicationNumRefRapPicsMinus1 = val;
+  sei.m_edrapIndicationRefRapId.resize(sei.m_edrapIndicationNumRefRapPicsMinus1 + 1);
+  for (int i = 0; i <= sei.m_edrapIndicationNumRefRapPicsMinus1; i++)
+  {
+    sei_read_code( pDecodedMessageOutputStream, 16, val,       "edrap_ref_rap_id[i]"          );
+    sei.m_edrapIndicationRefRapId[i] = val;
+  }
+}
+
+void SEIReader::xParseSEIConstrainedRaslIndication( SEIConstrainedRaslIndication& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream )
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+}
+
+void SEIReader::xParseSEINNPostFilterCharacteristics(SEINeuralNetworkPostFilterCharacteristics& sei, uint32_t payloadSize, const SPS* sps, std::ostream* pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+    sei_read_code(pDecodedMessageOutputStream, 16, val, "nnpfc_purpose");
+    sei.m_purpose = val;
+    CHECK(sei.m_purpose >= 64 && sei.m_purpose <= 65535, "Reserved nnpfc_purpose value");
+#endif
+
+  sei_read_uvlc( pDecodedMessageOutputStream, val, "nnpfc_id" );
+  sei.m_id = val;
+  CHECK((sei.m_id >= 256 && sei.m_id <= 511) || (sei.m_id >= (1<<31) && sei.m_id <= MAX_NNPFC_ID), "Reserved nnpfc_id value, shall ignore the SEI message");
+
+  sei_read_uvlc( pDecodedMessageOutputStream, val, "nnpfc_mode_idc" );
+  sei.m_modeIdc = val;
+
+  if (sei.m_modeIdc == POST_FILTER_MODE::URI)
+  {
+    std::string val2;
+    while (!isByteAligned())
+    {
+      sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_reserved_zero_bit");
+      CHECK(val != 0, "nnpfc_reserved_zero_bit not equal to zero");
+    }
+
+    sei_read_string(pDecodedMessageOutputStream, val2, "nnpfc_uri_tag");
+    sei.m_uriTag = val2;
+
+    val2 = "";
+    sei_read_string(pDecodedMessageOutputStream, val2, "nnpfc_uri");
+    sei.m_uri = val2;
+  }
+
+  sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_property_present_flag");
+  sei.m_propertyPresentFlag = val;
+
+  if (sei.m_propertyPresentFlag)
+  {
+#if !JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_purpose");
+    sei.m_purpose = val;
+#endif
+
+    ChromaFormat chromaFormatIdc = sps->getChromaFormatIdc();
+    uint8_t      subWidthC;
+    uint8_t      subHeightC;
+    if (chromaFormatIdc == ChromaFormat::_420)
+    {
+      subWidthC  = 2;
+      subHeightC = 2;
+    }
+    else if (chromaFormatIdc == ChromaFormat::_422)
+    {
+      subWidthC  = 2;
+      subHeightC = 1;
+    }
+    else
+    {
+      subWidthC  = 1;
+      subHeightC = 1;
+    }
+
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_number_of_input_pictures_minus1");
+      sei.m_numberInputDecodedPicturesMinus1 = val;
+#endif
+
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+    if((sei.m_purpose & NNPC_PurposeType::CHROMA_UPSAMPLING) != 0)
+#else
+    if(sei.m_purpose == 2 || sei.m_purpose == 4)
+#endif
+    {
+      sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_out_sub_c_flag");
+      sei.m_outSubCFlag = val;
+
+      CHECK(((subWidthC == 2) && (subHeightC == 1) && (sei.m_outSubCFlag == 0)),
+            "If SubWidthC is equal to 2 and SubHeightC is equal to 1, nnpfc_out_sub_c_flag shall not be equal to 0");
+
+      if (sei.m_outSubCFlag)
+      {
+        sei.m_outSubWidthC = 1;
+        sei.m_outSubHeightC = 1;
+      }
+      else
+      {
+        sei.m_outSubWidthC = 2;
+        sei.m_outSubHeightC = 1;
+      }
+    }
+#if !JVET_AC0154
+    else
+    {
+      sei.m_outSubWidthC  = subWidthC;
+      sei.m_outSubHeightC = subHeightC;
+    }
+#endif
+
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+    CHECK(((subWidthC == 1) && (subHeightC == 1)) && ((sei.m_purpose & NNPC_PurposeType::CHROMA_UPSAMPLING) != 0),
+          "If SubWidthC is equal to 1 and SubHeightC is equal to 1, nnpfc_purpose & 0x02 shall be equal to 0");
+#else
+    CHECK(((subWidthC == 1) && (subHeightC == 1)) && ((sei.m_purpose == 2) || (sei.m_purpose == 4)),
+          "If SubWidthC is equal to 1 and SubHeightC is equal to 1, nnpfc_purpose shall not be equal to 2 or 4");
+#endif
+
+#if JVET_AC0154
+    if((sei.m_purpose & NNPC_PurposeType::COLOURIZATION) != 0)
+    {
+      CHECK(((chromaFormatIdc != ChromaFormat::_400) || (sei.m_purpose & NNPC_PurposeType::CHROMA_UPSAMPLING) != 0),
+            "When ChromaFormatIdc or nnpfc_purpose & 0x02 is not equal to 0, nnpfc_purpose & 0x20 shall be equal to 0");
+
+      sei_read_code(pDecodedMessageOutputStream, 2, val, "nnpfc_out_colour_format_idc");
+      sei.m_outColourFormatIdc = ChromaFormat(val);
+      CHECK(sei.m_outColourFormatIdc == ChromaFormat::_400,
+            "The value of nnpfc_out_colour_format_idc shall not be equal to 0");
+
+      sei.m_outSubWidthC  = SPS::getWinUnitX(sei.m_outColourFormatIdc);
+      sei.m_outSubHeightC = SPS::getWinUnitY(sei.m_outColourFormatIdc);
+    }
+
+    if (((sei.m_purpose & NNPC_PurposeType::CHROMA_UPSAMPLING) == 0) && ((sei.m_purpose & NNPC_PurposeType::COLOURIZATION) == 0))
+    {
+      sei.m_outSubWidthC  = subWidthC;
+      sei.m_outSubHeightC = subHeightC;
+    }
+#endif
+
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+    if((sei.m_purpose & NNPC_PurposeType::RESOLUTION_UPSAMPLING) != 0)
+#else
+    if(sei.m_purpose == 3 || sei.m_purpose == 4)
+#endif
+    {
+      sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_pic_width_in_luma_samples");
+      sei.m_picWidthInLumaSamples = val;
+      sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_pic_height_in_luma_samples");
+      sei.m_picHeightInLumaSamples = val;
+    }
+
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+    if((sei.m_purpose & NNPC_PurposeType::FRAME_RATE_UPSAMPLING) != 0)
+#else
+    if(sei.m_purpose == NNPC_PurposeType::FRAME_RATE_UPSAMPLING)
+#endif
+    {
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+      CHECK(sei.m_numberInputDecodedPicturesMinus1 <= 0, "If nnpfc_purpose is FRAME_RATE_UPSAMPLING, nnpfc_num_input_pics_minus1 shall be greater than 0");
+      sei.m_numberInterpolatedPictures.resize(sei.m_numberInputDecodedPicturesMinus1);
+#else
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_number_of_input_pictures_minus2");
+      sei.m_numberInputDecodedPicturesMinus2 = val;
+      sei.m_numberInterpolatedPictures.resize(sei.m_numberInputDecodedPicturesMinus2 + 1);
+#endif
+#if JVET_AC0154
+      bool allZeroFlag = false;
+      for (int i = 0; i < sei.m_numberInterpolatedPictures.size(); i++)
+      {
+        sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_interpolated_pictures");
+        sei.m_numberInterpolatedPictures[i] = val;
+        if(sei.m_numberInterpolatedPictures[i] > 0)
+        {
+          allZeroFlag = true;
+        }
+      }
+      CHECK(!allZeroFlag, "At least one value of nnpfc_interpolated_pics[i] shall be greater than 0");
+#else
+      for (int i = 0; i < sei.m_numberInterpolatedPictures.size(); i++)
+      {
+        sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_interpolated_pictures");
+        sei.m_numberInterpolatedPictures[i] = val;
+      }
+#endif
+
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+      for (int i = 0; i <= sei.m_numberInterpolatedPictures.size(); i++)
+      {
+        sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_input_pic_output_flag");
+        sei.m_inputPicOutputFlag[i] = val;
+      }
+#endif
+    }
+
+    sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_component_last_flag");
+    sei.m_componentLastFlag = val;
+
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_inp_format_idc");
+    sei.m_inpFormatIdc = val;
+
+    if (sei.m_inpFormatIdc == 1)
+    {
+#if JVET_AC0061_TENSOR_BITDEPTH
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_inp_tensor_bitdepth_luma_minus8");
+      sei.m_inpTensorBitDepthLumaMinus8 = val;
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_inp_tensor_bitdepth_chroma_minus8");
+      sei.m_inpTensorBitDepthChromaMinus8 = val;
+#else
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_inp_tensor_bitdepth_minus8");
+      sei.m_inpTensorBitDepthMinus8 = val;
+#endif
+    }
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_inp_order_idc");
+    sei.m_inpOrderIdc = val;
+    sei_read_uvlc(pDecodedMessageOutputStream,val,"nnpfc_aux_inp_idc");
+    sei.m_auxInpIdc = val;
+    sei_read_flag(pDecodedMessageOutputStream,val,"nnpfc_sep_col_desc_flag");
+    sei.m_sepColDescriptionFlag = val;
+
+    if (sei.m_sepColDescriptionFlag)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 8, val,"nnpfc_col_primaries");
+      sei.m_colPrimaries = val;
+      sei_read_code(pDecodedMessageOutputStream, 8, val,"nnpfc_trans_characteristics");
+      sei.m_transCharacteristics = val;
+      sei_read_code(pDecodedMessageOutputStream, 8, val,"nnpfc_matrix_coeffs");
+      sei.m_matrixCoeffs = val;
+    }
+
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_out_format_idc");
+    sei.m_outFormatIdc = val;
+
+    if (sei.m_outFormatIdc == 1)
+    {
+#if JVET_AC0061_TENSOR_BITDEPTH
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_out_tensor_bitdepth_luma_minus8");
+      sei.m_outTensorBitDepthLumaMinus8 = val;
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_out_tensor_bitdepth_chroma_minus8");
+      sei.m_outTensorBitDepthChromaMinus8 = val; 
+#else
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_out_tensor_bitdepth_minus8");
+      sei.m_outTensorBitDepthMinus8 = val;
+#endif
+    }
+
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_out_order_idc");
+    sei.m_outOrderIdc = val;
+#if JVET_AC0127_BIT_MASKING_NNPFC_PURPOSE
+    CHECK(((sei.m_purpose & NNPC_PurposeType::CHROMA_UPSAMPLING) != 0)  && (sei.m_outOrderIdc == 3), "When nnpfc_purpose & 0x02 is not equal to 0, nnpfc_out_order_idc shall not be equal to 3.")
+#endif
+
+#if JVET_AC0344_NNPFC_PATCH
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_overlap");
+    sei.m_overlap = val;
+#endif
+
+#if JVET_AC0344_NNPFC_PATCH
+    if (sei.m_constantPatchSizeFlag)
+    {
+#endif
+    sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_constant_patch_size_flag");
+    sei.m_constantPatchSizeFlag = val;
+#if JVET_AC0344_NNPFC_PATCH
+    }
+    else
+    {
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_extended_patch_width_cd_delta_minus1");
+      sei.m_extendedPatchWidthCdDeltaMinus1 = val;
+
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_extended_patch_height_cd_delta_minus1");
+      sei.m_extendedPatchHeightCdDeltaMinus1 = val;
+    }
+#else
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_overlap");
+    sei.m_overlap = val;
+#endif
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_patch_width_minus1");
+    sei.m_patchWidthMinus1 = val;
+
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_patch_height_minus1");
+    sei.m_patchHeightMinus1 = val;
+
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_overlap");
+    sei.m_overlap = val;
+
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_padding_type");
+    sei.m_paddingType = val;
+
+    if (sei.m_paddingType == NNPC_PaddingType::FIXED_PADDING)
+    {
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_luma_padding_val");
+      sei.m_lumaPadding = val;
+
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_cb_padding_val");
+      sei.m_cbPadding = val;
+
+      sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_cr_padding_val");
+      sei.m_crPadding = val;
+    }
+
+    sei_read_flag(pDecodedMessageOutputStream, val, "nnpfc_complexity_info_present_flag");
+    sei.m_complexityInfoPresentFlag = val;
+
+    if (sei.m_complexityInfoPresentFlag)
+    {
+        sei_read_code(pDecodedMessageOutputStream, 2, val, "nnpfc_parameter_type_idc");
+        sei.m_parameterTypeIdc = val;
+        if (sei.m_parameterTypeIdc != 2)
+        {
+          sei_read_code(pDecodedMessageOutputStream, 2, val, "nnpfc_log2_parameter_bit_length_minus3");
+          sei.m_log2ParameterBitLengthMinus3 = val;
+        }
+
+        sei_read_code(pDecodedMessageOutputStream, 6, val, "nnpfc_num_parameters_idc");
+        sei.m_numParametersIdc = val;
+
+        sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_num_kmac_operations_idc");
+        sei.m_numKmacOperationsIdc = val;
+
+        sei_read_uvlc(pDecodedMessageOutputStream, val, "nnpfc_total_kilobyte_size");
+        sei.m_totalKilobyteSize = val;
+    }
+  }
+
+  if (sei.m_modeIdc == POST_FILTER_MODE::ISO_IEC_15938_17)
+  {
+    while (!isByteAligned())
+    {
+      sei_read_flag( pDecodedMessageOutputStream,   val,    "nnpfc_reserved_zero_bit");
+      CHECK (val != 0, "nnpfc_reserved_zero_bit not equal to zero");
+    }
+
+    int payloadBytesRemaining = getBitstream()->getNumBitsLeft() / 8;
+#if JVET_AC0074_USE_OF_NNPFC_FOR_PIC_RATE_UPSAMPLING
+    sei.m_payloadLength = payloadBytesRemaining;
+    sei.m_payloadByte = new char[sei.m_payloadLength];
+#endif
+    int code;
+
+    std::string filename = "payloadByte" + std::to_string(sei.m_id) + ".nnr";
+
+    std::ofstream outFile(filename.c_str(), std::ofstream::binary);
+
+    for (int i = 0; i < payloadBytesRemaining; i++)
+    {
+      sei_read_scode ( pDecodedMessageOutputStream, 8, code, "nnpfc_payload_byte[i]");
+#if JVET_AC0074_USE_OF_NNPFC_FOR_PIC_RATE_UPSAMPLING
+      sei.m_payloadByte[i] = (char)code;
+#endif
+      outFile.write((char*)&code, 1);
+    }
+    outFile.close();
+  }
+}
+
+void SEIReader::xParseSEINNPostFilterActivation(SEINeuralNetworkPostFilterActivation &sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+
+#if JVET_AC0074_USE_OF_NNPFC_FOR_PIC_RATE_UPSAMPLING
+  sei_read_uvlc( pDecodedMessageOutputStream, val, "nnpfa_target_id" );
+  sei.m_targetId =val;
+  CHECK((sei.m_targetId >= 256 && sei.m_targetId <= 511) || (sei.m_targetId >= (1<<31) && sei.m_targetId <= MAX_NNPFA_ID), "Reserved nnpfa_target_id value, shall ignore the SEI message");
+#else
+  sei_read_uvlc( pDecodedMessageOutputStream, val, "nnpfa_id" );
+  sei.m_id =val;
+  CHECK((sei.m_id >= 256 && sei.m_id <= 511) || (sei.m_id >= (1<<31) && sei.m_id <= MAX_NNPFA_ID), "Reserved nnpfa_id value, shall ignore the SEI message");
+#endif
+  sei_read_flag( pDecodedMessageOutputStream, val, "nnpfa_cancel_flag" );
+  sei.m_cancelFlag = val;
+
+  if(!sei.m_cancelFlag)
+  {
+    sei_read_flag( pDecodedMessageOutputStream, val, "nnpfa_persistence_flag" );
+    sei.m_persistenceFlag = val;
+  }
+}
+
+void SEIReader::xParseSEIPhaseIndication(SEIPhaseIndication& sei, uint32_t payloadSize, std::ostream* pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  uint32_t val;
+
+  sei_read_code(pDecodedMessageOutputStream, 8, val, "hor_phase_num");
+  sei.m_horPhaseNum = val;
+  sei_read_code(pDecodedMessageOutputStream, 8, val, "hor_phase_den_minus1");
+  sei.m_horPhaseDenMinus1 = val;
+  sei_read_code(pDecodedMessageOutputStream, 8, val, "ver_phase_num");
+  sei.m_verPhaseNum = val;
+  sei_read_code(pDecodedMessageOutputStream, 8, val, "ver_phase_den_minus1");
+  sei.m_verPhaseDenMinus1 = val;
+
+  CHECK(sei.m_horPhaseNum > sei.m_horPhaseDenMinus1 + 1, "The value of hor_phase_num shall be in the range of 0 to hor_phase_den_minus1 + 1, inclusive");
+  CHECK(sei.m_verPhaseNum > sei.m_verPhaseDenMinus1 + 1, "The value of ver_phase_num shall be in the range of 0 to ver_phase_den_minus1 + 1, inclusive");
+}
+
+void SEIReader::xParseSEIPostFilterHint(SEIPostFilterHint &sei, uint32_t payloadSize,
+                                        std::ostream *pDecodedMessageOutputStream)
+{
+  uint32_t val;
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+
+  sei_read_flag(pDecodedMessageOutputStream, val, "filter_hint_cancel_flag");
+  sei.m_filterHintCancelFlag = val;
+  if (sei.m_filterHintCancelFlag == false)
+  {
+    sei_read_flag(pDecodedMessageOutputStream, val, "filter_hint_persistence_flag");
+    sei.m_filterHintPersistenceFlag = val;
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "filter_hint_size_y");
+    sei.m_filterHintSizeY = val;
+    sei_read_uvlc(pDecodedMessageOutputStream, val, "filter_hint_size_x");
+    sei.m_filterHintSizeX = val;
+    sei_read_code(pDecodedMessageOutputStream, 2, val, "filter_hint_type");
+    sei.m_filterHintType = val;
+    sei_read_flag(pDecodedMessageOutputStream, val, "filter_hint_chroma_coeff_present_flag");
+    sei.m_filterHintChromaCoeffPresentFlag = val;
+
+    sei.m_filterHintValues.resize((sei.m_filterHintChromaCoeffPresentFlag ? 3 : 1) * sei.m_filterHintSizeX
+                                  * sei.m_filterHintSizeY);
+    for (uint32_t i = 0; i < sei.m_filterHintValues.size(); i++)
+    {
+      sei_read_svlc(pDecodedMessageOutputStream, sei.m_filterHintValues[i], "filter_hint_value[][][]");
+    }
+  }
+}
+
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+void SeiCfgFileDump::write360SeiDump (std::string decoded360MessageFileName, SEIMessages& seis, const SPS* sps)
+{
+  if (m_360SEIMessageDumped)
+  {
+    return;
+  }
+
+  SEIMessages equirectangularProjectionSEIs = getSeisByType(seis, SEI::PayloadType::EQUIRECTANGULAR_PROJECTION);
+  if (!equirectangularProjectionSEIs.empty())
+  {
+    SEIEquirectangularProjection* sei = (SEIEquirectangularProjection*)equirectangularProjectionSEIs.front();
+    xDumpSEIEquirectangularProjection(*sei, sps, decoded360MessageFileName);
+    m_360SEIMessageDumped = true;
+  }
+  else
+  {
+    SEIMessages generalizedCubemapProjectionSEIs =
+      getSeisByType(seis, SEI::PayloadType::GENERALIZED_CUBEMAP_PROJECTION);
+    if (!generalizedCubemapProjectionSEIs.empty())
+    {
+      SEIGeneralizedCubemapProjection* sei = (SEIGeneralizedCubemapProjection*)generalizedCubemapProjectionSEIs.front();
+      xDumpSEIGeneralizedCubemapProjection(*sei, sps, decoded360MessageFileName);
+      m_360SEIMessageDumped = true;
+    }
+  }
+}
+
+void SeiCfgFileDump::xDumpSEIEquirectangularProjection     (SEIEquirectangularProjection &sei, const SPS* sps, std::string decoded360MessageFileName)
+{
+  if (!decoded360MessageFileName.empty())
+  {
+    FILE *fp = fopen(decoded360MessageFileName.c_str(), "w");
+    if (fp)
+    {
+      EnumArray<int, ChromaFormat> chromaFormatTable = { 400, 420, 422, 444 };
+      fprintf(fp, "InputBitDepth                 : %d    # Input bitdepth\n", sps->getBitDepth(ChannelType::LUMA));
+      fprintf(fp, "InputChromaFormat             : %d    # Ratio of luminance to chrominance samples\n", chromaFormatTable[sps->getChromaFormatIdc()]);
+      fprintf(fp, "SourceWidth                   : %d    # Input  frame width\n", sps->getMaxPicWidthInLumaSamples());
+      fprintf(fp, "SourceHeight                  : %d    # Input  frame height\n\n", sps->getMaxPicHeightInLumaSamples());
+
+      fprintf(fp, "InputGeometryType             : 0     # 0: equirectangular; 1: cubemap; 2: equalarea; this should be in the cfg of per sequence.\n");
+      if (sei.m_erpGuardBandFlag == 1)
+      {
+        fprintf(fp, "InputPERP                     : 1     # 0: original ERP input; 1: padded ERP input\n");
+        fprintf(fp, "CodingPERP                    : 0     # 0: coding with original ERP size; 1: coding with padded ERP\n");
+      }
+      fclose(fp);
+      m_360SEIMessageDumped = true;
+    }
+    else
+    {
+      msg( ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
+    }
+  }
+}
+void SeiCfgFileDump::xDumpSEIGeneralizedCubemapProjection  (SEIGeneralizedCubemapProjection &sei, const SPS* sps, std::string decoded360MessageFileName)
+{
+  if (!sei.m_gcmpCancelFlag)
+  {
+    int numFace = sei.m_gcmpPackingType == 4 || sei.m_gcmpPackingType == 5 ? 5 : 6;
+    int packingTypeTable[6][2] = {{6, 1}, {3, 2}, {2, 3}, {1, 6}, {1, 5}, {5, 1}};
+    int rotationTable[4] = {0, 90, 180, 270};
+    std::string packingTypeStr = "";
+    std::string gcmpsettingsStr = "";
+    std::ostringstream oss;
+
+    packingTypeStr += "SourceFPStructure                 : " + std::to_string(packingTypeTable[sei.m_gcmpPackingType][0]) + " " + std::to_string(packingTypeTable[sei.m_gcmpPackingType][1]);
+    gcmpsettingsStr += "InputGCMPSettings                 : ";
+
+    for (int i = 0; i < numFace; i++)
+    {
+      int rotation = rotationTable[sei.m_gcmpFaceRotation[i]];
+      if (sei.m_gcmpFaceIndex[i] == 1)
+      {
+        rotation = (rotation + 270) % 360 + 360;
+      }
+      else if (sei.m_gcmpFaceIndex[i] == 2)
+      {
+        rotation = (rotation + 180) % 360 + 360;
+      }
+      else
+      {
+        rotation += 360;
+      }
+      if (i % packingTypeTable[sei.m_gcmpPackingType][1] == 0)
+      {
+        packingTypeStr += "   ";
+      }
+      packingTypeStr += std::to_string(sei.m_gcmpFaceIndex[i]) + " " + std::to_string(rotation) + " ";
+
+      if (sei.m_gcmpMappingFunctionType == 2)
+      {
+        double a = ((int)sei.m_gcmpFunctionCoeffU[i] + 1) / 128.0;
+        double b = ((int)sei.m_gcmpFunctionCoeffV[i] + 1) / 128.0;
+        oss.str("");
+        oss<<a;
+        std::string a_str = oss.str();
+        oss.str("");
+        oss<<b;
+        std::string b_str = oss.str();
+        gcmpsettingsStr += a_str + " " + std::to_string(sei.m_gcmpFunctionUAffectedByVFlag[i]) + " " + b_str + " " + std::to_string(sei.m_gcmpFunctionVAffectedByUFlag[i]) + "   ";
+      }
+    }
+    if (!decoded360MessageFileName.empty())
+    {
+      FILE *fp = fopen(decoded360MessageFileName.c_str(), "w");
+      if (fp)
+      {
+        const EnumArray<int, ChromaFormat> chromaFormatTable = { 400, 420, 422, 444 };
+        fprintf(fp, "InputBitDepth                 : %d    # Input bitdepth\n", sps->getBitDepth(ChannelType::LUMA));
+        fprintf(fp, "InputChromaFormat             : %d    # Ratio of luminance to chrominance samples\n", chromaFormatTable[sps->getChromaFormatIdc()]);
+        fprintf(fp, "SourceWidth                   : %d    # Input  frame width\n", sps->getMaxPicWidthInLumaSamples());
+        fprintf(fp, "SourceHeight                  : %d    # Input  frame height\n\n", sps->getMaxPicHeightInLumaSamples());
+
+        fprintf(fp, "InputGeometryType             : 15    # 0: equirectangular; 1: cubemap; 2: equalarea; this should be in the cfg of per sequence.\n");
+
+        packingTypeStr += " # frame packing order: numRows numCols Row0Idx0 ROT Row0Idx1 ROT ... Row1...";
+        gcmpsettingsStr += " # mapping function parameters for each face: u coefficient, u affected by v flag, v coefficient, v affected by u flag";
+        fprintf(fp, "%s\n", packingTypeStr.c_str());
+        fprintf(fp, "InputGCMPMappingType              : %d                                    # 0: CMP; 1: EAC; 2: parameterized CMP\n", (int)sei.m_gcmpMappingFunctionType);
+        if ((int)sei.m_gcmpMappingFunctionType == 2)
+        {
+          fprintf(fp, "%s\n", gcmpsettingsStr.c_str());
+        }
+        fprintf(fp, "InputGCMPPaddingFlag              : %d                                   # 0: input without guard bands; 1: input with guard bands\n", sei.m_gcmpGuardBandFlag);
+        if (sei.m_gcmpGuardBandFlag)
+        {
+          fprintf(fp, "InputGCMPPaddingType              : %d                                   # 0: unspecified(repetitive padding is used); 1: repetitive padding; 2: copy from neighboring face; 3: geometry padding\n", (int)sei.m_gcmpGuardBandType);
+          fprintf(fp, "InputGCMPPaddingExteriorFlag      : %d                                   # 0: guard bands only on discontinuous edges; 1: guard bands on both discontinuous edges and frame boundaries\n", sei.m_gcmpGuardBandBoundaryExteriorFlag);
+          fprintf(fp, "InputGCMPPaddingSize              : %d                                   # guard band size for input GCMP\n", (int)sei.m_gcmpGuardBandSamplesMinus1 + 1);
+        }
+        fclose(fp);
+        m_360SEIMessageDumped = true;
+      }
+      else
+      {
+        msg( ERROR, "File %s could not be opened.\n", decoded360MessageFileName.c_str() );
+      }
+    }
+  }
+}
+
+#endif
+
+void SEIReader::xParseSEISEIManifest(SEIManifest &sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  unsigned int val;
+  sei_read_code(pDecodedMessageOutputStream, 16, val, "manifest_num_sei_msg_types");
+  sei.m_manifestNumSeiMsgTypes = val;
+  if (sei.m_manifestNumSeiMsgTypes > 0)
+  {
+    sei.m_manifestSeiPayloadType.resize(sei.m_manifestNumSeiMsgTypes);
+    sei.m_manifestSeiDescription.resize(sei.m_manifestNumSeiMsgTypes);
+    for (int i = 0; i < sei.m_manifestNumSeiMsgTypes; i++)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 16, val, "manifest_sei_payload_types");
+      sei.m_manifestSeiPayloadType[i] = static_cast<SEI::PayloadType>(val);
+      sei_read_code(pDecodedMessageOutputStream, 8, val, "manifest_sei_description");
+      sei.m_manifestSeiDescription[i] = val;
+    }
+  }
+}
+
+void SEIReader::xParseSEISEIPrefixIndication(SEIPrefixIndication &sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream)
+{
+  output_sei_message_header(sei, pDecodedMessageOutputStream, payloadSize);
+  unsigned int val;
+  unsigned int bitsRead = 0;
+  sei_read_code(pDecodedMessageOutputStream, 16, val, "prefix_sei_payload_type");
+  sei.m_prefixSeiPayloadType = static_cast<SEI::PayloadType>(val);
+  sei_read_code(pDecodedMessageOutputStream, 8, val, "num_sei_prefix_indications_minus1");
+  sei.m_numSeiPrefixIndicationsMinus1 = val;
+  if (sei.m_numSeiPrefixIndicationsMinus1 >= 0)
+  {
+    sei.m_numBitsInPrefixIndicationMinus1.resize(sei.m_numSeiPrefixIndicationsMinus1 + 1);
+    sei.m_seiPrefixDataBit.resize(sei.m_numSeiPrefixIndicationsMinus1 + 1);
+    for (int i = 0; i <= sei.m_numSeiPrefixIndicationsMinus1; i++)
+    {
+      sei_read_code(pDecodedMessageOutputStream, 16, val, "num_bits_in_prefix_indication_minus1");
+      sei.m_numBitsInPrefixIndicationMinus1[i] = val;
+      sei.m_seiPrefixDataBit[i].resize(sei.m_numBitsInPrefixIndicationMinus1[i] + 1);
+      for (int j = 0; j <= sei.m_numBitsInPrefixIndicationMinus1[i]; j++)
+      {
+        sei_read_code(pDecodedMessageOutputStream, 1, val, "sei_prefix_data_bit");
+        sei.m_seiPrefixDataBit[i][j] = val;
+        bitsRead += 1;
+      }
+      while (bitsRead % 8 != 0)
+      {
+        sei_read_code(pDecodedMessageOutputStream, 1, val, "byte_alignment_bit_equal_to_one"); 
+        CHECK(!val, "error to read/write SEI_prefix_indication::byte_alignment_bit_equal_to_one");
+        bitsRead += 1;
+      }
+    }
+  }
+}
+
+//! \}
diff --git a/source/Lib/SkipLib/SEIread.h b/source/Lib/SkipLib/SEIread.h
new file mode 100644
index 00000000..3892468a
--- /dev/null
+++ b/source/Lib/SkipLib/SEIread.h
@@ -0,0 +1,152 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/**
+ \file     SEIread.h
+ \brief    reading funtionality for SEI messages
+ */
+
+#ifndef __SEIREAD__
+#define __SEIREAD__
+
+#pragma once
+
+#include <fstream>
+//! \ingroup DecoderLib
+//! \{
+
+#include "CommonLib/SEI.h"
+class InputBitstream;
+
+
+class SEIReader: public VLCReader
+{
+public:
+  SEIReader() {};
+  virtual ~SEIReader() {};
+  bool parseSEImessage(InputBitstream* bs, SEIMessages& seis, const NalUnitType nalUnitType, const uint32_t nuh_layer_id, const uint32_t temporalId,const VPS *vps, const SPS *sps, HRD &hrd, std::ostream *pDecodedMessageOutputStream);
+  void parseAndExtractSEIScalableNesting(InputBitstream *bs, const NalUnitType nalUnitType, const uint32_t nuh_layer_id,
+                                         const VPS *vps, const SPS *sps, HRD &hrd, uint32_t payloadSize,
+                                         std::vector<SeiPayload> *seiList);
+  void getSEIDecodingUnitInfoDuiIdx(InputBitstream* bs, const NalUnitType nalUnitType, const uint32_t nuh_layer_id, HRD &hrd, uint32_t payloadSize, int& duiIdx);
+  bool nnpfcProcessed;
+  std::vector<int> nnpfcValues;
+  
+protected:
+  bool xReadSEImessage                        (SEIMessages& seis, const NalUnitType nalUnitType, const uint32_t nuh_layer_id, const uint32_t temporalId, const VPS *vps, const SPS *sps, HRD &hrd, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIFillerPayload                 (SEIFillerPayload &sei,                 uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIuserDataUnregistered          (SEIuserDataUnregistered &sei,          uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIDecodingUnitInfo              (SEIDecodingUnitInfo& sei,              uint32_t payloadSize, const SEIBufferingPeriod& bp, const uint32_t temporalId, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIDecodedPictureHash            (SEIDecodedPictureHash& sei,            uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIBufferingPeriod               (SEIBufferingPeriod& sei,               uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIPictureTiming                 (SEIPictureTiming& sei,                 uint32_t payloadSize, const uint32_t temporalId, const SEIBufferingPeriod& bp, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIScalableNesting               (SEIScalableNesting& sei, const NalUnitType nalUnitType, const uint32_t nuhLayerId, uint32_t payloadSize, const VPS* vps, const SPS* sps, HRD &hrd, std::ostream* decodedMessageOutputStream);
+  void xParseSEIScalableNestingBinary(SEIScalableNesting &sei, const NalUnitType nalUnitType, const uint32_t nuhLayerId,
+                                      uint32_t payloadSize, const VPS *vps, const SPS *sps, HRD &hrd,
+                                      std::ostream *decodedMessageOutputStream, std::vector<SeiPayload> *seiList);
+  void xCheckScalableNestingConstraints       (const SEIScalableNesting& sei, const NalUnitType nalUnitType, const GeneralHrdParams* generalHrd);
+  void xParseSEIFrameFieldinfo                (SEIFrameFieldInfo& sei,                uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIGreenMetadataInfo             (SEIGreenMetadataInfo& sei,             uint32_t payLoadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIDependentRAPIndication        (SEIDependentRAPIndication& sei,        uint32_t payLoadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIFramePacking                  (SEIFramePacking& sei,                  uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIDisplayOrientation            (SEIDisplayOrientation& sei,            uint32_t payloadSize,                     std::ostream* pDecodedMessageOutputStream);
+  void xParseSEIParameterSetsInclusionIndication(SEIParameterSetsInclusionIndication& sei, uint32_t payloadSize,                std::ostream* pDecodedMessageOutputStream);
+  void xParseSEIMasteringDisplayColourVolume  (SEIMasteringDisplayColourVolume& sei,  uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIAnnotatedRegions              (SEIAnnotatedRegions& sei,              uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIAlternativeTransferCharacteristics(SEIAlternativeTransferCharacteristics& sei,              uint32_t payLoadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIEquirectangularProjection     (SEIEquirectangularProjection &sei,     uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEISphereRotation                (SEISphereRotation &sei,                uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIOmniViewport                  (SEIOmniViewport& sei,                  uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIRegionWisePacking             (SEIRegionWisePacking& sei,             uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIGeneralizedCubemapProjection  (SEIGeneralizedCubemapProjection &sei,  uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIScalabilityDimensionInfo      (SEIScalabilityDimensionInfo& sei,      uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIMultiviewAcquisitionInfo      (SEIMultiviewAcquisitionInfo& sei,      uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIMultiviewViewPosition         (SEIMultiviewViewPosition& sei,         uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIAlphaChannelInfo              (SEIAlphaChannelInfo& sei,              uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIDepthRepresentationInfo       (SEIDepthRepresentationInfo& sei,       uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIDepthRepInfoElement           (double &f,std::ostream *pDecodedMessageOutputStream);
+  void xParseSEISubpictureLevelInfo           (SEISubpicureLevelInfo& sei,            uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEISampleAspectRatioInfo         (SEISampleAspectRatioInfo& sei,         uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIUserDataRegistered            (SEIUserDataRegistered& sei,            uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIFilmGrainCharacteristics      (SEIFilmGrainCharacteristics& sei,      uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIContentLightLevelInfo         (SEIContentLightLevelInfo& sei,         uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIAmbientViewingEnvironment     (SEIAmbientViewingEnvironment& sei,     uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIContentColourVolume           (SEIContentColourVolume& sei,           uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIExtendedDrapIndication        (SEIExtendedDrapIndication& sei,        uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIColourTransformInfo           (SEIColourTransformInfo& sei, uint32_t payloadSize, std::ostream* pDecodedMessageOutputStream);
+  void xParseSEISEIManifest                   (SEIManifest& sei,                      uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEISEIPrefixIndication           (SEIPrefixIndication& sei,              uint32_t payloadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIConstrainedRaslIndication     (SEIConstrainedRaslIndication& sei,     uint32_t payLoadSize,                     std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIShutterInterval(SEIShutterIntervalInfo& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEINNPostFilterCharacteristics(SEINeuralNetworkPostFilterCharacteristics& sei, uint32_t payloadSize, const SPS* sps, std::ostream* pDecodedMessageOutputStream);
+  void xParseSEINNPostFilterActivation(SEINeuralNetworkPostFilterActivation& sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+  void xParseSEIPhaseIndication(SEIPhaseIndication& sei, uint32_t payloadSize, std::ostream* pDecodedMessageOutputStream);
+  void xParseSEIProcessingOrder               (SEIProcessingOrderInfo& sei, uint32_t payloadSize, std::ostream *decodedMessageOutputStream);
+  void xParseSEIPostFilterHint(SEIPostFilterHint &sei, uint32_t payloadSize, std::ostream *pDecodedMessageOutputStream);
+
+  void sei_read_scode(std::ostream *pOS, uint32_t length, int& code, const char *pSymbolName);
+  void sei_read_code(std::ostream *pOS, uint32_t length, uint32_t &ruiCode, const char *pSymbolName);
+  void sei_read_uvlc(std::ostream *pOS,                uint32_t& ruiCode, const char *pSymbolName);
+  void sei_read_svlc(std::ostream *pOS,                int&  ruiCode, const char *pSymbolName);
+  void sei_read_flag(std::ostream *pOS,                uint32_t& ruiCode, const char *pSymbolName);
+  void sei_read_string(std::ostream* os, std::string& code, const char* symbolName);
+
+protected:
+  HRD m_nestedHrd;
+};
+
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+class SeiCfgFileDump
+{
+public:
+  SeiCfgFileDump()
+  : m_360SEIMessageDumped(false)
+  {};
+  virtual ~SeiCfgFileDump() {};
+
+  void write360SeiDump (std::string decoded360MessageFileName, SEIMessages& seis, const SPS* sps);
+
+protected:
+  void xDumpSEIEquirectangularProjection     (SEIEquirectangularProjection &sei, const SPS* sps, std::string decoded360MessageFileName);
+  void xDumpSEIGeneralizedCubemapProjection  (SEIGeneralizedCubemapProjection &sei, const SPS* sps, std::string decoded360MessageFileName);
+
+  bool m_360SEIMessageDumped;
+
+};
+
+
+#endif
+
+//! \}
+
+#endif
diff --git a/source/Lib/SkipLib/VLCReader.cpp b/source/Lib/SkipLib/VLCReader.cpp
new file mode 100644
index 00000000..db0f35ed
--- /dev/null
+++ b/source/Lib/SkipLib/VLCReader.cpp
@@ -0,0 +1,5228 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     VLCWReader.cpp
+ *  \brief    Reader for high level syntax
+ */
+
+//! \ingroup DecoderLib
+//! \{
+
+#include "VLCReader.h"
+
+#include "CommonLib/CommonDef.h"
+#include "CommonLib/dtrace_next.h"
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+#include "CommonLib/CodingStatistics.h"
+#endif
+#include "CommonLib/AdaptiveLoopFilter.h"
+#include "CommonLib/ProfileTierLevel.h"
+
+// ====================================================================================================================
+// Protected member functions
+// ====================================================================================================================
+
+#if ENABLE_TRACING || RExt__DECODER_DEBUG_BIT_STATISTICS
+void  VLCReader::xReadCode( const uint32_t length, uint32_t& value, const char *symbolName )
+#else
+void  VLCReader::xReadCode( const uint32_t length, uint32_t& value, const char* )
+#endif
+{
+  CHECK(length == 0, "Reading a code of length '0'");
+  m_pcBitstream->read(length, value);
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP(symbolName, length, value);
+#endif
+
+#if ENABLE_TRACING
+  if (length < 10)
+  {
+    DTRACE( g_trace_ctx, D_HEADER, "%-50s u(%d)  : %u\n", symbolName, length, value );
+  }
+  else
+  {
+    DTRACE( g_trace_ctx, D_HEADER, "%-50s u(%d) : %u\n", symbolName, length, value );
+  }
+#endif
+}
+
+#if ENABLE_TRACING || RExt__DECODER_DEBUG_BIT_STATISTICS
+void  VLCReader::xReadUvlc(uint32_t& value, const char *symbolName )
+#else
+void  VLCReader::xReadUvlc(uint32_t& value, const char* )
+#endif
+{
+  uint32_t suffix    = 0;
+  uint32_t prefixBit = 0;
+  m_pcBitstream->read( 1, prefixBit );
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  uint32_t totalLen=1;
+#endif
+
+  if( 0 == prefixBit )
+  {
+    uint32_t length = 0;
+
+    while( prefixBit == 0 )
+    {
+      m_pcBitstream->read( 1, prefixBit );
+      length++;
+    }
+
+    m_pcBitstream->read(length, suffix);
+    suffix += (1 << length) - 1;
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+    totalLen += length + length;
+#endif
+  }
+
+  value = suffix;
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP(symbolName, int(totalLen), value);
+#endif
+
+#if ENABLE_TRACING
+  DTRACE( g_trace_ctx, D_HEADER, "%-50s ue(v) : %u\n", symbolName, value );
+#endif
+}
+
+#if ENABLE_TRACING || RExt__DECODER_DEBUG_BIT_STATISTICS
+void  VLCReader::xReadSvlc( int& value, const char *symbolName )
+#else
+void  VLCReader::xReadSvlc( int& value, const char* )
+#endif
+{
+  uint32_t prefixBit = 0;
+  uint32_t suffix = 0;
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  uint32_t totalLen=1;
+#endif
+
+  m_pcBitstream->read(1, prefixBit);
+
+  if (0 == prefixBit)
+  {
+    uint32_t length = 0;
+
+    while ( prefixBit == 0 )
+    {
+      m_pcBitstream->read(1, prefixBit);
+      length++;
+    }
+
+    m_pcBitstream->read(length, suffix);
+
+    suffix += (1 << length);
+    value = (suffix & 1) ? -(int) (suffix >> 1) : (int) (suffix >> 1);
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+    totalLen += length + length;
+#endif
+  }
+  else
+  {
+    value = 0;
+  }
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP(symbolName, int(totalLen), suffix);
+#endif
+
+#if ENABLE_TRACING
+  DTRACE( g_trace_ctx, D_HEADER, "%-50s se(v) : %d\n", symbolName, value );
+#endif
+}
+
+#if ENABLE_TRACING || RExt__DECODER_DEBUG_BIT_STATISTICS
+void VLCReader::xReadFlag( uint32_t& value, const char *symbolName )
+#else
+void VLCReader::xReadFlag( uint32_t& value, const char* )
+#endif
+{
+  m_pcBitstream->read( 1, value );
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP(symbolName, 1, int(/*ruiCode*/0));
+#endif
+
+#if ENABLE_TRACING
+  DTRACE( g_trace_ctx, D_HEADER, "%-50s u(1)  : %d\n", symbolName, value );
+#endif
+}
+
+#if ENABLE_TRACING || RExt__DECODER_DEBUG_BIT_STATISTICS
+void VLCReader::xReadString( std::string& value, const char *symbolName )
+#else
+void VLCReader::xReadString( std::string& value, const char*  )
+#endif
+{
+  uint32_t code;
+  value = "";
+  do
+  {
+    m_pcBitstream->read(8, code);
+    if (code != 0)
+    {
+      value += (char) code;
+    }
+  } while (code != 0);
+
+#if ENABLE_TRACING
+  DTRACE(g_trace_ctx, D_HEADER, "%-50s u(1)  : %s\n", symbolName, value.c_str());
+#endif
+}
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS || ENABLE_TRACING
+void VLCReader::xReadSCode (const uint32_t length, int& value, const char *symbolName )
+#else
+void VLCReader::xReadSCode (const uint32_t length, int& value, const char* )
+#endif
+{
+  uint32_t val;
+  CHECK ( length < 1 || length > 32, "Syntax element length must be in range 1..32");
+  m_pcBitstream->read (length, val);
+  value = length>=32 ? int(val) : ( (-int( val & (uint32_t(1)<<(length-1)))) | int(val) );
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP(symbolName, length, value);
+#endif
+#if ENABLE_TRACING
+  if (length < 10)
+  {
+    DTRACE( g_trace_ctx, D_HEADER, "%-50s i(%d)  : %d\n", symbolName, length, value );
+  }
+  else
+  {
+    DTRACE( g_trace_ctx, D_HEADER, "%-50s i(%d) : %d\n", symbolName, length, value );
+  }
+#endif
+}
+
+void VLCReader::xReadRbspTrailingBits()
+{
+  uint32_t bit;
+  xReadFlag( bit, "rbsp_stop_one_bit");
+  CHECK(bit!=1, "Trailing bit not '1'");
+  int cnt = 0;
+  while (m_pcBitstream->getNumBitsUntilByteAligned())
+  {
+    xReadFlag( bit, "rbsp_alignment_zero_bit");
+    CHECK(bit!=0, "Alignment bit is not '0'");
+    cnt++;
+  }
+  CHECK(cnt >= 8, "Read more than '8' trailing bits");
+}
+
+void AUDReader::parseAccessUnitDelimiter(InputBitstream* bs, uint32_t &audIrapOrGdrAuFlag, uint32_t &picType)
+{
+  setBitstream(bs);
+
+#if ENABLE_TRACING
+  xTraceAccessUnitDelimiter();
+#endif
+
+  xReadFlag (audIrapOrGdrAuFlag, "aud_irap_or_gdr_au_flag");
+  xReadCode (3, picType, "pic_type");
+  xReadRbspTrailingBits();
+}
+
+void FDReader::parseFillerData(InputBitstream* bs, uint32_t &fdSize)
+{
+  setBitstream(bs);
+#if ENABLE_TRACING
+  xTraceFillerData();
+#endif
+  uint32_t ffByte;
+  fdSize = 0;
+  while( m_pcBitstream->getNumBitsLeft() >8 )
+  {
+    xReadCode (8, ffByte, "ff_byte");
+    CHECK(ffByte!=0xff, "Invalid filler data : not '0xff'");
+    fdSize++;
+  }
+  xReadRbspTrailingBits();
+}
+
+// ====================================================================================================================
+// Constructor / destructor / create / destroy
+// ====================================================================================================================
+
+HLSyntaxReader::HLSyntaxReader()
+{
+}
+
+HLSyntaxReader::~HLSyntaxReader()
+{
+
+}
+
+// ====================================================================================================================
+// Public member functions
+// ====================================================================================================================
+
+void HLSyntaxReader::copyRefPicList(SPS* sps, ReferencePictureList* source_rpl, ReferencePictureList* dest_rp)
+{
+  dest_rp->setNumberOfShorttermPictures(source_rpl->getNumberOfShorttermPictures());
+
+  dest_rp->setNumberOfInterLayerPictures( sps->getInterLayerPresentFlag() ? source_rpl->getNumberOfInterLayerPictures() : 0 );
+
+  if( sps->getLongTermRefsPresent() )
+  {
+    dest_rp->setLtrpInSliceHeaderFlag(source_rpl->getLtrpInSliceHeaderFlag());
+    dest_rp->setNumberOfLongtermPictures( source_rpl->getNumberOfLongtermPictures() );
+  }
+  else
+  {
+    dest_rp->setNumberOfLongtermPictures(0);
+  }
+
+  uint32_t numRefPic = dest_rp->getNumRefEntries();
+
+  for( int ii = 0; ii < numRefPic; ii++ )
+  {
+    dest_rp->setRefPicIdentifier( ii, source_rpl->getRefPicIdentifier( ii ), source_rpl->isRefPicLongterm( ii ), source_rpl->isInterLayerRefPic( ii ), source_rpl->getInterLayerRefPicIdx( ii ) );
+  }
+}
+
+void HLSyntaxReader::parseRefPicList(SPS* sps, ReferencePictureList* rpl, int rplIdx)
+{
+  uint32_t code;
+  xReadUvlc(code, "num_ref_entries[ listIdx ][ rplsIdx ]");
+  uint32_t numRefPic = code;
+  uint32_t numStrp = 0;
+  uint32_t numLtrp = 0;
+  uint32_t numIlrp = 0;
+
+  if (sps->getLongTermRefsPresent() && numRefPic > 0 && rplIdx != -1)
+  {
+    xReadFlag(code, "ltrp_in_slice_header_flag[ listIdx ][ rplsIdx ]");
+    rpl->setLtrpInSliceHeaderFlag(code);
+  }
+  else if(sps->getLongTermRefsPresent())
+  {
+    rpl->setLtrpInSliceHeaderFlag( 1 );
+  }
+
+  bool isLongTerm;
+  int prevDelta = MAX_INT;
+  int deltaValue = 0;
+  bool firstSTRP = true;
+
+  rpl->setInterLayerPresentFlag( sps->getInterLayerPresentFlag() );
+
+  for (int ii = 0; ii < numRefPic; ii++)
+  {
+    uint32_t isInterLayerRefPic = 0;
+
+    if( rpl->getInterLayerPresentFlag() )
+    {
+      xReadFlag( isInterLayerRefPic, "inter_layer_ref_pic_flag[ listIdx ][ rplsIdx ][ i ]" );
+
+      if( isInterLayerRefPic )
+      {
+        xReadUvlc( code, "ilrp_idx[ listIdx ][ rplsIdx ][ i ]" );
+        rpl->setRefPicIdentifier( ii, 0, true, true, code );
+        numIlrp++;
+      }
+    }
+
+    if( !isInterLayerRefPic )
+    {
+      isLongTerm = false;
+      if (sps->getLongTermRefsPresent())
+      {
+        xReadFlag(code, "st_ref_pic_flag[ listIdx ][ rplsIdx ][ i ]");
+        isLongTerm = (code == 1) ? false : true;
+      }
+
+      if (!isLongTerm)
+      {
+        xReadUvlc(code, "abs_delta_poc_st[ listIdx ][ rplsIdx ][ i ]");
+        if ((!sps->getUseWP() && !sps->getUseWPBiPred()) || (ii == 0))
+        {
+          code++;
+        }
+        int readValue = code;
+        if (readValue > 0)
+        {
+          xReadFlag(code, "strp_entry_sign_flag[ listIdx ][ rplsIdx ][ i ]");
+          if (code)
+          {
+            readValue = -readValue;
+          }
+        }
+        if (firstSTRP)
+        {
+          firstSTRP = false;
+          prevDelta = deltaValue = readValue;
+        }
+        else
+        {
+          deltaValue = prevDelta + readValue;
+          prevDelta  = deltaValue;
+        }
+
+        rpl->setRefPicIdentifier(ii, deltaValue, isLongTerm, false, 0);
+        numStrp++;
+      }
+      else
+      {
+        if (!rpl->getLtrpInSliceHeaderFlag())
+        {
+          xReadCode(sps->getBitsForPOC(), code, "poc_lsb_lt[listIdx][rplsIdx][j]");
+        }
+        rpl->setRefPicIdentifier(ii, code, isLongTerm, false, 0);
+        numLtrp++;
+      }
+    }
+  }
+  rpl->setNumberOfShorttermPictures(numStrp);
+  rpl->setNumberOfLongtermPictures(numLtrp);
+  rpl->setNumberOfInterLayerPictures( numIlrp );
+}
+
+void HLSyntaxReader::parsePPS( PPS* pcPPS )
+{
+#if ENABLE_TRACING
+  xTracePPSHeader ();
+#endif
+  uint32_t  uiCode;
+
+  int   iCode;
+  xReadCode(6, uiCode, "pps_pic_parameter_set_id");
+  CHECK(uiCode > 63, "PPS id exceeds boundary (63)");
+  pcPPS->setPPSId (uiCode);
+
+  xReadCode(4, uiCode, "pps_seq_parameter_set_id");
+  pcPPS->setSPSId (uiCode);
+
+  xReadFlag( uiCode, "pps_mixed_nalu_types_in_pic_flag" );       pcPPS->setMixedNaluTypesInPicFlag( uiCode == 1 );
+
+  xReadUvlc( uiCode, "pps_pic_width_in_luma_samples" );          pcPPS->setPicWidthInLumaSamples( uiCode );
+  xReadUvlc( uiCode, "pps_pic_height_in_luma_samples" );         pcPPS->setPicHeightInLumaSamples( uiCode );
+  xReadFlag( uiCode, "pps_conformance_window_flag");
+  pcPPS->setConformanceWindowFlag( uiCode );
+  if (uiCode != 0)
+  {
+    Window& conf = pcPPS->getConformanceWindow();
+    xReadUvlc(uiCode, "pps_conf_win_left_offset");               conf.setWindowLeftOffset(uiCode);
+    xReadUvlc(uiCode, "pps_conf_win_right_offset");              conf.setWindowRightOffset(uiCode);
+    xReadUvlc(uiCode, "pps_conf_win_top_offset");                conf.setWindowTopOffset(uiCode);
+    xReadUvlc(uiCode, "pps_conf_win_bottom_offset");             conf.setWindowBottomOffset(uiCode);
+  }
+  xReadFlag( uiCode, "pps_scaling_window_explicit_signalling_flag" );
+  pcPPS->setExplicitScalingWindowFlag( uiCode );
+  if( uiCode != 0 )
+  {
+    Window &scalingWindow = pcPPS->getScalingWindow();
+    xReadSvlc( iCode, "pps_scaling_win_left_offset" );               scalingWindow.setWindowLeftOffset( iCode );
+    xReadSvlc( iCode, "pps_scaling_win_right_offset" );              scalingWindow.setWindowRightOffset( iCode );
+    xReadSvlc( iCode, "pps_scaling_win_top_offset" );                scalingWindow.setWindowTopOffset( iCode );
+    xReadSvlc( iCode, "pps_scaling_win_bottom_offset" );             scalingWindow.setWindowBottomOffset( iCode );
+  }
+  else
+  {
+    Window &scalingWindow = pcPPS->getScalingWindow();
+    Window& conf = pcPPS->getConformanceWindow();
+    scalingWindow.setWindowLeftOffset( conf.getWindowLeftOffset() );
+    scalingWindow.setWindowRightOffset( conf.getWindowRightOffset() );
+    scalingWindow.setWindowTopOffset( conf.getWindowTopOffset() );
+    scalingWindow.setWindowBottomOffset( conf.getWindowBottomOffset() );
+  }
+
+  xReadFlag( uiCode, "pps_output_flag_present_flag" );                    pcPPS->setOutputFlagPresentFlag( uiCode==1 );
+
+  xReadFlag( uiCode, "pps_no_pic_partition_flag");                     pcPPS->setNoPicPartitionFlag(uiCode == 1);
+  xReadFlag( uiCode, "pps_subpic_id_mapping_present_flag" );           pcPPS->setSubPicIdMappingInPpsFlag( uiCode != 0 );
+  if( pcPPS->getSubPicIdMappingInPpsFlag() )
+  {
+    if( !pcPPS->getNoPicPartitionFlag() )
+    {
+      xReadUvlc(uiCode, "pps_num_subpics_minus1");                         pcPPS->setNumSubPics(uiCode + 1);
+    }
+    else
+    {
+      pcPPS->setNumSubPics(1);
+    }
+    CHECK( uiCode > MAX_NUM_SUB_PICS-1,  "Number of sub-pictures exceeds limit");
+
+    xReadUvlc( uiCode, "pps_subpic_id_len_minus1" );                       pcPPS->setSubPicIdLen( uiCode + 1 );
+    CHECK( uiCode > 15, "Invalid pps_subpic_id_len_minus1 signalled");
+
+    CHECK((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
+    for( int picIdx = 0; picIdx < pcPPS->getNumSubPics( ); picIdx++ )
+    {
+      xReadCode( pcPPS->getSubPicIdLen( ), uiCode, "pps_subpic_id[i]" );   pcPPS->setSubPicId( picIdx, uiCode );
+    }
+  }
+  if(!pcPPS->getNoPicPartitionFlag())
+  {
+    int colIdx, rowIdx;
+    pcPPS->resetTileSliceInfo();
+
+    // CTU size - required to match size in SPS
+    xReadCode(2, uiCode, "pps_log2_ctu_size_minus5");                 pcPPS->setLog2CtuSize(uiCode + 5);
+    CHECK(uiCode > 2, "pps_log2_ctu_size_minus5 must be less than or equal to 2");
+
+    // number of explicit tile columns/rows
+    xReadUvlc( uiCode, "pps_num_exp_tile_columns_minus1" );               pcPPS->setNumExpTileColumns( uiCode + 1 );
+    xReadUvlc( uiCode, "pps_num_exp_tile_rows_minus1" );                  pcPPS->setNumExpTileRows( uiCode + 1 );
+    CHECK(pcPPS->getNumExpTileColumns() > MAX_TILE_COLS,              "Number of explicit tile columns exceeds valid range");
+
+    // tile sizes
+    for( colIdx = 0; colIdx < pcPPS->getNumExpTileColumns(); colIdx++ )
+    {
+      xReadUvlc( uiCode, "pps_tile_column_width_minus1[i]" );             pcPPS->addTileColumnWidth( uiCode + 1 );
+      CHECK(uiCode  > (pcPPS->getPicWidthInCtu()-1),                 "The value of pps_tile_column_width_minus1[i] shall be in the range of 0 to PicWidthInCtbY-1, inclusive");
+    }
+    for( rowIdx = 0; rowIdx < pcPPS->getNumExpTileRows(); rowIdx++ )
+    {
+      xReadUvlc( uiCode, "pps_tile_row_height_minus1[i]" );               pcPPS->addTileRowHeight( uiCode + 1 );
+      CHECK(uiCode > (pcPPS->getPicHeightInCtu() - 1),                "The value of pps_tile_row_height_minus shall be in the range of 0 to PicHeightInCtbY-1, inclusive");
+    }
+    pcPPS->initTiles();
+    // rectangular slice signalling
+    if (pcPPS->getNumTiles() > 1)
+    {
+      xReadCode(1, uiCode, "pps_loop_filter_across_tiles_enabled_flag");    pcPPS->setLoopFilterAcrossTilesEnabledFlag(uiCode == 1);
+      xReadCode(1, uiCode, "pps_rect_slice_flag");
+    }
+    else
+    {
+      pcPPS->setLoopFilterAcrossTilesEnabledFlag(false);
+      uiCode = 1;
+    }
+    pcPPS->setRectSliceFlag(uiCode == 1);
+    if (pcPPS->getRectSliceFlag())
+    {
+      xReadFlag(uiCode, "pps_single_slice_per_subpic_flag");            pcPPS->setSingleSlicePerSubPicFlag(uiCode == 1);
+    }
+    else
+    {
+      pcPPS->setSingleSlicePerSubPicFlag(0);
+    }
+    if (pcPPS->getRectSliceFlag() && !(pcPPS->getSingleSlicePerSubPicFlag()))
+    {
+      int32_t tileIdx = 0;
+
+      xReadUvlc( uiCode, "pps_num_slices_in_pic_minus1" );                pcPPS->setNumSlicesInPic( uiCode + 1 );
+      CHECK(pcPPS->getNumSlicesInPic() > MAX_SLICES,                  "Number of slices in picture exceeds valid range");
+      if ((pcPPS->getNumSlicesInPic() - 1) > 1)
+      {
+        xReadCode(1, uiCode, "pps_tile_idx_delta_present_flag");
+        pcPPS->setTileIdxDeltaPresentFlag(uiCode == 1);
+      }
+      else
+      {
+        pcPPS->setTileIdxDeltaPresentFlag(0);
+      }
+      pcPPS->initRectSlices();
+
+      // read rectangular slice parameters
+      for( int i = 0; i < pcPPS->getNumSlicesInPic()-1; i++ )
+      {
+        pcPPS->setSliceTileIdx( i, tileIdx );
+
+        // complete tiles within a single slice
+        if( ( tileIdx % pcPPS->getNumTileColumns() ) != pcPPS->getNumTileColumns() - 1 )
+        {
+          xReadUvlc( uiCode, "pps_slice_width_in_tiles_minus1[i]" );
+          pcPPS->setSliceWidthInTiles ( i, uiCode + 1 );
+        }
+        else
+        {
+          pcPPS->setSliceWidthInTiles( i, 1 );
+        }
+
+        if( tileIdx / pcPPS->getNumTileColumns() != pcPPS->getNumTileRows() - 1  &&
+         ( pcPPS->getTileIdxDeltaPresentFlag() || tileIdx % pcPPS->getNumTileColumns() == 0 ) )
+        {
+          xReadUvlc( uiCode, "pps_slice_height_in_tiles_minus1[i]" );
+          pcPPS->setSliceHeightInTiles( i, uiCode + 1 );
+        }
+        else
+        {
+          if( ( tileIdx / pcPPS->getNumTileColumns() ) == pcPPS->getNumTileRows() - 1 )
+          {
+            pcPPS->setSliceHeightInTiles( i, 1 );
+          }
+          else
+          {
+            pcPPS->setSliceHeightInTiles( i, pcPPS->getSliceHeightInTiles( i - 1 ) );
+          }
+        }
+
+        // multiple slices within a single tile special case
+        if( pcPPS->getSliceWidthInTiles(i) == 1 && pcPPS->getSliceHeightInTiles(i) == 1 )
+        {
+          if( pcPPS->getTileRowHeight(tileIdx / pcPPS->getNumTileColumns()) > 1 )
+          {
+            xReadUvlc(uiCode, "pps_num_exp_slices_in_tile[i]");
+            if (uiCode == 0)
+            {
+              pcPPS->setNumSlicesInTile(i, 1);
+              pcPPS->setSliceHeightInCtu(i, pcPPS->getTileRowHeight(tileIdx / pcPPS->getNumTileColumns()));
+            }
+            else
+            {
+              uint32_t numExpSliceInTile = uiCode;
+              uint32_t remTileRowHeight  = pcPPS->getTileRowHeight(tileIdx / pcPPS->getNumTileColumns());
+              int j = 0;
+
+              for( ; j < numExpSliceInTile; j++ )
+              {
+                xReadUvlc(uiCode, "pps_exp_slice_height_in_ctus_minus1[i]");
+                pcPPS->setSliceHeightInCtu(i + j, uiCode + 1);
+                remTileRowHeight -= (uiCode + 1);
+              }
+              uint32_t uniformSliceHeight = uiCode + 1;
+
+              while( remTileRowHeight >= uniformSliceHeight )
+              {
+                pcPPS->setSliceHeightInCtu(i + j, uniformSliceHeight);
+                remTileRowHeight -= uniformSliceHeight;
+                j++;
+              }
+              if( remTileRowHeight > 0 )
+              {
+                pcPPS->setSliceHeightInCtu(i + j, remTileRowHeight);
+                j++;
+              }
+              for( int k = 0; k < j; k++ )
+              {
+                pcPPS->setNumSlicesInTile(i + k, j);
+                pcPPS->setSliceWidthInTiles(i + k, 1);
+                pcPPS->setSliceHeightInTiles(i + k, 1);
+                pcPPS->setSliceTileIdx(i + k, tileIdx);
+              }
+              i += (j - 1);
+            }
+          }
+          else
+          {
+            pcPPS->setNumSlicesInTile(i, 1);
+            pcPPS->setSliceHeightInCtu(i, pcPPS->getTileRowHeight(tileIdx / pcPPS->getNumTileColumns()));
+          }
+        }
+
+        // tile index offset to start of next slice
+        if( i < pcPPS->getNumSlicesInPic()-1 )
+        {
+          if( pcPPS->getTileIdxDeltaPresentFlag() )
+          {
+            int32_t  tileIdxDelta;
+            xReadSvlc( tileIdxDelta, "pps_tile_idx_delta[i]" );
+            tileIdx += tileIdxDelta;
+            CHECK( tileIdx < 0 || tileIdx >= pcPPS->getNumTiles(), "Invalid pps_tile_idx_delta.");
+          }
+          else
+          {
+            tileIdx += pcPPS->getSliceWidthInTiles( i );
+            if( tileIdx % pcPPS->getNumTileColumns() == 0)
+            {
+              tileIdx += (pcPPS->getSliceHeightInTiles( i ) - 1) * pcPPS->getNumTileColumns();
+            }
+          }
+        }
+      }
+      pcPPS->setSliceTileIdx(pcPPS->getNumSlicesInPic()-1, tileIdx );
+    }
+
+    if (pcPPS->getRectSliceFlag() == 0 || pcPPS->getSingleSlicePerSubPicFlag() || pcPPS->getNumSlicesInPic() > 1)
+    {
+      xReadCode(1, uiCode, "pps_loop_filter_across_slices_enabled_flag");   pcPPS->setLoopFilterAcrossSlicesEnabledFlag( uiCode == 1 );
+    }
+    else
+    {
+      pcPPS->setLoopFilterAcrossSlicesEnabledFlag( false );
+    }
+  }
+  else
+  {
+    pcPPS->setSingleSlicePerSubPicFlag(1);
+  }
+
+  xReadFlag( uiCode,   "pps_cabac_init_present_flag" );            pcPPS->setCabacInitPresentFlag( uiCode ? true : false );
+
+  xReadUvlc(uiCode, "pps_num_ref_idx_default_active_minus1[0]");
+  CHECK(uiCode >= MAX_NUM_ACTIVE_REF,
+        "The value of pps_num_ref_idx_default_active_minus1[0] shall be in the range of 0 to 14, inclusive");
+  pcPPS->setNumRefIdxDefaultActive(REF_PIC_LIST_0, uiCode + 1);
+
+  xReadUvlc(uiCode, "pps_num_ref_idx_default_active_minus1[1]");
+  CHECK(uiCode >= MAX_NUM_ACTIVE_REF,
+        "The value of pps_num_ref_idx_default_active_minus1[1] shall be in the range of 0 to 14, inclusive");
+  pcPPS->setNumRefIdxDefaultActive(REF_PIC_LIST_1, uiCode + 1);
+
+  xReadFlag(uiCode, "pps_rpl1_idx_present_flag");
+  pcPPS->setRpl1IdxPresentFlag(uiCode);
+  xReadFlag( uiCode, "pps_weighted_pred_flag" );          // Use of Weighting Prediction (P_SLICE)
+  pcPPS->setUseWP( uiCode==1 );
+  xReadFlag( uiCode, "pps_weighted_bipred_flag" );         // Use of Bi-Directional Weighting Prediction (B_SLICE)
+  pcPPS->setWPBiPred( uiCode==1 );
+  xReadFlag(uiCode, "pps_ref_wraparound_enabled_flag");           pcPPS->setWrapAroundEnabledFlag( uiCode ? true : false );
+  if (pcPPS->getWrapAroundEnabledFlag())
+  {
+    xReadUvlc(uiCode, "pps_ref_wraparound_offset");
+    pcPPS->setPicWidthMinusWrapAroundOffset(uiCode);
+  }
+  else
+  {
+    pcPPS->setPicWidthMinusWrapAroundOffset(0);
+  }
+
+  xReadSvlc(iCode, "pps_init_qp_minus26" );                            pcPPS->setPicInitQPMinus26(iCode);
+  xReadFlag( uiCode, "pps_cu_qp_delta_enabled_flag" );            pcPPS->setUseDQP( uiCode ? true : false );
+  xReadFlag(uiCode, "pps_chroma_tool_offsets_present_flag");
+  pcPPS->setPPSChromaToolFlag(uiCode ? true : false);
+  if (pcPPS->getPPSChromaToolFlag())
+  {
+    xReadSvlc(iCode, "pps_cb_qp_offset");
+    pcPPS->setQpOffset(COMPONENT_Cb, iCode);
+    CHECK(pcPPS->getQpOffset(COMPONENT_Cb) < -12, "Invalid Cb QP offset");
+    CHECK(pcPPS->getQpOffset(COMPONENT_Cb) > 12, "Invalid Cb QP offset");
+
+    xReadSvlc(iCode, "pps_cr_qp_offset");
+    pcPPS->setQpOffset(COMPONENT_Cr, iCode);
+    CHECK(pcPPS->getQpOffset(COMPONENT_Cr) < -12, "Invalid Cr QP offset");
+    CHECK(pcPPS->getQpOffset(COMPONENT_Cr) > 12, "Invalid Cr QP offset");
+
+    xReadFlag(uiCode, "pps_joint_cbcr_qp_offset_present_flag");
+    pcPPS->setJointCbCrQpOffsetPresentFlag(uiCode ? true : false);
+
+    if (pcPPS->getJointCbCrQpOffsetPresentFlag())
+    {
+      xReadSvlc(iCode, "pps_joint_cbcr_qp_offset_value");
+    }
+    else
+    {
+      iCode = 0;
+    }
+    pcPPS->setQpOffset(JOINT_CbCr, iCode);
+
+    CHECK(pcPPS->getQpOffset(JOINT_CbCr) < -12, "Invalid CbCr QP offset");
+    CHECK(pcPPS->getQpOffset(JOINT_CbCr) > 12, "Invalid CbCr QP offset");
+
+    CHECK(MAX_NUM_COMPONENT > 3, "Invalid maximal number of components");
+
+    xReadFlag(uiCode, "pps_slice_chroma_qp_offsets_present_flag");
+    pcPPS->setSliceChromaQpFlag(uiCode ? true : false);
+
+    xReadFlag(uiCode, "pps_cu_chroma_qp_offset_list_enabled_flag");
+    if (uiCode == 0)
+    {
+      pcPPS->clearChromaQpOffsetList();
+    }
+    else
+    {
+      uint32_t tableSizeMinus1 = 0;
+      xReadUvlc(tableSizeMinus1, "pps_chroma_qp_offset_list_len_minus1");
+      CHECK(tableSizeMinus1 >= MAX_QP_OFFSET_LIST_SIZE, "Table size exceeds maximum");
+
+      for (int cuChromaQpOffsetIdx = 0; cuChromaQpOffsetIdx <= (tableSizeMinus1); cuChromaQpOffsetIdx++)
+      {
+        int cbOffset;
+        int crOffset;
+        int jointCbCrOffset;
+        xReadSvlc(cbOffset, "pps_cb_qp_offset_list[i]");
+        CHECK(cbOffset < -12 || cbOffset > 12, "Invalid chroma QP offset");
+        xReadSvlc(crOffset, "pps_cr_qp_offset_list[i]");
+        CHECK(crOffset < -12 || crOffset > 12, "Invalid chroma QP offset");
+        if (pcPPS->getJointCbCrQpOffsetPresentFlag())
+        {
+          xReadSvlc(jointCbCrOffset, "pps_joint_cbcr_qp_offset_list[i]");
+        }
+        else
+        {
+          jointCbCrOffset = 0;
+        }
+        CHECK(jointCbCrOffset < -12 || jointCbCrOffset > 12, "Invalid chroma QP offset");
+        // table uses +1 for index (see comment inside the function)
+        pcPPS->setChromaQpOffsetListEntry(cuChromaQpOffsetIdx + 1, cbOffset, crOffset, jointCbCrOffset);
+      }
+      CHECK(pcPPS->getChromaQpOffsetListLen() != tableSizeMinus1 + 1, "Invalid chroma QP offset list length");
+    }
+  }
+  else
+  {
+    pcPPS->setQpOffset(COMPONENT_Cb, 0);
+    pcPPS->setQpOffset(COMPONENT_Cr, 0);
+    pcPPS->setJointCbCrQpOffsetPresentFlag(0);
+    pcPPS->setSliceChromaQpFlag(0);
+    pcPPS->clearChromaQpOffsetList();
+  }
+  xReadFlag( uiCode, "pps_deblocking_filter_control_present_flag" );       pcPPS->setDeblockingFilterControlPresentFlag( uiCode ? true : false );
+  if(pcPPS->getDeblockingFilterControlPresentFlag())
+  {
+    xReadFlag( uiCode, "pps_deblocking_filter_override_enabled_flag" );    pcPPS->setDeblockingFilterOverrideEnabledFlag( uiCode ? true : false );
+    xReadFlag( uiCode, "pps_deblocking_filter_disabled_flag" );        pcPPS->setPPSDeblockingFilterDisabledFlag(uiCode ? true : false );
+    if (!pcPPS->getNoPicPartitionFlag() && pcPPS->getDeblockingFilterOverrideEnabledFlag())
+    {
+      xReadFlag(uiCode, "pps_dbf_info_in_ph_flag");
+      pcPPS->setDbfInfoInPhFlag(uiCode ? true : false);
+    }
+    else
+    {
+      pcPPS->setDbfInfoInPhFlag(false);
+    }
+    if(!pcPPS->getPPSDeblockingFilterDisabledFlag())
+    {
+      xReadSvlc( iCode, "pps_beta_offset_div2" );                    pcPPS->setDeblockingFilterBetaOffsetDiv2( iCode );
+      CHECK(  pcPPS->getDeblockingFilterBetaOffsetDiv2() < -12 ||
+              pcPPS->getDeblockingFilterBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
+
+      xReadSvlc( iCode, "pps_tc_offset_div2");                       pcPPS->setDeblockingFilterTcOffsetDiv2( iCode );
+      CHECK(  pcPPS->getDeblockingFilterTcOffsetDiv2() < -12 ||
+              pcPPS->getDeblockingFilterTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
+
+      if( pcPPS->getPPSChromaToolFlag() )
+      {
+        xReadSvlc( iCode, "pps_cb_beta_offset_div2" );                   pcPPS->setDeblockingFilterCbBetaOffsetDiv2( iCode );
+        CHECK( pcPPS->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
+          pcPPS->getDeblockingFilterCbBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
+
+        xReadSvlc( iCode, "pps_cb_tc_offset_div2" );                     pcPPS->setDeblockingFilterCbTcOffsetDiv2( iCode );
+        CHECK( pcPPS->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
+          pcPPS->getDeblockingFilterCbTcOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
+
+        xReadSvlc( iCode, "pps_cr_beta_offset_div2") ;                   pcPPS->setDeblockingFilterCrBetaOffsetDiv2( iCode );
+        CHECK( pcPPS->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
+          pcPPS->getDeblockingFilterCrBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration" );
+
+        xReadSvlc( iCode, "pps_cr_tc_offset_div2" );                     pcPPS->setDeblockingFilterCrTcOffsetDiv2( iCode );
+        CHECK(pcPPS->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
+          pcPPS->getDeblockingFilterCrTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
+      }
+      else
+      {
+        pcPPS->setDeblockingFilterCbBetaOffsetDiv2 ( pcPPS->getDeblockingFilterBetaOffsetDiv2() );
+        pcPPS->setDeblockingFilterCbTcOffsetDiv2   ( pcPPS->getDeblockingFilterTcOffsetDiv2()   );
+        pcPPS->setDeblockingFilterCrBetaOffsetDiv2 ( pcPPS->getDeblockingFilterBetaOffsetDiv2() );
+        pcPPS->setDeblockingFilterCrTcOffsetDiv2   ( pcPPS->getDeblockingFilterTcOffsetDiv2()   );
+      }
+    }
+  }
+  else
+  {
+    pcPPS->setDeblockingFilterOverrideEnabledFlag(false);
+    pcPPS->setDbfInfoInPhFlag(false);
+  }
+
+  if (!pcPPS->getNoPicPartitionFlag())
+  {
+    xReadFlag(uiCode, "pps_rpl_info_in_ph_flag");                    pcPPS->setRplInfoInPhFlag(uiCode ? true : false);
+    xReadFlag(uiCode, "pps_sao_info_in_ph_flag");                    pcPPS->setSaoInfoInPhFlag(uiCode ? true : false);
+    xReadFlag(uiCode, "pps_alf_info_in_ph_flag");                    pcPPS->setAlfInfoInPhFlag(uiCode ? true : false);
+    if ((pcPPS->getUseWP() || pcPPS->getWPBiPred()) && pcPPS->getRplInfoInPhFlag())
+    {
+      xReadFlag(uiCode, "pps_wp_info_in_ph_flag");                   pcPPS->setWpInfoInPhFlag(uiCode ? true : false);
+    }
+    else
+    {
+      pcPPS->setWpInfoInPhFlag(false);
+    }
+    xReadFlag(uiCode, "pps_qp_delta_info_in_ph_flag");               pcPPS->setQpDeltaInfoInPhFlag(uiCode ? true : false);
+  }
+  else
+  {
+    pcPPS->setRplInfoInPhFlag(false);
+    pcPPS->setSaoInfoInPhFlag(false);
+    pcPPS->setAlfInfoInPhFlag(false);
+    pcPPS->setWpInfoInPhFlag(false);
+    pcPPS->setQpDeltaInfoInPhFlag(false);
+  }
+
+  xReadFlag( uiCode, "pps_picture_header_extension_present_flag");
+  pcPPS->setPictureHeaderExtensionPresentFlag(uiCode);
+  xReadFlag( uiCode, "pps_slice_header_extension_present_flag");
+  pcPPS->setSliceHeaderExtensionPresentFlag(uiCode);
+
+  xReadFlag( uiCode, "pps_extension_flag");
+
+  if (uiCode)
+  {
+    while (xMoreRbspData())
+    {
+      xReadFlag(uiCode, "pps_extension_data_flag");
+    }
+  }
+  xReadRbspTrailingBits();
+}
+
+void HLSyntaxReader::parseAPS( APS* aps )
+{
+#if ENABLE_TRACING
+  xTraceAPSHeader();
+#endif
+
+  uint32_t  code;
+  xReadCode(3, code, "aps_params_type");
+  aps->setAPSType(ApsType(code));
+
+  xReadCode(5, code, "adaptation_parameter_set_id");
+  aps->setAPSId(code);
+  uint32_t codeApsChromaPresentFlag;
+  xReadFlag(codeApsChromaPresentFlag, "aps_chroma_present_flag");
+  aps->chromaPresentFlag = codeApsChromaPresentFlag;
+
+  const ApsType apsType = aps->getAPSType();
+
+  if (apsType == ApsType::ALF)
+  {
+    parseAlfAps( aps );
+  }
+  else if (apsType == ApsType::LMCS)
+  {
+    parseLmcsAps( aps );
+  }
+  else if (apsType == ApsType::SCALING_LIST)
+  {
+    parseScalingListAps( aps );
+  }
+  xReadFlag(code, "aps_extension_flag");
+  if (code)
+  {
+    while (xMoreRbspData())
+    {
+      xReadFlag(code, "aps_extension_data_flag");
+    }
+  }
+  xReadRbspTrailingBits();
+}
+
+void HLSyntaxReader::parseAlfAps( APS* aps )
+{
+  uint32_t  code;
+
+  AlfParam param = aps->getAlfAPSParam();
+  param.reset();
+  param.enabledFlag[COMPONENT_Y] = param.enabledFlag[COMPONENT_Cb] = param.enabledFlag[COMPONENT_Cr] = true;
+  xReadFlag(code, "alf_luma_new_filter");
+  param.newFilterFlag[ChannelType::LUMA] = code;
+
+  if (aps->chromaPresentFlag)
+  {
+    xReadFlag(code, "alf_chroma_new_filter");
+    param.newFilterFlag[ChannelType::CHROMA] = code;
+  }
+  else
+  {
+    param.newFilterFlag[ChannelType::CHROMA] = 0;
+  }
+
+  CcAlfFilterParam ccAlfParam = aps->getCcAlfAPSParam();
+  if (aps->chromaPresentFlag)
+  {
+    xReadFlag(code, "alf_cc_cb_filter_signal_flag");
+    ccAlfParam.newCcAlfFilter[COMPONENT_Cb - 1] = code;
+  }
+  else
+  {
+    ccAlfParam.newCcAlfFilter[COMPONENT_Cb - 1] = 0;
+  }
+  if (aps->chromaPresentFlag)
+  {
+    xReadFlag(code, "alf_cc_cr_filter_signal_flag");
+    ccAlfParam.newCcAlfFilter[COMPONENT_Cr - 1] = code;
+  }
+  else
+  {
+    ccAlfParam.newCcAlfFilter[COMPONENT_Cr - 1] = 0;
+  }
+  CHECK(param.newFilterFlag[ChannelType::LUMA] == 0 && param.newFilterFlag[ChannelType::CHROMA] == 0
+          && ccAlfParam.newCcAlfFilter[COMPONENT_Cb - 1] == 0 && ccAlfParam.newCcAlfFilter[COMPONENT_Cr - 1] == 0,
+        "bitstream conformance error: one of alf_luma_filter_signal_flag, alf_chroma_filter_signal_flag, "
+        "alf_cross_component_cb_filter_signal_flag, and alf_cross_component_cr_filter_signal_flag shall be nonzero");
+
+  if (param.newFilterFlag[ChannelType::LUMA])
+  {
+    xReadFlag(code, "alf_luma_clip");
+    param.nonLinearFlag[ChannelType::LUMA] = code ? true : false;
+    xReadUvlc(code, "alf_luma_num_filters_signalled_minus1");
+    param.numLumaFilters = code + 1;
+    if (param.numLumaFilters > 1)
+    {
+      const int length =  ceilLog2(param.numLumaFilters);
+      for (int i = 0; i < MAX_NUM_ALF_CLASSES; i++)
+      {
+        xReadCode(length, code, "alf_luma_coeff_delta_idx");
+        param.filterCoeffDeltaIdx[i] = code;
+      }
+    }
+    else
+    {
+      memset(param.filterCoeffDeltaIdx, 0, sizeof(param.filterCoeffDeltaIdx));
+    }
+    alfFilter( param, false, 0 );
+  }
+  if (param.newFilterFlag[ChannelType::CHROMA])
+  {
+    xReadFlag(code, "alf_nonlinear_enable_flag_chroma");
+    param.nonLinearFlag[ChannelType::CHROMA] = code ? true : false;
+
+    if constexpr (ALF_MAX_NUM_ALTERNATIVES_CHROMA > 1)
+    {
+      xReadUvlc( code, "alf_chroma_num_alts_minus1" );
+    }
+    else
+    {
+      code = 0;
+    }
+
+    param.numAlternativesChroma = code + 1;
+
+    for( int altIdx=0; altIdx < param.numAlternativesChroma; ++altIdx )
+    {
+      alfFilter( param, true, altIdx );
+    }
+  }
+
+  for (int ccIdx = 0; ccIdx < 2; ccIdx++)
+  {
+    if (ccAlfParam.newCcAlfFilter[ccIdx])
+    {
+      if (MAX_NUM_CC_ALF_FILTERS > 1)
+      {
+        xReadUvlc(code, ccIdx == 0 ? "alf_cc_cb_filters_signalled_minus1" : "alf_cc_cr_filters_signalled_minus1");
+      }
+      else
+      {
+        code = 0;
+      }
+      ccAlfParam.ccAlfFilterCount[ccIdx] = code + 1;
+
+      for (int filterIdx = 0; filterIdx < ccAlfParam.ccAlfFilterCount[ccIdx]; filterIdx++)
+      {
+        ccAlfParam.ccAlfFilterIdxEnabled[ccIdx][filterIdx] = true;
+        AlfFilterShape alfShape(size_CC_ALF);
+
+        short *coeff = ccAlfParam.ccAlfCoeff[ccIdx][filterIdx];
+        // Filter coefficients
+        for (int i = 0; i < alfShape.numCoeff - 1; i++)
+        {
+          xReadCode(CCALF_BITS_PER_COEFF_LEVEL, code,
+                    ccIdx == 0 ? "alf_cc_cb_mapped_coeff_abs" : "alf_cc_cr_mapped_coeff_abs");
+          if (code == 0)
+          {
+            coeff[i] = 0;
+          }
+          else
+          {
+            coeff[i] = 1 << (code - 1);
+            xReadFlag(code, ccIdx == 0 ? "alf_cc_cb_coeff_sign" : "alf_cc_cr_coeff_sign");
+            coeff[i] *= 1 - 2 * code;
+          }
+        }
+
+        DTRACE(g_trace_ctx, D_SYNTAX, "%s coeff filterIdx %d: ", ccIdx == 0 ? "Cb" : "Cr", filterIdx);
+        for (int i = 0; i < alfShape.numCoeff; i++)
+        {
+          DTRACE(g_trace_ctx, D_SYNTAX, "%d ", coeff[i]);
+        }
+        DTRACE(g_trace_ctx, D_SYNTAX, "\n");
+      }
+
+      for (int filterIdx = ccAlfParam.ccAlfFilterCount[ccIdx]; filterIdx < MAX_NUM_CC_ALF_FILTERS; filterIdx++)
+      {
+        ccAlfParam.ccAlfFilterIdxEnabled[ccIdx][filterIdx] = false;
+      }
+    }
+  }
+  aps->setCcAlfAPSParam(ccAlfParam);
+
+  aps->setAlfAPSParam(param);
+}
+
+void HLSyntaxReader::parseLmcsAps( APS* aps )
+{
+  uint32_t  code;
+
+  SliceReshapeInfo& info = aps->getReshaperAPSInfo();
+  memset(info.reshaperModelBinCWDelta, 0, PIC_CODE_CW_BINS * sizeof(int));
+  xReadUvlc(code, "lmcs_min_bin_idx");                             info.reshaperModelMinBinIdx = code;
+  xReadUvlc(code, "lmcs_delta_max_bin_idx");                       info.reshaperModelMaxBinIdx = PIC_CODE_CW_BINS - 1 - code;
+  xReadUvlc(code, "lmcs_delta_cw_prec_minus1");                    info.maxNbitsNeededDeltaCW = code + 1;
+
+  for (uint32_t i = info.reshaperModelMinBinIdx; i <= info.reshaperModelMaxBinIdx; i++)
+  {
+    xReadCode(info.maxNbitsNeededDeltaCW, code, "lmcs_delta_abs_cw[ i ]");
+    int absCW = code;
+    if (absCW > 0)
+    {
+      xReadCode(1, code, "lmcs_delta_sign_cw_flag[ i ]");
+    }
+    int signCW = code;
+    info.reshaperModelBinCWDelta[i] = (1 - 2 * signCW) * absCW;
+  }
+  if (aps->chromaPresentFlag)
+  {
+    xReadCode(3, code, "lmcs_delta_abs_crs");
+  }
+  int absCW = aps->chromaPresentFlag ? code : 0;
+  if (absCW > 0)
+  {
+    xReadCode(1, code, "lmcs_delta_sign_crs_flag");
+  }
+  int signCW = code;
+  info.chrResScalingOffset = (1 - 2 * signCW) * absCW;
+
+  aps->setReshaperAPSInfo(info);
+}
+
+void HLSyntaxReader::parseScalingListAps( APS* aps )
+{
+  ScalingList& info = aps->getScalingList();
+  parseScalingList(&info, aps->chromaPresentFlag);
+}
+
+void  HLSyntaxReader::parseVUI(VUI* pcVUI, SPS *pcSPS)
+{
+#if ENABLE_TRACING
+  DTRACE( g_trace_ctx, D_HEADER, "----------- vui_parameters -----------\n");
+#endif
+  unsigned vuiPayloadSize = pcSPS->getVuiPayloadSize();
+  InputBitstream *bs = getBitstream();
+  setBitstream(bs->extractSubstream(vuiPayloadSize * 8));
+
+  uint32_t  symbol;
+
+  xReadFlag(symbol,  "vui_progressive_source_flag"          ); pcVUI->setProgressiveSourceFlag(symbol ? true : false);
+  xReadFlag(symbol,  "vui_interlaced_source_flag"           ); pcVUI->setInterlacedSourceFlag(symbol ? true : false);
+  xReadFlag(symbol, "vui_non_packed_constraint_flag");         pcVUI->setNonPackedFlag(symbol ? true : false);
+  xReadFlag(symbol, "vui_non_projected_constraint_flag");      pcVUI->setNonProjectedFlag(symbol ? true : false);
+  xReadFlag( symbol, "vui_aspect_ratio_info_present_flag");           pcVUI->setAspectRatioInfoPresentFlag(symbol);
+  if (pcVUI->getAspectRatioInfoPresentFlag())
+  {
+    xReadFlag( symbol, "vui_aspect_ratio_constant_flag");           pcVUI->setAspectRatioConstantFlag(symbol);
+    xReadCode(8, symbol, "vui_aspect_ratio_idc");                         pcVUI->setAspectRatioIdc(symbol);
+    if (pcVUI->getAspectRatioIdc() == 255)
+    {
+      xReadCode(16, symbol, "vui_sar_width");                             pcVUI->setSarWidth(symbol);
+      xReadCode(16, symbol, "vui_sar_height");                            pcVUI->setSarHeight(symbol);
+    }
+  }
+
+  xReadFlag(     symbol, "vui_overscan_info_present_flag");               pcVUI->setOverscanInfoPresentFlag(symbol);
+  if (pcVUI->getOverscanInfoPresentFlag())
+  {
+    xReadFlag(   symbol, "vui_overscan_appropriate_flag");                pcVUI->setOverscanAppropriateFlag(symbol);
+  }
+
+  xReadFlag(   symbol, "vui_colour_description_present_flag");          pcVUI->setColourDescriptionPresentFlag(symbol);
+  if (pcVUI->getColourDescriptionPresentFlag())
+  {
+    xReadCode(8, symbol, "vui_colour_primaries");                       pcVUI->setColourPrimaries(symbol);
+    xReadCode(8, symbol, "vui_transfer_characteristics");               pcVUI->setTransferCharacteristics(symbol);
+    xReadCode(8, symbol, "vui_matrix_coeffs");                          pcVUI->setMatrixCoefficients(symbol);
+    xReadFlag(   symbol, "vui_full_range_flag");                    pcVUI->setVideoFullRangeFlag(symbol);
+  }
+
+  xReadFlag(     symbol, "vui_chroma_loc_info_present_flag");             pcVUI->setChromaLocInfoPresentFlag(symbol);
+  if (pcVUI->getChromaLocInfoPresentFlag())
+  {
+    if(pcVUI->getProgressiveSourceFlag() && !pcVUI->getInterlacedSourceFlag())
+    {
+      xReadUvlc(   symbol, "vui_chroma_sample_loc_type" );        pcVUI->setChromaSampleLocType(symbol);
+    }
+    else
+    {
+      xReadUvlc(   symbol, "vui_chroma_sample_loc_type_top_field" );        pcVUI->setChromaSampleLocTypeTopField(symbol);
+      xReadUvlc(   symbol, "vui_chroma_sample_loc_type_bottom_field" );     pcVUI->setChromaSampleLocTypeBottomField(symbol);
+    }
+  }
+
+  int payloadBitsRem = getBitstream()->getNumBitsLeft();
+  if(payloadBitsRem)      //Corresponds to more_data_in_payload()
+  {
+    while(payloadBitsRem > 9)    //payload_extension_present()
+    {
+      xReadCode(1, symbol, "vui_reserved_payload_extension_data");
+      payloadBitsRem--;
+    }
+    int finalBits = getBitstream()->peekBits(payloadBitsRem);
+    int numFinalZeroBits = 0;
+    int mask = 0xff;
+    while(finalBits & (mask >> numFinalZeroBits))
+    {
+      numFinalZeroBits++;
+    }
+    while(payloadBitsRem > 9-numFinalZeroBits)     //payload_extension_present()
+    {
+      xReadCode(1, symbol, "vui_reserved_payload_extension_data");
+      payloadBitsRem--;
+    }
+    xReadFlag(symbol, "vui_payload_bit_equal_to_one");
+    CHECK(symbol != 1, "vui_payload_bit_equal_to_one not equal to 1");
+    payloadBitsRem--;
+    while(payloadBitsRem)
+    {
+      xReadFlag(symbol, "vui_payload_bit_equal_to_zero");
+      CHECK(symbol != 0, "vui_payload_bit_equal_to_zero not equal to 0");
+      payloadBitsRem--;
+    }
+  }
+  delete getBitstream();
+  setBitstream(bs);
+}
+
+void HLSyntaxReader::parseGeneralHrdParameters(GeneralHrdParams *hrd)
+{
+  uint32_t  symbol;
+  xReadCode(32, symbol, "num_units_in_tick");                hrd->setNumUnitsInTick(symbol);
+  xReadCode(32, symbol, "time_scale");                       hrd->setTimeScale(symbol);
+  xReadFlag(symbol, "general_nal_hrd_parameters_present_flag");           hrd->setGeneralNalHrdParametersPresentFlag(symbol == 1 ? true : false);
+  xReadFlag(symbol, "general_vcl_hrd_parameters_present_flag");           hrd->setGeneralVclHrdParametersPresentFlag(symbol == 1 ? true : false);
+  if(  hrd->getGeneralNalHrdParametersPresentFlag() || hrd->getGeneralVclHrdParametersPresentFlag() )
+  {
+    xReadFlag(symbol, "general_same_pic_timing_in_all_ols_flag");           hrd->setGeneralSamePicTimingInAllOlsFlag(symbol == 1 ? true : false);
+    xReadFlag(symbol, "general_decoding_unit_hrd_params_present_flag");     hrd->setGeneralDecodingUnitHrdParamsPresentFlag(symbol == 1 ? true : false);
+    if (hrd->getGeneralDecodingUnitHrdParamsPresentFlag())
+    {
+      xReadCode(8, symbol, "tick_divisor_minus2");                        hrd->setTickDivisorMinus2(symbol);
+    }
+    xReadCode(4, symbol, "bit_rate_scale");                       hrd->setBitRateScale(symbol);
+    xReadCode(4, symbol, "cpb_size_scale");                       hrd->setCpbSizeScale(symbol);
+    if (hrd->getGeneralDecodingUnitHrdParamsPresentFlag())
+    {
+      xReadCode(4, symbol, "cpb_size_du_scale");                  hrd->setCpbSizeDuScale(symbol);
+    }
+    xReadUvlc(symbol, "hrd_cpb_cnt_minus1");                      hrd->setHrdCpbCntMinus1(symbol);
+    CHECK(symbol > 31,"The value of hrd_cpb_cnt_minus1 shall be in the range of 0 to 31, inclusive");
+  }
+}
+
+void HLSyntaxReader::parseOlsHrdParameters(GeneralHrdParams * generalHrd, OlsHrdParams *olsHrd, uint32_t firstSubLayer, uint32_t maxNumSubLayersMinus1)
+{
+  uint32_t  symbol;
+
+  for( int i = firstSubLayer; i <= maxNumSubLayersMinus1; i ++ )
+  {
+    OlsHrdParams *hrd = &(olsHrd[i]);
+    xReadFlag(symbol, "fixed_pic_rate_general_flag");                     hrd->setFixedPicRateGeneralFlag(symbol == 1 ? true : false);
+    if (!hrd->getFixedPicRateGeneralFlag())
+    {
+      xReadFlag(symbol, "fixed_pic_rate_within_cvs_flag");                hrd->setFixedPicRateWithinCvsFlag(symbol == 1 ? true : false);
+    }
+    else
+    {
+      hrd->setFixedPicRateWithinCvsFlag(true);
+    }
+
+    hrd->setLowDelayHrdFlag(false); // Inferred to be 0 when not present
+
+    if (hrd->getFixedPicRateWithinCvsFlag())
+    {
+      xReadUvlc(symbol, "elemental_duration_in_tc_minus1");             hrd->setElementDurationInTcMinus1(symbol);
+    }
+    else if((generalHrd->getGeneralNalHrdParametersPresentFlag() || generalHrd->getGeneralVclHrdParametersPresentFlag()) && generalHrd->getHrdCpbCntMinus1() == 0)
+    {
+      xReadFlag(symbol, "low_delay_hrd_flag");                      hrd->setLowDelayHrdFlag(symbol == 1 ? true : false);
+    }
+
+    for( int nalOrVcl = 0; nalOrVcl < 2; nalOrVcl ++ )
+    {
+      if (((nalOrVcl == 0) && (generalHrd->getGeneralNalHrdParametersPresentFlag())) || ((nalOrVcl == 1) && (generalHrd->getGeneralVclHrdParametersPresentFlag())))
+      {
+        for (int j = 0; j <= (generalHrd->getHrdCpbCntMinus1()); j++)
+        {
+          xReadUvlc(symbol, "bit_rate_value_minus1");             hrd->setBitRateValueMinus1(j, nalOrVcl, symbol);
+          xReadUvlc(symbol, "cpb_size_value_minus1");             hrd->setCpbSizeValueMinus1(j, nalOrVcl, symbol);
+          if (generalHrd->getGeneralDecodingUnitHrdParamsPresentFlag())
+          {
+            xReadUvlc(symbol, "cpb_size_du_value_minus1");             hrd->setDuCpbSizeValueMinus1(j, nalOrVcl, symbol);
+            xReadUvlc(symbol, "bit_rate_du_value_minus1");             hrd->setDuBitRateValueMinus1(j, nalOrVcl, symbol);
+          }
+          xReadFlag(symbol, "cbr_flag");                          hrd->setCbrFlag(j, nalOrVcl, symbol == 1 ? true : false);
+        }
+      }
+    }
+  }
+  for (int i = 0; i < firstSubLayer; i++)
+  {
+    OlsHrdParams* hrdHighestTLayer = &(olsHrd[maxNumSubLayersMinus1]);
+    OlsHrdParams* hrdTemp = &(olsHrd[i]);
+    bool tempFlag = hrdHighestTLayer->getFixedPicRateGeneralFlag();
+    hrdTemp->setFixedPicRateGeneralFlag(tempFlag);
+    tempFlag = hrdHighestTLayer->getFixedPicRateWithinCvsFlag();
+    hrdTemp->setFixedPicRateWithinCvsFlag(tempFlag);
+    uint32_t tempElementDurationInTcMinus1 = hrdHighestTLayer->getElementDurationInTcMinus1();
+    hrdTemp->setElementDurationInTcMinus1(tempElementDurationInTcMinus1);
+    for (int nalOrVcl = 0; nalOrVcl < 2; nalOrVcl++)
+    {
+      if (((nalOrVcl == 0) && (generalHrd->getGeneralNalHrdParametersPresentFlag())) || ((nalOrVcl == 1) && (generalHrd->getGeneralVclHrdParametersPresentFlag())))
+      {
+        for (int j = 0; j <= (generalHrd->getHrdCpbCntMinus1()); j++)
+        {
+          uint32_t bitRate = hrdHighestTLayer->getBitRateValueMinus1(j, nalOrVcl);
+          hrdTemp->setBitRateValueMinus1(j, nalOrVcl, bitRate);
+          uint32_t cpbSize = hrdHighestTLayer->getCpbSizeValueMinus1(j, nalOrVcl);
+          hrdTemp->setCpbSizeValueMinus1(j, nalOrVcl, cpbSize);
+          if (generalHrd->getGeneralDecodingUnitHrdParamsPresentFlag())
+          {
+            uint32_t bitRateDu = hrdHighestTLayer->getDuBitRateValueMinus1(j, nalOrVcl);
+            hrdTemp->setDuBitRateValueMinus1(j, nalOrVcl, bitRateDu);
+            uint32_t cpbSizeDu = hrdHighestTLayer->getDuCpbSizeValueMinus1(j, nalOrVcl);
+            hrdTemp->setDuCpbSizeValueMinus1(j, nalOrVcl, cpbSizeDu);
+          }
+          bool flag = hrdHighestTLayer->getCbrFlag(j, nalOrVcl);
+          hrdTemp->setCbrFlag(j, nalOrVcl, flag);
+        }
+      }
+    }
+  }
+}
+
+void HLSyntaxReader::dpb_parameters(int maxSubLayersMinus1, bool subLayerInfoFlag, SPS *pcSPS)
+{
+  uint32_t code;
+  for (int i = (subLayerInfoFlag ? 0 : maxSubLayersMinus1); i <= maxSubLayersMinus1; i++)
+  {
+    xReadUvlc(code, "dpb_max_dec_pic_buffering_minus1[i]");
+    pcSPS->setMaxDecPicBuffering(code + 1, i);
+    xReadUvlc(code, "dpb_max_num_reorder_pics[i]");
+    pcSPS->setMaxNumReorderPics(code, i);
+    CHECK( pcSPS->getMaxNumReorderPics(i) >= pcSPS->getMaxDecPicBuffering(i), "The value of dpb_max_num_reorder_pics[ i ] shall be in the range of 0 to dpb_max_dec_pic_buffering_minus1[ i ], inclusive" );
+    xReadUvlc(code, "dpb_max_latency_increase_plus1[i]");
+    pcSPS->setMaxLatencyIncreasePlus1(code, i);
+  }
+
+  if (!subLayerInfoFlag)
+  {
+    for(int i = 0; i < maxSubLayersMinus1; ++i)
+    {
+      pcSPS->setMaxDecPicBuffering(pcSPS->getMaxDecPicBuffering(maxSubLayersMinus1), i);
+      pcSPS->setMaxNumReorderPics(pcSPS->getMaxNumReorderPics(maxSubLayersMinus1), i);
+      pcSPS->setMaxLatencyIncreasePlus1(pcSPS->getMaxLatencyIncreasePlus1(maxSubLayersMinus1), i);
+    }
+  }
+}
+
+
+void HLSyntaxReader::parseSPS(SPS* pcSPS)
+{
+  uint32_t  uiCode;
+
+#if ENABLE_TRACING
+  xTraceSPSHeader ();
+#endif
+
+  xReadCode(4, uiCode, "sps_seq_parameter_set_id");              pcSPS->setSPSId(uiCode);
+  xReadCode( 4,  uiCode, "sps_video_parameter_set_id" );      pcSPS->setVPSId( uiCode );
+  xReadCode(3, uiCode, "sps_max_sub_layers_minus1");          pcSPS->setMaxTLayers   (uiCode + 1);
+  CHECK(uiCode > 6, "Invalid maximum number of T-layer signalled");
+  xReadCode(2, uiCode, "sps_chroma_format_idc");
+  pcSPS->setChromaFormatIdc(ChromaFormat(uiCode));
+
+  xReadCode(2, uiCode, "sps_log2_ctu_size_minus5");
+  pcSPS->setCTUSize(1 << (uiCode + 5));
+  CHECK(uiCode > 2, "sps_log2_ctu_size_minus5 must be less than or equal to 2");
+  unsigned ctbLog2SizeY = uiCode + 5;
+  pcSPS->setMaxCUWidth(pcSPS->getCTUSize());
+  pcSPS->setMaxCUHeight(pcSPS->getCTUSize());
+  xReadFlag(uiCode, "sps_ptl_dpb_hrd_params_present_flag"); pcSPS->setPtlDpbHrdParamsPresentFlag(uiCode);
+
+  if( !pcSPS->getVPSId() )
+  {
+    CHECK( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+  }
+
+  if (pcSPS->getPtlDpbHrdParamsPresentFlag())
+  {
+    parseProfileTierLevel(pcSPS->getProfileTierLevel(), true, pcSPS->getMaxTLayers() - 1);
+  }
+
+  xReadFlag(uiCode, "sps_gdr_enabled_flag");
+  pcSPS->setGDREnabledFlag(uiCode);
+
+  if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoGdrConstraintFlag())
+  {
+    CHECK(uiCode != 0, "When gci_no_gdr_constraint_flag equal to 1 , the value of sps_gdr_enabled_flag shall be equal to 0");
+  }
+
+  xReadFlag(uiCode, "sps_ref_pic_resampling_enabled_flag");          pcSPS->setRprEnabledFlag(uiCode);
+  if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoRprConstraintFlag())
+  {
+    CHECK(uiCode != 0, "When gci_no_ref_pic_resampling_constraint_flag is equal to 1, sps_ref_pic_resampling_enabled_flag shall be equal to 0");
+  }
+  if (uiCode)
+  {
+    xReadFlag(uiCode, "sps_res_change_in_clvs_allowed_flag");        pcSPS->setResChangeInClvsEnabledFlag(uiCode);
+  }
+  else
+  {
+    pcSPS->setResChangeInClvsEnabledFlag(0);
+  }
+
+  if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoResChangeInClvsConstraintFlag())
+  {
+    CHECK(uiCode != 0, "When no_res_change_in_clvs_constraint_flag is equal to 1, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+  }
+
+  xReadUvlc( uiCode, "sps_pic_width_max_in_luma_samples" );          pcSPS->setMaxPicWidthInLumaSamples( uiCode );
+  xReadUvlc( uiCode, "sps_pic_height_max_in_luma_samples" );         pcSPS->setMaxPicHeightInLumaSamples( uiCode );
+  xReadFlag( uiCode, "sps_conformance_window_flag");
+  if (uiCode != 0)
+  {
+    Window& conf = pcSPS->getConformanceWindow();
+    xReadUvlc(uiCode, "sps_conf_win_left_offset");               conf.setWindowLeftOffset(uiCode);
+    xReadUvlc(uiCode, "sps_conf_win_right_offset");              conf.setWindowRightOffset(uiCode);
+    xReadUvlc(uiCode, "sps_conf_win_top_offset");                conf.setWindowTopOffset(uiCode);
+    xReadUvlc(uiCode, "sps_conf_win_bottom_offset");             conf.setWindowBottomOffset(uiCode);
+  }
+
+  xReadFlag( uiCode, "sps_subpic_info_present_flag" );               pcSPS->setSubPicInfoPresentFlag(uiCode);
+  if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoSubpicInfoConstraintFlag())
+  {
+    CHECK(uiCode != 0, "When gci_no_subpic_info_constraint_flag is equal to 1, the value of sps_subpic_info_present_flag shall be equal to 0");
+  }
+
+  if (pcSPS->getSubPicInfoPresentFlag())
+  {
+    const int maxPicWidthInCtus  = ((pcSPS->getMaxPicWidthInLumaSamples() - 1) / pcSPS->getCTUSize()) + 1;
+    const int maxPicHeightInCtus = ((pcSPS->getMaxPicHeightInLumaSamples() - 1) / pcSPS->getCTUSize()) + 1;
+
+    xReadUvlc(uiCode, "sps_num_subpics_minus1"); pcSPS->setNumSubPics(uiCode + 1);
+    CHECK(uiCode > maxPicWidthInCtus * maxPicHeightInCtus - 1, "Invalid sps_num_subpics_minus1 value");
+    if( pcSPS->getNumSubPics() == 1 )
+    {
+      pcSPS->setSubPicCtuTopLeftX( 0, 0 );
+      pcSPS->setSubPicCtuTopLeftY( 0, 0 );
+      pcSPS->setSubPicWidth(0, maxPicWidthInCtus);
+      pcSPS->setSubPicHeight(0, maxPicHeightInCtus);
+
+      pcSPS->setIndependentSubPicsFlag(1);
+      pcSPS->setSubPicSameSizeFlag(0);
+
+      pcSPS->setSubPicTreatedAsPicFlag(0, 1);
+      pcSPS->setLoopFilterAcrossSubpicEnabledFlag(0, 0);
+    }
+    else
+    {
+      xReadFlag(uiCode, "sps_independent_subpics_flag"); pcSPS->setIndependentSubPicsFlag(uiCode != 0);
+      xReadFlag(uiCode, "sps_subpic_same_size_flag"); pcSPS->setSubPicSameSizeFlag(uiCode);
+      uint32_t tmpWidthVal   = maxPicWidthInCtus;
+      uint32_t tmpHeightVal  = maxPicHeightInCtus;
+      uint32_t numSubpicCols = 1;
+      for (int picIdx = 0; picIdx < pcSPS->getNumSubPics(); picIdx++)
+      {
+        if (!pcSPS->getSubPicSameSizeFlag() || picIdx == 0)
+        {
+          if ((picIdx > 0) && (pcSPS->getMaxPicWidthInLumaSamples() > pcSPS->getCTUSize()))
+          {
+            xReadCode(ceilLog2(tmpWidthVal), uiCode, "sps_subpic_ctu_top_left_x[ i ]");
+            pcSPS->setSubPicCtuTopLeftX(picIdx, uiCode);
+          }
+          else
+          {
+            pcSPS->setSubPicCtuTopLeftX(picIdx, 0);
+          }
+          if ((picIdx > 0) && (pcSPS->getMaxPicHeightInLumaSamples() > pcSPS->getCTUSize()))
+          {
+            xReadCode(ceilLog2(tmpHeightVal), uiCode, "sps_subpic_ctu_top_left_y[ i ]");
+            pcSPS->setSubPicCtuTopLeftY(picIdx, uiCode);
+          }
+          else
+          {
+            pcSPS->setSubPicCtuTopLeftY(picIdx, 0);
+          }
+          if (picIdx <pcSPS->getNumSubPics() - 1 && pcSPS->getMaxPicWidthInLumaSamples() > pcSPS->getCTUSize())
+          {
+            xReadCode(ceilLog2(tmpWidthVal), uiCode, "sps_subpic_width_minus1[ i ]");
+            pcSPS->setSubPicWidth(picIdx, uiCode + 1);
+          }
+          else
+          {
+            pcSPS->setSubPicWidth(picIdx, tmpWidthVal - pcSPS->getSubPicCtuTopLeftX(picIdx));
+          }
+          if (picIdx <pcSPS->getNumSubPics() - 1 && pcSPS->getMaxPicHeightInLumaSamples() > pcSPS->getCTUSize())
+          {
+            xReadCode(ceilLog2(tmpHeightVal), uiCode, "sps_subpic_height_minus1[ i ]");
+            pcSPS->setSubPicHeight(picIdx, uiCode + 1);
+          }
+          else
+          {
+            pcSPS->setSubPicHeight(picIdx, tmpHeightVal - pcSPS->getSubPicCtuTopLeftY(picIdx));
+          }
+          if (pcSPS->getSubPicSameSizeFlag())
+          {
+            numSubpicCols = tmpWidthVal / pcSPS->getSubPicWidth(0);
+            CHECK(!(tmpWidthVal % pcSPS->getSubPicWidth(0) == 0), "sps_subpic_width_minus1[0] is invalid.");
+            CHECK(!(tmpHeightVal % pcSPS->getSubPicHeight(0) == 0), "sps_subpic_height_minus1[0] is invalid.");
+            CHECK(!(numSubpicCols * (tmpHeightVal / pcSPS->getSubPicHeight(0)) == pcSPS->getNumSubPics()), "when sps_subpic_same_size_flag is equal to, sps_num_subpics_minus1 is invalid");
+          }
+        }
+        else
+        {
+          pcSPS->setSubPicCtuTopLeftX(picIdx, (picIdx % numSubpicCols) * pcSPS->getSubPicWidth(0));
+          pcSPS->setSubPicCtuTopLeftY(picIdx, (picIdx / numSubpicCols) * pcSPS->getSubPicHeight(0));
+          pcSPS->setSubPicWidth(picIdx, pcSPS->getSubPicWidth(0));
+          pcSPS->setSubPicHeight(picIdx, pcSPS->getSubPicHeight(0));
+        }
+        if (!pcSPS->getIndependentSubPicsFlag())
+        {
+          xReadFlag(uiCode, "sps_subpic_treated_as_pic_flag[ i ]");
+          pcSPS->setSubPicTreatedAsPicFlag(picIdx, uiCode);
+          xReadFlag(uiCode, "sps_loop_filter_across_subpic_enabled_flag[ i ]");
+          pcSPS->setLoopFilterAcrossSubpicEnabledFlag(picIdx, uiCode);
+        }
+        else
+        {
+          pcSPS->setSubPicTreatedAsPicFlag(picIdx, 1);
+          pcSPS->setLoopFilterAcrossSubpicEnabledFlag(picIdx, 0);
+        }
+      }
+    }
+
+    xReadUvlc( uiCode, "sps_subpic_id_len_minus1" );                       pcSPS->setSubPicIdLen( uiCode + 1 );
+    CHECK( uiCode > 15, "Invalid sps_subpic_id_len_minus1 value" );
+    CHECK( (1 << (uiCode + 1)) < pcSPS->getNumSubPics(), "Invalid sps_subpic_id_len_minus1 value" );
+    xReadFlag( uiCode, "sps_subpic_id_mapping_explicitly_signalled_flag" );    pcSPS->setSubPicIdMappingExplicitlySignalledFlag( uiCode != 0 );
+    if (pcSPS->getSubPicIdMappingExplicitlySignalledFlag())
+    {
+      xReadFlag( uiCode, "sps_subpic_id_mapping_present_flag" );                pcSPS->setSubPicIdMappingPresentFlag( uiCode != 0 );
+      if (pcSPS->getSubPicIdMappingPresentFlag())
+      {
+        for (int picIdx = 0; picIdx < pcSPS->getNumSubPics(); picIdx++)
+        {
+          xReadCode(pcSPS->getSubPicIdLen(), uiCode, "sps_subpic_id[i]");   pcSPS->setSubPicId(picIdx, uiCode);
+        }
+      }
+    }
+  }
+  else
+  {
+    pcSPS->setSubPicIdMappingExplicitlySignalledFlag(0);
+    pcSPS->setNumSubPics(1);
+    pcSPS->setSubPicCtuTopLeftX(0, 0);
+    pcSPS->setSubPicCtuTopLeftY(0, 0);
+    pcSPS->setSubPicWidth(0, (pcSPS->getMaxPicWidthInLumaSamples() + pcSPS->getCTUSize() - 1) >> floorLog2(pcSPS->getCTUSize()));
+    pcSPS->setSubPicHeight(0, (pcSPS->getMaxPicHeightInLumaSamples() + pcSPS->getCTUSize() - 1) >> floorLog2(pcSPS->getCTUSize()));
+  }
+
+  if( !pcSPS->getSubPicIdMappingExplicitlySignalledFlag() || !pcSPS->getSubPicIdMappingPresentFlag() )
+  {
+    for( int picIdx = 0; picIdx < pcSPS->getNumSubPics( ); picIdx++ )
+    {
+      pcSPS->setSubPicId( picIdx, picIdx );
+    }
+  }
+
+  xReadUvlc(uiCode, "sps_bitdepth_minus8");
+  CHECK(uiCode > 8, "Invalid bit depth signalled");
+  const Profile::Name profile = pcSPS->getProfileTierLevel()->getProfileIdc();
+  if (profile != Profile::NONE)
+  {
+    CHECK(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "sps_bitdepth_minus8 exceeds range supported by signalled profile");
+  }
+  pcSPS->setBitDepth(ChannelType::LUMA, 8 + uiCode);
+  pcSPS->setBitDepth(ChannelType::CHROMA, 8 + uiCode);
+  pcSPS->setQpBDOffset(ChannelType::LUMA, (int) (6 * uiCode));
+  pcSPS->setQpBDOffset(ChannelType::CHROMA, (int) (6 * uiCode));
+
+  xReadFlag( uiCode, "sps_entropy_coding_sync_enabled_flag" );       pcSPS->setEntropyCodingSyncEnabledFlag(uiCode == 1);
+  xReadFlag( uiCode, "sps_entry_point_offsets_present_flag");   pcSPS->setEntryPointsPresentFlag(uiCode == 1);
+  xReadCode(4, uiCode, "sps_log2_max_pic_order_cnt_lsb_minus4");     pcSPS->setBitsForPOC( 4 + uiCode );
+  CHECK(uiCode > 12, "sps_log2_max_pic_order_cnt_lsb_minus4 shall be in the range of 0 to 12");
+
+  xReadFlag(uiCode, "sps_poc_msb_cycle_flag");                    pcSPS->setPocMsbCycleFlag(uiCode ? true : false);
+  if (pcSPS->getPocMsbCycleFlag())
+  {
+    xReadUvlc(uiCode, "sps_poc_msb_cycle_len_minus1");                  pcSPS->setPocMsbCycleLen(1 + uiCode);
+    CHECK(uiCode > (32 - ( pcSPS->getBitsForPOC() - 4 )- 5), "The value of sps_poc_msb_cycle_len_minus1 shall be in the range of 0 to 32 - sps_log2_max_pic_order_cnt_lsb_minus4 - 5, inclusive");
+  }
+
+  // extra bits are for future extensions, we will read, but ignore them,
+  // unless a meaning is specified in the spec
+  xReadCode(2, uiCode, "sps_num_extra_ph_bytes");  pcSPS->setNumExtraPHBytes(uiCode);
+  int numExtraPhBytes = uiCode;
+  std::vector<bool> extraPhBitPresentFlags;
+  extraPhBitPresentFlags.resize ( 8 * numExtraPhBytes );
+  for (int i=0; i < 8*numExtraPhBytes; i++)
+  {
+    xReadFlag(uiCode, "sps_extra_ph_bit_present_flag[ i ]");
+    extraPhBitPresentFlags[i] = uiCode;
+  }
+  pcSPS->setExtraPHBitPresentFlags(extraPhBitPresentFlags);
+  xReadCode(2, uiCode, "sps_num_extra_sh_bytes");  pcSPS->setNumExtraSHBytes(uiCode);
+  int numExtraShBytes = uiCode;
+  std::vector<bool> extraShBitPresentFlags;
+  extraShBitPresentFlags.resize ( 8 * numExtraShBytes );
+  for (int i=0; i < 8*numExtraShBytes; i++)
+  {
+    xReadFlag(uiCode, "sps_extra_sh_bit_present_flag[ i ]");
+    extraShBitPresentFlags[i] = uiCode;
+  }
+  pcSPS->setExtraSHBitPresentFlags(extraShBitPresentFlags);
+
+  if (pcSPS->getPtlDpbHrdParamsPresentFlag())
+  {
+    if (pcSPS->getMaxTLayers() - 1 > 0)
+    {
+      xReadFlag(uiCode, "sps_sublayer_dpb_params_flag");     pcSPS->setSubLayerDpbParamsFlag(uiCode ? true : false);
+    }
+    dpb_parameters(pcSPS->getMaxTLayers() - 1, pcSPS->getSubLayerDpbParamsFlag(), pcSPS);
+  }
+  unsigned  minQT[3] = { 0, 0, 0 };
+  unsigned  maxBTD[3] = { 0, 0, 0 };
+
+  unsigned  maxBTSize[3] = { 0, 0, 0 };
+  unsigned  maxTTSize[3] = { 0, 0, 0 };
+  xReadUvlc(uiCode, "sps_log2_min_luma_coding_block_size_minus2");
+  int log2MinCUSize = uiCode + 2;
+  pcSPS->setLog2MinCodingBlockSize(log2MinCUSize);
+  CHECK(uiCode > ctbLog2SizeY - 2, "Invalid sps_log2_min_luma_coding_block_size_minus2 signalled");
+
+  CHECK(log2MinCUSize > std::min(6, (int)(ctbLog2SizeY)), "sps_log2_min_luma_coding_block_size_minus2 shall be in the range of 0 to min (4, log2_ctu_size - 2)");
+  const int minCuSize = 1 << pcSPS->getLog2MinCodingBlockSize();
+  CHECK( ( pcSPS->getMaxPicWidthInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame width must be a multiple of Max(8, the minimum unit size)" );
+  CHECK( ( pcSPS->getMaxPicHeightInLumaSamples() % ( std::max( 8, minCuSize ) ) ) != 0, "Coded frame height must be a multiple of Max(8, the minimum unit size)" );
+
+  xReadFlag(uiCode, "sps_partition_constraints_override_enabled_flag"); pcSPS->setSplitConsOverrideEnabledFlag(uiCode);
+  xReadUvlc(uiCode, "sps_log2_diff_min_qt_min_cb_intra_slice_luma");
+  unsigned minQtLog2SizeIntraY = uiCode + pcSPS->getLog2MinCodingBlockSize();
+  minQT[0] = 1 << minQtLog2SizeIntraY;
+  CHECK(minQT[0] > 64, "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+  CHECK(minQT[0] > (1<<ctbLog2SizeY), "The value of sps_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+  xReadUvlc(uiCode, "sps_max_mtt_hierarchy_depth_intra_slice_luma");     maxBTD[0] = uiCode;
+  CHECK(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_luma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+
+  maxTTSize[0] = maxBTSize[0] = minQT[0];
+  if (maxBTD[0] != 0)
+  {
+    xReadUvlc(uiCode, "sps_log2_diff_max_bt_min_qt_intra_slice_luma");     maxBTSize[0] <<= uiCode;
+    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+    xReadUvlc(uiCode, "sps_log2_diff_max_tt_min_qt_intra_slice_luma");     maxTTSize[0] <<= uiCode;
+    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+    CHECK(maxTTSize[0] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
+  }
+  if (isChromaEnabled(pcSPS->getChromaFormatIdc()))
+  {
+    xReadFlag(uiCode, "sps_qtbtt_dual_tree_intra_flag");           pcSPS->setUseDualITree(uiCode);
+  }
+  else
+  {
+    pcSPS->setUseDualITree(0);
+  }
+  if (pcSPS->getUseDualITree())
+  {
+    xReadUvlc(uiCode, "sps_log2_diff_min_qt_min_cb_intra_slice_chroma"); minQT[2] = 1 << (uiCode + pcSPS->getLog2MinCodingBlockSize());
+    xReadUvlc(uiCode, "sps_max_mtt_hierarchy_depth_intra_slice_chroma"); maxBTD[2] = uiCode;
+    CHECK(uiCode > 2 * (ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_intra_slice_chroma shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+    maxTTSize[2] = maxBTSize[2] = minQT[2];
+    if (maxBTD[2] != 0)
+    {
+      xReadUvlc(uiCode, "sps_log2_diff_max_bt_min_qt_intra_slice_chroma");       maxBTSize[2] <<= uiCode;
+      xReadUvlc(uiCode, "sps_log2_diff_max_tt_min_qt_intra_slice_chroma");       maxTTSize[2] <<= uiCode;
+      CHECK(maxTTSize[2] > 64, "The value of sps_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+      CHECK(maxBTSize[2] > 64, "The value of sps_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+    }
+  }
+  xReadUvlc(uiCode, "sps_log2_diff_min_qt_min_cb_inter_slice");
+  unsigned minQtLog2SizeInterY = uiCode + pcSPS->getLog2MinCodingBlockSize();
+  minQT[1] = 1 << minQtLog2SizeInterY;
+  xReadUvlc(uiCode, "sps_max_mtt_hierarchy_depth_inter_slice");     maxBTD[1] = uiCode;
+  CHECK(uiCode > 2*(ctbLog2SizeY - log2MinCUSize), "sps_max_mtt_hierarchy_depth_inter_slice shall be in the range 0 to 2*(ctbLog2SizeY - log2MinCUSize)");
+  maxTTSize[1] = maxBTSize[1] = minQT[1];
+  if (maxBTD[1] != 0)
+  {
+    xReadUvlc(uiCode, "sps_log2_diff_max_bt_min_qt_inter_slice");     maxBTSize[1] <<= uiCode;
+    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+    xReadUvlc(uiCode, "sps_log2_diff_max_tt_min_qt_inter_slice");     maxTTSize[1] <<= uiCode;
+    CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+    CHECK(maxTTSize[1] > 64, "The value of sps_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY");
+  }
+
+  pcSPS->setMinQTSizes(minQT);
+  pcSPS->setMaxMTTHierarchyDepth(maxBTD[1], maxBTD[0], maxBTD[2]);
+  pcSPS->setMaxBTSize(maxBTSize[1], maxBTSize[0], maxBTSize[2]);
+  pcSPS->setMaxTTSize(maxTTSize[1], maxTTSize[0], maxTTSize[2]);
+
+  if (pcSPS->getCTUSize() > 32)
+  {
+    xReadFlag(uiCode, "sps_max_luma_transform_size_64_flag");        pcSPS->setLog2MaxTbSize((uiCode ? 1 : 0) + 5);
+  }
+  else
+  {
+    pcSPS->setLog2MaxTbSize(5);
+  }
+
+  xReadFlag(uiCode, "sps_transform_skip_enabled_flag"); pcSPS->setTransformSkipEnabledFlag(uiCode ? true : false);
+  if (pcSPS->getTransformSkipEnabledFlag())
+  {
+    xReadUvlc(uiCode, "sps_log2_transform_skip_max_size_minus2");
+    pcSPS->setLog2MaxTransformSkipBlockSize(uiCode + 2);
+    xReadFlag(uiCode, "sps_bdpcm_enabled_flag"); pcSPS->setBDPCMEnabledFlag(uiCode ? true : false);
+  }
+  xReadFlag(uiCode, "sps_mts_enabled_flag");
+  pcSPS->setMtsEnabled(uiCode != 0);
+  if (pcSPS->getMtsEnabled())
+  {
+    xReadFlag(uiCode, "sps_explicit_mts_intra_enabled_flag");
+    pcSPS->setExplicitMtsIntraEnabled(uiCode != 0);
+    xReadFlag(uiCode, "sps_explicit_mts_inter_enabled_flag");
+    pcSPS->setExplicitMtsInterEnabled(uiCode != 0);
+  }
+  xReadFlag(uiCode, "sps_lfnst_enabled_flag");                    pcSPS->setUseLFNST(uiCode != 0);
+
+  if (isChromaEnabled(pcSPS->getChromaFormatIdc()))
+  {
+    xReadFlag(uiCode, "sps_joint_cbcr_enabled_flag");                pcSPS->setJointCbCrEnabledFlag(uiCode ? true : false);
+    ChromaQpMappingTableParams chromaQpMappingTableParams;
+    xReadFlag(uiCode, "sps_same_qp_table_for_chroma_flag");        chromaQpMappingTableParams.setSameCQPTableForAllChromaFlag(uiCode);
+    int numQpTables = chromaQpMappingTableParams.getSameCQPTableForAllChromaFlag() ? 1 : (pcSPS->getJointCbCrEnabledFlag() ? 3 : 2);
+    chromaQpMappingTableParams.setNumQpTables(numQpTables);
+    for (int i = 0; i < numQpTables; i++)
+    {
+      int32_t qpTableStart = 0;
+      xReadSvlc(qpTableStart, "sps_qp_table_starts_minus26");
+      chromaQpMappingTableParams.setQpTableStartMinus26(i, qpTableStart);
+      CHECK(qpTableStart < -26 - pcSPS->getQpBDOffset(ChannelType::LUMA) || qpTableStart > 36,
+            "The value of sps_qp_table_start_minus26[ i ] shall be in the range of -26 - QpBdOffset to 36 inclusive");
+      xReadUvlc(uiCode, "sps_num_points_in_qp_table_minus1");
+      chromaQpMappingTableParams.setNumPtsInCQPTableMinus1(i, uiCode);
+      CHECK(uiCode > 36 - qpTableStart, "The value of sps_num_points_in_qp_table_minus1[ i ] shall be in the range of "
+                                        "0 to 36 - sps_qp_table_start_minus26[ i ], inclusive");
+      std::vector<int> deltaQpInValMinus1(chromaQpMappingTableParams.getNumPtsInCQPTableMinus1(i) + 1);
+      std::vector<int> deltaQpOutVal(chromaQpMappingTableParams.getNumPtsInCQPTableMinus1(i) + 1);
+      for (int j = 0; j <= chromaQpMappingTableParams.getNumPtsInCQPTableMinus1(i); j++)
+      {
+        xReadUvlc(uiCode, "sps_delta_qp_in_val_minus1");
+        deltaQpInValMinus1[j] = uiCode;
+        xReadUvlc(uiCode, "sps_delta_qp_diff_val");
+        deltaQpOutVal[j] = uiCode ^ deltaQpInValMinus1[j];
+      }
+      chromaQpMappingTableParams.setDeltaQpInValMinus1(i, deltaQpInValMinus1);
+      chromaQpMappingTableParams.setDeltaQpOutVal(i, deltaQpOutVal);
+    }
+    pcSPS->setChromaQpMappingTableFromParams(chromaQpMappingTableParams, pcSPS->getQpBDOffset(ChannelType::CHROMA));
+    pcSPS->deriveChromaQPMappingTables();
+  }
+
+
+  xReadFlag( uiCode, "sps_sao_enabled_flag" );                      pcSPS->setSAOEnabledFlag ( uiCode ? true : false );
+  xReadFlag( uiCode, "sps_alf_enabled_flag" );                      pcSPS->setALFEnabledFlag ( uiCode ? true : false );
+  if (pcSPS->getALFEnabledFlag() && isChromaEnabled(pcSPS->getChromaFormatIdc()))
+  {
+    xReadFlag( uiCode, "sps_ccalf_enabled_flag" );                      pcSPS->setCCALFEnabledFlag ( uiCode ? true : false );
+  }
+  else
+  {
+    pcSPS->setCCALFEnabledFlag(false);
+  }
+
+  xReadFlag(uiCode, "sps_lmcs_enable_flag");                   pcSPS->setUseLmcs(uiCode == 1);
+
+  xReadFlag( uiCode, "sps_weighted_pred_flag" );                    pcSPS->setUseWP( uiCode ? true : false );
+  xReadFlag( uiCode, "sps_weighted_bipred_flag" );                  pcSPS->setUseWPBiPred( uiCode ? true : false );
+
+  xReadFlag(uiCode, "sps_long_term_ref_pics_flag");          pcSPS->setLongTermRefsPresent(uiCode);
+  if (pcSPS->getVPSId() > 0)
+  {
+    xReadFlag( uiCode, "sps_inter_layer_prediction_enabled_flag" );  pcSPS->setInterLayerPresentFlag( uiCode );
+  }
+  else
+  {
+    pcSPS->setInterLayerPresentFlag(0);
+  }
+  xReadFlag( uiCode, "sps_idr_rpl_present_flag" );       pcSPS->setIDRRefParamListPresent( (bool) uiCode );
+  if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoIdrRplConstraintFlag())
+  {
+    CHECK(uiCode != 0, "When gci_no_idr_rpl_constraint_flag equal to 1 , the value of sps_idr_rpl_present_flag shall be equal to 0");
+  }
+
+  xReadFlag(uiCode, "sps_rpl1_same_as_rpl0_flag");
+  pcSPS->setRPL1CopyFromRPL0Flag(uiCode);
+
+  //Read candidate for List0
+  xReadUvlc(uiCode, "sps_num_ref_pic_lists[0]");
+  uint32_t numberOfRPL = uiCode;
+  pcSPS->createRplList(REF_PIC_LIST_0, numberOfRPL);
+  RPLList              *rplList = pcSPS->getRplList(REF_PIC_LIST_0);
+  ReferencePictureList* rpl;
+  for (uint32_t ii = 0; ii < numberOfRPL; ii++)
+  {
+    rpl = rplList->getReferencePictureList(ii);
+    parseRefPicList(pcSPS, rpl, ii);
+  }
+
+  //Read candidate for List1
+  if (!pcSPS->getRPL1CopyFromRPL0Flag())
+  {
+    xReadUvlc(uiCode, "sps_num_ref_pic_lists[1]");
+    numberOfRPL = uiCode;
+    pcSPS->createRplList(REF_PIC_LIST_1, numberOfRPL);
+    rplList = pcSPS->getRplList(REF_PIC_LIST_1);
+    for (uint32_t ii = 0; ii < numberOfRPL; ii++)
+    {
+      rpl = rplList->getReferencePictureList(ii);
+      parseRefPicList(pcSPS, rpl, ii);
+    }
+  }
+  else
+  {
+    numberOfRPL = pcSPS->getNumRpl(REF_PIC_LIST_0);
+    pcSPS->createRplList(REF_PIC_LIST_1, numberOfRPL);
+    RPLList *rplListSource = pcSPS->getRplList(REF_PIC_LIST_0);
+    RPLList *rplListDest   = pcSPS->getRplList(REF_PIC_LIST_1);
+    for (uint32_t ii = 0; ii < numberOfRPL; ii++)
+    {
+      copyRefPicList(pcSPS, rplListSource->getReferencePictureList(ii), rplListDest->getReferencePictureList(ii));
+    }
+  }
+
+
+  xReadFlag(uiCode, "sps_ref_wraparound_enabled_flag");                  pcSPS->setWrapAroundEnabledFlag( uiCode ? true : false );
+
+  if (pcSPS->getWrapAroundEnabledFlag())
+  {
+    for (int i = 0; i < pcSPS->getNumSubPics(); i++)
+    {
+      CHECK(pcSPS->getSubPicTreatedAsPicFlag(i) && (pcSPS->getSubPicWidth(i) != (pcSPS->getMaxPicWidthInLumaSamples() + pcSPS->getCTUSize() - 1) / pcSPS->getCTUSize()), "sps_ref_wraparound_enabled_flag cannot be equal to 1 when there is at least one subpicture with SubPicTreatedAsPicFlag equal to 1 and the subpicture's width is not equal to picture's width");
+    }
+  }
+
+  xReadFlag( uiCode, "sps_temporal_mvp_enabled_flag" );                  pcSPS->setSPSTemporalMVPEnabledFlag(uiCode);
+
+  if ( pcSPS->getSPSTemporalMVPEnabledFlag() )
+  {
+    xReadFlag(uiCode, "sps_sbtmvp_enabled_flag");
+    pcSPS->setSbTMVPEnabledFlag(uiCode != 0);
+  }
+  else
+  {
+    pcSPS->setSbTMVPEnabledFlag(false);
+  }
+
+  xReadFlag( uiCode,  "sps_amvr_enabled_flag" );                     pcSPS->setAMVREnabledFlag ( uiCode != 0 );
+
+  xReadFlag( uiCode, "sps_bdof_enabled_flag" );                      pcSPS->setBDOFEnabledFlag ( uiCode != 0 );
+  if (pcSPS->getBDOFEnabledFlag())
+  {
+    xReadFlag(uiCode, "sps_bdof_control_present_in_ph_flag");        pcSPS->setBdofControlPresentInPhFlag( uiCode != 0 );
+  }
+  else
+  {
+    pcSPS->setBdofControlPresentInPhFlag( false );
+  }
+  xReadFlag(uiCode, "sps_smvd_enabled_flag");                       pcSPS->setUseSMVD( uiCode != 0 );
+  xReadFlag(uiCode, "sps_dmvr_enabled_flag");                        pcSPS->setUseDMVR(uiCode != 0);
+  if (pcSPS->getUseDMVR())
+  {
+    xReadFlag(uiCode, "sps_dmvr_control_present_in_ph_flag");                 pcSPS->setDmvrControlPresentInPhFlag( uiCode != 0 );
+  }
+  else
+  {
+    pcSPS->setDmvrControlPresentInPhFlag( false );
+  }
+  xReadFlag(uiCode, "sps_mmvd_enabled_flag");                        pcSPS->setUseMMVD(uiCode != 0);
+  if (pcSPS->getUseMMVD())
+  {
+    xReadFlag(uiCode, "sps_mmvd_fullpel_only_flag");                pcSPS->setFpelMmvdEnabledFlag(uiCode != 0);
+  }
+  else
+  {
+    pcSPS->setFpelMmvdEnabledFlag( false );
+  }
+
+  xReadUvlc(uiCode, "sps_six_minus_max_num_merge_cand");
+  CHECK(MRG_MAX_NUM_CANDS <= uiCode, "Incorrrect max number of merge candidates!");
+  pcSPS->setMaxNumMergeCand(MRG_MAX_NUM_CANDS - uiCode);
+  xReadFlag(uiCode, "sps_sbt_enabled_flag");                        pcSPS->setUseSBT                 ( uiCode != 0 );
+  xReadFlag( uiCode,    "sps_affine_enabled_flag" );                            pcSPS->setUseAffine              ( uiCode != 0 );
+  if ( pcSPS->getUseAffine() )
+  {
+    xReadUvlc(uiCode, "sps_five_minus_max_num_subblock_merge_cand");
+    CHECK(
+      uiCode > 5 - (pcSPS->getSbTMVPEnabledFlag() ? 1 : 0),
+      "The value of sps_five_minus_max_num_subblock_merge_cand shall be in the range of 0 to 5 - sps_sbtmvp_enabled_flag");
+    CHECK(AFFINE_MRG_MAX_NUM_CANDS < uiCode, "The value of sps_five_minus_max_num_subblock_merge_cand shall be in the range of 0 to 5 - sps_sbtmvp_enabled_flag");
+    pcSPS->setMaxNumAffineMergeCand(AFFINE_MRG_MAX_NUM_CANDS - uiCode);
+    xReadFlag( uiCode,  "sps_affine_type_flag" );                       pcSPS->setUseAffineType          ( uiCode != 0 );
+    if( pcSPS->getAMVREnabledFlag())
+    {
+      xReadFlag( uiCode, "sps_affine_amvr_enabled_flag" );            pcSPS->setAffineAmvrEnabledFlag  ( uiCode != 0 );
+    }
+    xReadFlag( uiCode, "sps_affine_prof_enabled_flag" );            pcSPS->setUsePROF                ( uiCode != 0 );
+    if (pcSPS->getUsePROF())
+    {
+      xReadFlag(uiCode, "sps_prof_control_present_in_ph_flag");               pcSPS->setProfControlPresentInPhFlag ( uiCode != 0 );
+    }
+    else
+    {
+      pcSPS->setProfControlPresentInPhFlag( false );
+    }
+  }
+
+  xReadFlag( uiCode,    "sps_bcw_enabled_flag" );                   pcSPS->setUseBcw( uiCode != 0 );
+
+  xReadFlag( uiCode,     "sps_ciip_enabled_flag" );                           pcSPS->setUseCiip             ( uiCode != 0 );
+  if (pcSPS->getMaxNumMergeCand() >= 2)
+  {
+    xReadFlag(uiCode, "sps_gpm_enabled_flag");
+    pcSPS->setUseGeo(uiCode != 0);
+    if (pcSPS->getUseGeo())
+    {
+      if (pcSPS->getMaxNumMergeCand() >= 3)
+      {
+        xReadUvlc(uiCode, "sps_max_num_merge_cand_minus_max_num_gpm_cand");
+        CHECK(pcSPS->getMaxNumMergeCand() - 2 < uiCode,
+              "sps_max_num_merge_cand_minus_max_num_gpm_cand must not be greater than the number of merge candidates minus 2");
+        pcSPS->setMaxNumGeoCand((uint32_t)(pcSPS->getMaxNumMergeCand() - uiCode));
+      }
+      else
+      {
+        pcSPS->setMaxNumGeoCand(2);
+      }
+    }
+  }
+  else
+  {
+    pcSPS->setUseGeo(0);
+    pcSPS->setMaxNumGeoCand(0);
+  }
+
+  xReadUvlc(uiCode, "sps_log2_parallel_merge_level_minus2");
+  CHECK(uiCode + 2 > ctbLog2SizeY, "The value of sps_log2_parallel_merge_level_minus2 shall be in the range of 0 to ctbLog2SizeY - 2");
+  pcSPS->setLog2ParallelMergeLevelMinus2(uiCode);
+
+
+  xReadFlag(uiCode, "sps_isp_enabled_flag");                        pcSPS->setUseISP( uiCode != 0 );
+  xReadFlag(uiCode, "sps_mrl_enabled_flag");                        pcSPS->setUseMRL( uiCode != 0 );
+  xReadFlag(uiCode, "sps_mip_enabled_flag");                        pcSPS->setUseMIP( uiCode != 0 );
+  if (isChromaEnabled(pcSPS->getChromaFormatIdc()))
+  {
+    xReadFlag( uiCode, "sps_cclm_enabled_flag" );                   pcSPS->setUseLMChroma( uiCode != 0 );
+  }
+  else
+  {
+    pcSPS->setUseLMChroma(0);
+  }
+  if (pcSPS->getChromaFormatIdc() == ChromaFormat::_420)
+  {
+    xReadFlag( uiCode, "sps_chroma_horizontal_collocated_flag" );   pcSPS->setHorCollocatedChromaFlag( uiCode != 0 );
+    xReadFlag( uiCode, "sps_chroma_vertical_collocated_flag" );     pcSPS->setVerCollocatedChromaFlag( uiCode != 0 );
+  }
+  else
+  {
+    pcSPS->setHorCollocatedChromaFlag(true);
+    pcSPS->setVerCollocatedChromaFlag(true);
+  }
+  xReadFlag( uiCode,  "sps_palette_enabled_flag");                                pcSPS->setPLTMode                ( uiCode != 0 );
+  CHECK((profile == Profile::MAIN_12 || profile == Profile::MAIN_12_INTRA || profile == Profile::MAIN_12_STILL_PICTURE)
+    && uiCode != 0, "sps_palette_enabled_flag shall be equal to 0 for Main 12 (420) profiles");
+  if (pcSPS->getChromaFormatIdc() == ChromaFormat::_444 && pcSPS->getLog2MaxTbSize() != 6)
+  {
+    xReadFlag(uiCode, "sps_act_enabled_flag");                                pcSPS->setUseColorTrans(uiCode != 0);
+  }
+  else
+  {
+    pcSPS->setUseColorTrans(false);
+  }
+  if (pcSPS->getTransformSkipEnabledFlag() || pcSPS->getPLTMode())
+  {
+    xReadUvlc(uiCode, "sps_internal_bit_depth_minus_input_bit_depth");
+    pcSPS->setInternalMinusInputBitDepth(ChannelType::LUMA, uiCode);
+    CHECK(uiCode > 8, "Invalid sps_internal_bit_depth_minus_input_bit_depth signalled");
+    pcSPS->setInternalMinusInputBitDepth(ChannelType::CHROMA, uiCode);
+  }
+  xReadFlag(uiCode, "sps_ibc_enabled_flag");                                    pcSPS->setIBCFlag(uiCode != 0);
+  if (pcSPS->getIBCFlag())
+  {
+    xReadUvlc(uiCode, "sps_six_minus_max_num_ibc_merge_cand");
+    CHECK(IBC_MRG_MAX_NUM_CANDS <= uiCode, "Incorrect max number of IBC merge candidates!");
+    pcSPS->setMaxNumIBCMergeCand(IBC_MRG_MAX_NUM_CANDS - uiCode);
+  }
+  else
+  {
+    pcSPS->setMaxNumIBCMergeCand(0);
+  }
+
+  xReadFlag( uiCode, "sps_ladf_enabled_flag" );                     pcSPS->setLadfEnabled( uiCode != 0 );
+  if ( pcSPS->getLadfEnabled() )
+  {
+    int signedSymbol = 0;
+    xReadCode( 2, uiCode, "sps_num_ladf_intervals_minus2");         pcSPS->setLadfNumIntervals( uiCode + 2 );
+    xReadSvlc(signedSymbol, "sps_ladf_lowest_interval_qp_offset" );      pcSPS->setLadfQpOffset( signedSymbol, 0 );
+    for ( int k = 1; k < pcSPS->getLadfNumIntervals(); k++ )
+    {
+      xReadSvlc(signedSymbol, "sps_ladf_qp_offset" );                    pcSPS->setLadfQpOffset( signedSymbol, k );
+      xReadUvlc( uiCode, "sps_ladf_delta_threshold_minus1");
+      pcSPS->setLadfIntervalLowerBound(uiCode + pcSPS->getLadfIntervalLowerBound(k - 1) + 1, k);
+    }
+  }
+  xReadFlag(uiCode, "sps_explicit_scaling_list_enabled_flag");                 pcSPS->setScalingListFlag(uiCode);
+  if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoExplicitScaleListConstraintFlag())
+  {
+    CHECK(uiCode != 0, "When gci_no_explicit_scaling_list_constraint_flag is equal to 1, sps_explicit_scaling_list_enabled_flag shall be equal to 0");
+  }
+
+  if (pcSPS->getUseLFNST() && pcSPS->getScalingListFlag())
+  {
+    xReadFlag(uiCode, "sps_scaling_matrix_for_lfnst_disabled_flag"); pcSPS->setDisableScalingMatrixForLfnstBlks(uiCode ? true : false);
+  }
+
+  if (pcSPS->getUseColorTrans() && pcSPS->getScalingListFlag())
+  {
+    xReadFlag(uiCode, "sps_scaling_matrix_for_alternative_colour_space_disabled_flag"); pcSPS->setScalingMatrixForAlternativeColourSpaceDisabledFlag(uiCode);
+  }
+  if (pcSPS->getScalingMatrixForAlternativeColourSpaceDisabledFlag())
+  {
+    xReadFlag(uiCode, "sps_scaling_matrix_designated_colour_space_flag"); pcSPS->setScalingMatrixDesignatedColourSpaceFlag(uiCode);
+  }
+  xReadFlag(uiCode, "sps_dep_quant_enabled_flag"); pcSPS->setDepQuantEnabledFlag(uiCode);
+  xReadFlag(uiCode, "sps_sign_data_hiding_enabled_flag"); pcSPS->setSignDataHidingEnabledFlag(uiCode);
+
+  xReadFlag( uiCode, "sps_virtual_boundaries_enabled_flag" ); pcSPS->setVirtualBoundariesEnabledFlag( uiCode != 0 );
+  if (pcSPS->getProfileTierLevel()->getConstraintInfo()->getNoVirtualBoundaryConstraintFlag())
+  {
+    CHECK(uiCode != 0, "When gci_no_virtual_boundaries_constraint_flag is equal to 1, sps_virtual_boundaries_enabled_flag shall be equal to 0");
+  }
+
+  if( pcSPS->getVirtualBoundariesEnabledFlag() )
+  {
+    xReadFlag( uiCode, "sps_loop_filter_across_virtual_boundaries_present_flag" ); pcSPS->setVirtualBoundariesPresentFlag( uiCode != 0 );
+    if( pcSPS->getVirtualBoundariesPresentFlag() )
+    {
+      xReadUvlc(uiCode, "sps_num_ver_virtual_boundaries");
+      pcSPS->setNumVerVirtualBoundaries(uiCode);
+      if (pcSPS->getMaxPicWidthInLumaSamples() <= 8)
+      {
+        CHECK(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the "
+                                                        "number of vertical virtual boundaries shall be equal to 0");
+      }
+      else
+      {
+        CHECK(pcSPS->getNumVerVirtualBoundaries() > 3,
+              "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+      }
+      for (unsigned i = 0; i < pcSPS->getNumVerVirtualBoundaries(); i++)
+      {
+        xReadUvlc(uiCode, "sps_virtual_boundary_pos_x_minus1[i]");
+        pcSPS->setVirtualBoundariesPosX((uiCode + 1) << 3, i);
+        CHECK(uiCode > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2),
+              "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( "
+              "sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
+      }
+      xReadUvlc(uiCode, "sps_num_hor_virtual_boundaries");
+      pcSPS->setNumHorVirtualBoundaries(uiCode);
+      if (pcSPS->getMaxPicHeightInLumaSamples() <= 8)
+      {
+        CHECK(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the "
+                                                        "number of horizontal virtual boundaries shall be equal to 0");
+      }
+      else
+      {
+        CHECK(pcSPS->getNumHorVirtualBoundaries() > 3,
+              "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+      }
+      for (unsigned i = 0; i < pcSPS->getNumHorVirtualBoundaries(); i++)
+      {
+        xReadUvlc(uiCode, "sps_virtual_boundary_pos_y_minus1[i]");
+        pcSPS->setVirtualBoundariesPosY((uiCode + 1) << 3, i);
+        CHECK(uiCode > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2),
+              "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( "
+              "sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
+      }
+    }
+    else
+    {
+      pcSPS->setNumVerVirtualBoundaries(0);
+      pcSPS->setNumHorVirtualBoundaries(0);
+    }
+  }
+  else
+  {
+    pcSPS->setVirtualBoundariesPresentFlag(false);
+  }
+
+  if (pcSPS->getPtlDpbHrdParamsPresentFlag())
+  {
+    xReadFlag(uiCode, "sps_timing_hrd_params_present_flag");        pcSPS->setGeneralHrdParametersPresentFlag(uiCode);
+    if (pcSPS->getGeneralHrdParametersPresentFlag())
+    {
+      parseGeneralHrdParameters(pcSPS->getGeneralHrdParameters());
+      if ((pcSPS->getMaxTLayers()-1) > 0)
+      {
+        xReadFlag(uiCode, "sps_sublayer_cpb_params_present_flag");  pcSPS->setSubLayerParametersPresentFlag(uiCode);
+      }
+      else if((pcSPS->getMaxTLayers()-1) == 0)
+      {
+        pcSPS->setSubLayerParametersPresentFlag(0);
+      }
+
+      uint32_t firstSubLayer = pcSPS->getSubLayerParametersPresentFlag() ? 0 : (pcSPS->getMaxTLayers() - 1);
+      parseOlsHrdParameters(pcSPS->getGeneralHrdParameters(),pcSPS->getOlsHrdParameters(), firstSubLayer, pcSPS->getMaxTLayers() - 1);
+    }
+  }
+
+  xReadFlag(     uiCode, "sps_field_seq_flag");                       pcSPS->setFieldSeqFlag(uiCode);
+  CHECK( pcSPS->getProfileTierLevel()->getFrameOnlyConstraintFlag() && uiCode, "When ptl_frame_only_constraint_flag equal to 1 , the value of sps_field_seq_flag shall be equal to 0");
+
+  xReadFlag( uiCode, "sps_vui_parameters_present_flag" );             pcSPS->setVuiParametersPresentFlag(uiCode);
+
+  if (pcSPS->getVuiParametersPresentFlag())
+  {
+    xReadUvlc(uiCode, "sps_vui_payload_size_minus1");
+    pcSPS->setVuiPayloadSize(uiCode+1);
+    while (!isByteAligned())
+    {
+      xReadFlag(uiCode, "sps_vui_alignment_zero_bit");
+      CHECK(uiCode != 0, "sps_vui_alignment_zero_bit not equal to 0");
+    }
+    parseVUI(pcSPS->getVuiParameters(), pcSPS);
+  }
+
+  xReadFlag( uiCode, "sps_extension_present_flag");
+
+  if (uiCode)
+  {
+    static const char *syntaxStrings[] = {
+      "sps_range_extension_flag", "sps_extension_7bits[0]", "sps_extension_7bits[1]", "sps_extension_7bits[2]",
+      "sps_extension_7bits[3]",   "sps_extension_7bits[4]", "sps_extension_7bits[5]", "sps_extension_7bits[6]",
+    };
+
+    bool sps_extension_flags[NUM_SPS_EXTENSION_FLAGS];
+
+    for(int i=0; i<NUM_SPS_EXTENSION_FLAGS; i++)
+    {
+      xReadFlag( uiCode, syntaxStrings[i] );
+      sps_extension_flags[i] = uiCode!=0;
+    }
+
+    if (pcSPS->getBitDepth(ChannelType::LUMA) <= 10)
+    {
+      CHECK(sps_extension_flags[SPS_EXT__REXT] == 1,
+            "The value of sps_range_extension_flag shall be 0 when BitDepth is less than or equal to 10.");
+    }
+
+    bool bSkipTrailingExtensionBits=false;
+    for(int i=0; i<NUM_SPS_EXTENSION_FLAGS; i++) // loop used so that the order is determined by the enum.
+    {
+      if (sps_extension_flags[i])
+      {
+        switch (SPSExtensionFlagIndex(i))
+        {
+        case SPS_EXT__REXT:
+          CHECK(bSkipTrailingExtensionBits, "Skipping trailing extension bits not supported");
+          {
+            SPSRExt &spsRangeExtension = pcSPS->getSpsRangeExtension();
+            xReadFlag( uiCode, "extended_precision_processing_flag");       spsRangeExtension.setExtendedPrecisionProcessingFlag (uiCode != 0);
+            if (pcSPS->getTransformSkipEnabledFlag())
+            {
+              xReadFlag( uiCode, "sps_ts_residual_coding_rice_present_in_sh_flag"); spsRangeExtension.setTSRCRicePresentFlag(uiCode != 0);
+            }
+            xReadFlag(uiCode,  "rrc_rice_extension_flag");                  spsRangeExtension.setRrcRiceExtensionEnableFlag      (uiCode != 0);
+            xReadFlag( uiCode, "persistent_rice_adaptation_enabled_flag");  spsRangeExtension.setPersistentRiceAdaptationEnabledFlag (uiCode != 0);
+            xReadFlag( uiCode, "reverse_last_position_enabled_flag");       spsRangeExtension.setReverseLastSigCoeffEnabledFlag(uiCode != 0);
+          }
+          break;
+        default:
+          bSkipTrailingExtensionBits=true;
+          break;
+        }
+      }
+    }
+    if (bSkipTrailingExtensionBits)
+    {
+      while ( xMoreRbspData() )
+      {
+        xReadFlag( uiCode, "sps_extension_data_flag");
+      }
+    }
+  }
+  xReadRbspTrailingBits();
+}
+
+void HLSyntaxReader::parseOPI(OPI* opi)
+{
+#if ENABLE_TRACING
+  xTraceOPIHeader();
+#endif
+  uint32_t  symbol;
+
+  xReadFlag(symbol, "opi_ols_info_present_flag");
+  opi->setOlsInfoPresentFlag(symbol);
+  xReadFlag(symbol, "opi_htid_info_present_flag");
+  opi->setHtidInfoPresentFlag(symbol);
+
+  if (opi->getOlsInfoPresentFlag())
+  {
+    xReadUvlc(symbol, "opi_ols_idx");
+    opi->setOpiOlsIdx(symbol);
+  }
+
+  if (opi->getHtidInfoPresentFlag())
+  {
+    xReadCode(3, symbol, "opi_htid_plus1");
+    opi->setOpiHtidPlus1(symbol);
+  }
+
+  xReadFlag(symbol, "opi_extension_flag");
+  if (symbol)
+  {
+    while (xMoreRbspData())
+    {
+      xReadFlag(symbol, "opi_extension_data_flag");
+    }
+  }
+  xReadRbspTrailingBits();
+}
+
+
+void HLSyntaxReader::parseDCI(DCI* dci)
+{
+#if ENABLE_TRACING
+  xTraceDCIHeader();
+#endif
+  uint32_t  symbol;
+
+  xReadCode(4, symbol, "dci_reserved_zero_4bits");
+
+  uint32_t numPTLs;
+  xReadCode(4, numPTLs, "dci_num_ptls_minus1");
+  numPTLs += 1;
+
+  std::vector<ProfileTierLevel> ptls;
+  ptls.resize(numPTLs);
+  for (int i = 0; i < numPTLs; i++)
+  {
+    parseProfileTierLevel(&ptls[i], true, 0);
+  }
+  dci->setProfileTierLevel(ptls);
+
+  xReadFlag(symbol, "dci_extension_flag");
+  if (symbol)
+  {
+    while (xMoreRbspData())
+    {
+      xReadFlag(symbol, "dci_extension_data_flag");
+    }
+  }
+  xReadRbspTrailingBits();
+}
+
+void HLSyntaxReader::parseVPS(VPS* pcVPS)
+{
+#if ENABLE_TRACING
+  xTraceVPSHeader();
+#endif
+  uint32_t  uiCode;
+
+  xReadCode(4, uiCode, "vps_video_parameter_set_id");
+  CHECK( uiCode == 0, "vps_video_parameter_set_id equal to zero is reserved and shall not be used in a bitstream" );
+  pcVPS->setVPSId(uiCode);
+
+  xReadCode(6, uiCode, "vps_max_layers_minus1");              pcVPS->setMaxLayers(uiCode + 1);    CHECK(uiCode + 1 > MAX_VPS_LAYERS, "Signalled number of layers larger than MAX_VPS_LAYERS.");
+  if (pcVPS->getMaxLayers() - 1 == 0)
+  {
+    pcVPS->setEachLayerIsAnOlsFlag(1);
+  }
+  xReadCode(3, uiCode, "vps_max_sublayers_minus1");           pcVPS->setMaxSubLayers(uiCode + 1); CHECK(uiCode + 1 > MAX_VPS_SUBLAYERS, "Signalled number of sublayers larger than MAX_VPS_SUBLAYERS.");
+  if( pcVPS->getMaxLayers() > 1 && pcVPS->getMaxSubLayers() > 1)
+  {
+    xReadFlag(uiCode, "vps_default_ptl_dpb_hrd_max_tid_flag"); pcVPS->setDefaultPtlDpbHrdMaxTidFlag(uiCode);
+  }
+  else
+  {
+    pcVPS->setDefaultPtlDpbHrdMaxTidFlag(1);
+  }
+  if( pcVPS->getMaxLayers() > 1 )
+  {
+    xReadFlag(uiCode, "vps_all_independent_layers_flag");  pcVPS->setAllIndependentLayersFlag(uiCode);
+    if (pcVPS->getAllIndependentLayersFlag() == 0)
+    {
+      pcVPS->setEachLayerIsAnOlsFlag(0);
+    }
+  }
+  std::vector<std::vector<uint32_t>> maxTidilRefPicsPlus1;
+  maxTidilRefPicsPlus1.resize(pcVPS->getMaxLayers(), std::vector<uint32_t>(pcVPS->getMaxLayers(), NOT_VALID));
+  pcVPS->setMaxTidIlRefPicsPlus1(maxTidilRefPicsPlus1);
+  for (uint32_t i = 0; i < pcVPS->getMaxLayers(); i++)
+  {
+    xReadCode(6, uiCode, "vps_layer_id");                     pcVPS->setLayerId(i, uiCode);
+    pcVPS->setGeneralLayerIdx(uiCode, i);
+
+    if (i > 0 && !pcVPS->getAllIndependentLayersFlag())
+    {
+      xReadFlag(uiCode, "vps_independent_layer_flag");     pcVPS->setIndependentLayerFlag(i, uiCode);
+      if (!pcVPS->getIndependentLayerFlag(i))
+      {
+        xReadFlag(uiCode, "max_tid_ref_present_flag[ i ]");
+        bool presentFlag = uiCode;
+        uint16_t sumUiCode = 0;
+        for (int j = 0, k = 0; j < i; j++)
+        {
+          xReadFlag(uiCode, "vps_direct_ref_layer_flag"); pcVPS->setDirectRefLayerFlag(i, j, uiCode);
+          if (uiCode)
+          {
+            pcVPS->setInterLayerRefIdc(i, j, k);
+            pcVPS->setDirectRefLayerIdx(i, k++, j);
+            sumUiCode++;
+          }
+          if (presentFlag && pcVPS->getDirectRefLayerFlag(i, j))
+          {
+            xReadCode(3, uiCode, "max_tid_il_ref_pics_plus1[ i ][ j ]");
+            pcVPS->setMaxTidIlRefPicsPlus1(i, j, uiCode);
+          }
+          else
+          {
+            pcVPS->setMaxTidIlRefPicsPlus1(i, j, 7);
+          }
+        }
+        CHECK(sumUiCode == 0, "There has to be at least one value of j such that the value of vps_direct_dependency_flag[ i ][ j ] is equal to 1,when vps_independent_layer_flag[ i ] is equal to 0 ");
+      }
+    }
+  }
+
+  if (pcVPS->getMaxLayers() > 1)
+  {
+    if (pcVPS->getAllIndependentLayersFlag())
+    {
+      xReadFlag(uiCode, "vps_each_layer_is_an_ols_flag");  pcVPS->setEachLayerIsAnOlsFlag(uiCode);
+      if (pcVPS->getEachLayerIsAnOlsFlag() == 0)
+      {
+        pcVPS->setOlsModeIdc(2);
+      }
+    }
+    if (!pcVPS->getEachLayerIsAnOlsFlag())
+    {
+      if (!pcVPS->getAllIndependentLayersFlag())
+      {
+        xReadCode(2, uiCode, "vps_ols_mode_idc");         pcVPS->setOlsModeIdc(uiCode); CHECK(uiCode > MAX_VPS_OLS_MODE_IDC, "vps_ols_mode_idc shall be in the range of 0 to 2");
+      }
+      if (pcVPS->getOlsModeIdc() == 2)
+      {
+        xReadCode(8, uiCode, "vps_num_output_layer_sets_minus2");   pcVPS->setNumOutputLayerSets(uiCode + 2);
+        pcVPS->setOlsOutputLayerFlag(0, 0, true);
+        for (uint32_t i = 1; i <= pcVPS->getNumOutputLayerSets() - 1; i++)
+        {
+          for (uint32_t j = 0; j < pcVPS->getMaxLayers(); j++)
+          {
+            xReadFlag(uiCode, "vps_ols_output_layer_flag");        pcVPS->setOlsOutputLayerFlag(i, j, uiCode);
+          }
+        }
+      }
+    }
+    xReadCode(8, uiCode, "vps_num_ptls_minus1");      pcVPS->setNumPtls(uiCode + 1);
+  }
+  else
+  {
+    pcVPS->setNumPtls(1);
+  }
+  pcVPS->deriveOutputLayerSets();
+  CHECK( pcVPS->getNumPtls() > pcVPS->getTotalNumOLSs(),"The value of vps_num_ptls_minus1 shall be less than TotalNumOlss");
+  std::vector<bool> isPTLReferred( pcVPS->getNumPtls(), false);
+
+  for (int i = 0; i < pcVPS->getNumPtls(); i++)
+  {
+    if(i > 0)
+    {
+      xReadFlag(uiCode, "vps_pt_present_flag");
+      pcVPS->setPtPresentFlag(i, uiCode != 0);
+    }
+    else
+    {
+      pcVPS->setPtPresentFlag(0, true);
+    }
+    if (!pcVPS->getDefaultPtlDpbHrdMaxTidFlag())
+    {
+      xReadCode(3, uiCode, "vps_ptl_max_tid");
+      pcVPS->setPtlMaxTemporalId(i, uiCode);
+    }
+    else
+    {
+      pcVPS->setPtlMaxTemporalId(i, pcVPS->getMaxSubLayers() - 1);
+    }
+  }
+  int cnt = 0;
+  while (m_pcBitstream->getNumBitsUntilByteAligned())
+  {
+    xReadFlag( uiCode, "vps_ptl_reserved_zero_bit");
+    CHECK(uiCode!=0, "Alignment bit is not '0'");
+    cnt++;
+  }
+  CHECK(cnt >= 8, "Read more than '8' alignment bits");
+
+  for (int i = 0; i < pcVPS->getNumPtls(); i++)
+  {
+    ProfileTierLevel ptl;
+    parseProfileTierLevel(&ptl, pcVPS->getPtPresentFlag(i), pcVPS->getPtlMaxTemporalId(i));
+
+    if (!pcVPS->getPtPresentFlag(i))
+    {
+      CHECK(i == 0, "Profile/Tier should always be present for first entry");
+
+      ptl.copyProfileTierConstraintsFrom(pcVPS->getProfileTierLevel(i - 1));
+    }
+    pcVPS->setProfileTierLevel(i, ptl);
+  }
+
+  for (int i = 0; i < pcVPS->getTotalNumOLSs(); i++)
+  {
+    if (pcVPS->getNumPtls() > 1 && pcVPS->getNumPtls() != pcVPS->getTotalNumOLSs())
+    {
+      xReadCode(8, uiCode, "vps_ols_ptl_idx");
+      pcVPS->setOlsPtlIdx(i, uiCode);
+    }
+    else if (pcVPS->getNumPtls() == pcVPS->getTotalNumOLSs())
+    {
+      pcVPS->setOlsPtlIdx(i, i);
+    }
+    else
+    {
+      pcVPS->setOlsPtlIdx(i, 0);
+    }
+    isPTLReferred[pcVPS->getOlsPtlIdx(i)] = true;
+  }
+  for( int i = 0; i < pcVPS->getNumPtls(); i++ )
+  {
+    CHECK( !isPTLReferred[i],"Each profile_tier_level( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_ptl_idx[ i ] for i in the range of 0 to TotalNumOlss ? 1, inclusive");
+  }
+
+  if( !pcVPS->getEachLayerIsAnOlsFlag() )
+  {
+    xReadUvlc( uiCode, "vps_num_dpb_params_minus1" ); pcVPS->m_numDpbParams = uiCode + 1;
+
+    CHECK( pcVPS->m_numDpbParams > pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_dpb_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+    std::vector<bool> isDPBParamReferred(pcVPS->m_numDpbParams, false);
+
+    if( pcVPS->m_numDpbParams > 0 && pcVPS->getMaxSubLayers() > 1 )
+    {
+      xReadFlag( uiCode, "vps_sublayer_dpb_params_present_flag" ); pcVPS->m_sublayerDpbParamsPresentFlag = uiCode;
+    }
+
+    pcVPS->m_dpbParameters.resize( pcVPS->m_numDpbParams );
+
+    for( int i = 0; i < pcVPS->m_numDpbParams; i++ )
+    {
+      if (!pcVPS->getDefaultPtlDpbHrdMaxTidFlag())
+      {
+        xReadCode(3, uiCode, "vps_dpb_max_tid[i]");
+        pcVPS->m_dpbMaxTemporalId.push_back(uiCode);
+        CHECK (uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_dpb_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
+      }
+      else
+      {
+        pcVPS->m_dpbMaxTemporalId.push_back(pcVPS->getMaxSubLayers() - 1);
+      }
+
+      for( int j = ( pcVPS->m_sublayerDpbParamsPresentFlag ? 0 : pcVPS->m_dpbMaxTemporalId[i] ); j <= pcVPS->m_dpbMaxTemporalId[i]; j++ )
+      {
+        xReadUvlc(uiCode, "dpb_max_dec_pic_buffering_minus1[i]");
+        pcVPS->m_dpbParameters[i].maxDecPicBuffering[j] = uiCode + 1;
+        xReadUvlc( uiCode, "dpb_max_num_reorder_pics[i]" );          pcVPS->m_dpbParameters[i].maxNumReorderPics[j] = uiCode;
+        xReadUvlc( uiCode, "dpb_max_latency_increase_plus1[i]" );    pcVPS->m_dpbParameters[i].maxLatencyIncreasePlus1[j] = uiCode;
+      }
+
+      for( int j = ( pcVPS->m_sublayerDpbParamsPresentFlag ? pcVPS->m_dpbMaxTemporalId[i] : 0 ); j < pcVPS->m_dpbMaxTemporalId[i]; j++ )
+      {
+        // When dpb_max_dec_pic_buffering_minus1[ i ] is not present for i in the range of 0 to maxSubLayersMinus1 - 1, inclusive, due to subLayerInfoFlag being equal to 0, it is inferred to be equal to dpb_max_dec_pic_buffering_minus1[ maxSubLayersMinus1 ].
+        pcVPS->m_dpbParameters[i].maxDecPicBuffering[j] = pcVPS->m_dpbParameters[i].maxDecPicBuffering[pcVPS->m_dpbMaxTemporalId[i]];
+
+        // When dpb_max_num_reorder_pics[ i ] is not present for i in the range of 0 to maxSubLayersMinus1 - 1, inclusive, due to subLayerInfoFlag being equal to 0, it is inferred to be equal to dpb_max_num_reorder_pics[ maxSubLayersMinus1 ].
+        pcVPS->m_dpbParameters[i].maxNumReorderPics[j] = pcVPS->m_dpbParameters[i].maxNumReorderPics[pcVPS->m_dpbMaxTemporalId[i]];
+
+        // When dpb_max_latency_increase_plus1[ i ] is not present for i in the range of 0 to maxSubLayersMinus1 - 1, inclusive, due to subLayerInfoFlag being equal to 0, it is inferred to be equal to dpb_max_latency_increase_plus1[ maxSubLayersMinus1 ].
+        pcVPS->m_dpbParameters[i].maxLatencyIncreasePlus1[j] = pcVPS->m_dpbParameters[i].maxLatencyIncreasePlus1[pcVPS->m_dpbMaxTemporalId[i]];
+      }
+    }
+
+
+    for( int i = 0, j=0; i < pcVPS->getTotalNumOLSs(); i++ )
+    {
+      if( pcVPS->m_numLayersInOls[i] > 1 )
+      {
+        xReadUvlc( uiCode, "vps_ols_dpb_pic_width[i]" ); pcVPS->setOlsDpbPicWidth( i, uiCode );
+        xReadUvlc( uiCode, "vps_ols_dpb_pic_height[i]" ); pcVPS->setOlsDpbPicHeight( i, uiCode );
+        xReadCode(2, uiCode, "vps_ols_dpb_chroma_format[i]");
+        pcVPS->setOlsDpbChromaFormatIdc(i, static_cast<ChromaFormat>(uiCode));
+        xReadUvlc( uiCode, "vps_ols_dpb_bitdepth_minus8[i]"); pcVPS->setOlsDpbBitDepthMinus8(i, uiCode);
+        const Profile::Name profile = pcVPS->getProfileTierLevel(pcVPS->getOlsPtlIdx(i)).getProfileIdc();
+        if (profile != Profile::NONE)
+        {
+          CHECK(uiCode + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
+        }
+        if ((pcVPS->m_numDpbParams > 1) && (pcVPS->m_numDpbParams != pcVPS->m_numMultiLayeredOlss))
+        {
+          xReadUvlc( uiCode, "vps_ols_dpb_params_idx[i]" ); pcVPS->setOlsDpbParamsIdx( i, uiCode );
+        }
+        else if (pcVPS->m_numDpbParams == 1)
+        {
+          pcVPS->setOlsDpbParamsIdx(i, 0);
+        }
+        else
+        {
+          pcVPS->setOlsDpbParamsIdx(i, j);
+        }
+        j += 1;
+        isDPBParamReferred[pcVPS->getOlsDpbParamsIdx(i)] = true;
+      }
+    }
+    for( int i = 0; i < pcVPS->m_numDpbParams; i++ )
+    {
+      CHECK( !isDPBParamReferred[i],"Each dpb_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_dpb_params_idx[i] for i in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+    }
+  }
+
+  if (!pcVPS->getEachLayerIsAnOlsFlag())
+  {
+    xReadFlag(uiCode, "vps_general_hrd_params_present_flag");  pcVPS->setVPSGeneralHrdParamsPresentFlag(uiCode);
+  }
+  if (pcVPS->getVPSGeneralHrdParamsPresentFlag())
+  {
+    parseGeneralHrdParameters(pcVPS->getGeneralHrdParameters());
+    if ((pcVPS->getMaxSubLayers() - 1) > 0)
+    {
+      xReadFlag(uiCode, "vps_sublayer_cpb_params_present_flag");  pcVPS->setVPSSublayerCpbParamsPresentFlag(uiCode);
+    }
+    else
+    {
+      pcVPS->setVPSSublayerCpbParamsPresentFlag(0);
+    }
+    xReadUvlc(uiCode, "vps_num_ols_timing_hrd_params_minus1"); pcVPS->setNumOlsTimingHrdParamsMinus1(uiCode);
+    CHECK( uiCode >= pcVPS->getNumMultiLayeredOlss(),"The value of vps_num_ols_timing_hrd_params_minus1 shall be in the range of 0 to NumMultiLayerOlss - 1, inclusive");
+    std::vector<bool> isHRDParamReferred( uiCode + 1, false);
+    pcVPS->m_olsHrdParams.clear();
+    pcVPS->m_olsHrdParams.resize(pcVPS->getNumOlsTimingHrdParamsMinus1() + 1, std::vector<OlsHrdParams>(pcVPS->getMaxSubLayers()));
+    for (int i = 0; i <= pcVPS->getNumOlsTimingHrdParamsMinus1(); i++)
+    {
+      if (!pcVPS->getDefaultPtlDpbHrdMaxTidFlag())
+      {
+        xReadCode(3, uiCode, "vps_hrd_max_tid[i]");  pcVPS->setHrdMaxTid(i, uiCode);
+        CHECK (uiCode > (pcVPS->getMaxSubLayers() - 1), "The value of vps_hrd_max_tid[i] shall be in the range of 0 to vps_max_sublayers_minus1, inclusive." )
+      }
+      else
+      {
+        pcVPS->setHrdMaxTid(i, pcVPS->getMaxSubLayers() - 1);
+      }
+      uint32_t firstSublayer = pcVPS->getVPSSublayerCpbParamsPresentFlag() ? 0 : pcVPS->getHrdMaxTid(i);
+      parseOlsHrdParameters(pcVPS->getGeneralHrdParameters(),pcVPS->getOlsHrdParameters(i), firstSublayer, pcVPS->getHrdMaxTid(i));
+    }
+    for (int i = pcVPS->getNumOlsTimingHrdParamsMinus1() + 1; i < pcVPS->getTotalNumOLSs(); i++)
+    {
+      pcVPS->setHrdMaxTid(i, pcVPS->getMaxSubLayers() - 1);
+    }
+    for (int i = 0; i < pcVPS->m_numMultiLayeredOlss; i++)
+    {
+      if (((pcVPS->getNumOlsTimingHrdParamsMinus1() + 1) != pcVPS->m_numMultiLayeredOlss) && (pcVPS->getNumOlsTimingHrdParamsMinus1() > 0))
+      {
+        xReadUvlc(uiCode, "vps_ols_timing_hrd_idx[i]"); pcVPS->setOlsTimingHrdIdx(i, uiCode);
+        CHECK(uiCode > pcVPS->getNumOlsTimingHrdParamsMinus1(), "The value of vps_ols_timing_hrd_idx[[ i ] shall be in the range of 0 to vps_num_ols_timing_hrd_params_minus1, inclusive.");
+      }
+      else if (pcVPS->getNumOlsTimingHrdParamsMinus1() == 0)
+      {
+        pcVPS->setOlsTimingHrdIdx(i, 0);
+      }
+      else
+      {
+        pcVPS->setOlsTimingHrdIdx(i, i);
+      }
+      isHRDParamReferred[pcVPS->getOlsTimingHrdIdx(i)] = true;
+    }
+    for( int i = 0; i <= pcVPS->getNumOlsTimingHrdParamsMinus1(); i++ )
+    {
+      CHECK( !isHRDParamReferred[i], "Each vps_ols_timing_hrd_parameters( ) syntax structure in the VPS shall be referred to by at least one value of vps_ols_timing_hrd_idx[ i ] for i in the range of 1 to NumMultiLayerOlss - 1, inclusive");
+    }
+  }
+  else
+  {
+    for (int i = 0; i < pcVPS->getTotalNumOLSs(); i++)
+    {
+      pcVPS->setHrdMaxTid(i, pcVPS->getMaxSubLayers() - 1);
+    }
+  }
+
+
+  xReadFlag(uiCode, "vps_extension_flag");
+  if (uiCode)
+  {
+    while (xMoreRbspData())
+    {
+      xReadFlag(uiCode, "vps_extension_data_flag");
+    }
+  }
+  pcVPS->checkVPS();
+  xReadRbspTrailingBits();
+}
+
+void HLSyntaxReader::parsePictureHeader( PicHeader* picHeader, ParameterSetManager *parameterSetManager, bool readRbspTrailingBits )
+{
+  uint32_t  uiCode;
+  int       iCode;
+
+  PPS *pps = nullptr;
+  SPS *sps = nullptr;
+
+#if ENABLE_TRACING
+  xTracePictureHeader();
+#endif
+
+  xReadFlag(uiCode, "ph_gdr_or_irap_pic_flag");               picHeader->setGdrOrIrapPicFlag(uiCode != 0);
+  xReadFlag(uiCode, "ph_non_ref_pic_flag");                picHeader->setNonReferencePictureFlag(uiCode != 0);
+  if (picHeader->getGdrOrIrapPicFlag())
+  {
+    xReadFlag(uiCode, "ph_gdr_pic_flag");                     picHeader->setGdrPicFlag(uiCode != 0);
+  }
+  else
+  {
+    picHeader->setGdrPicFlag(false);
+  }
+  xReadFlag(uiCode, "ph_inter_slice_allowed_flag");       picHeader->setPicInterSliceAllowedFlag(uiCode != 0);
+  if (picHeader->getPicInterSliceAllowedFlag())
+  {
+    xReadFlag(uiCode, "ph_intra_slice_allowed_flag");       picHeader->setPicIntraSliceAllowedFlag(uiCode != 0);
+  }
+  else
+  {
+    picHeader->setPicIntraSliceAllowedFlag(true);
+  }
+  CHECK(picHeader->getPicInterSliceAllowedFlag() == 0 && picHeader->getPicIntraSliceAllowedFlag() == 0, "Invalid picture without intra or inter slice");
+  // parameter sets
+  xReadUvlc(uiCode, "ph_pic_parameter_set_id");
+  picHeader->setPPSId(uiCode);
+  pps = parameterSetManager->getPPS(picHeader->getPPSId());
+  CHECK(pps == 0, "Invalid PPS");
+  picHeader->setSPSId(pps->getSPSId());
+  sps = parameterSetManager->getSPS(picHeader->getSPSId());
+  CHECK(sps == 0, "Invalid SPS");
+  xReadCode(sps->getBitsForPOC(), uiCode, "ph_pic_order_cnt_lsb");
+  picHeader->setPocLsb(uiCode);
+  if( picHeader->getGdrPicFlag() )
+  {
+    xReadUvlc(uiCode, "ph_recovery_poc_cnt");               picHeader->setRecoveryPocCnt( uiCode );
+  }
+  else
+  {
+    picHeader->setRecoveryPocCnt( -1 );
+  }
+
+  bool isIrapOrGdrWRecoveryPocCnt0 = (picHeader->getGdrOrIrapPicFlag() && !picHeader->getGdrPicFlag()) ||
+                                     (picHeader->getGdrPicFlag() && picHeader->getRecoveryPocCnt() == 0);
+
+  if (!isIrapOrGdrWRecoveryPocCnt0)
+  {
+    const Profile::Name profile = sps->getProfileTierLevel()->getProfileIdc();
+    bool isIntraProfile = profile == Profile::MAIN_12_INTRA || profile == Profile::MAIN_12_444_INTRA ||
+                          profile == Profile::MAIN_16_444_INTRA;
+
+    CHECK(isIntraProfile && !isIrapOrGdrWRecoveryPocCnt0,
+          "Invalid non-irap pictures or gdr pictures with ph_recovery_poc_cnt!=0 for Intra profile");
+    CHECK(sps->getProfileTierLevel()->getConstraintInfo()->getAllRapPicturesFlag() == 1 && !isIrapOrGdrWRecoveryPocCnt0,
+          "gci_all_rap_pictures_flag equal to 1 specifies that all pictures in OlsInScope are IRAP pictures or GDR pictures with ph_recovery_poc_cnt equal to 0");
+  }
+
+  std::vector<bool> phExtraBitsPresent = sps->getExtraPHBitPresentFlags();
+  for (int i=0; i< sps->getNumExtraPHBytes() * 8; i++)
+  {
+    // extra bits are ignored (when present)
+    if (phExtraBitsPresent[i])
+    {
+      xReadFlag(uiCode, "ph_extra_bit[ i ]");
+    }
+  }
+
+  if (sps->getPocMsbCycleFlag())
+  {
+    xReadFlag(uiCode, "ph_poc_msb_present_flag"); picHeader->setPocMsbPresentFlag(uiCode != 0);
+    if (picHeader->getPocMsbPresentFlag())
+    {
+      xReadCode(sps->getPocMsbCycleLen(), uiCode, "ph_poc_msb_cycle_val");
+      picHeader->setPocMsbVal(uiCode);
+    }
+  }
+
+
+  // alf enable flags and aps IDs
+  picHeader->setCcAlfEnabledFlag(COMPONENT_Cb, false);
+  picHeader->setCcAlfEnabledFlag(COMPONENT_Cr, false);
+  if (sps->getALFEnabledFlag())
+  {
+    if (pps->getAlfInfoInPhFlag())
+    {
+      xReadFlag(uiCode, "ph_alf_enabled_flag");
+      const bool alfEnabledFlag = uiCode != 0;
+      picHeader->setAlfEnabledFlag(COMPONENT_Y, alfEnabledFlag);
+
+      bool alfCbEnabledFlag = false;
+      bool alfCrEnabledFlag = false;
+
+      AlfApsList apsIds;
+      if (alfEnabledFlag)
+      {
+        xReadCode(3, uiCode, "ph_num_alf_aps_ids_luma");
+        const int numAps = uiCode;
+
+        for (int i = 0; i < numAps; i++)
+        {
+          xReadCode(3, uiCode, "ph_alf_aps_id_luma");
+          const int apsId = uiCode;
+
+          apsIds.push_back(apsId);
+
+          APS *apsToCheckLuma = parameterSetManager->getAPS(apsId, ApsType::ALF);
+          CHECK(apsToCheckLuma == nullptr, "referenced APS not found");
+          CHECK(apsToCheckLuma->getAlfAPSParam().newFilterFlag[ChannelType::LUMA] != 1,
+                "bitstream conformance error, alf_luma_filter_signal_flag shall be equal to 1");
+        }
+
+        if (isChromaEnabled(sps->getChromaFormatIdc()))
+        {
+          xReadCode(1, uiCode, "ph_alf_cb_enabled_flag");
+          alfCbEnabledFlag = uiCode != 0;
+          xReadCode(1, uiCode, "ph_alf_cr_enabled_flag");
+          alfCrEnabledFlag = uiCode != 0;
+        }
+
+        if (alfCbEnabledFlag || alfCrEnabledFlag)
+        {
+          xReadCode(3, uiCode, "ph_alf_aps_id_chroma");
+          picHeader->setAlfApsIdChroma(uiCode);
+          APS *apsToCheckChroma = parameterSetManager->getAPS(uiCode, ApsType::ALF);
+          CHECK(apsToCheckChroma == nullptr, "referenced APS not found");
+          CHECK(apsToCheckChroma->getAlfAPSParam().newFilterFlag[ChannelType::CHROMA] != 1,
+                "bitstream conformance error, alf_chroma_filter_signal_flag shall be equal to 1");
+        }
+        if (sps->getCCALFEnabledFlag())
+        {
+          xReadFlag(uiCode, "ph_cc_alf_cb_enabled_flag");
+          picHeader->setCcAlfEnabledFlag(COMPONENT_Cb, uiCode != 0);
+          picHeader->setCcAlfCbApsId(-1);
+          if (picHeader->getCcAlfEnabledFlag(COMPONENT_Cb))
+          {
+            // parse APS ID
+            xReadCode(3, uiCode, "ph_cc_alf_cb_aps_id");
+            picHeader->setCcAlfCbApsId(uiCode);
+            APS *apsToCheckCcCb = parameterSetManager->getAPS(uiCode, ApsType::ALF);
+            CHECK(apsToCheckCcCb == nullptr, "referenced APS not found");
+            CHECK(apsToCheckCcCb->getCcAlfAPSParam().newCcAlfFilter[COMPONENT_Cb - 1] != 1, "bitstream conformance error, alf_cc_cb_filter_signal_flag shall be equal to 1");
+          }
+          // Cr
+          xReadFlag(uiCode, "ph_cc_alf_cr_enabled_flag");
+          picHeader->setCcAlfEnabledFlag(COMPONENT_Cr, uiCode != 0);
+          picHeader->setCcAlfCrApsId(-1);
+          if (picHeader->getCcAlfEnabledFlag(COMPONENT_Cr))
+          {
+            // parse APS ID
+            xReadCode(3, uiCode, "ph_cc_alf_cr_aps_id");
+            picHeader->setCcAlfCrApsId(uiCode);
+            APS *apsToCheckCcCr = parameterSetManager->getAPS(uiCode, ApsType::ALF);
+            CHECK(apsToCheckCcCr == nullptr, "referenced APS not found");
+            CHECK(apsToCheckCcCr->getCcAlfAPSParam().newCcAlfFilter[COMPONENT_Cr - 1] != 1, "bitstream conformance error, alf_cc_cr_filter_signal_flag shall be equal to 1");
+          }
+        }
+      }
+
+      picHeader->setNumAlfApsIdsLuma((int) apsIds.size());
+      picHeader->setAlfApsIdsLuma(apsIds);
+      picHeader->setAlfEnabledFlag(COMPONENT_Cb, alfCbEnabledFlag);
+      picHeader->setAlfEnabledFlag(COMPONENT_Cr, alfCrEnabledFlag);
+    }
+    else
+    {
+      picHeader->setAlfEnabledFlag(COMPONENT_Y, true);
+      picHeader->setAlfEnabledFlag(COMPONENT_Cb, true);
+      picHeader->setAlfEnabledFlag(COMPONENT_Cr, true);
+    }
+  }
+  else
+  {
+    picHeader->setAlfEnabledFlag(COMPONENT_Y, false);
+    picHeader->setAlfEnabledFlag(COMPONENT_Cb, false);
+    picHeader->setAlfEnabledFlag(COMPONENT_Cr, false);
+  }
+  // luma mapping / chroma scaling controls
+  if (sps->getUseLmcs())
+  {
+    xReadFlag(uiCode, "ph_lmcs_enabled_flag");
+    picHeader->setLmcsEnabledFlag(uiCode != 0);
+
+    if (picHeader->getLmcsEnabledFlag())
+    {
+      xReadCode(2, uiCode, "ph_lmcs_aps_id");
+      picHeader->setLmcsAPSId(uiCode);
+
+      if (isChromaEnabled(sps->getChromaFormatIdc()))
+      {
+        xReadFlag(uiCode, "ph_chroma_residual_scale_flag");
+        picHeader->setLmcsChromaResidualScaleFlag(uiCode != 0);
+      }
+      else
+      {
+        picHeader->setLmcsChromaResidualScaleFlag(false);
+      }
+    }
+  }
+  else
+  {
+    picHeader->setLmcsEnabledFlag(false);
+    picHeader->setLmcsChromaResidualScaleFlag(false);
+  }
+  // quantization scaling lists
+  if (sps->getScalingListFlag())
+  {
+    xReadFlag(uiCode, "ph_explicit_scaling_list_enabled_flag");
+    picHeader->setExplicitScalingListEnabledFlag(uiCode);
+    if (picHeader->getExplicitScalingListEnabledFlag())
+    {
+      xReadCode(3, uiCode, "ph_scaling_list_aps_id");
+      picHeader->setScalingListAPSId(uiCode);
+    }
+  }
+  else
+  {
+    picHeader->setExplicitScalingListEnabledFlag(false);
+  }
+  if (pps->getPicWidthInLumaSamples() == sps->getMaxPicWidthInLumaSamples() && pps->getPicHeightInLumaSamples() == sps->getMaxPicHeightInLumaSamples())
+  {
+    CHECK(pps->getConformanceWindowFlag(), "When pps_pic_width_in_luma_samples is equal to sps_pic_width_max_in_luma_samples and pps_pic_height_in_luma_samples is equal to sps_pic_height_max_in_luma_samples, the value of pps_conformance_window_flag shall be equal to 0");
+    pps->getConformanceWindow().setWindowLeftOffset(sps->getConformanceWindow().getWindowLeftOffset());
+    pps->getConformanceWindow().setWindowRightOffset(sps->getConformanceWindow().getWindowRightOffset());
+    pps->getConformanceWindow().setWindowTopOffset(sps->getConformanceWindow().getWindowTopOffset());
+    pps->getConformanceWindow().setWindowBottomOffset(sps->getConformanceWindow().getWindowBottomOffset());
+    if (!pps->getExplicitScalingWindowFlag())
+    {
+      pps->setScalingWindow(pps->getConformanceWindow());
+    }
+  }
+  CHECK(!sps->getRprEnabledFlag() && pps->getExplicitScalingWindowFlag(), "When sps_ref_pic_resampling_enabled_flag is equal to 0, the value of pps_scaling_window_explicit_signalling_flag shall be equal to 0");
+
+  // initialize tile/slice info for no partitioning case
+
+  if( pps->getNoPicPartitionFlag() )
+  {
+    pps->resetTileSliceInfo();
+    pps->setLog2CtuSize( ceilLog2(sps->getCTUSize()) );
+    pps->setNumExpTileColumns(1);
+    pps->setNumExpTileRows(1);
+    pps->addTileColumnWidth( pps->getPicWidthInCtu( ) );
+    pps->addTileRowHeight( pps->getPicHeightInCtu( ) );
+    pps->initTiles();
+    pps->setRectSliceFlag( 1 );
+    pps->setNumSlicesInPic( 1 );
+    pps->initRectSlices( );
+    pps->setTileIdxDeltaPresentFlag( 0 );
+    pps->setSliceTileIdx( 0, 0 );
+    pps->initRectSliceMap(sps);
+    // when no Pic partition, number of sub picture shall be less than 2
+    CHECK(pps->getNumSubPics()>=2, "error, no picture partitions, but have equal to or more than 2 sub pictures");
+  }
+  else
+  {
+    CHECK(pps->getCtuSize() != sps->getCTUSize(), "PPS CTU size does not match CTU size in SPS");
+    if (pps->getRectSliceFlag())
+    {
+      pps->initRectSliceMap(sps);
+    }
+  }
+
+  pps->initSubPic(*sps);
+
+  // set wraparound offset from PPS and SPS info
+  int minCbSizeY = (1 << sps->getLog2MinCodingBlockSize());
+  CHECK( !sps->getWrapAroundEnabledFlag() && pps->getWrapAroundEnabledFlag(), "When sps_ref_wraparound_enabled_flag is equal to 0, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  CHECK( (((sps->getCTUSize() / minCbSizeY) + 1) > ((pps->getPicWidthInLumaSamples() / minCbSizeY) - 1)) && pps->getWrapAroundEnabledFlag(), "When the value of CtbSizeY / MinCbSizeY + 1 is greater than pps_pic_width_in_luma_samples / MinCbSizeY - 1, the value of pps_ref_wraparound_enabled_flag shall be equal to 0.");
+  if( pps->getWrapAroundEnabledFlag() )
+  {
+    CHECK((pps->getPicWidthMinusWrapAroundOffset() > (pps->getPicWidthInLumaSamples() / minCbSizeY - sps->getCTUSize() / minCbSizeY - 2)), "pps_pic_width_minus_wraparound_ofsfet shall be less than or equal to pps_pic_width_in_luma_samples/MinCbSizeY - CtbSizeY/MinCbSizeY-2");
+    pps->setWrapAroundOffset(minCbSizeY * (pps->getPicWidthInLumaSamples()/minCbSizeY- pps->getPicWidthMinusWrapAroundOffset()));
+  }
+  else
+  {
+    pps->setWrapAroundOffset( 0 );
+  }
+
+  // virtual boundaries
+  if( sps->getVirtualBoundariesEnabledFlag() && !sps->getVirtualBoundariesPresentFlag() )
+  {
+    xReadFlag( uiCode, "ph_virtual_boundaries_present_flag" );
+    picHeader->setVirtualBoundariesPresentFlag( uiCode != 0 );
+    if( picHeader->getVirtualBoundariesPresentFlag() )
+    {
+      xReadUvlc(uiCode, "ph_num_ver_virtual_boundaries");        picHeader->setNumVerVirtualBoundaries( uiCode );
+      if (pps->getPicWidthInLumaSamples() <= 8)
+      {
+        CHECK(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+      }
+      else
+      {
+        CHECK(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+      }
+      for( unsigned i = 0; i < picHeader->getNumVerVirtualBoundaries(); i++ )
+      {
+        xReadUvlc(uiCode, "ph_virtual_boundary_pos_x_minus1[i]");        picHeader->setVirtualBoundariesPosX((uiCode + 1) << 3, i);
+        CHECK(uiCode > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
+      }
+#if GDR_DEC_TRACE
+      printf("\n");
+      printf("-num_ver_boundary :%d\n", picHeader->getNumVerVirtualBoundaries());
+      printf("-vir_boundary_pos :%d\n", picHeader->getVirtualBoundariesPosX(0));
+#endif
+      xReadUvlc(uiCode, "ph_num_hor_virtual_boundaries");        picHeader->setNumHorVirtualBoundaries( uiCode );
+      if (pps->getPicHeightInLumaSamples() <= 8)
+      {
+        CHECK(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+      }
+      else
+      {
+        CHECK(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+      }
+      for( unsigned i = 0; i < picHeader->getNumHorVirtualBoundaries(); i++ )
+      {
+        xReadUvlc(uiCode, "ph_virtual_boundary_pos_y_minus1[i]");        picHeader->setVirtualBoundariesPosY((uiCode + 1) << 3, i);
+        CHECK(uiCode > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
+      }
+    }
+    else
+    {
+      picHeader->setNumVerVirtualBoundaries( 0 );
+      picHeader->setNumHorVirtualBoundaries( 0 );
+    }
+  }
+  else
+  {
+    picHeader->setVirtualBoundariesPresentFlag( sps->getVirtualBoundariesPresentFlag() );
+    if( picHeader->getVirtualBoundariesPresentFlag() )
+    {
+      picHeader->setNumVerVirtualBoundaries(sps->getNumVerVirtualBoundaries());
+      picHeader->setNumHorVirtualBoundaries(sps->getNumHorVirtualBoundaries());
+      for (unsigned i = 0; i < 3; i++)
+      {
+        picHeader->setVirtualBoundariesPosX(sps->getVirtualBoundariesPosX(i), i);
+        picHeader->setVirtualBoundariesPosY(sps->getVirtualBoundariesPosY(i), i);
+      }
+    }
+  }
+
+
+  // picture output flag
+  if (pps->getOutputFlagPresentFlag() && !picHeader->getNonReferencePictureFlag())
+  {
+    xReadFlag( uiCode, "ph_pic_output_flag" ); picHeader->setPicOutputFlag( uiCode != 0 );
+  }
+  else
+  {
+    picHeader->setPicOutputFlag( true );
+  }
+
+  // reference picture lists
+  if (pps->getRplInfoInPhFlag())
+  {
+    bool rplSpsFlag = false;
+
+    for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+    {
+      int numRplsInSps = sps->getNumRpl(l);
+      if (numRplsInSps == 0)
+      {
+        rplSpsFlag = false;
+      }
+      else if (l == REF_PIC_LIST_0 || pps->getRpl1IdxPresentFlag())
+      {
+        xReadFlag(uiCode, "rpl_sps_flag[i]");
+        rplSpsFlag = uiCode != 0;
+      }
+
+      ReferencePictureList *rpl = picHeader->getRpl(l);
+      if (!rplSpsFlag)
+      {
+        // explicit RPL in picture header
+        *rpl = ReferencePictureList();
+        parseRefPicList(sps, rpl, -1);
+        picHeader->setRplIdx(l, -1);
+      }
+      else
+      {
+        // use list from SPS
+        int rplIdx = 0;
+
+        if (numRplsInSps > 1 && (l == REF_PIC_LIST_0 || pps->getRpl1IdxPresentFlag()))
+        {
+          int numBits = ceilLog2(numRplsInSps);
+          xReadCode(numBits, uiCode, "rpl_idx[i]");
+          rplIdx = uiCode;
+        }
+        else if(numRplsInSps != 1)
+        {
+          rplIdx = picHeader->getRplIdx(REF_PIC_LIST_0);
+          CHECK(rplIdx == -1, "There should be a list 0 RPL");
+        }
+
+        picHeader->setRplIdx(l, rplIdx);
+        *rpl = *sps->getRplList(l)->getReferencePictureList(rplIdx);
+      }
+      if (picHeader->getPicInterSliceAllowedFlag() && l == REF_PIC_LIST_0)
+      {
+        CHECK(picHeader->getRpl(REF_PIC_LIST_0)->getNumRefEntries() <= 0,
+              "When pps_rpl_info_in_ph_flag is equal to 1 and ph_inter_slice_allowed_flag is equal to 1, the value of "
+              "num_ref_entries[ 0 ][ RplsIdx[ 0 ] ] shall be greater than 0");
+      }
+      // POC MSB cycle signalling for LTRP
+      for (int i = 0; i < rpl->getNumRefEntries(); i++)
+      {
+        rpl->setDeltaPocMSBPresentFlag(i, false);
+        rpl->setDeltaPocMSBCycleLT(i, 0);
+      }
+      if (rpl->getNumberOfLongtermPictures())
+      {
+        for (int i = 0; i < rpl->getNumRefEntries(); i++)
+        {
+          if (rpl->isRefPicLongterm(i))
+          {
+            if (rpl->getLtrpInSliceHeaderFlag())
+            {
+              xReadCode(sps->getBitsForPOC(), uiCode, "poc_lsb_lt[i][j]");
+              rpl->setRefPicIdentifier( i, uiCode, true, false, 0 );
+            }
+            xReadFlag(uiCode, "delta_poc_msb_present_flag[i][j]");
+            rpl->setDeltaPocMSBPresentFlag(i, uiCode ? true : false);
+            if (uiCode)
+            {
+              xReadUvlc(uiCode, "delta_poc_msb_cycle_lt[i][j]");
+              if(i != 0)
+              {
+                uiCode += rpl->getDeltaPocMSBCycleLT(i-1);
+              }
+              rpl->setDeltaPocMSBCycleLT(i, uiCode);
+            }
+            else if(i != 0)
+            {
+              rpl->setDeltaPocMSBCycleLT(i, rpl->getDeltaPocMSBCycleLT(i-1));
+            }
+            else
+            {
+              rpl->setDeltaPocMSBCycleLT(i,0);
+            }
+          }
+          else if(i != 0)
+          {
+            rpl->setDeltaPocMSBCycleLT(i, rpl->getDeltaPocMSBCycleLT(i-1));
+          }
+          else
+          {
+            rpl->setDeltaPocMSBCycleLT(i,0);
+          }
+        }
+      }
+    }
+  }
+
+  // partitioning constraint overrides
+  if (sps->getSplitConsOverrideEnabledFlag())
+  {
+    xReadFlag(uiCode, "ph_partition_constraints_override_flag");  picHeader->setSplitConsOverrideFlag( uiCode != 0 );
+  }
+  else
+  {
+    picHeader->setSplitConsOverrideFlag(0);
+  }
+  // Q0781, two-flags
+  unsigned  minQT[3] = { 0, 0, 0 };
+  unsigned  maxBTD[3] = { 0, 0, 0 };
+  unsigned  maxBTSize[3] = { 0, 0, 0 };
+  unsigned  maxTTSize[3] = { 0, 0, 0 };
+  unsigned  ctbLog2SizeY = floorLog2(sps->getCTUSize());
+
+  if (picHeader->getPicIntraSliceAllowedFlag())
+  {
+    if (picHeader->getSplitConsOverrideFlag())
+    {
+      xReadUvlc(uiCode, "ph_log2_diff_min_qt_min_cb_intra_slice_luma");
+      unsigned minQtLog2SizeIntraY = uiCode + sps->getLog2MinCodingBlockSize();
+      minQT[0] = 1 << minQtLog2SizeIntraY;
+      CHECK(minQT[0] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+      xReadUvlc(uiCode, "ph_max_mtt_hierarchy_depth_intra_slice_luma");         maxBTD[0] = uiCode;
+
+      maxTTSize[0] = maxBTSize[0] = minQT[0];
+      if (maxBTD[0] != 0)
+      {
+        xReadUvlc(uiCode, "ph_log2_diff_max_bt_min_qt_intra_slice_luma");       maxBTSize[0] <<= uiCode;
+        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+        xReadUvlc(uiCode, "ph_log2_diff_max_tt_min_qt_intra_slice_luma");       maxTTSize[0] <<= uiCode;
+        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeIntraY, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeIntraY");
+        CHECK(maxTTSize[0] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_luma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraY");
+      }
+
+      if (sps->getUseDualITree())
+      {
+        xReadUvlc(uiCode, "ph_log2_diff_min_qt_min_cb_intra_slice_chroma");     minQT[2] = 1 << (uiCode + sps->getLog2MinCodingBlockSize());
+        CHECK(minQT[2] > 64, "The value of ph_log2_diff_min_qt_min_cb_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinCbLog2Size");
+        xReadUvlc(uiCode, "ph_max_mtt_hierarchy_depth_intra_slice_chroma");     maxBTD[2] = uiCode;
+        maxTTSize[2] = maxBTSize[2] = minQT[2];
+        if (maxBTD[2] != 0)
+        {
+          xReadUvlc(uiCode, "ph_log2_diff_max_bt_min_qt_intra_slice_chroma");   maxBTSize[2] <<= uiCode;
+          xReadUvlc(uiCode, "ph_log2_diff_max_tt_min_qt_intra_slice_chroma");   maxTTSize[2] <<= uiCode;
+          CHECK(maxBTSize[2] > 64, "The value of ph_log2_diff_max_bt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+          CHECK(maxTTSize[2] > 64, "The value of ph_log2_diff_max_tt_min_qt_intra_slice_chroma shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeIntraChroma");
+        }
+      }
+    }
+  }
+
+
+  if (picHeader->getPicIntraSliceAllowedFlag())
+  {
+  // delta quantization and chrom and chroma offset
+    if (pps->getUseDQP())
+    {
+      xReadUvlc( uiCode, "ph_cu_qp_delta_subdiv_intra_slice" );   picHeader->setCuQpDeltaSubdivIntra( uiCode );
+    }
+    else
+    {
+      picHeader->setCuQpDeltaSubdivIntra( 0 );
+    }
+    if (pps->getCuChromaQpOffsetListEnabledFlag())
+    {
+      xReadUvlc( uiCode, "ph_cu_chroma_qp_offset_subdiv_intra_slice" );   picHeader->setCuChromaQpOffsetSubdivIntra( uiCode );
+    }
+    else
+    {
+      picHeader->setCuChromaQpOffsetSubdivIntra( 0 );
+    }
+  }
+
+
+  if (picHeader->getPicInterSliceAllowedFlag())
+  {
+    if (picHeader->getSplitConsOverrideFlag())
+    {
+      xReadUvlc(uiCode, "ph_log2_diff_min_qt_min_cb_inter_slice");
+      unsigned minQtLog2SizeInterY = uiCode + sps->getLog2MinCodingBlockSize();
+      minQT[1] = 1 << minQtLog2SizeInterY;
+      CHECK(minQT[1] > 64, "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY.");
+      CHECK(minQT[1] > (1<<ctbLog2SizeY), "The value of ph_log2_diff_min_qt_min_cb_inter_slice shall be in the range of 0 to min(6, CtbLog2SizeY) - MinCbLog2SizeY");
+      xReadUvlc(uiCode, "ph_max_mtt_hierarchy_depth_inter_slice");              maxBTD[1] = uiCode;
+
+      maxTTSize[1] = maxBTSize[1] = minQT[1];
+      if (maxBTD[1] != 0)
+      {
+        xReadUvlc(uiCode, "ph_log2_diff_max_bt_min_qt_inter_slice");            maxBTSize[1] <<= uiCode;
+        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_bt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+        xReadUvlc(uiCode, "ph_log2_diff_max_tt_min_qt_inter_slice");            maxTTSize[1] <<= uiCode;
+        CHECK(uiCode > ctbLog2SizeY - minQtLog2SizeInterY, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to CtbLog2SizeY - MinQtLog2SizeInterY");
+        CHECK(maxTTSize[1] > 64, "The value of ph_log2_diff_max_tt_min_qt_inter_slice shall be in the range of 0 to min(6,CtbLog2SizeY) - MinQtLog2SizeInterY.");
+      }
+    }
+    // delta quantization and chrom and chroma offset
+    if (pps->getUseDQP())
+    {
+      xReadUvlc(uiCode, "ph_cu_qp_delta_subdiv_inter_slice");   picHeader->setCuQpDeltaSubdivInter(uiCode);
+    }
+    else
+    {
+      picHeader->setCuQpDeltaSubdivInter(0);
+    }
+    if (pps->getCuChromaQpOffsetListEnabledFlag())
+    {
+      xReadUvlc(uiCode, "ph_cu_chroma_qp_offset_subdiv_inter_slice");   picHeader->setCuChromaQpOffsetSubdivInter(uiCode);
+    }
+    else
+    {
+      picHeader->setCuChromaQpOffsetSubdivInter(0);
+    }
+
+  // temporal motion vector prediction
+    if (sps->getSPSTemporalMVPEnabledFlag())
+    {
+      xReadFlag( uiCode, "ph_temporal_mvp_enabled_flag" );
+      picHeader->setEnableTMVPFlag( uiCode != 0 );
+    }
+    else
+    {
+      picHeader->setEnableTMVPFlag(false);
+    }
+
+    if (picHeader->getEnableTMVPFlag() && pps->getRplInfoInPhFlag())
+    {
+      if (picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 0)
+      {
+        xReadCode(1, uiCode, "ph_collocated_from_l0_flag");
+        picHeader->setPicColFromL0Flag(uiCode);
+      }
+      else
+      {
+        picHeader->setPicColFromL0Flag(true);
+      }
+      if (picHeader->getRpl(picHeader->getPicColFromL0Flag() ? REF_PIC_LIST_0 : REF_PIC_LIST_1)->getNumRefEntries() > 1)
+      {
+        xReadUvlc(uiCode, "ph_collocated_ref_idx");
+        picHeader->setColRefIdx(uiCode);
+      }
+      else
+      {
+        picHeader->setColRefIdx(0);
+      }
+    }
+    else
+    {
+      picHeader->setPicColFromL0Flag(false);
+    }
+
+
+    // merge candidate list size
+    // subblock merge candidate list size
+    if ( sps->getUseAffine() )
+    {
+      picHeader->setMaxNumAffineMergeCand(sps->getMaxNumAffineMergeCand());
+    }
+    else
+    {
+      picHeader->setMaxNumAffineMergeCand(sps->getSbTMVPEnabledFlag() && picHeader->getEnableTMVPFlag());
+    }
+
+  // full-pel MMVD flag
+    if (sps->getFpelMmvdEnabledFlag())
+    {
+      xReadFlag( uiCode, "ph_fpel_mmvd_enabled_flag" );
+      picHeader->setDisFracMMVD( uiCode != 0 );
+    }
+    else
+    {
+      picHeader->setDisFracMMVD(false);
+    }
+
+    // mvd L1 zero flag
+    if (!pps->getRplInfoInPhFlag() || picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 0)
+    {
+      xReadFlag(uiCode, "ph_mvd_l1_zero_flag");
+    }
+    else
+    {
+      uiCode = 1;
+    }
+    picHeader->setMvdL1ZeroFlag(uiCode != 0);
+
+    // picture level BDOF disable flags
+    if (sps->getBdofControlPresentInPhFlag()
+        && (!pps->getRplInfoInPhFlag() || picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 0))
+    {
+      xReadFlag(uiCode, "ph_bdof_disabled_flag");  picHeader->setBdofDisabledFlag(uiCode != 0);
+    }
+    else
+    {
+      if (!sps->getBdofControlPresentInPhFlag())
+      {
+        picHeader->setBdofDisabledFlag(!sps->getBDOFEnabledFlag());
+      }
+      else
+      {
+        picHeader->setBdofDisabledFlag(true);
+      }
+    }
+
+  // picture level DMVR disable flags
+    if (sps->getDmvrControlPresentInPhFlag()
+        && (!pps->getRplInfoInPhFlag() || picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 0))
+    {
+      xReadFlag(uiCode, "ph_dmvr_disabled_flag");  picHeader->setDmvrDisabledFlag(uiCode != 0);
+    }
+    else
+    {
+      if (!sps->getDmvrControlPresentInPhFlag())
+      {
+        picHeader->setDmvrDisabledFlag(!sps->getUseDMVR());
+      }
+      else
+      {
+        picHeader->setDmvrDisabledFlag(true);
+      }
+    }
+
+  // picture level PROF disable flags
+    if (sps->getProfControlPresentInPhFlag())
+    {
+      xReadFlag(uiCode, "ph_prof_disabled_flag");  picHeader->setProfDisabledFlag(uiCode != 0);
+    }
+    else
+    {
+      picHeader->setProfDisabledFlag(!sps->getUsePROF());
+    }
+
+    if( (pps->getUseWP() || pps->getWPBiPred()) && pps->getWpInfoInPhFlag() )
+    {
+      parsePredWeightTable(picHeader, pps, sps);
+    }
+  }
+  // inherit constraint values from SPS
+  if (!sps->getSplitConsOverrideEnabledFlag() || !picHeader->getSplitConsOverrideFlag())
+  {
+    picHeader->setMinQTSizes(sps->getMinQTSizes());
+    picHeader->setMaxMTTHierarchyDepths(sps->getMaxMTTHierarchyDepths());
+    picHeader->setMaxBTSizes(sps->getMaxBTSizes());
+    picHeader->setMaxTTSizes(sps->getMaxTTSizes());
+  }
+  else
+  {
+    picHeader->setMinQTSizes(minQT);
+    picHeader->setMaxMTTHierarchyDepths(maxBTD);
+    picHeader->setMaxBTSizes(maxBTSize);
+    picHeader->setMaxTTSizes(maxTTSize);
+  }
+  // ibc merge candidate list size
+  if (pps->getQpDeltaInfoInPhFlag())
+  {
+    int iCode = 0;
+    xReadSvlc(iCode, "ph_qp_delta");
+    picHeader->setQpDelta(iCode);
+  }
+
+  // joint Cb/Cr sign flag
+  if (sps->getJointCbCrEnabledFlag())
+  {
+    xReadFlag( uiCode, "ph_joint_cbcr_sign_flag" );
+    picHeader->setJointCbCrSignFlag(uiCode != 0);
+  }
+  else
+  {
+    picHeader->setJointCbCrSignFlag(false);
+  }
+
+  // sao enable flags
+  if(sps->getSAOEnabledFlag())
+  {
+    if (pps->getSaoInfoInPhFlag())
+    {
+      xReadFlag(uiCode, "ph_sao_luma_enabled_flag");
+      picHeader->setSaoEnabledFlag(ChannelType::LUMA, uiCode != 0);
+
+      if (isChromaEnabled(sps->getChromaFormatIdc()))
+      {
+        xReadFlag(uiCode, "ph_sao_chroma_enabled_flag");
+        picHeader->setSaoEnabledFlag(ChannelType::CHROMA, uiCode != 0);
+      }
+    }
+    else
+    {
+      picHeader->setSaoEnabledFlag(ChannelType::LUMA, true);
+      picHeader->setSaoEnabledFlag(ChannelType::CHROMA, isChromaEnabled(sps->getChromaFormatIdc()));
+    }
+  }
+  else
+  {
+    picHeader->setSaoEnabledFlag(ChannelType::LUMA, false);
+    picHeader->setSaoEnabledFlag(ChannelType::CHROMA, false);
+  }
+
+
+
+  // deblocking filter controls
+  if (pps->getDeblockingFilterControlPresentFlag())
+  {
+    if ( pps->getDbfInfoInPhFlag() )
+    {
+      xReadFlag( uiCode, "ph_deblocking_params_present_flag" );
+      picHeader->setDeblockingFilterOverrideFlag( uiCode != 0 );
+    }
+    else
+    {
+      picHeader->setDeblockingFilterOverrideFlag(false);
+    }
+
+    if(picHeader->getDeblockingFilterOverrideFlag())
+    {
+      if (!pps->getPPSDeblockingFilterDisabledFlag())
+      {
+        xReadFlag(uiCode, "ph_deblocking_filter_disabled_flag");
+        picHeader->setDeblockingFilterDisable(uiCode != 0);
+      }
+      else
+      {
+        picHeader->setDeblockingFilterDisable(false);
+      }
+      if (!picHeader->getDeblockingFilterDisable())
+      {
+        xReadSvlc( iCode, "ph_beta_offset_div2" );
+        picHeader->setDeblockingFilterBetaOffsetDiv2(iCode);
+        CHECK(  picHeader->getDeblockingFilterBetaOffsetDiv2() < -12 ||
+                picHeader->getDeblockingFilterBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
+
+        xReadSvlc( iCode, "ph_tc_offset_div2" );
+        picHeader->setDeblockingFilterTcOffsetDiv2(iCode);
+        CHECK(  picHeader->getDeblockingFilterTcOffsetDiv2() < -12 ||
+                picHeader->getDeblockingFilterTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
+
+        if( pps->getPPSChromaToolFlag() )
+        {
+          xReadSvlc( iCode, "ph_cb_beta_offset_div2" );
+          picHeader->setDeblockingFilterCbBetaOffsetDiv2(iCode);
+          CHECK(  picHeader->getDeblockingFilterCbBetaOffsetDiv2() < -12 ||
+                  picHeader->getDeblockingFilterCbBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
+
+          xReadSvlc( iCode, "ph_cb_tc_offset_div2" );
+          picHeader->setDeblockingFilterCbTcOffsetDiv2(iCode);
+          CHECK(  picHeader->getDeblockingFilterCbTcOffsetDiv2() < -12 ||
+                  picHeader->getDeblockingFilterCbTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
+
+          xReadSvlc( iCode, "ph_cr_beta_offset_div2" );
+          picHeader->setDeblockingFilterCrBetaOffsetDiv2(iCode);
+          CHECK(  picHeader->getDeblockingFilterCrBetaOffsetDiv2() < -12 ||
+                  picHeader->getDeblockingFilterCrBetaOffsetDiv2() > 12, "Invalid deblocking filter configuration");
+
+          xReadSvlc( iCode, "ph_cr_tc_offset_div2" );
+          picHeader->setDeblockingFilterCrTcOffsetDiv2(iCode);
+          CHECK(  picHeader->getDeblockingFilterCrTcOffsetDiv2() < -12 ||
+                  picHeader->getDeblockingFilterCrTcOffsetDiv2() > 12, "Invalid deblocking filter configuration");
+        }
+        else
+        {
+          picHeader->setDeblockingFilterCbBetaOffsetDiv2 ( picHeader->getDeblockingFilterBetaOffsetDiv2() );
+          picHeader->setDeblockingFilterCbTcOffsetDiv2   ( picHeader->getDeblockingFilterTcOffsetDiv2()   );
+          picHeader->setDeblockingFilterCrBetaOffsetDiv2 ( picHeader->getDeblockingFilterBetaOffsetDiv2() );
+          picHeader->setDeblockingFilterCrTcOffsetDiv2   ( picHeader->getDeblockingFilterTcOffsetDiv2()   );
+        }
+      }
+    }
+    else
+    {
+      picHeader->setDeblockingFilterDisable       ( pps->getPPSDeblockingFilterDisabledFlag() );
+      picHeader->setDeblockingFilterBetaOffsetDiv2( pps->getDeblockingFilterBetaOffsetDiv2() );
+      picHeader->setDeblockingFilterTcOffsetDiv2  ( pps->getDeblockingFilterTcOffsetDiv2() );
+      picHeader->setDeblockingFilterCbBetaOffsetDiv2( pps->getDeblockingFilterCbBetaOffsetDiv2() );
+      picHeader->setDeblockingFilterCbTcOffsetDiv2  ( pps->getDeblockingFilterCbTcOffsetDiv2() );
+      picHeader->setDeblockingFilterCrBetaOffsetDiv2( pps->getDeblockingFilterCrBetaOffsetDiv2() );
+      picHeader->setDeblockingFilterCrTcOffsetDiv2  ( pps->getDeblockingFilterCrTcOffsetDiv2() );
+    }
+  }
+  else
+  {
+    picHeader->setDeblockingFilterDisable       ( false );
+    picHeader->setDeblockingFilterBetaOffsetDiv2( 0 );
+    picHeader->setDeblockingFilterTcOffsetDiv2  ( 0 );
+    picHeader->setDeblockingFilterCbBetaOffsetDiv2( 0 );
+    picHeader->setDeblockingFilterCbTcOffsetDiv2  ( 0 );
+    picHeader->setDeblockingFilterCrBetaOffsetDiv2(0);
+    picHeader->setDeblockingFilterCrTcOffsetDiv2(0);
+  }
+
+
+  // picture header extension
+  if(pps->getPictureHeaderExtensionPresentFlag())
+  {
+    xReadUvlc(uiCode,"ph_extension_length");
+    for(int i=0; i<uiCode; i++)
+    {
+      uint32_t ignore_;
+      xReadCode(8,ignore_,"ph_extension_data_byte");
+    }
+  }
+
+  if( readRbspTrailingBits )
+  {
+    xReadRbspTrailingBits();
+  }
+}
+
+void  HLSyntaxReader::checkAlfNaluTidAndPicTid(Slice* pcSlice, PicHeader* picHeader, ParameterSetManager *parameterSetManager)
+{
+  SPS* sps = parameterSetManager->getSPS(picHeader->getSPSId());
+  PPS* pps = parameterSetManager->getPPS(picHeader->getPPSId());
+  VPS* vps = parameterSetManager->getVPS(sps->getVPSId());
+  int curPicTid = pcSlice->getTLayer();
+  APS* aps;
+  const AlfApsList &apsId = picHeader->getAlfApsIdsLuma();
+
+  if (sps->getALFEnabledFlag() && pps->getAlfInfoInPhFlag() && picHeader->getAlfEnabledFlag(COMPONENT_Y))
+  {
+    //luma
+    for (int i = 0; i < picHeader->getNumAlfApsIdsLuma(); i++)
+    {
+      aps = parameterSetManager->getAPS(apsId[i], ApsType::ALF);
+      CHECK(aps->getTemporalId() > curPicTid,
+            "The TemporalId of the APS NAL unit having aps_params_type equal to ApsType::ALF and "
+            "adaptation_parameter_set_id equal to ph_alf_aps_id_luma[ i ] shall be less than or equal to the "
+            "TemporalId of the picture associated with the PH.");
+      if( pcSlice->getNalUnitLayerId() != aps->getLayerId() )
+      {
+        CHECK( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK( sps->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        for (int i = 0; i < vps->getNumOutputLayerSets(); i++ )
+        {
+          bool isCurrLayerInOls = false;
+          bool isRefLayerInOls = false;
+          for( int j = vps->getNumLayersInOls(i) - 1; j >= 0; j-- )
+          {
+            if( vps->getLayerIdInOls(i, j) == pcSlice->getNalUnitLayerId() )
+            {
+              isCurrLayerInOls = true;
+            }
+            if( vps->getLayerIdInOls(i, j) == aps->getLayerId() )
+            {
+              isRefLayerInOls = true;
+            }
+          }
+          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+        }
+      }
+    }
+    //chroma
+    if (picHeader->getAlfEnabledFlag(COMPONENT_Cb) || picHeader->getAlfEnabledFlag(COMPONENT_Cr))
+    {
+      int chromaAlfApsId = picHeader->getAlfApsIdChroma();
+      aps                = parameterSetManager->getAPS(chromaAlfApsId, ApsType::ALF);
+      CHECK(aps->getTemporalId() > curPicTid,
+            "The TemporalId of the APS NAL unit having aps_params_type equal to ApsType::ALF and "
+            "adaptation_parameter_set_id equal to ph_alf_aps_id_chroma shall be less than or equal to the TemporalId "
+            "of the picture associated with the PH.");
+      if( pcSlice->getNalUnitLayerId() != aps->getLayerId() )
+      {
+        CHECK( aps->getLayerId() > pcSlice->getNalUnitLayerId(), "Layer Id of APS cannot be greater than layer Id of VCL NAL unit the refer to it" );
+        CHECK( sps->getVPSId() == 0, "VPSId of the referred SPS cannot be 0 when layer Id of APS and layer Id of current slice are different" );
+        for (int i = 0; i < vps->getNumOutputLayerSets(); i++ )
+        {
+          bool isCurrLayerInOls = false;
+          bool isRefLayerInOls = false;
+          for( int j = vps->getNumLayersInOls(i) - 1; j >= 0; j-- )
+          {
+            if( vps->getLayerIdInOls(i, j) == pcSlice->getNalUnitLayerId() )
+            {
+              isCurrLayerInOls = true;
+            }
+            if( vps->getLayerIdInOls(i, j) == aps->getLayerId() )
+            {
+              isRefLayerInOls = true;
+            }
+          }
+          CHECK( isCurrLayerInOls && !isRefLayerInOls, "When VCL NAl unit in layer A refers to APS in layer B, all OLS that contains layer A shall also contains layer B" );
+        }
+      }
+    }
+  }
+}
+
+void HLSyntaxReader::parseSliceHeader (Slice* pcSlice, PicHeader* picHeader, ParameterSetManager *parameterSetManager, const int prevTid0POC, const int prevPicPOC)
+{
+  uint32_t  uiCode;
+  int   iCode;
+
+#if ENABLE_TRACING
+  xTraceSliceHeader();
+#endif
+  PPS *pps = nullptr;
+  SPS *sps = nullptr;
+  xReadFlag(uiCode, "sh_picture_header_in_slice_header_flag");
+  pcSlice->setPictureHeaderInSliceHeader(uiCode);
+  if (uiCode)
+  {
+    parsePictureHeader(picHeader, parameterSetManager, false);
+    picHeader->setValid();
+  }
+  CHECK(picHeader==0, "Invalid Picture Header");
+  CHECK(picHeader->isValid()==false, "Invalid Picture Header");
+  checkAlfNaluTidAndPicTid(pcSlice, picHeader, parameterSetManager);
+  pps = parameterSetManager->getPPS( picHeader->getPPSId() );
+  //!KS: need to add error handling code here, if PPS is not available
+  CHECK(pps==0, "Invalid PPS");
+  sps = parameterSetManager->getSPS(pps->getSPSId());
+  //!KS: need to add error handling code here, if SPS is not available
+  CHECK(sps==0, "Invalid SPS");
+  if (sps->getProfileTierLevel()->getConstraintInfo()->getPicHeaderInSliceHeaderConstraintFlag())
+  {
+    CHECK(pcSlice->getPictureHeaderInSliceHeader() == false, "PH shall be present in SH, when pic_header_in_slice_header_constraint_flag is equal to 1");
+  }
+  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getRplInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, rpl_info_in_ph_flag shall be equal to 0");
+  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getDbfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, dbf_info_in_ph_flag shall be equal to 0");
+  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getSaoInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, sao_info_in_ph_flag shall be equal to 0");
+  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getAlfInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, alf_info_in_ph_flag shall be equal to 0");
+  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getWpInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, wp_info_in_ph_flag shall be equal to 0");
+  CHECK(pcSlice->getPictureHeaderInSliceHeader() && pps->getQpDeltaInfoInPhFlag() == 1, "When sh_picture_header_in_slice_header_flag is equal to 1, qp_delta_info_in_ph_flag shall be equal to 0");
+  CHECK(pcSlice->getPictureHeaderInSliceHeader() && sps->getSubPicInfoPresentFlag() == 1, "When sps_subpic_info_present_flag is equal to 1, the value of sh_picture_header_in_slice_header_flag shall be equal to 0");
+  CHECK(sps->getSubPicInfoPresentFlag() == 1 && sps->getVirtualBoundariesEnabledFlag() == 1 && sps->getVirtualBoundariesPresentFlag() == 0,
+        "when sps_subpic_info_present_flag is equal to 1 and sps_virtual_boundaries_enabled_flag is equal to 1, sps_virtual_boundaries_present_flag shall be equal 1");
+
+  const ChromaFormat chFmt        = sps->getChromaFormatIdc();
+  const uint32_t     numValidComp = getNumberValidComponents(chFmt);
+  const bool         hasChroma    = isChromaEnabled(chFmt);
+
+  // picture order count
+  uiCode = picHeader->getPocLsb();
+  int iPOClsb = uiCode;
+  int iMaxPOClsb = 1 << sps->getBitsForPOC();
+  int iPOCmsb;
+  if (pcSlice->getIdrPicFlag())
+  {
+    if (picHeader->getPocMsbPresentFlag())
+    {
+      iPOCmsb = picHeader->getPocMsbVal()*iMaxPOClsb;
+    }
+    else
+    {
+      iPOCmsb = 0;
+    }
+    pcSlice->setPOC(iPOCmsb + iPOClsb);
+  }
+  else
+  {
+    int iPrevPOC = prevTid0POC;
+    int iPrevPOClsb = iPrevPOC & (iMaxPOClsb - 1);
+    int iPrevPOCmsb = iPrevPOC - iPrevPOClsb;
+    if (picHeader->getPocMsbPresentFlag())
+    {
+      iPOCmsb = picHeader->getPocMsbVal()*iMaxPOClsb;
+    }
+    else
+    {
+      if ((iPOClsb < iPrevPOClsb) && ((iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2)))
+      {
+        iPOCmsb = iPrevPOCmsb + iMaxPOClsb;
+      }
+      else if ((iPOClsb > iPrevPOClsb) && ((iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2)))
+      {
+        iPOCmsb = iPrevPOCmsb - iMaxPOClsb;
+      }
+      else
+      {
+        iPOCmsb = iPrevPOCmsb;
+      }
+    }
+    pcSlice->setPOC(iPOCmsb + iPOClsb);
+  }
+
+  if (sps->getSubPicInfoPresentFlag())
+  {
+    uint32_t bitsSubPicId;
+    bitsSubPicId = sps->getSubPicIdLen();
+    xReadCode(bitsSubPicId, uiCode, "sh_subpic_id");    pcSlice->setSliceSubPicId(uiCode);
+  }
+  else
+  {
+    pcSlice->setSliceSubPicId(0);
+  }
+
+  // raster scan slices
+  uint32_t sliceAddr = 0;
+  if(pps->getRectSliceFlag() == 0)
+  {
+    // slice address is the raster scan tile index of first tile in slice
+    if( pps->getNumTiles() > 1 )
+    {
+      int bitsSliceAddress = ceilLog2(pps->getNumTiles());
+      xReadCode(bitsSliceAddress, uiCode, "sh_slice_address");  sliceAddr = uiCode;
+    }
+  }
+  // rectangular slices
+  else
+  {
+    // slice address is the index of the slice within the current sub-picture
+    uint32_t currSubPicIdx = pps->getSubPicIdxFromSubPicId( pcSlice->getSliceSubPicId() );
+    SubPic currSubPic = pps->getSubPic(currSubPicIdx);
+    if( currSubPic.getNumSlicesInSubPic() > 1 )
+    {
+      int bitsSliceAddress = ceilLog2(currSubPic.getNumSlicesInSubPic());
+      xReadCode(bitsSliceAddress, uiCode, "sh_slice_address");  sliceAddr = uiCode;
+      CHECK(sliceAddr >= currSubPic.getNumSlicesInSubPic(), "Invalid slice address");
+    }
+    uint32_t picLevelSliceIdx = sliceAddr;
+    for(int subpic = 0; subpic < currSubPicIdx; subpic++)
+    {
+      picLevelSliceIdx += pps->getSubPic(subpic).getNumSlicesInSubPic();
+    }
+    pcSlice->setSliceMap( pps->getSliceMap(picLevelSliceIdx) );
+    pcSlice->setSliceID(picLevelSliceIdx);
+  }
+
+  std::vector<bool> shExtraBitsPresent = sps->getExtraSHBitPresentFlags();
+  for (int i=0; i< sps->getNumExtraSHBytes() * 8; i++)
+  {
+    // extra bits are ignored (when present)
+    if (shExtraBitsPresent[i])
+    {
+      xReadFlag(uiCode, "sh_extra_bit[ i ]");
+    }
+  }
+
+  if(pps->getRectSliceFlag() == 0)
+  {
+    uint32_t numTilesInSlice = 1;
+    if( pps->getNumTiles() > 1 )
+    {
+      if (((int)pps->getNumTiles() - (int)sliceAddr) > 1)
+      {
+        xReadUvlc(uiCode, "sh_num_tiles_in_slice_minus1");        numTilesInSlice = uiCode + 1;
+      }
+      if (!pps->getRectSliceFlag() && sps->getProfileTierLevel()->getConstraintInfo()->getOneSlicePerPicConstraintFlag())
+      {
+        CHECK(pps->getNumTiles() != uiCode + 1, "When pps_rect_slice_flag is equal to 0 and one_slice_per_pic_constraint_flag equal to 1, the value of sh_num_tiles_in_slice_minus1 present in each slice header shall be equal to NumTilesInPic - 1");
+      }
+    }
+    CHECK(sliceAddr >= pps->getNumTiles(), "Invalid slice address");
+    pcSlice->initSliceMap();
+    pcSlice->setSliceID(sliceAddr);
+
+    for( uint32_t tileIdx = sliceAddr; tileIdx < sliceAddr + numTilesInSlice; tileIdx++ )
+    {
+      uint32_t tileX = tileIdx % pps->getNumTileColumns();
+      uint32_t tileY = tileIdx / pps->getNumTileColumns();
+      CHECK(tileY >= pps->getNumTileRows(), "Number of tiles in slice exceeds the remaining number of tiles in picture");
+
+      pcSlice->addCtusToSlice(pps->getTileColumnBd(tileX), pps->getTileColumnBd(tileX + 1),
+                              pps->getTileRowBd(tileY), pps->getTileRowBd(tileY + 1), pps->getPicWidthInCtu());
+    }
+  }
+
+  if (picHeader->getPicInterSliceAllowedFlag())
+  {
+    xReadUvlc (    uiCode, "sh_slice_type" );            pcSlice->setSliceType((SliceType)uiCode);
+    VPS *vps = parameterSetManager->getVPS(sps->getVPSId());
+    if (pcSlice->isIRAP() && (sps->getVPSId() == 0 || pcSlice->getPOC() != prevPicPOC || vps->getIndependentLayerFlag(vps->getGeneralLayerIdx(pcSlice->getNalUnitLayerId())) == 1))
+    {
+      CHECK(uiCode != 2, "When nal_unit_type is in the range of IDR_W_RADL to CRA_NUT, inclusive, and vps_independent_layer_flag[ GeneralLayerIdx[ nuh_layer_id ] ] is equal to 1 or the current picture is the first picture in the current AU, sh_slice_type shall be equal to 2");
+    }
+  }
+  else
+  {
+    pcSlice->setSliceType(I_SLICE);
+  }
+  if (!picHeader->getPicIntraSliceAllowedFlag())
+  {
+    CHECK(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
+  }
+  if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR)
+  {
+    xReadFlag(uiCode, "sh_no_output_of_prior_pics_flag");   pcSlice->setNoOutputOfPriorPicsFlag(uiCode != 0);
+  }
+  // inherit values from picture header
+  //   set default values in case slice overrides are disabled
+  pcSlice->inheritFromPicHeader(picHeader, pps, sps);
+
+  if (sps->getALFEnabledFlag() && !pps->getAlfInfoInPhFlag())
+  {
+    xReadFlag(uiCode, "sh_alf_enabled_flag");
+    const bool alfEnabledFlag = uiCode != 0;
+    pcSlice->setAlfEnabledFlag(COMPONENT_Y, alfEnabledFlag);
+
+    bool alfCbEnabledFlag = false;
+    bool alfCrEnabledFlag = false;
+
+    AlfApsList apsIds;
+    if (alfEnabledFlag)
+    {
+      xReadCode(3, uiCode, "sh_num_alf_aps_ids_luma");
+      const int numAps = uiCode;
+
+      for (int i = 0; i < numAps; i++)
+      {
+        xReadCode(3, uiCode, "sh_alf_aps_id_luma[i]");
+        const int apsId = uiCode;
+
+        apsIds.push_back(apsId);
+
+        APS *apsToCheckLuma = parameterSetManager->getAPS(apsId, ApsType::ALF);
+        CHECK(apsToCheckLuma == nullptr, "referenced APS not found");
+        CHECK(apsToCheckLuma->getAlfAPSParam().newFilterFlag[ChannelType::LUMA] != 1,
+              "bitstream conformance error, alf_luma_filter_signal_flag shall be equal to 1");
+      }
+
+      if (hasChroma)
+      {
+        xReadCode(1, uiCode, "sh_alf_cb_enabled_flag");
+        alfCbEnabledFlag = uiCode != 0;
+        xReadCode(1, uiCode, "sh_alf_cr_enabled_flag");
+        alfCrEnabledFlag = uiCode != 0;
+      }
+
+      if (alfCbEnabledFlag || alfCrEnabledFlag)
+      {
+        xReadCode(3, uiCode, "sh_alf_aps_id_chroma");
+        pcSlice->setAlfApsIdChroma(uiCode);
+        APS *apsToCheckChroma = parameterSetManager->getAPS(uiCode, ApsType::ALF);
+        CHECK(apsToCheckChroma == nullptr, "referenced APS not found");
+        CHECK(apsToCheckChroma->getAlfAPSParam().newFilterFlag[ChannelType::CHROMA] != 1,
+              "bitstream conformance error, alf_chroma_filter_signal_flag shall be equal to 1");
+      }
+    }
+
+    pcSlice->setNumAlfApsIdsLuma((int) apsIds.size());
+    pcSlice->setAlfApsIdsLuma(apsIds);
+    pcSlice->setAlfEnabledFlag(COMPONENT_Cb, alfCbEnabledFlag);
+    pcSlice->setAlfEnabledFlag(COMPONENT_Cr, alfCrEnabledFlag);
+
+    CcAlfFilterParam &filterParam = pcSlice->m_ccAlfFilterParam;
+    if (sps->getCCALFEnabledFlag() && pcSlice->getAlfEnabledFlag(COMPONENT_Y))
+    {
+      xReadFlag(uiCode, "sh_alf_cc_cb_enabled_flag");
+      pcSlice->setCcAlfCbEnabledFlag(uiCode);
+      filterParam.ccAlfFilterEnabled[COMPONENT_Cb - 1] = (uiCode == 1) ? true : false;
+      pcSlice->setCcAlfCbApsId(-1);
+      if (filterParam.ccAlfFilterEnabled[COMPONENT_Cb - 1])
+      {
+        // parse APS ID
+        xReadCode(3, uiCode, "sh_alf_cc_cb_aps_id");
+        pcSlice->setCcAlfCbApsId(uiCode);
+        APS *apsToCheckCcCb = parameterSetManager->getAPS(uiCode, ApsType::ALF);
+        CHECK(apsToCheckCcCb == nullptr, "referenced APS not found");
+        CHECK(apsToCheckCcCb->getCcAlfAPSParam().newCcAlfFilter[COMPONENT_Cb - 1] != 1, "bitstream conformance error, alf_cc_cb_filter_signal_flag shall be equal to 1");
+      }
+      // Cr
+      xReadFlag(uiCode, "sh_alf_cc_cr_enabled_flag");
+      pcSlice->setCcAlfCrEnabledFlag(uiCode);
+      filterParam.ccAlfFilterEnabled[COMPONENT_Cr - 1] = (uiCode == 1) ? true : false;
+      pcSlice->setCcAlfCrApsId(-1);
+      if (filterParam.ccAlfFilterEnabled[COMPONENT_Cr - 1])
+      {
+        // parse APS ID
+        xReadCode(3, uiCode, "sh_alf_cc_cr_aps_id");
+        pcSlice->setCcAlfCrApsId(uiCode);
+        APS *apsToCheckCcCr = parameterSetManager->getAPS(uiCode, ApsType::ALF);
+        CHECK(apsToCheckCcCr == nullptr, "referenced APS not found");
+        CHECK(apsToCheckCcCr->getCcAlfAPSParam().newCcAlfFilter[COMPONENT_Cr - 1] != 1, "bitstream conformance error, alf_cc_cr_filter_signal_flag shall be equal to 1");
+      }
+    }
+    else
+    {
+      filterParam.ccAlfFilterEnabled[COMPONENT_Cb - 1] = false;
+      filterParam.ccAlfFilterEnabled[COMPONENT_Cr - 1] = false;
+      pcSlice->setCcAlfCbApsId(-1);
+      pcSlice->setCcAlfCrApsId(-1);
+    }
+  }
+  if (picHeader->getLmcsEnabledFlag() && !pcSlice->getPictureHeaderInSliceHeader())
+  {
+    xReadFlag(uiCode, "sh_lmcs_used_flag");
+    pcSlice->setLmcsEnabledFlag(uiCode);
+  }
+  else
+  {
+    pcSlice->setLmcsEnabledFlag(pcSlice->getPictureHeaderInSliceHeader() ? picHeader->getLmcsEnabledFlag() : false);
+  }
+  if (picHeader->getExplicitScalingListEnabledFlag() && !pcSlice->getPictureHeaderInSliceHeader())
+  {
+    xReadFlag(uiCode, "sh_explicit_scaling_list_used_flag");
+    pcSlice->setExplicitScalingListUsed(uiCode);
+  }
+  else
+  {
+    pcSlice->setExplicitScalingListUsed(pcSlice->getPictureHeaderInSliceHeader() ? picHeader->getExplicitScalingListEnabledFlag() : false);
+  }
+
+  if (pps->getRplInfoInPhFlag())
+  {
+    *pcSlice->getRpl(REF_PIC_LIST_0) = *picHeader->getRpl(REF_PIC_LIST_0);
+    *pcSlice->getRpl(REF_PIC_LIST_1) = *picHeader->getRpl(REF_PIC_LIST_1);
+  }
+  else if (pcSlice->getIdrPicFlag() && !(sps->getIDRRefParamListPresent()))
+  {
+    ReferencePictureList *rpl0 = pcSlice->getRpl(REF_PIC_LIST_0);
+    (*rpl0)                    = ReferencePictureList();
+    ReferencePictureList *rpl1 = pcSlice->getRpl(REF_PIC_LIST_1);
+    (*rpl1)                    = ReferencePictureList();
+  }
+  else
+  {
+    // Read L0 related syntax elements
+    bool rplSpsFlag0 = false;
+
+    if (sps->getNumRpl(REF_PIC_LIST_0) > 0)
+    {
+      xReadFlag(uiCode, "ref_pic_list_sps_flag[0]");
+      rplSpsFlag0 = uiCode != 0;
+    }
+
+    auto const rpl0 = pcSlice->getRpl(REF_PIC_LIST_0);
+    if (!rplSpsFlag0)   // explicitly carried in this SH
+    {
+      *rpl0 = ReferencePictureList();
+      parseRefPicList(sps, rpl0, -1);
+      pcSlice->setRplIdx(REF_PIC_LIST_0, -1);
+    }
+    else   // Refer to list in SPS
+    {
+      int rpsIdx = 0;
+      if (sps->getNumRpl(REF_PIC_LIST_0) > 1)
+      {
+        int numBits = ceilLog2(sps->getNumRpl(REF_PIC_LIST_0));
+        xReadCode(numBits, uiCode, "ref_pic_list_idx[0]");
+        rpsIdx = uiCode;
+      }
+
+      pcSlice->setRplIdx(REF_PIC_LIST_0, rpsIdx);
+      *rpl0 = *sps->getRplList(REF_PIC_LIST_0)->getReferencePictureList(rpsIdx);
+    }
+    // Deal POC Msb cycle signalling for LTRP
+    for (int i = 0; i < rpl0->getNumRefEntries(); i++)
+    {
+      rpl0->setDeltaPocMSBPresentFlag(i, false);
+      rpl0->setDeltaPocMSBCycleLT(i, 0);
+    }
+    if (rpl0->getNumberOfLongtermPictures())
+    {
+      for (int i = 0; i < rpl0->getNumRefEntries(); i++)
+      {
+        if (rpl0->isRefPicLongterm(i))
+        {
+          if (rpl0->getLtrpInSliceHeaderFlag())
+          {
+            xReadCode(sps->getBitsForPOC(), uiCode, "slice_poc_lsb_lt[i][j]");
+            rpl0->setRefPicIdentifier(i, uiCode, true, false, 0);
+          }
+          xReadFlag(uiCode, "delta_poc_msb_present_flag[i][j]");
+          rpl0->setDeltaPocMSBPresentFlag(i, uiCode ? true : false);
+          if (uiCode)
+          {
+            xReadUvlc(uiCode, "slice_delta_poc_msb_cycle_lt[i][j]");
+            if (i != 0)
+            {
+              uiCode += rpl0->getDeltaPocMSBCycleLT(i - 1);
+            }
+            rpl0->setDeltaPocMSBCycleLT(i, uiCode);
+          }
+          else if(i != 0)
+          {
+            rpl0->setDeltaPocMSBCycleLT(i, rpl0->getDeltaPocMSBCycleLT(i-1));
+          }
+          else
+          {
+            rpl0->setDeltaPocMSBCycleLT(i,0);
+          }
+        }
+        else if (i != 0)
+        {
+          rpl0->setDeltaPocMSBCycleLT(i, rpl0->getDeltaPocMSBCycleLT(i - 1));
+        }
+        else
+        {
+          rpl0->setDeltaPocMSBCycleLT(i, 0);
+        }
+      }
+    }
+
+    // Read L1 related syntax elements
+    bool rplSpsFlag1 = sps->getNumRpl(REF_PIC_LIST_1) == 0 ? false : rplSpsFlag0;
+    if (sps->getNumRpl(REF_PIC_LIST_1) > 0 && pps->getRpl1IdxPresentFlag())
+    {
+      xReadFlag(uiCode, "ref_pic_list_sps_flag[1]");
+      rplSpsFlag1 = uiCode != 0;
+    }
+
+    auto const rpl1 = pcSlice->getRpl(REF_PIC_LIST_1);
+    if (rplSpsFlag1)
+    {
+      if (sps->getNumRpl(REF_PIC_LIST_1) > 1 && pps->getRpl1IdxPresentFlag())
+      {
+        int numBits = ceilLog2(sps->getNumRpl(REF_PIC_LIST_1));
+        xReadCode(numBits, uiCode, "ref_pic_list_idx[1]");
+        pcSlice->setRplIdx(REF_PIC_LIST_1, uiCode);
+        *rpl1 = *sps->getRplList(REF_PIC_LIST_1)->getReferencePictureList(uiCode);
+      }
+      else if (sps->getNumRpl(REF_PIC_LIST_1) == 1)
+      {
+        pcSlice->setRplIdx(REF_PIC_LIST_1, 0);
+        *rpl1 = *sps->getRplList(REF_PIC_LIST_1)->getReferencePictureList(0);
+      }
+      else
+      {
+        assert(pcSlice->getRplIdx(REF_PIC_LIST_0) != -1);
+        pcSlice->setRplIdx(REF_PIC_LIST_1, pcSlice->getRplIdx(REF_PIC_LIST_0));
+        *rpl1 = *sps->getRplList(REF_PIC_LIST_1)->getReferencePictureList(pcSlice->getRplIdx(REF_PIC_LIST_0));
+      }
+    }
+    else
+    {
+      (*rpl1) = ReferencePictureList();
+      parseRefPicList(sps, rpl1, -1);
+      pcSlice->setRplIdx(REF_PIC_LIST_1, -1);
+    }
+
+    // Deal POC Msb cycle signalling for LTRP
+    for (int i = 0; i < rpl1->getNumRefEntries(); i++)
+    {
+      rpl1->setDeltaPocMSBPresentFlag(i, false);
+      rpl1->setDeltaPocMSBCycleLT(i, 0);
+    }
+    if (rpl1->getNumberOfLongtermPictures())
+    {
+      for (int i = 0; i < rpl1->getNumRefEntries(); i++)
+      {
+        if (rpl1->isRefPicLongterm(i))
+        {
+          if (rpl1->getLtrpInSliceHeaderFlag())
+          {
+            xReadCode(sps->getBitsForPOC(), uiCode, "slice_poc_lsb_lt[i][j]");
+            rpl1->setRefPicIdentifier(i, uiCode, true, false, 0);
+          }
+          xReadFlag(uiCode, "delta_poc_msb_present_flag[i][j]");
+          rpl1->setDeltaPocMSBPresentFlag(i, uiCode ? true : false);
+          if (uiCode)
+          {
+            xReadUvlc(uiCode, "slice_delta_poc_msb_cycle_lt[i][j]");
+            if (i != 0)
+            {
+              uiCode += rpl1->getDeltaPocMSBCycleLT(i - 1);
+            }
+            rpl1->setDeltaPocMSBCycleLT(i, uiCode);
+          }
+          else if(i != 0)
+          {
+            rpl1->setDeltaPocMSBCycleLT(i, rpl1->getDeltaPocMSBCycleLT(i-1));
+          }
+          else
+          {
+            rpl1->setDeltaPocMSBCycleLT(i,0);
+          }
+        }
+        else if (i != 0)
+        {
+          rpl1->setDeltaPocMSBCycleLT(i, rpl1->getDeltaPocMSBCycleLT(i - 1));
+        }
+        else
+        {
+          rpl1->setDeltaPocMSBCycleLT(i, 0);
+        }
+      }
+    }
+  }
+
+  uint32_t numActiveRefs[NUM_REF_PIC_LIST_01] = { pcSlice->isIntra() ? 0u : 1u, pcSlice->isInterB() ? 1u : 0u };
+
+  if ((!pcSlice->isIntra() && pcSlice->getRpl(REF_PIC_LIST_0)->getNumRefEntries() > 1)
+      || (pcSlice->isInterB() && pcSlice->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 1))
+  {
+    xReadFlag(uiCode, "sh_num_ref_idx_active_override_flag");
+    if (uiCode)
+    {
+      if (pcSlice->getRpl(REF_PIC_LIST_0)->getNumRefEntries() > 1)
+      {
+        xReadUvlc(uiCode, "sh_num_ref_idx_active_minus1[0]");
+        CHECK(uiCode >= MAX_NUM_ACTIVE_REF,
+              "The value of sh_num_ref_idx_active_minus1[0] shall be in the range of 0 to 14, inclusive");
+        numActiveRefs[REF_PIC_LIST_0] = uiCode + 1;
+      }
+      if (pcSlice->isInterB() && pcSlice->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 1)
+      {
+        xReadUvlc(uiCode, "sh_num_ref_idx_active_minus1[1]");
+        CHECK(uiCode >= MAX_NUM_ACTIVE_REF,
+              "The value of sh_num_ref_idx_active_minus1[1] shall be in the range of 0 to 14, inclusive");
+        numActiveRefs[REF_PIC_LIST_1] = uiCode + 1;
+      }
+    }
+    else
+    {
+      numActiveRefs[REF_PIC_LIST_0] = std::min<int>(pcSlice->getRpl(REF_PIC_LIST_0)->getNumRefEntries(),
+                                                    pps->getNumRefIdxDefaultActive(REF_PIC_LIST_0));
+
+      if (pcSlice->isInterB())
+      {
+        numActiveRefs[REF_PIC_LIST_1] = std::min<int>(pcSlice->getRpl(REF_PIC_LIST_1)->getNumRefEntries(),
+                                                      pps->getNumRefIdxDefaultActive(REF_PIC_LIST_1));
+      }
+    }
+  }
+
+  pcSlice->setNumRefIdx(REF_PIC_LIST_0, numActiveRefs[REF_PIC_LIST_0]);
+  pcSlice->setNumRefIdx(REF_PIC_LIST_1, numActiveRefs[REF_PIC_LIST_1]);
+
+  if (pcSlice->isInterP() || pcSlice->isInterB())
+  {
+    CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) == 0,
+          "Number of active entries in RPL0 of P or B picture shall be greater than 0");
+
+    if (pcSlice->isInterB())
+    {
+      CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) == 0,
+            "Number of active entries in RPL1 of B picture shall be greater than 0");
+    }
+  }
+
+  pcSlice->setCabacInitFlag(false);   // default
+  if (pps->getCabacInitPresentFlag() && !pcSlice->isIntra())
+  {
+    xReadFlag(uiCode, "sh_cabac_init_flag");
+    pcSlice->setCabacInitFlag(uiCode ? true : false);
+    pcSlice->setEncCABACTableIdx(pcSlice->getSliceType() == B_SLICE ? (uiCode ? P_SLICE : B_SLICE)
+                                                                    : (uiCode ? B_SLICE : P_SLICE));
+  }
+
+  if (picHeader->getEnableTMVPFlag())
+  {
+    if (pcSlice->getSliceType() == P_SLICE)
+    {
+      pcSlice->setColFromL0Flag(true);
+    }
+    else if (!pps->getRplInfoInPhFlag() && pcSlice->getSliceType() == B_SLICE)
+    {
+      xReadFlag(uiCode, "sh_collocated_from_l0_flag");
+      pcSlice->setColFromL0Flag(uiCode);
+    }
+    else
+    {
+      pcSlice->setColFromL0Flag(picHeader->getPicColFromL0Flag());
+    }
+
+    if (!pps->getRplInfoInPhFlag())
+    {
+      if (pcSlice->getSliceType() != I_SLICE
+          && ((pcSlice->getColFromL0Flag() == 1 && pcSlice->getNumRefIdx(REF_PIC_LIST_0) > 1)
+              || (pcSlice->getColFromL0Flag() == 0 && pcSlice->getNumRefIdx(REF_PIC_LIST_1) > 1)))
+      {
+        xReadUvlc(uiCode, "sh_collocated_ref_idx");
+        pcSlice->setColRefIdx(uiCode);
+      }
+      else
+      {
+        pcSlice->setColRefIdx(0);
+      }
+    }
+    else
+    {
+      pcSlice->setColRefIdx(picHeader->getColRefIdx());
+    }
+  }
+  if ((pps->getUseWP() && pcSlice->getSliceType() == P_SLICE)
+      || (pps->getWPBiPred() && pcSlice->getSliceType() == B_SLICE))
+  {
+    if (pps->getWpInfoInPhFlag())
+    {
+      CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_0) > picHeader->getNumWeights(REF_PIC_LIST_0),
+            "ERROR: Number of active reference picture L0 is greater than the number of weighted prediction signalled "
+            "in Picture Header");
+      CHECK(pcSlice->getNumRefIdx(REF_PIC_LIST_1) > picHeader->getNumWeights(REF_PIC_LIST_1),
+            "ERROR: Number of active reference picture L1 is greater than the number of weighted prediction signalled "
+            "in Picture Header");
+      pcSlice->setWpScaling(picHeader->getWpScalingAll());
+    }
+    else
+    {
+      parsePredWeightTable(pcSlice, sps);
+    }
+    pcSlice->initWpScaling(sps);
+  }
+  else
+  {
+    for (int iNumRef = 0; iNumRef < ((pcSlice->getSliceType() == B_SLICE) ? 2 : 1); iNumRef++)
+    {
+      RefPicList eRefPicList = (iNumRef ? REF_PIC_LIST_1 : REF_PIC_LIST_0);
+      for (int refIdx = 0; refIdx < pcSlice->getNumRefIdx(eRefPicList); refIdx++)
+      {
+        WPScalingParam *wp = pcSlice->getWpScaling(eRefPicList, refIdx);
+
+        wp[0].presentFlag = false;
+        wp[1].presentFlag = false;
+        wp[2].presentFlag = false;
+      }
+    }
+  }
+
+  int qpDelta = 0;
+  if (pps->getQpDeltaInfoInPhFlag())
+  {
+    qpDelta = picHeader->getQpDelta();
+  }
+  else
+  {
+    xReadSvlc(iCode, "sh_qp_delta");
+    qpDelta = iCode;
+  }
+  pcSlice->setSliceQp(26 + pps->getPicInitQPMinus26() + qpDelta);
+  pcSlice->setSliceQpBase(pcSlice->getSliceQp());
+
+  CHECK(pcSlice->getSliceQp() < -sps->getQpBDOffset(ChannelType::LUMA), "Invalid slice QP delta");
+  CHECK(pcSlice->getSliceQp() > MAX_QP, "Invalid slice QP");
+
+  if (pps->getSliceChromaQpFlag())
+  {
+    if (numValidComp > COMPONENT_Cb)
+    {
+      xReadSvlc(iCode, "sh_cb_qp_offset");
+      pcSlice->setSliceChromaQpDelta(COMPONENT_Cb, iCode);
+      CHECK(pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) < -12, "Invalid chroma QP offset");
+      CHECK(pcSlice->getSliceChromaQpDelta(COMPONENT_Cb) > 12, "Invalid chroma QP offset");
+      CHECK((pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) < -12,
+            "Invalid chroma QP offset");
+      CHECK((pps->getQpOffset(COMPONENT_Cb) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cb)) > 12,
+            "Invalid chroma QP offset");
+    }
+
+    if (numValidComp > COMPONENT_Cr)
+    {
+      xReadSvlc(iCode, "sh_cr_qp_offset");
+      pcSlice->setSliceChromaQpDelta(COMPONENT_Cr, iCode);
+      CHECK(pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) < -12, "Invalid chroma QP offset");
+      CHECK(pcSlice->getSliceChromaQpDelta(COMPONENT_Cr) > 12, "Invalid chroma QP offset");
+      CHECK((pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) < -12,
+            "Invalid chroma QP offset");
+      CHECK((pps->getQpOffset(COMPONENT_Cr) + pcSlice->getSliceChromaQpDelta(COMPONENT_Cr)) > 12,
+            "Invalid chroma QP offset");
+      if (sps->getJointCbCrEnabledFlag())
+      {
+        xReadSvlc(iCode, "sh_joint_cbcr_qp_offset");
+        pcSlice->setSliceChromaQpDelta(JOINT_CbCr, iCode);
+        CHECK(pcSlice->getSliceChromaQpDelta(JOINT_CbCr) < -12, "Invalid chroma QP offset");
+        CHECK(pcSlice->getSliceChromaQpDelta(JOINT_CbCr) > 12, "Invalid chroma QP offset");
+        CHECK((pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) < -12,
+              "Invalid chroma QP offset");
+        CHECK((pps->getQpOffset(JOINT_CbCr) + pcSlice->getSliceChromaQpDelta(JOINT_CbCr)) > 12,
+              "Invalid chroma QP offset");
+      }
+    }
+  }
+
+  if (pps->getCuChromaQpOffsetListEnabledFlag())
+  {
+    xReadFlag(uiCode, "sh_cu_chroma_qp_offset_enabled_flag");
+    pcSlice->setUseChromaQpAdj(uiCode != 0);
+  }
+  else
+  {
+    pcSlice->setUseChromaQpAdj(false);
+  }
+
+  if (sps->getSAOEnabledFlag() && !pps->getSaoInfoInPhFlag())
+  {
+    xReadFlag(uiCode, "sh_sao_luma_used_flag");
+    pcSlice->setSaoEnabledFlag(ChannelType::LUMA, uiCode != 0);
+
+    if (hasChroma)
+    {
+      xReadFlag(uiCode, "sh_sao_chroma_used_flag");
+      pcSlice->setSaoEnabledFlag(ChannelType::CHROMA, uiCode != 0);
+    }
+  }
+
+  if (pps->getDeblockingFilterControlPresentFlag())
+  {
+    if (pps->getDeblockingFilterOverrideEnabledFlag() && !pps->getDbfInfoInPhFlag())
+    {
+      xReadFlag(uiCode, "sh_deblocking_params_present_flag");
+      pcSlice->setDeblockingFilterOverrideFlag(uiCode ? true : false);
+    }
+    else
+    {
+      pcSlice->setDeblockingFilterOverrideFlag(false);
+    }
+    if (pcSlice->getDeblockingFilterOverrideFlag())
+    {
+      if (!pps->getPPSDeblockingFilterDisabledFlag())
+      {
+        xReadFlag(uiCode, "sh_deblocking_filter_disabled_flag");
+        pcSlice->setDeblockingFilterDisable(uiCode != 0);
+      }
+      else
+      {
+        pcSlice->setDeblockingFilterDisable(false);
+      }
+      if (!pcSlice->getDeblockingFilterDisable())
+      {
+        xReadSvlc(iCode, "sh_luma_beta_offset_div2");
+        pcSlice->setDeblockingFilterBetaOffsetDiv2(iCode);
+        CHECK(pcSlice->getDeblockingFilterBetaOffsetDiv2() < -12 || pcSlice->getDeblockingFilterBetaOffsetDiv2() > 12,
+              "Invalid deblocking filter configuration");
+        xReadSvlc(iCode, "sh_luma_tc_offset_div2");
+        pcSlice->setDeblockingFilterTcOffsetDiv2(iCode);
+        CHECK(pcSlice->getDeblockingFilterTcOffsetDiv2() < -12 || pcSlice->getDeblockingFilterTcOffsetDiv2() > 12,
+              "Invalid deblocking filter configuration");
+
+        if (pps->getPPSChromaToolFlag())
+        {
+          xReadSvlc(iCode, "sh_cb_beta_offset_div2");
+          pcSlice->setDeblockingFilterCbBetaOffsetDiv2(iCode);
+          CHECK(pcSlice->getDeblockingFilterCbBetaOffsetDiv2() < -12
+                  || pcSlice->getDeblockingFilterCbBetaOffsetDiv2() > 12,
+                "Invalid deblocking filter configuration");
+          xReadSvlc(iCode, "sh_cb_tc_offset_div2");
+          pcSlice->setDeblockingFilterCbTcOffsetDiv2(iCode);
+          CHECK(pcSlice->getDeblockingFilterCbTcOffsetDiv2() < -12 || pcSlice->getDeblockingFilterCbTcOffsetDiv2() > 12,
+                "Invalid deblocking filter configuration");
+
+          xReadSvlc(iCode, "sh_cr_beta_offset_div2");
+          pcSlice->setDeblockingFilterCrBetaOffsetDiv2(iCode);
+          CHECK(pcSlice->getDeblockingFilterCrBetaOffsetDiv2() < -12
+                  || pcSlice->getDeblockingFilterCrBetaOffsetDiv2() > 12,
+                "Invalid deblocking filter configuration");
+          xReadSvlc(iCode, "sh_cr_tc_offset_div2");
+          pcSlice->setDeblockingFilterCrTcOffsetDiv2(iCode);
+          CHECK(pcSlice->getDeblockingFilterCrTcOffsetDiv2() < -12 || pcSlice->getDeblockingFilterCrTcOffsetDiv2() > 12,
+                "Invalid deblocking filter configuration");
+        }
+        else
+        {
+          pcSlice->setDeblockingFilterCbBetaOffsetDiv2(pcSlice->getDeblockingFilterBetaOffsetDiv2());
+          pcSlice->setDeblockingFilterCbTcOffsetDiv2(pcSlice->getDeblockingFilterTcOffsetDiv2());
+          pcSlice->setDeblockingFilterCrBetaOffsetDiv2(pcSlice->getDeblockingFilterBetaOffsetDiv2());
+          pcSlice->setDeblockingFilterCrTcOffsetDiv2(pcSlice->getDeblockingFilterTcOffsetDiv2());
+        }
+      }
+    }
+    else
+    {
+      pcSlice->setDeblockingFilterDisable(picHeader->getDeblockingFilterDisable());
+      pcSlice->setDeblockingFilterBetaOffsetDiv2(picHeader->getDeblockingFilterBetaOffsetDiv2());
+      pcSlice->setDeblockingFilterTcOffsetDiv2(picHeader->getDeblockingFilterTcOffsetDiv2());
+      pcSlice->setDeblockingFilterCbBetaOffsetDiv2(picHeader->getDeblockingFilterCbBetaOffsetDiv2());
+      pcSlice->setDeblockingFilterCbTcOffsetDiv2(picHeader->getDeblockingFilterCbTcOffsetDiv2());
+      pcSlice->setDeblockingFilterCrBetaOffsetDiv2(picHeader->getDeblockingFilterCrBetaOffsetDiv2());
+      pcSlice->setDeblockingFilterCrTcOffsetDiv2(picHeader->getDeblockingFilterCrTcOffsetDiv2());
+    }
+  }
+  else
+  {
+    pcSlice->setDeblockingFilterDisable(false);
+    pcSlice->setDeblockingFilterBetaOffsetDiv2(0);
+    pcSlice->setDeblockingFilterTcOffsetDiv2(0);
+    pcSlice->setDeblockingFilterCbBetaOffsetDiv2(0);
+    pcSlice->setDeblockingFilterCbTcOffsetDiv2(0);
+    pcSlice->setDeblockingFilterCrBetaOffsetDiv2(0);
+    pcSlice->setDeblockingFilterCrTcOffsetDiv2(0);
+  }
+
+  // dependent quantization
+  if( sps->getDepQuantEnabledFlag() )
+  {
+    xReadFlag(uiCode, "sh_dep_quant_used_flag");
+    pcSlice->setDepQuantEnabledFlag(uiCode != 0);
+  }
+  else
+  {
+    pcSlice->setDepQuantEnabledFlag(false);
+  }
+
+  // sign data hiding
+  if( sps->getSignDataHidingEnabledFlag() && !pcSlice->getDepQuantEnabledFlag() )
+  {
+    xReadFlag( uiCode, "sh_sign_data_hiding_used_flag" );
+    pcSlice->setSignDataHidingEnabledFlag( uiCode != 0 );
+  }
+  else
+  {
+    pcSlice->setSignDataHidingEnabledFlag(false);
+  }
+
+  // signal TS residual coding disabled flag
+  if (sps->getTransformSkipEnabledFlag() && !pcSlice->getDepQuantEnabledFlag() && !pcSlice->getSignDataHidingEnabledFlag())
+  {
+    xReadFlag(uiCode, "sh_ts_residual_coding_disabled_flag");
+    pcSlice->setTSResidualCodingDisabledFlag( uiCode != 0 );
+  }
+  else
+  {
+    pcSlice->setTSResidualCodingDisabledFlag( false );
+  }
+
+  if ((!pcSlice->getTSResidualCodingDisabledFlag()) && sps->getSpsRangeExtension().getTSRCRicePresentFlag())
+  {
+    xReadCode(3, uiCode, "sh_ts_residual_coding_rice_idx_minus1");
+    pcSlice->setTsrcIndex(uiCode);
+  }
+  if (sps->getSpsRangeExtension().getReverseLastSigCoeffEnabledFlag())
+  {
+    xReadFlag(uiCode, "sh_reverse_last_sig_coeff_flag");
+    pcSlice->setReverseLastSigCoeffFlag(uiCode != 0);
+  }
+  else
+  {
+    pcSlice->setReverseLastSigCoeffFlag(false);
+  }
+
+  if( pcSlice->getFirstCtuRsAddrInSlice() == 0 )
+  {
+    pcSlice->setDefaultClpRng( *sps );
+  }
+
+  if(pps->getSliceHeaderExtensionPresentFlag())
+  {
+    xReadUvlc(uiCode,"sh_slice_header_extension_length");
+    for(int i=0; i<uiCode; i++)
+    {
+      uint32_t ignore_;
+      xReadCode(8,ignore_,"sh_slice_header_extension_data_byte");
+    }
+  }
+
+  std::vector<uint32_t> entryPointOffset;
+
+  pcSlice->resetNumberOfSubstream();
+  pcSlice->setNumSubstream(sps, pps);
+
+  pcSlice->setNumEntryPoints( sps, pps );
+  if( pcSlice->getNumEntryPoints() > 0 )
+  {
+    uint32_t offsetLenMinus1;
+    xReadUvlc( offsetLenMinus1, "sh_entry_offset_len_minus1" );
+    entryPointOffset.resize( pcSlice->getNumEntryPoints() );
+    for( uint32_t idx = 0; idx < pcSlice->getNumEntryPoints(); idx++ )
+    {
+      xReadCode( offsetLenMinus1 + 1, uiCode, "sh_entry_point_offset_minus1" );
+      entryPointOffset[idx] = uiCode + 1;
+    }
+  }
+
+#if RExt__DECODER_DEBUG_BIT_STATISTICS
+  CodingStatistics::IncrementStatisticEP(STATS__BYTE_ALIGNMENT_BITS,m_pcBitstream->readByteAlignment(),0);
+#else
+  m_pcBitstream->readByteAlignment();
+#endif
+
+  pcSlice->clearSubstreamSizes();
+
+  if( pcSlice->getNumEntryPoints() > 0 )
+  {
+    int endOfSliceHeaderLocation = m_pcBitstream->getByteLocation();
+
+    // Adjust endOfSliceHeaderLocation to account for emulation prevention bytes in the slice segment header
+    for ( uint32_t curByteIdx  = 0; curByteIdx<m_pcBitstream->numEmulationPreventionBytesRead(); curByteIdx++ )
+    {
+      if ( m_pcBitstream->getEmulationPreventionByteLocation( curByteIdx ) < endOfSliceHeaderLocation )
+      {
+        endOfSliceHeaderLocation++;
+      }
+    }
+
+    int  curEntryPointOffset     = 0;
+    int  prevEntryPointOffset    = 0;
+    for (uint32_t idx=0; idx<entryPointOffset.size(); idx++)
+    {
+      curEntryPointOffset += entryPointOffset[ idx ];
+
+      int emulationPreventionByteCount = 0;
+      for ( uint32_t curByteIdx  = 0; curByteIdx<m_pcBitstream->numEmulationPreventionBytesRead(); curByteIdx++ )
+      {
+        if (m_pcBitstream->getEmulationPreventionByteLocation(curByteIdx)
+              >= (prevEntryPointOffset + endOfSliceHeaderLocation)
+            && m_pcBitstream->getEmulationPreventionByteLocation(curByteIdx)
+                 < (curEntryPointOffset + endOfSliceHeaderLocation))
+        {
+          emulationPreventionByteCount++;
+        }
+      }
+
+      entryPointOffset[ idx ] -= emulationPreventionByteCount;
+      prevEntryPointOffset = curEntryPointOffset;
+      pcSlice->addSubstreamSize(entryPointOffset [ idx ] );
+    }
+  }
+  return;
+}
+
+void HLSyntaxReader::getSlicePoc(Slice* pcSlice, PicHeader* picHeader, ParameterSetManager *parameterSetManager, const int prevTid0POC)
+{
+  uint32_t  uiCode;
+  uint32_t  pocLsb;
+
+  PPS *pps = nullptr;
+  SPS *sps = nullptr;
+
+  CHECK(picHeader==0, "Invalid Picture Header");
+  CHECK(picHeader->isValid()==false, "Invalid Picture Header");
+  pps = parameterSetManager->getPPS( picHeader->getPPSId() );
+  //!KS: need to add error handling code here, if PPS is not available
+  CHECK(pps==0, "Invalid PPS");
+  sps = parameterSetManager->getSPS(pps->getSPSId());
+  //!KS: need to add error handling code here, if SPS is not available
+  CHECK(sps==0, "Invalid SPS");
+
+  DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 0 ) );
+
+  xReadFlag(uiCode, "sh_picture_header_in_slice_header_flag");
+  if (uiCode == 0)
+  {
+    pocLsb = picHeader->getPocLsb();
+  }
+  else
+  {
+    uint32_t phGdrOrIrapPicFlag;
+    xReadFlag(phGdrOrIrapPicFlag, "ph_gdr_or_irap_pic_flag");
+    xReadFlag(uiCode, "ph_non_ref_pic_flag");
+    if (phGdrOrIrapPicFlag)
+    {
+      xReadFlag(uiCode, "ph_gdr_pic_flag");
+    }
+    xReadFlag(uiCode, "ph_inter_slice_allowed_flag");
+    if (uiCode)
+    {
+      xReadFlag(uiCode, "ph_intra_slice_allowed_flag");
+    }
+    // parameter sets
+    xReadUvlc(uiCode, "ph_pic_parameter_set_id");
+    // picture order count
+    xReadCode(sps->getBitsForPOC(), pocLsb, "ph_pic_order_cnt_lsb");
+  }
+  int maxPocLsb = 1 << sps->getBitsForPOC();
+  int pocMsb;
+  if (pcSlice->getIdrPicFlag())
+  {
+    if (picHeader->getPocMsbPresentFlag())
+    {
+      pocMsb = picHeader->getPocMsbVal()*maxPocLsb;
+    }
+    else
+    {
+      pocMsb = 0;
+    }
+    pcSlice->setPOC(pocMsb + pocLsb);
+  }
+  else
+  {
+    int prevPoc = prevTid0POC;
+    int prevPocLsb = prevPoc & (maxPocLsb - 1);
+    int prevPocMsb = prevPoc - prevPocLsb;
+    if (picHeader->getPocMsbPresentFlag())
+    {
+      pocMsb = picHeader->getPocMsbVal()*maxPocLsb;
+    }
+    else
+    {
+      if ((pocLsb < prevPocLsb) && ((prevPocLsb - pocLsb) >= (maxPocLsb / 2)))
+      {
+        pocMsb = prevPocMsb + maxPocLsb;
+      }
+      else if ((pocLsb > prevPocLsb) && ((pocLsb - prevPocLsb) > (maxPocLsb / 2)))
+      {
+        pocMsb = prevPocMsb - maxPocLsb;
+      }
+      else
+      {
+        pocMsb = prevPocMsb;
+      }
+    }
+    pcSlice->setPOC(pocMsb + pocLsb);
+  }
+  DTRACE_UPDATE( g_trace_ctx, std::make_pair( "final", 1 ) );
+}
+
+void HLSyntaxReader::parseConstraintInfo(ConstraintInfo *cinfo, const ProfileTierLevel* ptl )
+{
+  uint32_t symbol;
+  xReadFlag(symbol, "gci_present_flag"); cinfo->setGciPresentFlag(symbol ? true : false);
+  if (cinfo->getGciPresentFlag())
+  {
+    /* general */
+    xReadFlag(symbol, "gci_intra_only_constraint_flag");                 cinfo->setIntraOnlyConstraintFlag(symbol ? true : false);
+    xReadFlag(symbol, "gci_all_layers_independent_constraint_flag");     cinfo->setAllLayersIndependentConstraintFlag(symbol ? true : false);
+    xReadFlag(symbol, "gci_one_au_only_constraint_flag");                cinfo->setOnePictureOnlyConstraintFlag(symbol ? true : false);
+
+    /* picture format */
+    xReadCode(4, symbol, "gci_sixteen_minus_max_bitdepth_constraint_idc"); cinfo->setMaxBitDepthConstraintIdc(symbol>8 ? 16 : (16 - symbol));
+    CHECK(symbol>8, "gci_sixteen_minus_max_bitdepth_constraint_idc shall be in the range 0 to 8, inclusive");
+    xReadCode(2, symbol, "gci_three_minus_max_chroma_format_constraint_idc"); cinfo->setMaxChromaFormatConstraintIdc((ChromaFormat)(3 - symbol));
+
+    /* NAL unit type related */
+    xReadFlag(symbol, "gci_no_mixed_nalu_types_in_pic_constraint_flag"); cinfo->setNoMixedNaluTypesInPicConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_trail_constraint_flag");                   cinfo->setNoTrailConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_stsa_constraint_flag");                    cinfo->setNoStsaConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_rasl_constraint_flag");                    cinfo->setNoRaslConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_radl_constraint_flag");                    cinfo->setNoRadlConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_idr_constraint_flag");                     cinfo->setNoIdrConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_cra_constraint_flag");                     cinfo->setNoCraConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_gdr_constraint_flag");                     cinfo->setNoGdrConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_aps_constraint_flag");                     cinfo->setNoApsConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_idr_rpl_constraint_flag");                 cinfo->setNoIdrRplConstraintFlag(symbol > 0 ? true : false);
+
+    /* tile, slice, subpicture partitioning */
+    xReadFlag(symbol, "gci_one_tile_per_pic_constraint_flag");           cinfo->setOneTilePerPicConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_pic_header_in_slice_header_constraint_flag"); cinfo->setPicHeaderInSliceHeaderConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_one_slice_per_pic_constraint_flag");          cinfo->setOneSlicePerPicConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_rectangular_slice_constraint_flag");       cinfo->setNoRectSliceConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_one_slice_per_subpic_constraint_flag");       cinfo->setOneSlicePerSubpicConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_subpic_info_constraint_flag");             cinfo->setNoSubpicInfoConstraintFlag(symbol > 0 ? true : false);
+
+    /* CTU and block partitioning */
+    xReadCode(2, symbol, "gci_three_minus_max_log2_ctu_size_constraint_idc");   cinfo->setMaxLog2CtuSizeConstraintIdc(((3 - symbol) + 5));
+    xReadFlag(symbol, "gci_no_partition_constraints_override_constraint_flag"); cinfo->setNoPartitionConstraintsOverrideConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_mtt_constraint_flag");                            cinfo->setNoMttConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_qtbtt_dual_tree_intra_constraint_flag");          cinfo->setNoQtbttDualTreeIntraConstraintFlag(symbol > 0 ? true : false);
+
+    /* intra */
+    xReadFlag(symbol, "gci_no_palette_constraint_flag");                 cinfo->setNoPaletteConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_ibc_constraint_flag");                     cinfo->setNoIbcConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_isp_constraint_flag");                     cinfo->setNoIspConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_mrl_constraint_flag");                     cinfo->setNoMrlConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_mip_constraint_flag");                     cinfo->setNoMipConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_cclm_constraint_flag");                    cinfo->setNoCclmConstraintFlag(symbol > 0 ? true : false);
+
+    /* inter */
+    xReadFlag(symbol, "gci_no_ref_pic_resampling_constraint_flag");      cinfo->setNoRprConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_res_change_in_clvs_constraint_flag");      cinfo->setNoResChangeInClvsConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_weighted_prediction_constraint_flag");     cinfo->setNoWeightedPredictionConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_ref_wraparound_constraint_flag");          cinfo->setNoRefWraparoundConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_temporal_mvp_constraint_flag");            cinfo->setNoTemporalMvpConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_sbtmvp_constraint_flag");                  cinfo->setNoSbtmvpConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_amvr_constraint_flag");                    cinfo->setNoAmvrConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_bdof_constraint_flag");                    cinfo->setNoBdofConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_smvd_constraint_flag");                    cinfo->setNoSmvdConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_dmvr_constraint_flag");                    cinfo->setNoDmvrConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_mmvd_constraint_flag");                    cinfo->setNoMmvdConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_affine_motion_constraint_flag");           cinfo->setNoAffineMotionConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_prof_constraint_flag");                    cinfo->setNoProfConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_bcw_constraint_flag");                     cinfo->setNoBcwConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_ciip_constraint_flag");                    cinfo->setNoCiipConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_gpm_constraint_flag");                     cinfo->setNoGeoConstraintFlag(symbol > 0 ? true : false);
+
+    /* transform, quantization, residual */
+    xReadFlag(symbol, "gci_no_luma_transform_size_64_constraint_flag");  cinfo->setNoLumaTransformSize64ConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_transform_skip_constraint_flag");          cinfo->setNoTransformSkipConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_bdpcm_constraint_flag");                   cinfo->setNoBDPCMConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_mts_constraint_flag");                     cinfo->setNoMtsConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_lfnst_constraint_flag");                   cinfo->setNoLfnstConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_joint_cbcr_constraint_flag");              cinfo->setNoJointCbCrConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_sbt_constraint_flag");                     cinfo->setNoSbtConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_act_constraint_flag");                     cinfo->setNoActConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_explicit_scaling_list_constraint_flag");   cinfo->setNoExplicitScaleListConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_dep_quant_constraint_flag");               cinfo->setNoDepQuantConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_sign_data_hiding_constraint_flag");        cinfo->setNoSignDataHidingConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_cu_qp_delta_constraint_flag");             cinfo->setNoCuQpDeltaConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_chroma_qp_offset_constraint_flag");        cinfo->setNoChromaQpOffsetConstraintFlag(symbol > 0 ? true : false);
+
+    /* loop filter */
+    xReadFlag(symbol, "gci_no_sao_constraint_flag");                     cinfo->setNoSaoConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_alf_constraint_flag");                     cinfo->setNoAlfConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_ccalf_constraint_flag");                   cinfo->setNoCCAlfConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_lmcs_constraint_flag");                    cinfo->setNoLmcsConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_ladf_constraint_flag");                    cinfo->setNoLadfConstraintFlag(symbol > 0 ? true : false);
+    xReadFlag(symbol, "gci_no_virtual_boundaries_constraint_flag");      cinfo->setNoVirtualBoundaryConstraintFlag(symbol > 0 ? true : false);
+    xReadCode(8, symbol, "gci_num_additional_bits");
+    uint32_t const numAdditionalBits = symbol;
+    int numAdditionalBitsUsed;
+    if (numAdditionalBits > 5)
+    {
+      xReadFlag(symbol, "gci_all_rap_pictures_flag");                    cinfo->setAllRapPicturesFlag(symbol > 0 ? true : false);
+      xReadFlag(symbol, "gci_no_extended_precision_processing_constraint_flag");  cinfo->setNoExtendedPrecisionProcessingConstraintFlag(symbol > 0 ? true : false);
+      xReadFlag(symbol, "gci_no_ts_residual_coding_rice_constraint_flag");        cinfo->setNoTsResidualCodingRiceConstraintFlag(symbol > 0 ? true : false);
+      xReadFlag(symbol, "gci_no_rrc_rice_extension_constraint_flag");             cinfo->setNoRrcRiceExtensionConstraintFlag(symbol > 0 ? true : false);
+      xReadFlag(symbol, "gci_no_persistent_rice_adaptation_constraint_flag");     cinfo->setNoPersistentRiceAdaptationConstraintFlag(symbol > 0 ? true : false);
+      xReadFlag(symbol, "gci_no_reverse_last_sig_coeff_constraint_flag");         cinfo->setNoReverseLastSigCoeffConstraintFlag(symbol > 0 ? true : false);
+      numAdditionalBitsUsed = 6;
+    }
+    else if (numAdditionalBits > 0)
+    {
+      msg(ERROR, "Invalid bitstream: gci_num_additional_bits set to value %d (must be 0 or >= 6)\n", numAdditionalBits);
+      numAdditionalBitsUsed = 0;
+    }
+    else
+    {
+      numAdditionalBitsUsed = 0;
+    }
+    for (int i = 0; i < numAdditionalBits - numAdditionalBitsUsed; i++)
+    {
+      xReadFlag(symbol, "gci_reserved_bit");
+    }
+  }
+  while (!isByteAligned())
+  {
+    xReadFlag(symbol, "gci_alignment_zero_bit");                     CHECK(symbol != 0, "gci_alignment_zero_bit not equal to zero");
+  }
+}
+
+
+void HLSyntaxReader::parseProfileTierLevel(ProfileTierLevel *ptl, bool profileTierPresentFlag, int maxNumSubLayersMinus1)
+{
+  uint32_t symbol;
+  if(profileTierPresentFlag)
+  {
+    xReadCode(7 , symbol,   "general_profile_idc"              ); ptl->setProfileIdc  (Profile::Name(symbol));
+    xReadFlag(    symbol,   "general_tier_flag"                ); ptl->setTierFlag    (symbol ? Level::HIGH : Level::MAIN);
+  }
+
+  xReadCode( 8, symbol, "general_level_idc" ); ptl->setLevelIdc( Level::Name( symbol ) );
+  CHECK(ptl->getProfileIdc() != Profile::NONE && ptl->getLevelIdc() < Level::LEVEL4 && ptl->getTierFlag() == Level::HIGH,
+        "High tier not defined for levels below 4");
+
+  xReadFlag(      symbol,   "ptl_frame_only_constraint_flag"   ); ptl->setFrameOnlyConstraintFlag(symbol);
+  xReadFlag(      symbol,   "ptl_multilayer_enabled_flag"      ); ptl->setMultiLayerEnabledFlag(symbol);
+  CHECK((ptl->getProfileIdc() == Profile::MAIN_10 || ptl->getProfileIdc() == Profile::MAIN_10_444
+         || ptl->getProfileIdc() == Profile::MAIN_10_STILL_PICTURE
+         || ptl->getProfileIdc() == Profile::MAIN_10_444_STILL_PICTURE)
+          && symbol,
+        "ptl_multilayer_enabled_flag shall be equal to 0 for non-multilayer profiles");
+
+  if(profileTierPresentFlag)
+  {
+    parseConstraintInfo(ptl->getConstraintInfo(), ptl);
+  }
+
+  for (int i = maxNumSubLayersMinus1 - 1; i >= 0; i--)
+  {
+    xReadFlag( symbol, "sub_layer_level_present_flag[i]"   ); ptl->setSubLayerLevelPresentFlag  (i, symbol);
+  }
+
+  while (!isByteAligned())
+  {
+    xReadFlag(    symbol,   "ptl_reserved_zero_bit"         ); CHECK (symbol != 0, "ptl_reserved_zero_bit not equal to zero");
+  }
+
+  for (int i = maxNumSubLayersMinus1 - 1; i >= 0; i--)
+  {
+    if (ptl->getSubLayerLevelPresentFlag(i))
+    {
+      xReadCode(8 , symbol,   "sub_layer_level_idc"                ); ptl->setSubLayerLevelIdc    (i, Level::Name(symbol));
+    }
+  }
+  ptl->setSubLayerLevelIdc(maxNumSubLayersMinus1, ptl->getLevelIdc());
+  for( int i = maxNumSubLayersMinus1 - 1; i >= 0; i-- )
+  {
+    if( !ptl->getSubLayerLevelPresentFlag( i ) )
+    {
+      ptl->setSubLayerLevelIdc( i, ptl->getSubLayerLevelIdc( i + 1 ) );
+    }
+  }
+
+  if (profileTierPresentFlag)
+  {
+    xReadCode(8, symbol, "ptl_num_sub_profiles");
+    uint8_t numSubProfiles = symbol;
+    ptl->setNumSubProfile(numSubProfiles);
+    for (int i = 0; i < numSubProfiles; i++)
+    {
+      xReadCode(32, symbol, "general_sub_profile_idc[i]");
+      ptl->setSubProfileIdc(i, symbol);
+    }
+  }
+}
+
+
+
+void HLSyntaxReader::parseTerminatingBit( uint32_t& ruiBit )
+{
+  ruiBit = false;
+  int iBitsLeft = m_pcBitstream->getNumBitsLeft();
+  if(iBitsLeft <= 8)
+  {
+    uint32_t uiPeekValue = m_pcBitstream->peekBits(iBitsLeft);
+    if (uiPeekValue == (1<<(iBitsLeft-1)))
+    {
+      ruiBit = true;
+    }
+  }
+}
+
+void HLSyntaxReader::parseRemainingBytes( bool noTrailingBytesExpected )
+{
+  if (noTrailingBytesExpected)
+  {
+    CHECK( 0 != m_pcBitstream->getNumBitsLeft(), "Bits left although no bits expected" );
+  }
+  else
+  {
+    while (m_pcBitstream->getNumBitsLeft())
+    {
+      uint32_t trailingNullByte=m_pcBitstream->readByte();
+      if (trailingNullByte!=0)
+      {
+        msg( ERROR, "Trailing byte should be 0, but has value %02x\n", trailingNullByte);
+        THROW("Invalid trailing '0' byte");
+      }
+    }
+  }
+}
+
+
+
+
+// ====================================================================================================================
+// Protected member functions
+// ====================================================================================================================
+
+//! parse explicit wp tables
+void HLSyntaxReader::parsePredWeightTable( Slice* pcSlice, const SPS *sps )
+{
+  const ChromaFormat chFmt        = sps->getChromaFormatIdc();
+  const int          numValidComp = int(getNumberValidComponents(chFmt));
+  const bool         hasChroma    = isChromaEnabled(chFmt);
+
+  uint32_t log2WeightDenomLuma       = 0;
+  uint32_t log2WeightDenomChroma     = 0;
+  uint32_t totalSignalledWeightFlags = 0;
+
+  int deltaDenom;
+  // decode delta_luma_log2_weight_denom :
+  xReadUvlc(log2WeightDenomLuma, "luma_log2_weight_denom");
+  CHECK(log2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7");
+  if (hasChroma)
+  {
+    xReadSvlc(deltaDenom, "delta_chroma_log2_weight_denom");
+    CHECK((deltaDenom + (int) log2WeightDenomLuma) < 0,
+          "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    CHECK((deltaDenom + (int) log2WeightDenomLuma) > 7,
+          "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+    log2WeightDenomChroma = (uint32_t) (deltaDenom + log2WeightDenomLuma);
+  }
+
+  for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+  {
+    const bool l0 = l == REF_PIC_LIST_0;
+
+    if (!l0 && !pcSlice->isInterB())
+    {
+      continue;
+    }
+
+    for (int refIdx = 0; refIdx < pcSlice->getNumRefIdx(l); refIdx++)
+    {
+      WPScalingParam *wp = pcSlice->getWpScaling(l, refIdx);
+
+      wp[COMPONENT_Y].log2WeightDenom = log2WeightDenomLuma;
+      for(int j=1; j<numValidComp; j++)
+      {
+        wp[j].log2WeightDenom = log2WeightDenomChroma;
+      }
+
+      uint32_t  uiCode;
+      xReadFlag(uiCode, (l0 ? "luma_weight_l0_flag[i]" : "luma_weight_l1_flag[i]"));
+      wp[COMPONENT_Y].presentFlag = uiCode != 0;
+      totalSignalledWeightFlags += wp[COMPONENT_Y].presentFlag ? 1 : 0;
+    }
+    if (hasChroma)
+    {
+      for (int refIdx = 0; refIdx < pcSlice->getNumRefIdx(l); refIdx++)
+      {
+        WPScalingParam *wp = pcSlice->getWpScaling(l, refIdx);
+        uint32_t        uiCode;
+        xReadFlag(uiCode, (l0 ? "chroma_weight_l0_flag[i]" : "chroma_weight_l1_flag[i]"));
+        for(int j=1; j<numValidComp; j++)
+        {
+          wp[j].presentFlag = uiCode != 0;
+          totalSignalledWeightFlags += wp[COMPONENT_Cb].presentFlag ? 1 : 0;
+        }
+      }
+    }
+    else
+    {
+      for (int refIdx = 0; refIdx < MAX_NUM_REF; refIdx++)
+      {
+        WPScalingParam *wp = pcSlice->getWpScaling(l, refIdx);
+
+        wp[COMPONENT_Cb].presentFlag = false;
+        wp[COMPONENT_Cr].presentFlag = false;
+      }
+    }
+    for (int refIdx = 0; refIdx < pcSlice->getNumRefIdx(l); refIdx++)
+    {
+      WPScalingParam *wp = pcSlice->getWpScaling(l, refIdx);
+      if (wp[COMPONENT_Y].presentFlag)
+      {
+        int deltaWeight;
+        xReadSvlc(deltaWeight, (l0 ? "delta_luma_weight_l0[i]" : "delta_luma_weight_l1[i]"));
+        CHECK(deltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127");
+        CHECK(deltaWeight > 127, "delta_luma_weight_lx shall be in the rage of -128 to 127");
+        wp[COMPONENT_Y].codedWeight = (deltaWeight + (1 << wp[COMPONENT_Y].log2WeightDenom));
+        xReadSvlc(wp[COMPONENT_Y].codedOffset, (l0 ? "luma_offset_l0[i]" : "luma_offset_l1[i]"));
+        const int range = sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag()
+                            ? (1 << sps->getBitDepth(ChannelType::LUMA)) / 2
+                            : 128;
+        CHECK(wp[COMPONENT_Y].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK(wp[COMPONENT_Y].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
+      }
+      else
+      {
+        wp[COMPONENT_Y].codedWeight = 1 << wp[COMPONENT_Y].log2WeightDenom;
+        wp[COMPONENT_Y].codedOffset = 0;
+      }
+      if (hasChroma)
+      {
+        if (wp[COMPONENT_Cb].presentFlag)
+        {
+          int range = sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag()
+                        ? (1 << sps->getBitDepth(ChannelType::CHROMA)) / 2
+                        : 128;
+          for ( int j=1 ; j<numValidComp ; j++ )
+          {
+            int deltaWeight;
+            xReadSvlc(deltaWeight, (l0 ? "delta_chroma_weight_l0[i]" : "delta_chroma_weight_l1[i]"));
+            CHECK(deltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127");
+            CHECK(deltaWeight > 127, "delta_chroma_weight_lx shall be in the rage of -128 to 127");
+            wp[j].codedWeight = (deltaWeight + (1 << wp[j].log2WeightDenom));
+
+            int deltaChroma;
+            xReadSvlc(deltaChroma, (l0 ? "delta_chroma_offset_l0[i]" : "delta_chroma_offset_l1[i]"));
+            CHECK(deltaChroma < -4 * range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127");
+            CHECK(deltaChroma > 4 * (range - 1), "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127");
+            int pred          = (range - ((range * wp[j].codedWeight) >> (wp[j].log2WeightDenom)));
+            wp[j].codedOffset = Clip3(-range, range - 1, (deltaChroma + pred));
+          }
+        }
+        else
+        {
+          for ( int j=1 ; j<numValidComp ; j++ )
+          {
+            wp[j].codedWeight = 1 << wp[j].log2WeightDenom;
+            wp[j].codedOffset = 0;
+          }
+        }
+      }
+    }
+
+    for (int refIdx = pcSlice->getNumRefIdx(l); refIdx < MAX_NUM_REF; refIdx++)
+    {
+      WPScalingParam *wp = pcSlice->getWpScaling(l, refIdx);
+
+      wp[COMPONENT_Y].presentFlag  = false;
+      wp[COMPONENT_Cb].presentFlag = false;
+      wp[COMPONENT_Cr].presentFlag = false;
+    }
+  }
+  CHECK(totalSignalledWeightFlags > 24, "Too many weight flag signalled");
+}
+
+void HLSyntaxReader::parsePredWeightTable(PicHeader *picHeader, const PPS *pps, const SPS *sps)
+{
+  const ChromaFormat chFmt        = sps->getChromaFormatIdc();
+  const int          numValidComp = getNumberValidComponents(chFmt);
+  const bool         chroma       = isChromaEnabled(chFmt);
+
+  uint32_t log2WeightDenomLuma       = 0;
+  uint32_t log2WeightDenomChroma     = 0;
+  uint32_t totalSignalledWeightFlags = 0;
+  xReadUvlc(log2WeightDenomLuma, "luma_log2_weight_denom");
+  CHECK(log2WeightDenomLuma > 7, "The value of luma_log2_weight_denom shall be in the range of 0 to 7");
+  if (chroma)
+  {
+    int deltaDenom;
+    xReadSvlc(deltaDenom, "delta_chroma_log2_weight_denom");
+    log2WeightDenomChroma = deltaDenom + log2WeightDenomLuma;
+    CHECK(log2WeightDenomChroma > 7,
+          "luma_log2_weight_denom + delta_chroma_log2_weight_denom shall be in the range of 0 to 7");
+  }
+
+  for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+  {
+    const bool l0 = l == REF_PIC_LIST_0;
+
+    WPScalingParam *wp;
+
+    uint32_t numLxWeights = 0;
+    if (l0 || (pps->getWPBiPred() && picHeader->getRpl(l)->getNumRefEntries() > 0))
+    {
+      xReadUvlc(numLxWeights, (l0 ? "num_l0_weights" : "num_l1_weights"));
+    }
+    picHeader->setNumWeights(l, numLxWeights);
+
+    for (int refIdx = 0; refIdx < numLxWeights; refIdx++)
+    {
+      wp = picHeader->getWpScaling(l, refIdx);
+
+      wp[COMPONENT_Y].log2WeightDenom = log2WeightDenomLuma;
+      for (int j = 1; j < numValidComp; j++)
+      {
+        wp[j].log2WeightDenom = log2WeightDenomChroma;
+      }
+
+      uint32_t uiCode;
+      xReadFlag(uiCode, (l0 ? "luma_weight_l0_flag[i]" : "luma_weight_l1_flag[i]"));
+      wp[COMPONENT_Y].presentFlag = uiCode != 0;
+      totalSignalledWeightFlags += wp[COMPONENT_Y].presentFlag ? 1 : 0;
+    }
+    if (chroma)
+    {
+      uint32_t uiCode;
+      for (int refIdx = 0; refIdx < numLxWeights; refIdx++)
+      {
+        wp = picHeader->getWpScaling(l, refIdx);
+        xReadFlag(uiCode, (l0 ? "chroma_weight_l0_flag[i]" : "chroma_weight_l1_flag[i]"));
+        for (int j = 1; j < numValidComp; j++)
+        {
+          wp[j].presentFlag = uiCode != 0;
+          totalSignalledWeightFlags += wp[COMPONENT_Cb].presentFlag ? 1 : 0;
+        }
+      }
+    }
+    else
+    {
+      for ( int refIdx=0; refIdx<MAX_NUM_REF; refIdx++ )
+      {
+        wp = picHeader->getWpScaling(l, refIdx);
+
+        wp[1].presentFlag = false;
+        wp[2].presentFlag = false;
+      }
+    }
+    for (int refIdx = 0; refIdx < numLxWeights; refIdx++)
+    {
+      wp = picHeader->getWpScaling(l, refIdx);
+      if (wp[COMPONENT_Y].presentFlag)
+      {
+        int deltaWeight;
+        xReadSvlc(deltaWeight, (l0 ? "delta_luma_weight_l0[i]" : "delta_luma_weight_l1[i]"));
+        CHECK(deltaWeight < -128, "delta_luma_weight_lx shall be in the rage of -128 to 127");
+        CHECK(deltaWeight > 127, "delta_luma_weight_lx shall be in the rage of -128 to 127");
+        wp[COMPONENT_Y].codedWeight = (deltaWeight + (1 << wp[COMPONENT_Y].log2WeightDenom));
+        xReadSvlc(wp[COMPONENT_Y].codedOffset, (l0 ? "luma_offset_l0[i]" : "luma_offset_l1[i]"));
+        const int range = sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag()
+                            ? (1 << sps->getBitDepth(ChannelType::LUMA)) / 2
+                            : 128;
+        CHECK(wp[0].codedOffset < -range, "luma_offset_lx shall be in the rage of -128 to 127");
+        CHECK(wp[0].codedOffset >= range, "luma_offset_lx shall be in the rage of -128 to 127");
+      }
+      else
+      {
+        wp[COMPONENT_Y].codedWeight = (1 << wp[COMPONENT_Y].log2WeightDenom);
+        wp[COMPONENT_Y].codedOffset = 0;
+      }
+      if (chroma)
+      {
+        if (wp[COMPONENT_Cb].presentFlag)
+        {
+          int range = sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag()
+                        ? (1 << sps->getBitDepth(ChannelType::CHROMA)) / 2
+                        : 128;
+          for (int j = 1; j < numValidComp; j++)
+          {
+            int deltaWeight;
+            xReadSvlc(deltaWeight, (l0 ? "delta_chroma_weight_l0[i]" : "delta_chroma_weight_l1[i]"));
+            CHECK( deltaWeight < -128, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            CHECK( deltaWeight >  127, "delta_chroma_weight_lx shall be in the rage of -128 to 127" );
+            wp[j].codedWeight = (deltaWeight + (1 << wp[j].log2WeightDenom));
+
+            int deltaChroma;
+            xReadSvlc(deltaChroma, (l0 ? "delta_chroma_offset_l0[i]" : "delta_chroma_offset_l1[i]"));
+            CHECK( deltaChroma <  -4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            CHECK( deltaChroma >=  4*range, "delta_chroma_offset_lx shall be in the range of -4 * 128 to 4 * 127" );
+            int pred          = (range - ((range * wp[j].codedWeight) >> (wp[j].log2WeightDenom)));
+            wp[j].codedOffset = Clip3(-range, range - 1, (deltaChroma + pred));
+          }
+        }
+        else
+        {
+          for (int j = 1; j < numValidComp; j++)
+          {
+            wp[j].codedWeight = (1 << wp[j].log2WeightDenom);
+            wp[j].codedOffset = 0;
+          }
+        }
+      }
+    }
+
+    for (int refIdx = numLxWeights; refIdx < MAX_NUM_REF; refIdx++)
+    {
+      wp = picHeader->getWpScaling(l, refIdx);
+
+      wp[COMPONENT_Y].presentFlag  = false;
+      wp[COMPONENT_Cb].presentFlag = false;
+      wp[COMPONENT_Cr].presentFlag = false;
+    }
+  }
+  CHECK(totalSignalledWeightFlags > 24, "Too many weight flag signalled");
+}
+
+/** decode quantization matrix
+* \param scalingList quantization matrix information
+*/
+void HLSyntaxReader::parseScalingList(ScalingList *scalingList, bool aps_chromaPrsentFlag)
+{
+  uint32_t  code;
+  bool scalingListCopyModeFlag;
+  scalingList->setChromaScalingListPresentFlag(aps_chromaPrsentFlag);
+  for (int scalingListId = 0; scalingListId < 28; scalingListId++)
+  {
+    if (aps_chromaPrsentFlag || scalingList->isLumaScalingList(scalingListId))
+    {
+      xReadFlag(code, "scaling_list_copy_mode_flag");
+      scalingListCopyModeFlag = (code) ? true : false;
+      scalingList->setScalingListCopyModeFlag(scalingListId, scalingListCopyModeFlag);
+
+      scalingList->setScalingListPreditorModeFlag(scalingListId, false);
+      if (!scalingListCopyModeFlag)
+      {
+        xReadFlag(code, "scaling_list_predictor_mode_flag");
+        scalingList->setScalingListPreditorModeFlag(scalingListId, code);
+      }
+
+      if ((scalingListCopyModeFlag || scalingList->getScalingListPreditorModeFlag(scalingListId))
+          && scalingListId != SCALING_LIST_1D_START_2x2 && scalingListId != SCALING_LIST_1D_START_4x4
+          && scalingListId != SCALING_LIST_1D_START_8x8)   // Copy Mode
+      {
+        xReadUvlc(code, "scaling_list_pred_matrix_id_delta");
+        scalingList->setRefMatrixId(scalingListId, (uint32_t) ((int) (scalingListId) - (code)));
+      }
+      else if (scalingListCopyModeFlag || scalingList->getScalingListPreditorModeFlag(scalingListId))
+      {
+        scalingList->setRefMatrixId(scalingListId, (uint32_t) ((int) (scalingListId)));
+      }
+      if (scalingListCopyModeFlag)   // copy
+      {
+        if (scalingListId >= SCALING_LIST_1D_START_16x16)
+        {
+          scalingList->setScalingListDC(
+            scalingListId, ((scalingListId == scalingList->getRefMatrixId(scalingListId)) ? 16
+                            : (scalingList->getRefMatrixId(scalingListId) < SCALING_LIST_1D_START_16x16)
+                              ? scalingList->getScalingListAddress(scalingList->getRefMatrixId(scalingListId))[0]
+                              : scalingList->getScalingListDC(scalingList->getRefMatrixId(scalingListId))));
+        }
+        scalingList->processRefMatrix(scalingListId, scalingList->getRefMatrixId(scalingListId));
+      }
+      else
+      {
+        decodeScalingList(scalingList, scalingListId, scalingList->getScalingListPreditorModeFlag(scalingListId));
+      }
+    }
+    else
+    {
+      scalingListCopyModeFlag = true;
+      scalingList->setScalingListCopyModeFlag(scalingListId, scalingListCopyModeFlag);
+      scalingList->setRefMatrixId(scalingListId, (uint32_t)((int)(scalingListId)));
+      if (scalingListId >= SCALING_LIST_1D_START_16x16)
+      {
+        scalingList->setScalingListDC(scalingListId, 16);
+      }
+      scalingList->processRefMatrix(scalingListId, scalingList->getRefMatrixId(scalingListId));
+    }
+  }
+
+  return;
+}
+
+/** decode DPCM
+* \param scalingList  quantization matrix information
+* \param sizeId size index
+* \param listId list index
+*/
+void HLSyntaxReader::decodeScalingList(ScalingList *scalingList, uint32_t scalingListId, bool isPredictor)
+{
+  int matrixSize = (scalingListId < SCALING_LIST_1D_START_4x4) ? 2 : (scalingListId < SCALING_LIST_1D_START_8x8) ? 4 : 8;
+  int i, coefNum = matrixSize * matrixSize;
+  int data;
+  int scalingListDcCoefMinus8 = 0;
+  int nextCoef = (isPredictor) ? 0 : SCALING_LIST_START_VALUE;
+  ScanElement *scan = g_scanOrder[SCAN_UNGROUPED][CoeffScanType::DIAG][gp_sizeIdxInfo->idxFrom(matrixSize)][gp_sizeIdxInfo->idxFrom(matrixSize)];
+  int *dst = scalingList->getScalingListAddress(scalingListId);
+
+  int PredListId = scalingList->getRefMatrixId(scalingListId);
+  CHECK(isPredictor && PredListId > scalingListId, "Scaling List error predictor!");
+  const int *srcPred = (isPredictor)
+                         ? ((scalingListId == PredListId) ? scalingList->getScalingListDefaultAddress(scalingListId)
+                                                          : scalingList->getScalingListAddress(PredListId))
+                         : nullptr;
+  if(isPredictor && scalingListId == PredListId)
+  {
+    scalingList->setScalingListDC(PredListId, SCALING_LIST_DC);
+  }
+  int predCoef = 0;
+
+  if (scalingListId >= SCALING_LIST_1D_START_16x16)
+  {
+    xReadSvlc(scalingListDcCoefMinus8, "scaling_list_dc_coef_minus8");
+    nextCoef += scalingListDcCoefMinus8;
+    if (isPredictor)
+    {
+      predCoef = (PredListId >= SCALING_LIST_1D_START_16x16) ? scalingList->getScalingListDC(PredListId) : srcPred[0];
+    }
+    scalingList->setScalingListDC(scalingListId, (nextCoef + predCoef + 256) & 255);
+  }
+
+  for(i = 0; i < coefNum; i++)
+  {
+    if (scalingListId >= SCALING_LIST_1D_START_64x64 && scan[i].x >= 4 && scan[i].y >= 4)
+    {
+      dst[scan[i].idx] = 0;
+      continue;
+    }
+    xReadSvlc( data, "scaling_list_delta_coef");
+    nextCoef += data;
+    predCoef = (isPredictor) ? srcPred[scan[i].idx] : 0;
+    dst[scan[i].idx] = (nextCoef + predCoef + 256) & 255;
+  }
+}
+
+bool HLSyntaxReader::xMoreRbspData()
+{
+  int bitsLeft = m_pcBitstream->getNumBitsLeft();
+
+  // if there are more than 8 bits, it cannot be rbsp_trailing_bits
+  if (bitsLeft > 8)
+  {
+    return true;
+  }
+
+  uint8_t lastByte = m_pcBitstream->peekBits(bitsLeft);
+  int cnt = bitsLeft;
+
+  // remove trailing bits equal to zero
+  while ((cnt>0) && ((lastByte & 1) == 0))
+  {
+    lastByte >>= 1;
+    cnt--;
+  }
+  // remove bit equal to one
+  cnt--;
+
+  // we should not have a negative number of bits
+  CHECK (cnt<0, "Negative number of bits");
+
+  // we have more data, if cnt is not zero
+  return (cnt>0);
+}
+
+
+void HLSyntaxReader::alfFilter( AlfParam& alfParam, const bool isChroma, const int altIdx )
+{
+  uint32_t code;
+
+  // derive maxGolombIdx
+  AlfFilterShape alfShape( isChroma ? 5 : 7 );
+  const int numFilters = isChroma ? 1 : alfParam.numLumaFilters;
+  short* coeff = isChroma ? alfParam.chromaCoeff[altIdx] : alfParam.lumaCoeff;
+  Pel*   clipp = isChroma ? alfParam.chromaClipp[altIdx] : alfParam.lumaClipp;
+
+  // Filter coefficients
+  for( int ind = 0; ind < numFilters; ++ind )
+  {
+    for( int i = 0; i < alfShape.numCoeff - 1; i++ )
+    {
+      xReadUvlc( code, isChroma ? "alf_chroma_coeff_abs" : "alf_luma_coeff_abs" );
+      coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ] = code;
+      if( coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ] != 0 )
+      {
+        xReadFlag( code, isChroma ? "alf_chroma_coeff_sign" : "alf_luma_coeff_sign" );
+        coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ] = ( code ) ? -coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ] : coeff[ ind * MAX_NUM_ALF_LUMA_COEFF + i ];
+      }
+      CHECK( isChroma &&
+             ( coeff[ind * MAX_NUM_ALF_LUMA_COEFF + i] > 127 || coeff[ind * MAX_NUM_ALF_LUMA_COEFF + i] < -128 )
+             , "AlfCoeffC shall be in the range of -128 to 127, inclusive" );
+    }
+  }
+
+  // Clipping values coding
+  if (alfParam.nonLinearFlag[isChroma ? ChannelType::CHROMA : ChannelType::LUMA])
+  {
+    // Filter coefficients
+    for( int ind = 0; ind < numFilters; ++ind )
+    {
+      for( int i = 0; i < alfShape.numCoeff - 1; i++ )
+      {
+        xReadCode(2, code, isChroma ? "alf_chroma_clip_idx" : "alf_luma_clip_idx");
+        clipp[ind * MAX_NUM_ALF_LUMA_COEFF + i] = code;
+      }
+    }
+  }
+  else
+  {
+    for( int ind = 0; ind < numFilters; ++ind )
+    {
+      std::fill_n( clipp + ind * MAX_NUM_ALF_LUMA_COEFF, alfShape.numCoeff, 0 );
+    }
+  }
+}
+
+
+//! \}
+
diff --git a/source/Lib/SkipLib/VLCReader.h b/source/Lib/SkipLib/VLCReader.h
new file mode 100644
index 00000000..21c7daf2
--- /dev/null
+++ b/source/Lib/SkipLib/VLCReader.h
@@ -0,0 +1,149 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     VLCWReader.h
+ *  \brief    Reader for high level syntax
+ */
+
+#ifndef __VLCREADER__
+#define __VLCREADER__
+
+#include "CommonLib/Rom.h"
+#include "CommonLib/BitStream.h"
+#include "CommonLib/Slice.h"
+#include "CommonLib/SampleAdaptiveOffset.h"
+#include "CommonLib/ParameterSetManager.h"
+#include "CABACReader.h"
+
+//! \ingroup DecoderLib
+//! \{
+
+// ====================================================================================================================
+// Class definition
+// ====================================================================================================================
+
+class VLCReader
+{
+protected:
+  InputBitstream*   m_pcBitstream;
+
+  VLCReader() : m_pcBitstream(nullptr){};
+  virtual ~VLCReader() {};
+
+  void  xReadCode    ( uint32_t length, uint32_t& val,    const char *symbolName );
+  void  xReadSCode   ( uint32_t length, int& val,         const char *symbolName );
+  void  xReadUvlc    (                  uint32_t& val,    const char *symbolName );
+  void  xReadSvlc    (                  int& val,         const char *symbolName );
+  void  xReadFlag    (                  uint32_t& val,    const char *symbolName );
+  void  xReadString  (                  std::string& val, const char *symbolName );
+
+public:
+  void  setBitstream ( InputBitstream* p )   { m_pcBitstream = p; }
+  InputBitstream* getBitstream() { return m_pcBitstream; }
+
+protected:
+  void xReadRbspTrailingBits();
+  bool isByteAligned() { return (m_pcBitstream->getNumBitsUntilByteAligned() == 0 ); }
+};
+
+class AUDReader: public VLCReader
+{
+public:
+  AUDReader() {};
+  virtual ~AUDReader() {};
+  void parseAccessUnitDelimiter(InputBitstream* bs, uint32_t &audIrapOrGdrAuFlag, uint32_t &picType);
+};
+
+
+
+class FDReader: public VLCReader
+{
+public:
+  FDReader() {};
+  virtual ~FDReader() {};
+  void parseFillerData(InputBitstream* bs, uint32_t &fdSize);
+};
+
+
+
+class HLSyntaxReader : public VLCReader
+{
+public:
+  HLSyntaxReader();
+  virtual ~HLSyntaxReader();
+
+protected:
+  void  copyRefPicList(SPS* pcSPS, ReferencePictureList* source_rpl, ReferencePictureList* dest_rpl);
+  void  parseRefPicList(SPS* pcSPS, ReferencePictureList* rpl, int rplIdx);
+
+public:
+  void  setBitstream        ( InputBitstream* p )   { m_pcBitstream = p; }
+  void  parseOPI            ( OPI* opi );
+  void  parseVPS            ( VPS* pcVPS );
+  void  parseDCI            ( DCI* dci );
+  void  parseSPS            ( SPS* pcSPS );
+  void  parsePPS            ( PPS* pcPPS );
+  void  parseAPS            ( APS* pcAPS );
+  void  parseAlfAps         ( APS* pcAPS );
+  void  parseLmcsAps        ( APS* pcAPS );
+  void  parseScalingListAps ( APS* pcAPS );
+  void  parseVUI            ( VUI* pcVUI, SPS* pcSPS );
+  void  parseConstraintInfo (ConstraintInfo *cinfo, const ProfileTierLevel* ptl );
+  void  parseProfileTierLevel(ProfileTierLevel *ptl, bool profileTierPresentFlag, int maxNumSubLayersMinus1);
+  void  parseOlsHrdParameters(GeneralHrdParams* generalHrd, OlsHrdParams *olsHrd, uint32_t firstSubLayer, uint32_t tempLevelHigh);
+  void parseGeneralHrdParameters(GeneralHrdParams *generalHrd);
+  void  parsePictureHeader  ( PicHeader* picHeader, ParameterSetManager *parameterSetManager, bool readRbspTrailingBits );
+  void  checkAlfNaluTidAndPicTid(Slice* pcSlice, PicHeader* picHeader, ParameterSetManager *parameterSetManager);
+  void  parseSliceHeader    ( Slice* pcSlice, PicHeader* picHeader, ParameterSetManager *parameterSetManager, const int prevTid0POC, const int prevPicPOC );
+  void  getSlicePoc ( Slice* pcSlice, PicHeader* picHeader, ParameterSetManager *parameterSetManager, const int prevTid0POC );
+  void  parseTerminatingBit ( uint32_t& ruiBit );
+  void  parseRemainingBytes ( bool noTrailingBytesExpected );
+
+  void  parsePredWeightTable( Slice* pcSlice, const SPS *sps );
+  void parsePredWeightTable ( PicHeader *picHeader, const PPS *pps, const SPS *sps );
+  void parseScalingList     ( ScalingList *scalingList, bool aps_chromaPresentFlag );
+  void  decodeScalingList   ( ScalingList *scalingList, uint32_t scalingListId, bool isPredictor);
+  void parseReshaper        ( SliceReshapeInfo& sliceReshaperInfo, const SPS* pcSPS, const bool isIntra );
+  void alfFilter( AlfParam& alfParam, const bool isChroma, const int altIdx );
+  void ccAlfFilter( Slice *pcSlice );
+  void dpb_parameters(int maxSubLayersMinus1, bool subLayerInfoFlag, SPS *pcSPS);
+private:
+
+protected:
+  bool  xMoreRbspData();
+};
+
+
+//! \}
+
+#endif
diff --git a/source/Lib/SkipLib/VLCWriter.cpp b/source/Lib/SkipLib/VLCWriter.cpp
new file mode 100644
index 00000000..6369e8ba
--- /dev/null
+++ b/source/Lib/SkipLib/VLCWriter.cpp
@@ -0,0 +1,3173 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     VLCWriter.cpp
+ *  \brief    Writer for high level syntax
+ */
+
+#include "VLCWriter.h"
+#include "SEIwrite.h"
+
+#include "CommonLib/CommonDef.h"
+#include "CommonLib/Unit.h"
+#include "CommonLib/Picture.h" // th remove this
+#include "CommonLib/dtrace_next.h"
+#include "EncAdaptiveLoopFilter.h"
+#include "CommonLib/AdaptiveLoopFilter.h"
+#include "CommonLib/ProfileTierLevel.h"
+
+//! \ingroup EncoderLib
+//! \{
+
+#if ENABLE_TRACING
+bool g_HLSTraceEnable = true;
+#endif
+
+#if ENABLE_TRACING
+void VLCWriter::xWriteSCode( const int value, const uint32_t length, const char *symbolName )
+#else
+void VLCWriter::xWriteSCode( const int value, const uint32_t length, const char* )
+#endif
+{
+  CHECK ( length < 1 || length > 32, "Syntax element length must be in range 1..32" );
+  CHECK (!( length==32 || (value>=-(1<<(length-1)) && value<(1<<(length-1)))), "Invalid syntax element" );
+  m_pcBitIf->write( length==32 ? uint32_t(value) : ( uint32_t(value)&((1<<length)-1) ), length );
+
+#if ENABLE_TRACING
+  if( g_HLSTraceEnable )
+  {
+    if( length<10 )
+    {
+      DTRACE( g_trace_ctx, D_HEADER, "%-50s u(%d)  : %d\n", symbolName, length, value );
+    }
+    else
+    {
+      DTRACE( g_trace_ctx, D_HEADER, "%-50s u(%d) : %d\n", symbolName, length, value );
+    }
+  }
+#endif
+}
+
+#if ENABLE_TRACING
+void VLCWriter::xWriteCode( const uint32_t value, const uint32_t length, const char *symbolName )
+#else
+void VLCWriter::xWriteCode( const uint32_t value, const uint32_t length, const char* )
+#endif
+{
+  CHECK(length == 0, "Code of length '0' not supported");
+  m_pcBitIf->write(value, length);
+
+#if ENABLE_TRACING
+  if( g_HLSTraceEnable )
+  {
+    if( length < 10 )
+    {
+      DTRACE( g_trace_ctx, D_HEADER, "%-50s u(%d)  : %d\n", symbolName, length, value );
+    }
+    else
+    {
+      DTRACE( g_trace_ctx, D_HEADER, "%-50s u(%d) : %d\n", symbolName, length, value );
+    }
+  }
+#endif
+}
+
+// write the VLC code without tracing
+void VLCWriter::xWriteVlc( uint32_t value )
+{
+  uint32_t length   = 1;
+  uint32_t temp     = ++value;
+
+  CHECK(!temp, "Integer overflow");
+  while (1 != temp)
+  {
+    temp >>= 1;
+    length += 2;
+  }
+  // Take care of cases where length > 32
+  m_pcBitIf->write(0, length >> 1);
+  m_pcBitIf->write(value, (length + 1) >> 1);
+}
+
+#if ENABLE_TRACING
+void VLCWriter::xWriteUvlc( const uint32_t value, const char *symbolName )
+#else
+void VLCWriter::xWriteUvlc( const uint32_t value, const char* )
+#endif
+{
+  xWriteVlc(value);
+
+#if ENABLE_TRACING
+  if( g_HLSTraceEnable )
+  {
+    DTRACE( g_trace_ctx, D_HEADER, "%-50s ue(v) : %d\n", symbolName, value );
+  }
+#endif
+}
+
+void  VLCWriter::xWriteSvlc( const int value, const char *symbolName )
+{
+  uint32_t unsigendValue = uint32_t( value <= 0 ? (-value)<<1 : (value<<1)-1);
+  xWriteVlc( unsigendValue );
+
+#if ENABLE_TRACING
+  if( g_HLSTraceEnable )
+  {
+    DTRACE( g_trace_ctx, D_HEADER, "%-50s se(v) : %d\n", symbolName, value );
+  }
+#endif
+}
+
+
+#if ENABLE_TRACING
+void VLCWriter::xWriteFlag( uint32_t value, const char *symbolName )
+#else
+void VLCWriter::xWriteFlag( uint32_t value, const char* )
+#endif
+{
+  m_pcBitIf->write( value, 1 );
+
+#if ENABLE_TRACING
+  if( g_HLSTraceEnable )
+  {
+    DTRACE( g_trace_ctx, D_HEADER, "%-50s u(1)  : %d\n", symbolName, value );
+  }
+#endif
+}
+
+#if ENABLE_TRACING
+void  VLCWriter::xWriteString( const std::string &value, const char *symbolName )
+#else
+void  VLCWriter::xWriteString( const std::string &value, const char* )
+#endif
+{
+  for (int i = 0; i < value.length(); ++i)
+  {
+    m_pcBitIf->write(value[i], 8);
+  }
+  m_pcBitIf->write('\0', 8);
+
+#if ENABLE_TRACING
+  if (g_HLSTraceEnable)
+  {
+    DTRACE(g_trace_ctx, D_HEADER, "%-50s st(v)  : %s\n", symbolName, value.c_str());
+  }
+#endif
+}
+
+void VLCWriter::xWriteRbspTrailingBits()
+{
+  xWriteFlag( 1, "rbsp_stop_one_bit");
+  int cnt = 0;
+  while (m_pcBitIf->getNumBitsUntilByteAligned())
+  {
+    xWriteFlag( 0, "rbsp_alignment_zero_bit");
+    cnt++;
+  }
+  CHECK(cnt>=8, "More than '8' alignment bytes read");
+}
+
+void AUDWriter::codeAUD(OutputBitstream& bs, const bool audIrapOrGdrAuFlag, const int pictureType)
+{
+#if ENABLE_TRACING
+  xTraceAccessUnitDelimiter();
+#endif
+
+  CHECK(pictureType >= 3, "Invalid picture type");
+  setBitstream(&bs);
+  xWriteFlag(audIrapOrGdrAuFlag, "aud_irap_or_gdr_au_flag");
+  xWriteCode(pictureType, 3, "pic_type");
+  xWriteRbspTrailingBits();
+}
+
+void FDWriter::codeFD(OutputBitstream& bs, uint32_t &fdSize)
+{
+#if ENABLE_TRACING
+  xTraceFillerData();
+#endif
+  setBitstream(&bs);
+  uint32_t ffByte = 0xff;
+  while( fdSize )
+  {
+    xWriteCode (ffByte, 8, "ff_byte");
+    fdSize--;
+  }
+  xWriteRbspTrailingBits();
+}
+
+void HLSWriter::xCodeRefPicList( const ReferencePictureList* rpl, bool isLongTermPresent, uint32_t ltLsbBitsCount, const bool isForbiddenZeroDeltaPoc, int rplIdx)
+{
+  uint32_t numRefPic = rpl->getNumRefEntries();
+  xWriteUvlc( numRefPic, "num_ref_entries[ listIdx ][ rplsIdx ]" );
+
+  if (isLongTermPresent && numRefPic > 0 && rplIdx != -1)
+  {
+    xWriteFlag(rpl->getLtrpInSliceHeaderFlag(), "ltrp_in_slice_header_flag[ listIdx ][ rplsIdx ]");
+  }
+  int prevDelta = MAX_INT;
+  int deltaValue = 0;
+  bool firstSTRP = true;
+  for (int ii = 0; ii < numRefPic; ii++)
+  {
+    if( rpl->getInterLayerPresentFlag() )
+    {
+      xWriteFlag( rpl->isInterLayerRefPic( ii ), "inter_layer_ref_pic_flag[ listIdx ][ rplsIdx ][ i ]" );
+
+      if( rpl->isInterLayerRefPic( ii ) )
+      {
+        CHECK( rpl->getInterLayerRefPicIdx( ii ) < 0, "Wrong inter-layer reference index" );
+        xWriteUvlc( rpl->getInterLayerRefPicIdx( ii ), "ilrp_idx[ listIdx ][ rplsIdx ][ i ]" );
+      }
+    }
+
+    if( !rpl->isInterLayerRefPic( ii ) )
+    {
+      if (isLongTermPresent)
+      {
+        xWriteFlag(!rpl->isRefPicLongterm(ii), "st_ref_pic_flag[ listIdx ][ rplsIdx ][ i ]");
+      }
+
+      if (!rpl->isRefPicLongterm(ii))
+      {
+        if (firstSTRP)
+        {
+          firstSTRP  = false;
+          deltaValue = prevDelta = rpl->getRefPicIdentifier(ii);
+        }
+        else
+        {
+          deltaValue = rpl->getRefPicIdentifier(ii) - prevDelta;
+          prevDelta  = rpl->getRefPicIdentifier(ii);
+        }
+        unsigned int absDeltaValue = (deltaValue < 0) ? 0 - deltaValue : deltaValue;
+        if (isForbiddenZeroDeltaPoc || ii == 0)
+        {
+          CHECK(!absDeltaValue, "Zero delta POC is not used without WP or is the 0-th entry");
+          xWriteUvlc(absDeltaValue - 1, "abs_delta_poc_st[ listIdx ][ rplsIdx ][ i ]");
+        }
+        else
+        {
+          xWriteUvlc(absDeltaValue, "abs_delta_poc_st[ listIdx ][ rplsIdx ][ i ]");
+        }
+        if (absDeltaValue > 0)
+        {
+          xWriteFlag(deltaValue < 0 ? 1 : 0, "strp_entry_sign_flag[ listIdx ][ rplsIdx ][ i ]");
+        }
+      }
+      else if (!rpl->getLtrpInSliceHeaderFlag())
+      {
+        xWriteCode(rpl->getRefPicIdentifier(ii), ltLsbBitsCount, "poc_lsb_lt[listIdx][rplsIdx][i]");
+      }
+    }
+  }
+}
+
+void HLSWriter::codePPS( const PPS* pcPPS )
+{
+#if ENABLE_TRACING
+  xTracePPSHeader ();
+#endif
+  xWriteCode( pcPPS->getPPSId(), 6,                          "pps_pic_parameter_set_id" );
+  xWriteCode( pcPPS->getSPSId(), 4,                          "pps_seq_parameter_set_id" );
+
+  xWriteFlag( pcPPS->getMixedNaluTypesInPicFlag() ? 1 : 0,   "pps_mixed_nalu_types_in_pic_flag" );
+
+  xWriteUvlc( pcPPS->getPicWidthInLumaSamples(), "pps_pic_width_in_luma_samples" );
+  xWriteUvlc( pcPPS->getPicHeightInLumaSamples(), "pps_pic_height_in_luma_samples" );
+
+  Window conf = pcPPS->getConformanceWindow();
+  xWriteFlag(pcPPS->getConformanceWindowFlag(), "pps_conformance_window_flag");
+  if (pcPPS->getConformanceWindowFlag())
+  {
+    xWriteUvlc(conf.getWindowLeftOffset(), "pps_conf_win_left_offset");
+    xWriteUvlc(conf.getWindowRightOffset(), "pps_conf_win_right_offset");
+    xWriteUvlc(conf.getWindowTopOffset(), "pps_conf_win_top_offset");
+    xWriteUvlc(conf.getWindowBottomOffset(), "pps_conf_win_bottom_offset");
+  }
+  Window scalingWindow = pcPPS->getScalingWindow();
+  xWriteFlag( pcPPS->getExplicitScalingWindowFlag(), "pps_scaling_window_explicit_signalling_flag");
+  if ( pcPPS->getExplicitScalingWindowFlag() )
+  {
+    xWriteSvlc( scalingWindow.getWindowLeftOffset(), "pps_scaling_win_left_offset" );
+    xWriteSvlc( scalingWindow.getWindowRightOffset(), "pps_scaling_win_right_offset" );
+    xWriteSvlc( scalingWindow.getWindowTopOffset(), "pps_scaling_win_top_offset" );
+    xWriteSvlc( scalingWindow.getWindowBottomOffset(), "pps_scaling_win_bottom_offset" );
+  }
+
+  xWriteFlag( pcPPS->getOutputFlagPresentFlag() ? 1 : 0,     "pps_output_flag_present_flag" );
+  xWriteFlag( pcPPS->getNoPicPartitionFlag() ? 1 : 0, "pps_no_pic_partition_flag" );
+  xWriteFlag( pcPPS->getSubPicIdMappingInPpsFlag() ? 1 : 0, "pps_subpic_id_mapping_present_flag" );
+  if( pcPPS->getSubPicIdMappingInPpsFlag() )
+  {
+    CHECK(pcPPS->getNumSubPics() < 1, "PPS: NumSubPics cannot be less than 1");
+    if( !pcPPS->getNoPicPartitionFlag() )
+    {
+      xWriteUvlc(pcPPS->getNumSubPics() - 1, "pps_num_subpics_minus1");
+    }
+    CHECK(pcPPS->getSubPicIdLen() < 1, "PPS: SubPicIdLen cannot be less than 1");
+    xWriteUvlc( pcPPS->getSubPicIdLen() - 1, "pps_subpic_id_len_minus1" );
+
+    CHECK((1 << pcPPS->getSubPicIdLen()) < pcPPS->getNumSubPics(), "pps_subpic_id_len exceeds valid range");
+    for( int picIdx = 0; picIdx < pcPPS->getNumSubPics( ); picIdx++ )
+    {
+      xWriteCode( pcPPS->getSubPicId(picIdx), pcPPS->getSubPicIdLen( ), "pps_subpic_id[i]" );
+    }
+  }
+  if( !pcPPS->getNoPicPartitionFlag() )
+  {
+    int colIdx, rowIdx;
+
+    // CTU size - required to match size in SPS
+    xWriteCode( pcPPS->getLog2CtuSize() - 5, 2, "pps_log2_ctu_size_minus5" );
+
+    // number of explicit tile columns/rows
+    xWriteUvlc( pcPPS->getNumExpTileColumns() - 1, "pps_num_exp_tile_columns_minus1" );
+    xWriteUvlc( pcPPS->getNumExpTileRows() - 1,    "pps_num_exp_tile_rows_minus1" );
+
+    // tile sizes
+    for( colIdx = 0; colIdx < pcPPS->getNumExpTileColumns(); colIdx++ )
+    {
+      xWriteUvlc( pcPPS->getTileColumnWidth( colIdx ) - 1, "pps_tile_column_width_minus1[i]" );
+    }
+    for( rowIdx = 0; rowIdx < pcPPS->getNumExpTileRows(); rowIdx++ )
+    {
+      xWriteUvlc( pcPPS->getTileRowHeight( rowIdx ) - 1, "pps_tile_row_height_minus1[i]" );
+    }
+
+    // rectangular slice signalling
+    if (pcPPS->getNumTiles() > 1)
+    {
+      xWriteFlag(pcPPS->getLoopFilterAcrossTilesEnabledFlag(), "pps_loop_filter_across_tiles_enabled_flag");
+      xWriteFlag(pcPPS->getRectSliceFlag() ? 1 : 0, "pps_rect_slice_flag");
+    }
+    if (pcPPS->getRectSliceFlag())
+    {
+      xWriteFlag(pcPPS->getSingleSlicePerSubPicFlag( ) ? 1 : 0, "pps_single_slice_per_subpic_flag");
+    }
+    if (pcPPS->getRectSliceFlag() && !(pcPPS->getSingleSlicePerSubPicFlag()))
+    {
+      xWriteUvlc( pcPPS->getNumSlicesInPic( ) - 1, "pps_num_slices_in_pic_minus1" );
+      if ((pcPPS->getNumSlicesInPic() - 1) > 1)
+      {
+        xWriteFlag(pcPPS->getTileIdxDeltaPresentFlag() ? 1 : 0, "pps_tile_idx_delta_present_flag");
+      }
+
+      // write rectangular slice parameters
+      for( int i = 0; i < pcPPS->getNumSlicesInPic()-1; i++ )
+      {
+        // complete tiles within a single slice
+        if( ( pcPPS->getSliceTileIdx( i ) % pcPPS->getNumTileColumns() ) != pcPPS->getNumTileColumns() - 1 )
+        {
+          xWriteUvlc( pcPPS->getSliceWidthInTiles( i ) - 1, "pps_slice_width_in_tiles_minus1[i]" );
+        }
+
+        if( pcPPS->getSliceTileIdx( i ) / pcPPS->getNumTileColumns() != pcPPS->getNumTileRows() - 1 &&
+          ( pcPPS->getTileIdxDeltaPresentFlag() || pcPPS->getSliceTileIdx( i ) % pcPPS->getNumTileColumns() == 0 ) )
+        {
+          xWriteUvlc(pcPPS->getSliceHeightInTiles(i) - 1, "pps_slice_height_in_tiles_minus1[i]");
+        }
+
+        // multiple slices within a single tile special case
+        if( pcPPS->getSliceWidthInTiles(i) == 1 && pcPPS->getSliceHeightInTiles(i) == 1 && pcPPS->getTileRowHeight(pcPPS->getSliceTileIdx(i) / pcPPS->getNumTileColumns()) > 1 )
+        {
+          uint32_t numExpSliceInTile = (pcPPS->getNumSlicesInTile(i) == 1) ? 0 : pcPPS->getNumSlicesInTile(i);
+          if (numExpSliceInTile > 1
+              && pcPPS->getSliceHeightInCtu(i + numExpSliceInTile - 2)
+                   >= pcPPS->getSliceHeightInCtu(i + numExpSliceInTile - 1))
+          {
+            numExpSliceInTile--;
+            while (numExpSliceInTile > 1
+                   && pcPPS->getSliceHeightInCtu(i + numExpSliceInTile - 2)
+                        == pcPPS->getSliceHeightInCtu(i + numExpSliceInTile - 1))
+            {
+              numExpSliceInTile--;
+            }
+          }
+          uint32_t expSliceHeightSum = 0;
+          xWriteUvlc(numExpSliceInTile, "pps_num_exp_slices_in_tile[i]");
+          for( int j = 0; j < numExpSliceInTile; j++ )
+          {
+            xWriteUvlc(pcPPS->getSliceHeightInCtu(i + j) - 1, "pps_exp_slice_height_in_ctus_minus1[i]");
+            expSliceHeightSum += pcPPS->getSliceHeightInCtu(i + j);
+          }
+
+          CHECK( expSliceHeightSum > pcPPS->getTileRowHeight(pcPPS->getSliceTileIdx(i) / pcPPS->getNumTileColumns()), "The sum of expressed slice heights is larger than the height of the tile containing the slices.");
+          i += (pcPPS->getNumSlicesInTile(i) - 1);
+        }
+
+        // tile index offset to start of next slice
+        if( i < pcPPS->getNumSlicesInPic()-1 )
+        {
+          if( pcPPS->getTileIdxDeltaPresentFlag() )
+          {
+            int32_t  tileIdxDelta = pcPPS->getSliceTileIdx( i + 1 ) - pcPPS->getSliceTileIdx( i );
+            xWriteSvlc( tileIdxDelta,  "pps_tile_idx_delta[i]" );
+          }
+        }
+      }
+    }
+
+    if (pcPPS->getRectSliceFlag() == 0 || pcPPS->getSingleSlicePerSubPicFlag() || pcPPS->getNumSlicesInPic() > 1)
+    {
+      xWriteFlag(pcPPS->getLoopFilterAcrossSlicesEnabledFlag(), "pps_loop_filter_across_slices_enabled_flag");
+    }
+  }
+
+  xWriteFlag( pcPPS->getCabacInitPresentFlag() ? 1 : 0,   "pps_cabac_init_present_flag" );
+  xWriteUvlc(pcPPS->getNumRefIdxDefaultActive(REF_PIC_LIST_0) - 1, "pps_num_ref_idx_default_active_minus1[0]");
+  xWriteUvlc(pcPPS->getNumRefIdxDefaultActive(REF_PIC_LIST_1) - 1, "pps_num_ref_idx_default_active_minus1[1]");
+  xWriteFlag( pcPPS->getRpl1IdxPresentFlag() ? 1 : 0,     "pps_rpl1_idx_present_flag");
+  xWriteFlag( pcPPS->getUseWP() ? 1 : 0,  "pps_weighted_pred_flag" );   // Use of Weighting Prediction (P_SLICE)
+  xWriteFlag( pcPPS->getWPBiPred() ? 1 : 0, "pps_weighted_bipred_flag" );  // Use of Weighting Bi-Prediction (B_SLICE)
+  xWriteFlag( pcPPS->getWrapAroundEnabledFlag() ? 1 : 0, "pps_ref_wraparound_enabled_flag" );
+  if( pcPPS->getWrapAroundEnabledFlag() )
+  {
+    xWriteUvlc(pcPPS->getPicWidthMinusWrapAroundOffset(), "pps_pic_width_minus_wraparound_offset");
+  }
+
+  xWriteSvlc( pcPPS->getPicInitQPMinus26(),                  "pps_init_qp_minus26");
+  xWriteFlag( pcPPS->getUseDQP() ? 1 : 0, "pps_cu_qp_delta_enabled_flag" );
+  xWriteFlag(pcPPS->getPPSChromaToolFlag() ? 1 : 0, "pps_chroma_tool_offsets_present_flag");
+  if (pcPPS->getPPSChromaToolFlag())
+  {
+    xWriteSvlc(pcPPS->getQpOffset(COMPONENT_Cb), "pps_cb_qp_offset");
+    xWriteSvlc(pcPPS->getQpOffset(COMPONENT_Cr), "pps_cr_qp_offset");
+    xWriteFlag(pcPPS->getJointCbCrQpOffsetPresentFlag() ? 1 : 0, "pps_joint_cbcr_qp_offset_present_flag");
+    if (pcPPS->getJointCbCrQpOffsetPresentFlag())
+    {
+      xWriteSvlc(pcPPS->getQpOffset(JOINT_CbCr), "pps_joint_cbcr_qp_offset_value");
+    }
+
+    xWriteFlag(pcPPS->getSliceChromaQpFlag() ? 1 : 0, "pps_slice_chroma_qp_offsets_present_flag");
+
+    xWriteFlag(uint32_t(pcPPS->getCuChromaQpOffsetListEnabledFlag()), "pps_cu_chroma_qp_offset_list_enabled_flag");
+    if (pcPPS->getCuChromaQpOffsetListEnabledFlag())
+    {
+      xWriteUvlc(pcPPS->getChromaQpOffsetListLen() - 1, "pps_chroma_qp_offset_list_len_minus1");
+      /* skip zero index */
+      for (int cuChromaQpOffsetIdx = 0; cuChromaQpOffsetIdx < pcPPS->getChromaQpOffsetListLen(); cuChromaQpOffsetIdx++)
+      {
+        xWriteSvlc(pcPPS->getChromaQpOffsetListEntry(cuChromaQpOffsetIdx + 1).u.comp.cbOffset,
+                   "pps_cb_qp_offset_list[i]");
+        xWriteSvlc(pcPPS->getChromaQpOffsetListEntry(cuChromaQpOffsetIdx + 1).u.comp.crOffset,
+                   "pps_cr_qp_offset_list[i]");
+        if (pcPPS->getJointCbCrQpOffsetPresentFlag())
+        {
+          xWriteSvlc(pcPPS->getChromaQpOffsetListEntry(cuChromaQpOffsetIdx + 1).u.comp.jointCbCrOffset,
+                     "pps_joint_cbcr_qp_offset_list[i]");
+        }
+      }
+    }
+  }
+  xWriteFlag( pcPPS->getDeblockingFilterControlPresentFlag()?1 : 0,       "pps_deblocking_filter_control_present_flag");
+  if(pcPPS->getDeblockingFilterControlPresentFlag())
+  {
+    xWriteFlag( pcPPS->getDeblockingFilterOverrideEnabledFlag() ? 1 : 0,  "pps_deblocking_filter_override_enabled_flag" );
+    xWriteFlag( pcPPS->getPPSDeblockingFilterDisabledFlag() ? 1 : 0,      "pps_deblocking_filter_disabled_flag" );
+    if (!pcPPS->getNoPicPartitionFlag() && pcPPS->getDeblockingFilterOverrideEnabledFlag())
+    {
+      xWriteFlag(pcPPS->getDbfInfoInPhFlag() ? 1 : 0, "pps_dbf_info_in_ph_flag");
+    }
+    if(!pcPPS->getPPSDeblockingFilterDisabledFlag())
+    {
+      xWriteSvlc( pcPPS->getDeblockingFilterBetaOffsetDiv2(),             "pps_beta_offset_div2" );
+      xWriteSvlc( pcPPS->getDeblockingFilterTcOffsetDiv2(),               "pps_tc_offset_div2" );
+      if( pcPPS->getPPSChromaToolFlag() )
+      {
+        xWriteSvlc( pcPPS->getDeblockingFilterCbBetaOffsetDiv2(),           "pps_cb_beta_offset_div2" );
+        xWriteSvlc( pcPPS->getDeblockingFilterCbTcOffsetDiv2(),             "pps_cb_tc_offset_div2" );
+        xWriteSvlc( pcPPS->getDeblockingFilterCrBetaOffsetDiv2(),           "pps_cr_beta_offset_div2" );
+        xWriteSvlc( pcPPS->getDeblockingFilterCrTcOffsetDiv2(),             "pps_cr_tc_offset_div2" );
+      }
+    }
+  }
+  if (!pcPPS->getNoPicPartitionFlag())
+  {
+    xWriteFlag(pcPPS->getRplInfoInPhFlag() ? 1 : 0, "pps_rpl_info_in_ph_flag");
+    xWriteFlag(pcPPS->getSaoInfoInPhFlag() ? 1 : 0, "pps_sao_info_in_ph_flag");
+    xWriteFlag(pcPPS->getAlfInfoInPhFlag() ? 1 : 0, "pps_alf_info_in_ph_flag");
+    if ((pcPPS->getUseWP() || pcPPS->getWPBiPred()) && pcPPS->getRplInfoInPhFlag())
+    {
+      xWriteFlag(pcPPS->getWpInfoInPhFlag() ? 1 : 0, "pps_wp_info_in_ph_flag");
+    }
+    xWriteFlag(pcPPS->getQpDeltaInfoInPhFlag() ? 1 : 0, "pps_qp_delta_info_in_ph_flag");
+  }
+
+  xWriteFlag( pcPPS->getPictureHeaderExtensionPresentFlag() ? 1 : 0, "pps_picture_header_extension_present_flag");
+  xWriteFlag( pcPPS->getSliceHeaderExtensionPresentFlag() ? 1 : 0, "pps_slice_header_extension_present_flag");
+
+  xWriteFlag(0, "pps_extension_flag");
+  xWriteRbspTrailingBits();
+}
+
+void HLSWriter::codeAPS( APS* pcAPS )
+{
+#if ENABLE_TRACING
+  xTraceAPSHeader();
+#endif
+
+  xWriteCode((int)pcAPS->getAPSType(), 3, "aps_params_type");
+  xWriteCode(pcAPS->getAPSId(), 5, "adaptation_parameter_set_id");
+  xWriteFlag(pcAPS->chromaPresentFlag, "aps_chroma_present_flag");
+
+  if (pcAPS->getAPSType() == ApsType::ALF)
+  {
+    codeAlfAps(pcAPS);
+  }
+  else if (pcAPS->getAPSType() == ApsType::LMCS)
+  {
+    codeLmcsAps (pcAPS);
+  }
+  else if (pcAPS->getAPSType() == ApsType::SCALING_LIST)
+  {
+    codeScalingListAps( pcAPS );
+  }
+  xWriteFlag(0, "aps_extension_flag");   //Implementation when this flag is equal to 1 should be added when it is needed. Currently in the spec we don't have case when this flag is equal to 1
+  xWriteRbspTrailingBits();
+}
+
+void HLSWriter::codeAlfAps( APS* pcAPS )
+{
+  AlfParam param = pcAPS->getAlfAPSParam();
+
+  xWriteFlag(param.newFilterFlag[ChannelType::LUMA], "alf_luma_new_filter");
+  if (pcAPS->chromaPresentFlag)
+  {
+    xWriteFlag(param.newFilterFlag[ChannelType::CHROMA], "alf_chroma_new_filter");
+  }
+
+  CcAlfFilterParam paramCcAlf = pcAPS->getCcAlfAPSParam();
+  if (pcAPS->chromaPresentFlag)
+  {
+    xWriteFlag(paramCcAlf.newCcAlfFilter[COMPONENT_Cb - 1], "alf_cc_cb_filter_signal_flag");
+    xWriteFlag(paramCcAlf.newCcAlfFilter[COMPONENT_Cr - 1], "alf_cc_cr_filter_signal_flag");
+  }
+
+  if (param.newFilterFlag[ChannelType::LUMA])
+  {
+    xWriteFlag(param.nonLinearFlag[ChannelType::LUMA], "alf_luma_clip");
+
+    xWriteUvlc(param.numLumaFilters - 1, "alf_luma_num_filters_signalled_minus1");
+    if (param.numLumaFilters > 1)
+    {
+      const int length =  ceilLog2( param.numLumaFilters);
+      for (int i = 0; i < MAX_NUM_ALF_CLASSES; i++)
+      {
+        xWriteCode(param.filterCoeffDeltaIdx[i], length, "alf_luma_coeff_delta_idx" );
+      }
+    }
+    alfFilter(param, false, 0);
+  }
+
+  if (param.newFilterFlag[ChannelType::CHROMA])
+  {
+    xWriteFlag(param.nonLinearFlag[ChannelType::CHROMA], "alf_nonlinear_enable_flag_chroma");
+    if constexpr (ALF_MAX_NUM_ALTERNATIVES_CHROMA > 1)
+    {
+      xWriteUvlc( param.numAlternativesChroma - 1, "alf_chroma_num_alts_minus1" );
+    }
+    for( int altIdx=0; altIdx < param.numAlternativesChroma; ++altIdx )
+    {
+      alfFilter(param, true, altIdx);
+    }
+  }
+  for (int ccIdx = 0; ccIdx < 2; ccIdx++)
+  {
+    if (paramCcAlf.newCcAlfFilter[ccIdx])
+    {
+      const int filterCount = paramCcAlf.ccAlfFilterCount[ccIdx];
+      CHECK(filterCount > MAX_NUM_CC_ALF_FILTERS, "CC ALF Filter count is too large");
+      CHECK(filterCount == 0, "CC ALF Filter count is too small");
+
+      if (MAX_NUM_CC_ALF_FILTERS > 1)
+      {
+        xWriteUvlc(filterCount - 1,
+                   ccIdx == 0 ? "alf_cc_cb_filters_signalled_minus1" : "alf_cc_cr_filters_signalled_minus1");
+      }
+
+      for (int filterIdx = 0; filterIdx < filterCount; filterIdx++)
+      {
+        AlfFilterShape alfShape(size_CC_ALF);
+
+        const short *coeff = paramCcAlf.ccAlfCoeff[ccIdx][filterIdx];
+        // Filter coefficients
+        for (int i = 0; i < alfShape.numCoeff - 1; i++)
+        {
+          if (coeff[i] == 0)
+          {
+            xWriteCode(0, CCALF_BITS_PER_COEFF_LEVEL,
+                       ccIdx == 0 ? "alf_cc_cb_mapped_coeff_abs" : "alf_cc_cr_mapped_coeff_abs");
+          }
+          else
+          {
+            xWriteCode(1 + floorLog2(abs(coeff[i])), CCALF_BITS_PER_COEFF_LEVEL,
+                       ccIdx == 0 ? "alf_cc_cb_mapped_coeff_abs" : "alf_cc_cr_mapped_coeff_abs");
+            xWriteFlag(coeff[i] < 0 ? 1 : 0, ccIdx == 0 ? "alf_cc_cb_coeff_sign" : "alf_cc_cr_coeff_sign");
+          }
+        }
+
+        DTRACE(g_trace_ctx, D_SYNTAX, "%s coeff filterIdx %d: ", ccIdx == 0 ? "Cb" : "Cr", filterIdx);
+        for (int i = 0; i < alfShape.numCoeff; i++)
+        {
+          DTRACE(g_trace_ctx, D_SYNTAX, "%d ", coeff[i]);
+        }
+        DTRACE(g_trace_ctx, D_SYNTAX, "\n");
+      }
+    }
+  }
+}
+
+void HLSWriter::codeLmcsAps( APS* pcAPS )
+{
+  SliceReshapeInfo param = pcAPS->getReshaperAPSInfo();
+  xWriteUvlc(param.reshaperModelMinBinIdx, "lmcs_min_bin_idx");
+  xWriteUvlc(PIC_CODE_CW_BINS - 1 - param.reshaperModelMaxBinIdx, "lmcs_delta_max_bin_idx");
+  CHECKD(param.maxNbitsNeededDeltaCW < 1, "maxNbitsNeededDeltaCW must be equal to or greater than 1");
+  xWriteUvlc(param.maxNbitsNeededDeltaCW - 1, "lmcs_delta_cw_prec_minus1");
+
+  for (int i = param.reshaperModelMinBinIdx; i <= param.reshaperModelMaxBinIdx; i++)
+  {
+    int deltaCW = param.reshaperModelBinCWDelta[i];
+    int signCW = (deltaCW < 0) ? 1 : 0;
+    int absCW = (deltaCW < 0) ? (-deltaCW) : deltaCW;
+    xWriteCode(absCW, param.maxNbitsNeededDeltaCW, "lmcs_delta_abs_cw[ i ]");
+    if (absCW > 0)
+    {
+      xWriteFlag(signCW, "lmcs_delta_sign_cw_flag[ i ]");
+    }
+  }
+  int deltaCRS = pcAPS->chromaPresentFlag ? param.chrResScalingOffset : 0;
+  int signCRS = (deltaCRS < 0) ? 1 : 0;
+  int absCRS = (deltaCRS < 0) ? (-deltaCRS) : deltaCRS;
+  if (pcAPS->chromaPresentFlag)
+  {
+    xWriteCode(absCRS, 3, "lmcs_delta_abs_crs");
+  }
+  if (absCRS > 0)
+  {
+    xWriteFlag(signCRS, "lmcs_delta_sign_crs_flag");
+  }
+}
+
+void HLSWriter::codeScalingListAps( APS* pcAPS )
+{
+  ScalingList param = pcAPS->getScalingList();
+  codeScalingList(param, pcAPS->chromaPresentFlag);
+}
+
+void HLSWriter::codeVUI( const VUI *pcVUI, const SPS* pcSPS )
+{
+#if ENABLE_TRACING
+  if( g_HLSTraceEnable )
+  {
+    DTRACE( g_trace_ctx, D_HEADER, "----------- vui_parameters -----------\n");
+  }
+#endif
+
+
+  xWriteFlag(pcVUI->getProgressiveSourceFlag(),   "vui_progressive_source_flag"         );
+  xWriteFlag(pcVUI->getInterlacedSourceFlag(),    "vui_interlaced_source_flag"          );
+  xWriteFlag(pcVUI->getNonPackedFlag(),           "vui_non_packed_constraint_flag");
+  xWriteFlag(pcVUI->getNonProjectedFlag(),        "vui_non_projected_constraint_flag");
+  xWriteFlag(pcVUI->getAspectRatioInfoPresentFlag(),            "vui_aspect_ratio_info_present_flag");
+  if (pcVUI->getAspectRatioInfoPresentFlag())
+  {
+    xWriteFlag(pcVUI->getAspectRatioConstantFlag(),             "vui_aspect_ratio_constant_flag");
+    xWriteCode(pcVUI->getAspectRatioIdc(), 8,                   "vui_aspect_ratio_idc" );
+    if (pcVUI->getAspectRatioIdc() == 255)
+    {
+      xWriteCode(pcVUI->getSarWidth(), 16,                      "vui_sar_width");
+      xWriteCode(pcVUI->getSarHeight(), 16,                     "vui_sar_height");
+    }
+  }
+  xWriteFlag(pcVUI->getOverscanInfoPresentFlag(),               "vui_overscan_info_present_flag");
+  if (pcVUI->getOverscanInfoPresentFlag())
+  {
+    xWriteFlag(pcVUI->getOverscanAppropriateFlag(),             "vui_overscan_appropriate_flag");
+  }
+  xWriteFlag(pcVUI->getColourDescriptionPresentFlag(),        "vui_colour_description_present_flag");
+  if (pcVUI->getColourDescriptionPresentFlag())
+  {
+    xWriteCode(pcVUI->getColourPrimaries(), 8,                "vui_colour_primaries");
+    xWriteCode(pcVUI->getTransferCharacteristics(), 8,        "vui_transfer_characteristics");
+    xWriteCode(pcVUI->getMatrixCoefficients(), 8,             "vui_matrix_coeffs");
+    xWriteFlag(pcVUI->getVideoFullRangeFlag(),                "vui_full_range_flag");
+  }
+  xWriteFlag(pcVUI->getChromaLocInfoPresentFlag(),              "vui_chroma_loc_info_present_flag");
+  if (pcVUI->getChromaLocInfoPresentFlag())
+  {
+    if(pcVUI->getProgressiveSourceFlag() && !pcVUI->getInterlacedSourceFlag())
+    {
+      xWriteUvlc(pcVUI->getChromaSampleLocType(),         "vui_chroma_sample_loc_type");
+    }
+    else
+    {
+      xWriteUvlc(pcVUI->getChromaSampleLocTypeTopField(),         "vui_chroma_sample_loc_type_top_field");
+      xWriteUvlc(pcVUI->getChromaSampleLocTypeBottomField(),      "vui_chroma_sample_loc_type_bottom_field");
+    }
+  }
+  if(!isByteAligned())
+  {
+    xWriteFlag(1, "vui_payload_bit_equal_to_one");
+    while(!isByteAligned())
+    {
+      xWriteFlag(0, "vui_payload_bit_equal_to_zero");
+    }
+  }
+}
+
+void HLSWriter::codeGeneralHrdparameters(const GeneralHrdParams * hrd)
+{
+  xWriteCode(hrd->getNumUnitsInTick(), 32, "num_units_in_tick");
+  xWriteCode(hrd->getTimeScale(), 32, "time_scale");
+  xWriteFlag(hrd->getGeneralNalHrdParametersPresentFlag() ? 1 : 0, "general_nal_hrd_parameters_present_flag");
+  xWriteFlag(hrd->getGeneralVclHrdParametersPresentFlag() ? 1 : 0, "general_vcl_hrd_parameters_present_flag");
+  if( hrd->getGeneralNalHrdParametersPresentFlag() || hrd->getGeneralVclHrdParametersPresentFlag() )
+  {
+    xWriteFlag(hrd->getGeneralSamePicTimingInAllOlsFlag() ? 1 : 0, "general_same_pic_timing_in_all_ols_flag");
+    xWriteFlag(hrd->getGeneralDecodingUnitHrdParamsPresentFlag() ? 1 : 0, "general_decoding_unit_hrd_params_present_flag");
+    if (hrd->getGeneralDecodingUnitHrdParamsPresentFlag())
+    {
+      xWriteCode(hrd->getTickDivisorMinus2(), 8, "tick_divisor_minus2");
+    }
+    xWriteCode(hrd->getBitRateScale(), 4, "bit_rate_scale");
+    xWriteCode(hrd->getCpbSizeScale(), 4, "cpb_size_scale");
+    if (hrd->getGeneralDecodingUnitHrdParamsPresentFlag())
+    {
+      xWriteCode(hrd->getCpbSizeDuScale(), 4, "cpb_size_du_scale");
+    }
+    xWriteUvlc(hrd->getHrdCpbCntMinus1(), "hrd_cpb_cnt_minus1");
+  }
+}
+void HLSWriter::codeOlsHrdParameters(const GeneralHrdParams * generalHrd, const OlsHrdParams *olsHrd, const uint32_t firstSubLayer, const uint32_t maxNumSubLayersMinus1)
+{
+
+  for( int i = firstSubLayer; i <= maxNumSubLayersMinus1; i ++ )
+  {
+    const OlsHrdParams *hrd = &(olsHrd[i]);
+    xWriteFlag(hrd->getFixedPicRateGeneralFlag() ? 1 : 0, "fixed_pic_rate_general_flag");
+
+    if (!hrd->getFixedPicRateGeneralFlag())
+    {
+      xWriteFlag(hrd->getFixedPicRateWithinCvsFlag() ? 1 : 0, "fixed_pic_rate_within_cvs_flag");
+    }
+    if (hrd->getFixedPicRateWithinCvsFlag())
+    {
+      xWriteUvlc(hrd->getElementDurationInTcMinus1(), "elemental_duration_in_tc_minus1");
+    }
+    else if ( (generalHrd->getGeneralNalHrdParametersPresentFlag() || generalHrd->getGeneralVclHrdParametersPresentFlag()) && generalHrd->getHrdCpbCntMinus1() == 0)
+    {
+      xWriteFlag(hrd->getLowDelayHrdFlag() ? 1 : 0, "low_delay_hrd_flag");
+    }
+
+    for( int nalOrVcl = 0; nalOrVcl < 2; nalOrVcl ++ )
+    {
+      if (((nalOrVcl == 0) && (generalHrd->getGeneralNalHrdParametersPresentFlag())) || ((nalOrVcl == 1) && (generalHrd->getGeneralVclHrdParametersPresentFlag())))
+      {
+        for (int j = 0; j <= (generalHrd->getHrdCpbCntMinus1()); j++)
+        {
+          xWriteUvlc(hrd->getBitRateValueMinus1(j, nalOrVcl), "bit_rate_value_minus1");
+          xWriteUvlc(hrd->getCpbSizeValueMinus1(j, nalOrVcl), "cpb_size_value_minus1");
+          if (generalHrd->getGeneralDecodingUnitHrdParamsPresentFlag())
+          {
+            xWriteUvlc(hrd->getDuCpbSizeValueMinus1(j, nalOrVcl), "cpb_size_du_value_minus1");
+            xWriteUvlc(hrd->getDuBitRateValueMinus1(j, nalOrVcl), "bit_rate_du_value_minus1");
+          }
+          xWriteFlag(hrd->getCbrFlag(j, nalOrVcl) ? 1 : 0, "cbr_flag");
+        }
+      }
+    }
+  }
+}
+
+void HLSWriter::dpb_parameters(int maxSubLayersMinus1, bool subLayerInfoFlag, const SPS *pcSPS)
+{
+  for (uint32_t i = (subLayerInfoFlag ? 0 : maxSubLayersMinus1); i <= maxSubLayersMinus1; i++)
+  {
+    CHECK(pcSPS->getMaxDecPicBuffering(i) < 1, "MaxDecPicBuffering must be greater than 0");
+    xWriteUvlc(pcSPS->getMaxDecPicBuffering(i) - 1, "dpb_max_dec_pic_buffering_minus1[i]");
+    xWriteUvlc(pcSPS->getMaxNumReorderPics(i), "dpb_max_num_reorder_pics[i]");
+    xWriteUvlc(pcSPS->getMaxLatencyIncreasePlus1(i), "dpb_max_latency_increase_plus1[i]");
+  }
+}
+
+void HLSWriter::codeSPS( const SPS* pcSPS )
+{
+#if ENABLE_TRACING
+  xTraceSPSHeader ();
+#endif
+  xWriteCode(pcSPS->getSPSId(), 4, "sps_seq_parameter_set_id");
+  xWriteCode( pcSPS->getVPSId(), 4, "sps_video_parameter_set_id" );
+  CHECK(pcSPS->getMaxTLayers() == 0, "Maximum number of temporal sub-layers is '0'");
+
+  xWriteCode(pcSPS->getMaxTLayers() - 1, 3, "sps_max_sub_layers_minus1");
+  xWriteCode(int(pcSPS->getChromaFormatIdc()), 2, "sps_chroma_format_idc");
+  xWriteCode(floorLog2(pcSPS->getCTUSize()) - 5, 2, "sps_log2_ctu_size_minus5");
+  xWriteFlag(pcSPS->getPtlDpbHrdParamsPresentFlag(), "sps_ptl_dpb_hrd_params_present_flag");
+
+  if( !pcSPS->getVPSId() )
+  {
+    CHECK( !pcSPS->getPtlDpbHrdParamsPresentFlag(), "When sps_video_parameter_set_id is equal to 0, the value of sps_ptl_dpb_hrd_params_present_flag shall be equal to 1" );
+  }
+
+  if (pcSPS->getPtlDpbHrdParamsPresentFlag())
+  {
+    codeProfileTierLevel(pcSPS->getProfileTierLevel(), true, pcSPS->getMaxTLayers() - 1);
+  }
+
+  xWriteFlag(pcSPS->getGDREnabledFlag(), "sps_gdr_enabled_flag");
+
+  xWriteFlag(pcSPS->getRprEnabledFlag(), "sps_ref_pic_resampling_enabled_flag");
+  if (pcSPS->getRprEnabledFlag())
+  {
+    xWriteFlag(pcSPS->getResChangeInClvsEnabledFlag(), "sps_res_change_in_clvs_allowed_flag");
+  }
+  CHECK(!pcSPS->getRprEnabledFlag() && pcSPS->getResChangeInClvsEnabledFlag(), "When sps_ref_pic_resampling_enabled_flag is equal to 0, sps_res_change_in_clvs_allowed_flag shall be equal to 0");
+
+  xWriteUvlc( pcSPS->getMaxPicWidthInLumaSamples(), "sps_pic_width_max_in_luma_samples" );
+  xWriteUvlc( pcSPS->getMaxPicHeightInLumaSamples(), "sps_pic_height_max_in_luma_samples" );
+  Window conf = pcSPS->getConformanceWindow();
+  xWriteFlag(conf.getWindowEnabledFlag(), "sps_conformance_window_flag");
+  if (conf.getWindowEnabledFlag())
+  {
+    xWriteUvlc(conf.getWindowLeftOffset(), "sps_conf_win_left_offset");
+    xWriteUvlc(conf.getWindowRightOffset(), "sps_conf_win_right_offset");
+    xWriteUvlc(conf.getWindowTopOffset(), "sps_conf_win_top_offset");
+    xWriteUvlc(conf.getWindowBottomOffset(), "sps_conf_win_bottom_offset");
+  }
+
+
+  xWriteFlag(pcSPS->getSubPicInfoPresentFlag(), "sps_subpic_info_present_flag");
+
+  if (pcSPS->getSubPicInfoPresentFlag())
+  {
+    CHECK(pcSPS->getNumSubPics() < 1, "SPS: NumSubPics cannot be less than 1");
+    xWriteUvlc(pcSPS->getNumSubPics() - 1, "sps_num_subpics_minus1");
+    if( pcSPS->getNumSubPics() > 1 )
+    {
+      xWriteFlag(pcSPS->getIndependentSubPicsFlag(), "sps_independent_subpics_flag");
+      xWriteFlag(pcSPS->getSubPicSameSizeFlag(), "sps_subpic_same_size_flag");
+      uint32_t tmpWidthVal = (pcSPS->getMaxPicWidthInLumaSamples() + pcSPS->getCTUSize() - 1) / pcSPS->getCTUSize();
+      uint32_t tmpHeightVal = (pcSPS->getMaxPicHeightInLumaSamples() + pcSPS->getCTUSize() - 1) / pcSPS->getCTUSize();
+      for (int picIdx = 0; picIdx < pcSPS->getNumSubPics(); picIdx++)
+      {
+        if (!pcSPS->getSubPicSameSizeFlag() || picIdx == 0)
+        {
+          if ((picIdx > 0) && (pcSPS->getMaxPicWidthInLumaSamples() > pcSPS->getCTUSize()))
+          {
+            xWriteCode(pcSPS->getSubPicCtuTopLeftX(picIdx), ceilLog2(tmpWidthVal), "sps_subpic_ctu_top_left_x[ i ]");
+          }
+          if ((picIdx > 0) && (pcSPS->getMaxPicHeightInLumaSamples() > pcSPS->getCTUSize()))
+          {
+            xWriteCode(pcSPS->getSubPicCtuTopLeftY(picIdx), ceilLog2(tmpHeightVal), "sps_subpic_ctu_top_left_y[ i ]");
+          }
+          if (picIdx<pcSPS->getNumSubPics() - 1 && pcSPS->getMaxPicWidthInLumaSamples() > pcSPS->getCTUSize())
+          {
+            xWriteCode(pcSPS->getSubPicWidth(picIdx) - 1, ceilLog2(tmpWidthVal), "sps_subpic_width_minus1[ i ]");
+          }
+          if (picIdx<pcSPS->getNumSubPics() - 1 && pcSPS->getMaxPicHeightInLumaSamples() > pcSPS->getCTUSize())
+          {
+            xWriteCode(pcSPS->getSubPicHeight(picIdx) - 1, ceilLog2(tmpHeightVal), "sps_subpic_height_minus1[ i ]");
+          }
+        }
+        if (!pcSPS->getIndependentSubPicsFlag())
+        {
+          xWriteFlag(pcSPS->getSubPicTreatedAsPicFlag(picIdx), "sps_subpic_treated_as_pic_flag[ i ]");
+          xWriteFlag(pcSPS->getLoopFilterAcrossSubpicEnabledFlag(picIdx), "sps_loop_filter_across_subpic_enabled_flag[ i ]");
+        }
+      }
+    }
+
+    CHECK(pcSPS->getSubPicIdLen() < 1, "SPS: SubPicIdLen cannot be less than 1");
+    xWriteUvlc(pcSPS->getSubPicIdLen() - 1, "sps_subpic_id_len_minus1");
+    xWriteFlag(pcSPS->getSubPicIdMappingExplicitlySignalledFlag(), "sps_subpic_id_mapping_explicitly_signalled_flag");
+    if (pcSPS->getSubPicIdMappingExplicitlySignalledFlag())
+    {
+      xWriteFlag(pcSPS->getSubPicIdMappingPresentFlag(), "sps_subpic_id_mapping_present_flag");
+      if (pcSPS->getSubPicIdMappingPresentFlag())
+      {
+        for (int picIdx = 0; picIdx < pcSPS->getNumSubPics(); picIdx++)
+        {
+          xWriteCode(pcSPS->getSubPicId(picIdx), pcSPS->getSubPicIdLen(), "sps_subpic_id[i]");
+        }
+      }
+    }
+  }
+
+  const Profile::Name profile = pcSPS->getProfileTierLevel()->getProfileIdc();
+  if (profile != Profile::NONE)
+  {
+    CHECK(pcSPS->getBitDepth(ChannelType::LUMA) > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth,
+          "sps_bitdepth_minus8 exceeds range supported by signalled profile");
+  }
+  xWriteUvlc(pcSPS->getBitDepth(ChannelType::LUMA) - 8, "sps_bitdepth_minus8");
+  xWriteFlag( pcSPS->getEntropyCodingSyncEnabledFlag() ? 1 : 0, "sps_entropy_coding_sync_enabled_flag" );
+  xWriteFlag( pcSPS->getEntryPointsPresentFlag() ? 1 : 0, "sps_entry_point_offsets_present_flag" );
+  xWriteCode(pcSPS->getBitsForPOC()-4, 4, "sps_log2_max_pic_order_cnt_lsb_minus4");
+
+  xWriteFlag(pcSPS->getPocMsbCycleFlag() ? 1 : 0, "sps_poc_msb_cycle_flag");
+  if (pcSPS->getPocMsbCycleFlag())
+  {
+    xWriteUvlc(pcSPS->getPocMsbCycleLen() - 1, "sps_poc_msb_cycle_len_minus1");
+  }
+  // extra bits are for future extensions, so these are currently hard coded to not being sent
+  xWriteCode(0, 2, "sps_num_extra_ph_bytes");
+  // for( i = 0; i < (sps_num_extra_ph_bytes * 8 ); i++ )
+  //   sps_extra_ph_bit_present_flag[ i ]
+  xWriteCode(0, 2, "sps_num_extra_sh_bytes");
+  // for( i = 0; i < (sps_num_extra_sh_bytes * 8 ); i++ )
+  //   sps_extra_sh_bit_present_flag[ i ]
+
+  if (pcSPS->getPtlDpbHrdParamsPresentFlag())
+  {
+    if (pcSPS->getMaxTLayers() - 1 > 0)
+    {
+      xWriteFlag(pcSPS->getSubLayerDpbParamsFlag(), "sps_sublayer_dpb_params_flag");
+    }
+    dpb_parameters(pcSPS->getMaxTLayers() - 1, pcSPS->getSubLayerDpbParamsFlag(), pcSPS);
+  }
+  CHECK( pcSPS->getMaxCUWidth() != pcSPS->getMaxCUHeight(),                          "Rectangular CTUs not supported" );
+  xWriteUvlc(pcSPS->getLog2MinCodingBlockSize() - 2, "sps_log2_min_luma_coding_block_size_minus2");
+  xWriteFlag(pcSPS->getSplitConsOverrideEnabledFlag(), "sps_partition_constraints_override_enabled_flag");
+  xWriteUvlc(floorLog2(pcSPS->getMinQTSize(I_SLICE)) - pcSPS->getLog2MinCodingBlockSize(), "sps_log2_diff_min_qt_min_cb_intra_slice_luma");
+  xWriteUvlc(pcSPS->getMaxMTTHierarchyDepthI(), "sps_max_mtt_hierarchy_depth_intra_slice_luma");
+  if (pcSPS->getMaxMTTHierarchyDepthI() != 0)
+  {
+    xWriteUvlc(floorLog2(pcSPS->getMaxBTSizeI()) - floorLog2(pcSPS->getMinQTSize(I_SLICE)), "sps_log2_diff_max_bt_min_qt_intra_slice_luma");
+    xWriteUvlc(floorLog2(pcSPS->getMaxTTSizeI()) - floorLog2(pcSPS->getMinQTSize(I_SLICE)), "sps_log2_diff_max_tt_min_qt_intra_slice_luma");
+  }
+  if (isChromaEnabled(pcSPS->getChromaFormatIdc()))
+  {
+    xWriteFlag(pcSPS->getUseDualITree(), "sps_qtbtt_dual_tree_intra_flag");
+  }
+  if (pcSPS->getUseDualITree())
+  {
+    xWriteUvlc(floorLog2(pcSPS->getMinQTSize(I_SLICE, ChannelType::CHROMA)) - pcSPS->getLog2MinCodingBlockSize(),
+               "sps_log2_diff_min_qt_min_cb_intra_slice_chroma");
+    xWriteUvlc(pcSPS->getMaxMTTHierarchyDepthIChroma(), "sps_max_mtt_hierarchy_depth_intra_slice_chroma");
+    if (pcSPS->getMaxMTTHierarchyDepthIChroma() != 0)
+    {
+      xWriteUvlc(floorLog2(pcSPS->getMaxBTSizeIChroma()) - floorLog2(pcSPS->getMinQTSize(I_SLICE, ChannelType::CHROMA)),
+                 "sps_log2_diff_max_bt_min_qt_intra_slice_chroma");
+      xWriteUvlc(floorLog2(pcSPS->getMaxTTSizeIChroma()) - floorLog2(pcSPS->getMinQTSize(I_SLICE, ChannelType::CHROMA)),
+                 "sps_log2_diff_max_tt_min_qt_intra_slice_chroma");
+    }
+  }
+  xWriteUvlc(floorLog2(pcSPS->getMinQTSize(B_SLICE)) - pcSPS->getLog2MinCodingBlockSize(), "sps_log2_diff_min_qt_min_cb_inter_slice");
+  xWriteUvlc(pcSPS->getMaxMTTHierarchyDepth(), "sps_max_mtt_hierarchy_depth_inter_slice");
+  if (pcSPS->getMaxMTTHierarchyDepth() != 0)
+  {
+    xWriteUvlc(floorLog2(pcSPS->getMaxBTSize()) - floorLog2(pcSPS->getMinQTSize(B_SLICE)), "sps_log2_diff_max_bt_min_qt_inter_slice");
+    xWriteUvlc(floorLog2(pcSPS->getMaxTTSize()) - floorLog2(pcSPS->getMinQTSize(B_SLICE)), "sps_log2_diff_max_tt_min_qt_inter_slice");
+  }
+  if (pcSPS->getCTUSize() > 32)
+  {
+    xWriteFlag( (pcSPS->getLog2MaxTbSize() - 5) ? 1 : 0,                       "sps_max_luma_transform_size_64_flag" );
+  }
+
+  xWriteFlag(pcSPS->getTransformSkipEnabledFlag() ? 1 : 0, "sps_transform_skip_enabled_flag");
+  if (pcSPS->getTransformSkipEnabledFlag())
+  {
+    xWriteUvlc(pcSPS->getLog2MaxTransformSkipBlockSize() - 2, "sps_log2_transform_skip_max_size_minus2");
+    xWriteFlag(pcSPS->getBDPCMEnabledFlag() ? 1 : 0, "sps_bdpcm_enabled_flag");
+  }
+  else
+  {
+    CHECK(pcSPS->getBDPCMEnabledFlag(), "BDPCM cannot be used when transform skip is disabled");
+  }
+  xWriteFlag(pcSPS->getMtsEnabled() ? 1 : 0, "sps_mts_enabled_flag");
+  if (pcSPS->getMtsEnabled())
+  {
+    xWriteFlag(pcSPS->getExplicitMtsIntraEnabled() ? 1 : 0, "sps_explicit_mts_intra_enabled_flag");
+    xWriteFlag(pcSPS->getExplicitMtsInterEnabled() ? 1 : 0, "sps_explicit_mts_inter_enabled_flag");
+  }
+  xWriteFlag(pcSPS->getUseLFNST() ? 1 : 0, "sps_lfnst_enabled_flag");
+
+  if (isChromaEnabled(pcSPS->getChromaFormatIdc()))
+  {
+    xWriteFlag(pcSPS->getJointCbCrEnabledFlag(), "sps_joint_cbcr_enabled_flag");
+    const ChromaQpMappingTable& chromaQpMappingTable = pcSPS->getChromaQpMappingTable();
+    xWriteFlag(chromaQpMappingTable.getSameCQPTableForAllChromaFlag(), "sps_same_qp_table_for_chroma_flag");
+    int numQpTables = chromaQpMappingTable.getSameCQPTableForAllChromaFlag() ? 1 : (pcSPS->getJointCbCrEnabledFlag() ? 3 : 2);
+    CHECK(numQpTables != chromaQpMappingTable.getNumQpTables(), " numQpTables does not match at encoder side ");
+    for (int i = 0; i < numQpTables; i++)
+    {
+      xWriteSvlc(chromaQpMappingTable.getQpTableStartMinus26(i), "sps_qp_table_starts_minus26");
+      xWriteUvlc(chromaQpMappingTable.getNumPtsInCQPTableMinus1(i), "sps_num_points_in_qp_table_minus1");
+
+      for (int j = 0; j <= chromaQpMappingTable.getNumPtsInCQPTableMinus1(i); j++)
+      {
+        xWriteUvlc(chromaQpMappingTable.getDeltaQpInValMinus1(i, j), "sps_delta_qp_in_val_minus1");
+        xWriteUvlc(chromaQpMappingTable.getDeltaQpOutVal(i, j) ^ chromaQpMappingTable.getDeltaQpInValMinus1(i, j),
+                   "sps_delta_qp_diff_val");
+      }
+    }
+  }
+
+  xWriteFlag( pcSPS->getSAOEnabledFlag(),                                            "sps_sao_enabled_flag");
+  xWriteFlag( pcSPS->getALFEnabledFlag(),                                            "sps_alf_enabled_flag" );
+  if (pcSPS->getALFEnabledFlag() && isChromaEnabled(pcSPS->getChromaFormatIdc()))
+  {
+    xWriteFlag( pcSPS->getCCALFEnabledFlag(),                                            "sps_ccalf_enabled_flag" );
+  }
+  xWriteFlag(pcSPS->getUseLmcs() ? 1 : 0, "sps_lmcs_enable_flag");
+  xWriteFlag(pcSPS->getUseWP() ? 1 : 0, "sps_weighted_pred_flag");           // Use of Weighting Prediction (P_SLICE)
+  xWriteFlag(pcSPS->getUseWPBiPred() ? 1 : 0, "sps_weighted_bipred_flag");   // Use of Weighting Bi-Prediction (B_SLICE)
+
+  xWriteFlag(pcSPS->getLongTermRefsPresent() ? 1 : 0, "sps_long_term_ref_pics_flag");
+  if( pcSPS->getVPSId() > 0 )
+  {
+    xWriteFlag( pcSPS->getInterLayerPresentFlag() ? 1 : 0, "sps_inter_layer_prediction_enabled_flag" );
+  }
+  xWriteFlag(pcSPS->getIDRRefParamListPresent() ? 1 : 0, "sps_idr_rpl_present_flag" );
+  xWriteFlag(pcSPS->getRPL1CopyFromRPL0Flag() ? 1 : 0, "sps_rpl1_same_as_rpl0_flag");
+
+  for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+  {
+    if (l == REF_PIC_LIST_1 && pcSPS->getRPL1CopyFromRPL0Flag())
+    {
+      continue;
+    }
+    const RPLList *rplList = pcSPS->getRplList(l);
+    const int      numRpl  = pcSPS->getNumRpl(l);
+    xWriteUvlc(numRpl, l == REF_PIC_LIST_0 ? "sps_num_ref_pic_lists[0]" : "sps_num_ref_pic_lists[1]");
+
+    for (int rplIdx = 0; rplIdx < numRpl; rplIdx++)
+    {
+      const ReferencePictureList *rpl = rplList->getReferencePictureList(rplIdx);
+      xCodeRefPicList(rpl, pcSPS->getLongTermRefsPresent(), pcSPS->getBitsForPOC(),
+                      !pcSPS->getUseWP() && !pcSPS->getUseWPBiPred(), rplIdx);
+    }
+  }
+
+  xWriteFlag( pcSPS->getWrapAroundEnabledFlag() ? 1 : 0,                              "sps_ref_wraparound_enabled_flag" );
+
+  xWriteFlag( pcSPS->getSPSTemporalMVPEnabledFlag()  ? 1 : 0,                        "sps_temporal_mvp_enabled_flag" );
+
+  if ( pcSPS->getSPSTemporalMVPEnabledFlag() )
+  {
+    xWriteFlag(pcSPS->getSbTMVPEnabledFlag() ? 1 : 0, "sps_sbtmvp_enabled_flag");
+  }
+
+  xWriteFlag( pcSPS->getAMVREnabledFlag() ? 1 : 0,                                   "sps_amvr_enabled_flag" );
+
+  xWriteFlag( pcSPS->getBDOFEnabledFlag() ? 1 : 0,                                   "sps_bdof_enabled_flag" );
+  if (pcSPS->getBDOFEnabledFlag())
+  {
+    xWriteFlag(pcSPS->getBdofControlPresentInPhFlag() ? 1 : 0,                        "sps_bdof_control_present_in_ph_flag");
+  }
+  xWriteFlag( pcSPS->getUseSMVD() ? 1 : 0,                                            "sps_smvd_enabled_flag" );
+  xWriteFlag( pcSPS->getUseDMVR() ? 1 : 0,                                            "sps_dmvr_enabled_flag" );
+  if (pcSPS->getUseDMVR())
+  {
+    xWriteFlag(pcSPS->getDmvrControlPresentInPhFlag() ? 1 : 0,                        "sps_dmvr_control_present_in_ph_flag");
+  }
+  xWriteFlag(pcSPS->getUseMMVD() ? 1 : 0,                                             "sps_mmvd_enabled_flag");
+  if (pcSPS->getUseMMVD())
+  {
+    xWriteFlag(pcSPS->getFpelMmvdEnabledFlag() ? 1 : 0,                               "sps_mmvd_fullpel_only_flag");
+  }
+  xWriteUvlc(MRG_MAX_NUM_CANDS - pcSPS->getMaxNumMergeCand(), "sps_six_minus_max_num_merge_cand");
+  xWriteFlag( pcSPS->getUseSBT() ? 1 : 0,                                                      "sps_sbt_enabled_flag");
+  xWriteFlag( pcSPS->getUseAffine() ? 1 : 0,                                                   "sps_affine_enabled_flag" );
+  if ( pcSPS->getUseAffine() )
+  {
+    xWriteUvlc(AFFINE_MRG_MAX_NUM_CANDS - pcSPS->getMaxNumAffineMergeCand(), "sps_five_minus_max_num_subblock_merge_cand");
+    xWriteFlag( pcSPS->getUseAffineType() ? 1 : 0,                                             "sps_affine_type_flag" );
+    if (pcSPS->getAMVREnabledFlag())
+    {
+      xWriteFlag( pcSPS->getAffineAmvrEnabledFlag() ? 1 : 0,                                     "sps_affine_amvr_enabled_flag" );
+    }
+    xWriteFlag( pcSPS->getUsePROF() ? 1 : 0,                                                   "sps_affine_prof_enabled_flag" );
+    if (pcSPS->getUsePROF())
+    {
+      xWriteFlag(pcSPS->getProfControlPresentInPhFlag() ? 1 : 0,                                   "sps_prof_control_present_in_ph_flag" );
+    }
+  }
+
+  xWriteFlag(pcSPS->getUseBcw() ? 1 : 0, "sps_bcw_enabled_flag");
+
+  xWriteFlag( pcSPS->getUseCiip() ? 1 : 0,                                                  "sps_ciip_enabled_flag" );
+  if (pcSPS->getMaxNumMergeCand() >= 2)
+  {
+    xWriteFlag(pcSPS->getUseGeo() ? 1 : 0, "sps_gpm_enabled_flag");
+    if (pcSPS->getUseGeo())
+    {
+      CHECK(pcSPS->getMaxNumMergeCand() < pcSPS->getMaxNumGeoCand(),
+            "The number of GPM candidates must not be greater than the number of merge candidates");
+      CHECK(2 > pcSPS->getMaxNumGeoCand(),
+            "The number of GPM candidates must not be smaller than 2");
+      if (pcSPS->getMaxNumMergeCand() >= 3)
+      {
+        xWriteUvlc(pcSPS->getMaxNumMergeCand() - pcSPS->getMaxNumGeoCand(),
+                   "sps_max_num_merge_cand_minus_max_num_gpm_cand");
+      }
+    }
+  }
+
+  xWriteUvlc(pcSPS->getLog2ParallelMergeLevelMinus2(), "sps_log2_parallel_merge_level_minus2");
+
+  xWriteFlag( pcSPS->getUseISP() ? 1 : 0,                                             "sps_isp_enabled_flag");
+  xWriteFlag( pcSPS->getUseMRL() ? 1 : 0,                                             "sps_mrl_enabled_flag");
+  xWriteFlag( pcSPS->getUseMIP() ? 1 : 0,                                             "sps_mip_enabled_flag");
+  if (isChromaEnabled(pcSPS->getChromaFormatIdc()))
+  {
+    xWriteFlag( pcSPS->getUseLMChroma() ? 1 : 0,                                      "sps_cclm_enabled_flag");
+  }
+  if (pcSPS->getChromaFormatIdc() == ChromaFormat::_420)
+  {
+    xWriteFlag( pcSPS->getHorCollocatedChromaFlag() ? 1 : 0, "sps_chroma_horizontal_collocated_flag" );
+    xWriteFlag( pcSPS->getVerCollocatedChromaFlag() ? 1 : 0, "sps_chroma_vertical_collocated_flag" );
+  }
+  else
+  {
+    CHECK(pcSPS->getHorCollocatedChromaFlag() != 1, "Invalid value for horizontal collocated chroma flag");
+    CHECK(pcSPS->getVerCollocatedChromaFlag() != 1, "Invalid value for vertical collocated chroma flag");
+  }
+  CHECK(pcSPS->getMaxNumMergeCand() > MRG_MAX_NUM_CANDS, "More merge candidates signalled than supported");
+  xWriteFlag(pcSPS->getPLTMode() ? 1 : 0,                                                    "sps_palette_enabled_flag" );
+  if (pcSPS->getChromaFormatIdc() == ChromaFormat::_444 && pcSPS->getLog2MaxTbSize() != 6)
+  {
+    xWriteFlag(pcSPS->getUseColorTrans() ? 1 : 0, "sps_act_enabled_flag");
+  }
+  if (pcSPS->getTransformSkipEnabledFlag() || pcSPS->getPLTMode())
+  {
+    xWriteUvlc(pcSPS->getInternalMinusInputBitDepth(ChannelType::LUMA), "sps_internal_bit_depth_minus_input_bit_depth");
+  }
+  xWriteFlag(pcSPS->getIBCFlag() ? 1 : 0,                                                      "sps_ibc_enabled_flag");
+  if (pcSPS->getIBCFlag())
+  {
+    CHECK(pcSPS->getMaxNumIBCMergeCand() > IBC_MRG_MAX_NUM_CANDS, "More IBC merge candidates signalled than supported");
+    xWriteUvlc(IBC_MRG_MAX_NUM_CANDS - pcSPS->getMaxNumIBCMergeCand(), "sps_six_minus_max_num_ibc_merge_cand");
+  }
+  xWriteFlag( pcSPS->getLadfEnabled() ? 1 : 0,                                                 "sps_ladf_enabled_flag" );
+  if ( pcSPS->getLadfEnabled() )
+  {
+    xWriteCode( pcSPS->getLadfNumIntervals() - 2, 2,                                           "sps_num_ladf_intervals_minus2" );
+    xWriteSvlc( pcSPS->getLadfQpOffset( 0 ),                                                   "sps_ladf_lowest_interval_qp_offset");
+    for ( int k = 1; k< pcSPS->getLadfNumIntervals(); k++ )
+    {
+      xWriteSvlc( pcSPS->getLadfQpOffset( k ),                                                 "sps_ladf_qp_offset" );
+      xWriteUvlc( pcSPS->getLadfIntervalLowerBound( k ) - pcSPS->getLadfIntervalLowerBound( k - 1 ) - 1, "sps_ladf_delta_threshold_minus1" );
+    }
+  }
+  // KJS: reference picture sets to be replaced
+
+
+  // KJS: remove scaling lists?
+  xWriteFlag( pcSPS->getScalingListFlag() ? 1 : 0,                                   "sps_explicit_scaling_list_enabled_flag" );
+
+  if (pcSPS->getUseLFNST() && pcSPS->getScalingListFlag())
+  {
+    xWriteFlag(pcSPS->getDisableScalingMatrixForLfnstBlks(), "sps_scaling_matrix_for_lfnst_disabled_flag");
+  }
+
+  if (pcSPS->getUseColorTrans() && pcSPS->getScalingListFlag())
+  {
+    xWriteFlag(pcSPS->getScalingMatrixForAlternativeColourSpaceDisabledFlag(), "sps_scaling_matrix_for_alternative_colour_space_disabled_flag");
+  }
+  if (pcSPS->getScalingMatrixForAlternativeColourSpaceDisabledFlag())
+  {
+    xWriteFlag(pcSPS->getScalingMatrixDesignatedColourSpaceFlag(), "sps_scaling_matrix_designated_colour_space_flag");
+  }
+  xWriteFlag(pcSPS->getDepQuantEnabledFlag(), "sps_dep_quant_enabled_flag");
+  xWriteFlag(pcSPS->getSignDataHidingEnabledFlag(), "sps_sign_data_hiding_enabled_flag");
+
+  xWriteFlag( pcSPS->getVirtualBoundariesEnabledFlag(), "sps_virtual_boundaries_enabled_flag" );
+  if( pcSPS->getVirtualBoundariesEnabledFlag() )
+  {
+    xWriteFlag( pcSPS->getVirtualBoundariesPresentFlag(), "sps_loop_filter_across_virtual_boundaries_present_flag" );
+    if( pcSPS->getVirtualBoundariesPresentFlag() )
+    {
+      xWriteUvlc( pcSPS->getNumVerVirtualBoundaries(), "sps_num_ver_virtual_boundaries");
+      if (pcSPS->getMaxPicWidthInLumaSamples() <= 8)
+      {
+        CHECK(pcSPS->getNumVerVirtualBoundaries() != 0, "SPS: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+      }
+      else
+      {
+        CHECK(pcSPS->getNumVerVirtualBoundaries() > 3, "SPS: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+      }
+      for( unsigned i = 0; i < pcSPS->getNumVerVirtualBoundaries(); i++ )
+      {
+        xWriteUvlc((pcSPS->getVirtualBoundariesPosX(i)>>3) - 1, "sps_virtual_boundary_pos_x_minus1[i]");
+        CHECK(((pcSPS->getVirtualBoundariesPosX(i)>>3) - 1) > (((pcSPS->getMaxPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_width_max_in_luma_samples / 8 ) - 2, inclusive.");
+      }
+      xWriteUvlc(pcSPS->getNumHorVirtualBoundaries(), "sps_num_hor_virtual_boundaries");
+      if (pcSPS->getMaxPicHeightInLumaSamples() <= 8)
+      {
+        CHECK(pcSPS->getNumHorVirtualBoundaries() != 0, "SPS: When picture height is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+      }
+      else
+      {
+        CHECK(pcSPS->getNumHorVirtualBoundaries() > 3, "SPS: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+      }
+      for( unsigned i = 0; i < pcSPS->getNumHorVirtualBoundaries(); i++ )
+      {
+        xWriteUvlc((pcSPS->getVirtualBoundariesPosY(i)>>3) - 1, "sps_virtual_boundary_pos_y_minus1[i]");
+        CHECK(((pcSPS->getVirtualBoundariesPosY(i)>>3) - 1) > (((pcSPS->getMaxPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of sps_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( sps_pic_height_max_in_luma_samples / 8 ) - 2, inclusive.");
+      }
+    }
+  }
+  if (pcSPS->getPtlDpbHrdParamsPresentFlag())
+  {
+    xWriteFlag(pcSPS->getGeneralHrdParametersPresentFlag(), "sps_timing_hrd_params_present_flag");
+    if (pcSPS->getGeneralHrdParametersPresentFlag())
+    {
+      codeGeneralHrdparameters(pcSPS->getGeneralHrdParameters());
+      if ((pcSPS->getMaxTLayers() - 1) > 0)
+      {
+        xWriteFlag(pcSPS->getSubLayerParametersPresentFlag(), "sps_sublayer_cpb_params_present_flag");
+      }
+      uint32_t firstSubLayer = pcSPS->getSubLayerParametersPresentFlag() ? 0 : (pcSPS->getMaxTLayers() - 1);
+      codeOlsHrdParameters(pcSPS->getGeneralHrdParameters(), pcSPS->getOlsHrdParameters(), firstSubLayer,
+                           pcSPS->getMaxTLayers() - 1);
+    }
+  }
+
+  xWriteFlag(pcSPS->getFieldSeqFlag(),                          "sps_field_seq_flag");
+  xWriteFlag( pcSPS->getVuiParametersPresentFlag(),            "sps_vui_parameters_present_flag" );
+  if (pcSPS->getVuiParametersPresentFlag())
+  {
+    OutputBitstream *bs = getBitstream();
+    OutputBitstream bs_count;
+    setBitstream(&bs_count);
+#if ENABLE_TRACING
+    bool traceEnable = g_HLSTraceEnable;
+    g_HLSTraceEnable = false;
+#endif
+    codeVUI(pcSPS->getVuiParameters(), pcSPS);
+#if ENABLE_TRACING
+    g_HLSTraceEnable = traceEnable;
+#endif
+    unsigned vui_payload_data_num_bits = bs_count.getNumberOfWrittenBits();
+    CHECK( vui_payload_data_num_bits % 8 != 0, "Invalid number of VUI payload data bits" );
+    setBitstream(bs);
+    xWriteUvlc((vui_payload_data_num_bits >> 3) - 1, "sps_vui_payload_size_minus1");
+    while (!isByteAligned())
+    {
+      xWriteFlag(0, "sps_vui_alignment_zero_bit");
+    }
+    codeVUI(pcSPS->getVuiParameters(), pcSPS);
+  }
+
+  bool sps_extension_present_flag=false;
+  bool sps_extension_flags[NUM_SPS_EXTENSION_FLAGS]={false};
+
+  sps_extension_flags[SPS_EXT__REXT] = pcSPS->getSpsRangeExtension().settingsDifferFromDefaults();
+
+  // Other SPS extension flags checked here.
+
+  for(int i=0; i<NUM_SPS_EXTENSION_FLAGS; i++)
+  {
+    sps_extension_present_flag|=sps_extension_flags[i];
+  }
+
+  xWriteFlag( (sps_extension_present_flag?1:0), "sps_extension_present_flag" );
+
+  if (sps_extension_present_flag)
+  {
+    static const char *syntaxStrings[]={ "sps_range_extension_flag",
+      "sps_extension_7bits[0]",
+      "sps_extension_7bits[1]",
+      "sps_extension_7bits[2]",
+      "sps_extension_7bits[3]",
+      "sps_extension_7bits[4]",
+      "sps_extension_7bits[5]",
+      "sps_extension_7bits[6]" };
+
+    if (pcSPS->getBitDepth(ChannelType::LUMA) <= 10)
+    {
+      CHECK((sps_extension_flags[SPS_EXT__REXT] == 1),
+            "The value of sps_range_extension_flag shall be 0 when BitDepth is less than or equal to 10.");
+    }
+
+    for(int i=0; i<NUM_SPS_EXTENSION_FLAGS; i++)
+    {
+      xWriteFlag( sps_extension_flags[i]?1:0, syntaxStrings[i] );
+    }
+
+    for(int i=0; i<NUM_SPS_EXTENSION_FLAGS; i++) // loop used so that the order is determined by the enum.
+    {
+      if (sps_extension_flags[i])
+      {
+        switch (SPSExtensionFlagIndex(i))
+        {
+        case SPS_EXT__REXT:
+        {
+          const SPSRExt &spsRangeExtension=pcSPS->getSpsRangeExtension();
+
+          xWriteFlag( (spsRangeExtension.getExtendedPrecisionProcessingFlag() ? 1 : 0),       "extended_precision_processing_flag" );
+          if (pcSPS->getTransformSkipEnabledFlag())
+          {
+            xWriteFlag( (spsRangeExtension.getTSRCRicePresentFlag() ? 1 : 0),                 "sps_ts_residual_coding_rice_present_in_sh_flag");
+          }
+          xWriteFlag( (spsRangeExtension.getRrcRiceExtensionEnableFlag() ? 1 : 0),                   "rrc_rice_extension_flag");
+          xWriteFlag( (spsRangeExtension.getPersistentRiceAdaptationEnabledFlag() ? 1 : 0),   "persistent_rice_adaptation_enabled_flag" );
+          xWriteFlag( (spsRangeExtension.getReverseLastSigCoeffEnabledFlag() ? 1 : 0),        "reverse_last_sig_coeff_enabled_flag" );
+          break;
+        }
+        default:
+          CHECK(sps_extension_flags[i]!=false, "Unknown PPS extension signalled"); // Should never get here with an active SPS extension flag.
+          break;
+        }
+      }
+    }
+  }
+  xWriteRbspTrailingBits();
+}
+
+void HLSWriter::codeDCI(const DCI* dci)
+{
+#if ENABLE_TRACING
+  xTraceDCIHeader();
+#endif
+  xWriteCode(0, 4, "dci_reserved_zero_4bits");
+  uint32_t numPTLs = (uint32_t)dci->getNumPTLs();
+  CHECK( (numPTLs < 1) || ( numPTLs > 15), "dci_num_plts_minus1 shall be in the range of 0 - 14");
+
+  xWriteCode(numPTLs - 1, 4, "dci_num_ptls_minus1");
+
+  for (int i = 0; i < numPTLs; i++)
+  {
+    ProfileTierLevel ptl = dci->getProfileTierLevel(i);
+    codeProfileTierLevel(&ptl, true, 0);
+  }
+
+  xWriteFlag(0, "dci_extension_flag");
+  xWriteRbspTrailingBits();
+}
+
+void HLSWriter::codeOPI(const OPI *opi)
+{
+#if ENABLE_TRACING
+  xTraceOPIHeader();
+#endif
+  xWriteFlag(opi->getOlsInfoPresentFlag(), "opi_ols_info_present_flag");
+  xWriteFlag(opi->getHtidInfoPresentFlag(), "opi_htid_info_present_flag");
+
+  if (opi->getOlsInfoPresentFlag())
+  {
+    xWriteUvlc(opi->getOpiOlsIdx(), "opi_ols_idx");
+  }
+
+  if (opi->getHtidInfoPresentFlag())
+  {
+    xWriteCode(opi->getOpiHtidPlus1(), 3, "opi_htid_plus1");
+  }
+  xWriteFlag(0, "opi_extension_flag");
+  xWriteRbspTrailingBits();
+}
+
+void HLSWriter::codeVPS(const VPS* pcVPS)
+{
+#if ENABLE_TRACING
+  xTraceVPSHeader();
+#endif
+  xWriteCode(pcVPS->getVPSId(), 4, "vps_video_parameter_set_id");
+  xWriteCode(pcVPS->getMaxLayers() - 1, 6, "vps_max_layers_minus1");
+  xWriteCode(pcVPS->getMaxSubLayers() - 1, 3, "vps_max_sublayers_minus1");
+  if (pcVPS->getMaxLayers() > 1 && pcVPS->getMaxSubLayers() > 1)
+  {
+    xWriteFlag(pcVPS->getDefaultPtlDpbHrdMaxTidFlag(), "vps_default_ptl_dpb_hrd_max_tid_flag");
+  }
+  if (pcVPS->getMaxLayers() > 1)
+  {
+    xWriteFlag(pcVPS->getAllIndependentLayersFlag(), "vps_all_independent_layers_flag");
+  }
+  for (uint32_t i = 0; i < pcVPS->getMaxLayers(); i++)
+  {
+    xWriteCode(pcVPS->getLayerId(i), 6, "vps_layer_id");
+    if (i > 0 && !pcVPS->getAllIndependentLayersFlag())
+    {
+      xWriteFlag(pcVPS->getIndependentLayerFlag(i), "vps_independent_layer_flag");
+      if (!pcVPS->getIndependentLayerFlag(i))
+      {
+        bool presentFlag = false;
+        for (int j = 0; j < i; j++)
+        {
+          presentFlag |= ((pcVPS->getMaxTidIlRefPicsPlus1(i, j) != MAX_TLAYER) && pcVPS->getDirectRefLayerFlag(i, j));
+        }
+        xWriteFlag(presentFlag, "max_tid_ref_present_flag[ i ]");
+        for (int j = 0; j < i; j++)
+        {
+          xWriteFlag(pcVPS->getDirectRefLayerFlag(i, j), "vps_direct_ref_layer_flag");
+          if (presentFlag && pcVPS->getDirectRefLayerFlag(i, j))
+          {
+            xWriteCode(pcVPS->getMaxTidIlRefPicsPlus1(i, j), 3, "max_tid_il_ref_pics_plus1[ i ][ j ]");
+          }
+        }
+      }
+    }
+  }
+  if( pcVPS->getMaxLayers() > 1 )
+  {
+    if (pcVPS->getAllIndependentLayersFlag())
+    {
+      xWriteFlag(pcVPS->getEachLayerIsAnOlsFlag(), "vps_each_layer_is_an_ols_flag");
+    }
+    if (!pcVPS->getEachLayerIsAnOlsFlag())
+    {
+      if (!pcVPS->getAllIndependentLayersFlag())
+      {
+        xWriteCode(pcVPS->getOlsModeIdc(), 2, "vps_ols_mode_idc");
+      }
+      if (pcVPS->getOlsModeIdc() == 2)
+      {
+        xWriteCode(pcVPS->getNumOutputLayerSets() - 2, 8, "vps_num_output_layer_sets_minus2");
+        for (uint32_t i = 1; i < pcVPS->getNumOutputLayerSets(); i++)
+        {
+          for (uint32_t j = 0; j < pcVPS->getMaxLayers(); j++)
+          {
+            xWriteFlag(pcVPS->getOlsOutputLayerFlag(i, j), "vps_ols_output_layer_flag");
+          }
+        }
+      }
+    }
+    CHECK(pcVPS->getNumPtls() - 1 >= pcVPS->getTotalNumOLSs(), "vps_num_ptls_minus1 shall be less than TotalNumOlss");
+    xWriteCode(pcVPS->getNumPtls() - 1, 8, "vps_num_ptls_minus1");
+  }
+
+  int totalNumOlss = pcVPS->getTotalNumOLSs();
+  for (int i = 0; i < pcVPS->getNumPtls(); i++)
+  {
+    if(i > 0)
+    {
+      xWriteFlag(pcVPS->getPtPresentFlag(i), "vps_pt_present_flag");
+    }
+    if (!pcVPS->getDefaultPtlDpbHrdMaxTidFlag())
+    {
+      xWriteCode(pcVPS->getPtlMaxTemporalId(i), 3, "vps_ptl_max_tid");
+    }
+    else
+    {
+      CHECK(pcVPS->getPtlMaxTemporalId(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_ptl_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+    }
+  }
+  int cnt = 0;
+  while (m_pcBitIf->getNumBitsUntilByteAligned())
+  {
+    xWriteFlag( 0, "vps_ptl_reserved_zero_bit");
+    cnt++;
+  }
+  CHECK(cnt>=8, "More than '8' alignment bytes written");
+  for (int i = 0; i < pcVPS->getNumPtls(); i++)
+  {
+    codeProfileTierLevel(&pcVPS->getProfileTierLevel(i), pcVPS->getPtPresentFlag(i), pcVPS->getPtlMaxTemporalId(i));
+  }
+  for (int i = 0; i < totalNumOlss; i++)
+  {
+    if (pcVPS->getNumPtls() > 1 && pcVPS->getNumPtls() != pcVPS->getTotalNumOLSs())
+    {
+      xWriteCode(pcVPS->getOlsPtlIdx(i), 8, "vps_ols_ptl_idx");
+    }
+  }
+
+  if( !pcVPS->getEachLayerIsAnOlsFlag() )
+  {
+    xWriteUvlc( pcVPS->m_numDpbParams - 1, "vps_num_dpb_params_minus1" );
+
+    if( pcVPS->getMaxSubLayers() > 1 )
+    {
+      xWriteFlag( pcVPS->m_sublayerDpbParamsPresentFlag, "vps_sublayer_dpb_params_present_flag" );
+    }
+
+    for( int i = 0; i < pcVPS->m_numDpbParams; i++ )
+    {
+      if (!pcVPS->getDefaultPtlDpbHrdMaxTidFlag())
+      {
+        xWriteCode(pcVPS->m_dpbMaxTemporalId[i], 3, "vps_dpb_max_tid[i]");
+      }
+      else
+      {
+        CHECK(pcVPS->m_dpbMaxTemporalId[i] != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_dpb_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+      }
+
+      for( int j = ( pcVPS->m_sublayerDpbParamsPresentFlag ? 0 : pcVPS->m_dpbMaxTemporalId[i] ); j <= pcVPS->m_dpbMaxTemporalId[i]; j++ )
+      {
+        CHECK(pcVPS->m_dpbParameters[i].maxDecPicBuffering[j] < 1, "MaxDecPicBuffering must be greater than 0");
+        xWriteUvlc(pcVPS->m_dpbParameters[i].maxDecPicBuffering[j] - 1, "dpb_max_dec_pic_buffering_minus1[i]");
+        xWriteUvlc( pcVPS->m_dpbParameters[i].maxNumReorderPics[j], "dpb_max_num_reorder_pics[i]" );
+        xWriteUvlc( pcVPS->m_dpbParameters[i].maxLatencyIncreasePlus1[j], "dpb_max_latency_increase_plus1[i]" );
+      }
+    }
+
+    for( int i = 0; i < pcVPS->getTotalNumOLSs(); i++ )
+    {
+      if( pcVPS->m_numLayersInOls[i] > 1 )
+      {
+        xWriteUvlc( pcVPS->getOlsDpbPicSize( i ).width, "vps_ols_dpb_pic_width[i]" );
+        xWriteUvlc( pcVPS->getOlsDpbPicSize( i ).height, "vps_ols_dpb_pic_height[i]" );
+        xWriteCode(to_underlying(pcVPS->m_olsDpbChromaFormatIdc[i]), 2, "vps_ols_dpb_chroma_format[i]");
+        const Profile::Name profile = pcVPS->getProfileTierLevel(pcVPS->getOlsPtlIdx(i)).getProfileIdc();
+        if (profile != Profile::NONE)
+        {
+          CHECK(pcVPS->m_olsDpbBitDepthMinus8[i] + 8 > ProfileFeatures::getProfileFeatures(profile)->maxBitDepth, "vps_ols_dpb_bitdepth_minus8[ i ] exceeds range supported by signalled profile");
+        }
+        xWriteUvlc( pcVPS->m_olsDpbBitDepthMinus8[i], "vps_ols_dpb_bitdepth_minus8[i]");
+        if( (pcVPS->m_numDpbParams > 1) && (pcVPS->m_numDpbParams != pcVPS->m_numMultiLayeredOlss) )
+        {
+          xWriteUvlc( pcVPS->getOlsDpbParamsIdx( i ), "vps_ols_dpb_params_idx[i]" );
+        }
+      }
+    }
+  }
+  if (!pcVPS->getEachLayerIsAnOlsFlag())
+  {
+    xWriteFlag(pcVPS->getVPSGeneralHrdParamsPresentFlag(), "vps_general_hrd_params_present_flag");
+  }
+  if (pcVPS->getVPSGeneralHrdParamsPresentFlag())
+  {
+    codeGeneralHrdparameters(pcVPS->getGeneralHrdParameters());
+    if ((pcVPS->getMaxSubLayers()-1) > 0)
+    {
+      xWriteFlag(pcVPS->getVPSSublayerCpbParamsPresentFlag(), "vps_sublayer_cpb_params_present_flag");
+    }
+    xWriteUvlc(pcVPS->getNumOlsTimingHrdParamsMinus1(), "vps_num_ols_timing_hrd_params_minus1");
+    for (int i = 0; i <= pcVPS->getNumOlsTimingHrdParamsMinus1(); i++)
+    {
+      if (!pcVPS->getDefaultPtlDpbHrdMaxTidFlag())
+      {
+        xWriteCode(pcVPS->getHrdMaxTid(i), 3, "vps_hrd_max_tid[i]");
+      }
+      else
+      {
+        CHECK(pcVPS->getHrdMaxTid(i) != pcVPS->getMaxSubLayers() - 1, "When vps_default_ptl_dpb_hrd_max_tid_flag is equal to 1, the value of vps_hrd_max_tid[ i ] is inferred to be equal to vps_max_sublayers_minus1");
+      }
+      uint32_t firstSublayer = pcVPS->getVPSSublayerCpbParamsPresentFlag() ? 0 : pcVPS->getHrdMaxTid(i);
+      codeOlsHrdParameters(pcVPS->getGeneralHrdParameters(), pcVPS->getOlsHrdParameters(i),firstSublayer, pcVPS->getHrdMaxTid(i));
+    }
+    if ((pcVPS->getNumOlsTimingHrdParamsMinus1() > 0) && ((pcVPS->getNumOlsTimingHrdParamsMinus1() + 1) != pcVPS->m_numMultiLayeredOlss))
+    {
+      for (int i = 0; i < pcVPS->m_numMultiLayeredOlss; i++)
+      {
+        xWriteUvlc(pcVPS->getOlsTimingHrdIdx(i), "vps_ols_timing_hrd_idx[i]");
+      }
+    }
+  }
+
+  xWriteFlag(0, "vps_extension_flag");
+
+  //future extensions here..
+  xWriteRbspTrailingBits();
+}
+
+void HLSWriter::codePictureHeader( PicHeader* picHeader, bool writeRbspTrailingBits, Slice *slice )
+{
+  const PPS *pps = nullptr;
+  const SPS *sps = nullptr;
+
+#if ENABLE_TRACING
+  xTracePictureHeader ();
+#endif
+
+  if (!slice)
+  {
+    slice = picHeader->getPic()->cs->slice;
+  }
+  xWriteFlag(picHeader->getGdrOrIrapPicFlag(), "ph_gdr_or_irap_pic_flag");
+  xWriteFlag(picHeader->getNonReferencePictureFlag(), "ph_non_ref_pic_flag");
+  if (picHeader->getGdrOrIrapPicFlag())
+  {
+    xWriteFlag(picHeader->getGdrPicFlag(), "ph_gdr_pic_flag");
+  }
+  // Q0781, two-flags
+  xWriteFlag(picHeader->getPicInterSliceAllowedFlag(), "ph_inter_slice_allowed_flag");
+  if (picHeader->getPicInterSliceAllowedFlag())
+  {
+    xWriteFlag(picHeader->getPicIntraSliceAllowedFlag(), "ph_intra_slice_allowed_flag");
+  }
+  // parameter sets
+  xWriteUvlc(picHeader->getPPSId(), "ph_pic_parameter_set_id");
+  pps = slice->getPPS();
+  CHECK(pps == 0, "Invalid PPS");
+  sps = slice->getSPS();
+  CHECK(sps == 0, "Invalid SPS");
+  int pocBits = slice->getSPS()->getBitsForPOC();
+  int pocMask = (1 << pocBits) - 1;
+  xWriteCode(slice->getPOC() & pocMask, pocBits, "ph_pic_order_cnt_lsb");
+  if( picHeader->getGdrPicFlag() )
+  {
+    xWriteUvlc(picHeader->getRecoveryPocCnt(), "ph_recovery_poc_cnt");
+  }
+  else
+  {
+    picHeader->setRecoveryPocCnt( -1 );
+  }
+  // PH extra bits are not written in the reference encoder
+  // as these bits are reserved for future extensions
+  // for( i = 0; i < NumExtraPhBits; i++ )
+  //    ph_extra_bit[ i ]
+
+  if (sps->getPocMsbCycleFlag())
+  {
+    xWriteFlag(picHeader->getPocMsbPresentFlag(), "ph_poc_msb_present_flag");
+    if (picHeader->getPocMsbPresentFlag())
+    {
+      xWriteCode(picHeader->getPocMsbVal(), sps->getPocMsbCycleLen(), "ph_poc_msb_cycle_val");
+    }
+  }
+
+
+   // alf enable flags and aps IDs
+  if( sps->getALFEnabledFlag() )
+  {
+    if (pps->getAlfInfoInPhFlag())
+    {
+      xWriteFlag(picHeader->getAlfEnabledFlag(COMPONENT_Y), "ph_alf_enabled_flag");
+      if (picHeader->getAlfEnabledFlag(COMPONENT_Y))
+      {
+        xWriteCode(picHeader->getNumAlfApsIdsLuma(), 3, "ph_num_alf_aps_ids_luma");
+        const AlfApsList &apsId = picHeader->getAlfApsIdsLuma();
+        for (int i = 0; i < picHeader->getNumAlfApsIdsLuma(); i++)
+        {
+          xWriteCode(apsId[i], 3, "ph_alf_aps_id_luma");
+        }
+
+        const int alfChromaIdc = picHeader->getAlfEnabledFlag(COMPONENT_Cb) + picHeader->getAlfEnabledFlag(COMPONENT_Cr) * 2 ;
+        if (isChromaEnabled(sps->getChromaFormatIdc()))
+        {
+          xWriteCode(picHeader->getAlfEnabledFlag(COMPONENT_Cb), 1, "ph_alf_cb_enabled_flag");
+          xWriteCode(picHeader->getAlfEnabledFlag(COMPONENT_Cr), 1, "ph_alf_cr_enabled_flag");
+        }
+        if (alfChromaIdc)
+        {
+          xWriteCode(picHeader->getAlfApsIdChroma(), 3, "ph_alf_aps_id_chroma");
+        }
+        if (sps->getCCALFEnabledFlag())
+        {
+          xWriteFlag(picHeader->getCcAlfEnabledFlag(COMPONENT_Cb), "ph_cc_alf_cb_enabled_flag");
+          if (picHeader->getCcAlfEnabledFlag(COMPONENT_Cb))
+          {
+            xWriteCode(picHeader->getCcAlfCbApsId(), 3, "ph_cc_alf_cb_aps_id");
+          }
+          xWriteFlag(picHeader->getCcAlfEnabledFlag(COMPONENT_Cr), "ph_cc_alf_cr_enabled_flag");
+          if (picHeader->getCcAlfEnabledFlag(COMPONENT_Cr))
+          {
+            xWriteCode(picHeader->getCcAlfCrApsId(), 3, "ph_cc_alf_cr_aps_id");
+          }
+        }
+      }
+    }
+    else
+    {
+      picHeader->setAlfEnabledFlag(COMPONENT_Y,  true);
+      picHeader->setAlfEnabledFlag(COMPONENT_Cb, true);
+      picHeader->setAlfEnabledFlag(COMPONENT_Cr, true);
+      picHeader->setCcAlfEnabledFlag(COMPONENT_Cb, sps->getCCALFEnabledFlag());
+      picHeader->setCcAlfEnabledFlag(COMPONENT_Cr, sps->getCCALFEnabledFlag());
+    }
+  }
+  else
+  {
+    picHeader->setAlfEnabledFlag(COMPONENT_Y,  false);
+    picHeader->setAlfEnabledFlag(COMPONENT_Cb, false);
+    picHeader->setAlfEnabledFlag(COMPONENT_Cr, false);
+    picHeader->setCcAlfEnabledFlag(COMPONENT_Cb, false);
+    picHeader->setCcAlfEnabledFlag(COMPONENT_Cr, false);
+  }
+
+  // luma mapping / chroma scaling controls
+  if (sps->getUseLmcs())
+  {
+    xWriteFlag(picHeader->getLmcsEnabledFlag(), "ph_lmcs_enabled_flag");
+    if (picHeader->getLmcsEnabledFlag())
+    {
+      xWriteCode(picHeader->getLmcsAPSId(), 2, "ph_lmcs_aps_id");
+      if (isChromaEnabled(sps->getChromaFormatIdc()))
+      {
+        xWriteFlag(picHeader->getLmcsChromaResidualScaleFlag(), "ph_chroma_residual_scale_flag");
+      }
+      else
+      {
+        picHeader->setLmcsChromaResidualScaleFlag(false);
+      }
+    }
+  }
+  else
+  {
+    picHeader->setLmcsEnabledFlag(false);
+    picHeader->setLmcsChromaResidualScaleFlag(false);
+  }
+
+  // quantization scaling lists
+  if( sps->getScalingListFlag() )
+  {
+    xWriteFlag( picHeader->getExplicitScalingListEnabledFlag(), "ph_scaling_list_present_flag" );
+    if( picHeader->getExplicitScalingListEnabledFlag() )
+    {
+      xWriteCode( picHeader->getScalingListAPSId(), 3, "ph_scaling_list_aps_id" );
+    }
+  }
+  else
+  {
+    picHeader->setExplicitScalingListEnabledFlag( false );
+  }
+
+  // virtual boundaries
+  if( sps->getVirtualBoundariesEnabledFlag() && !sps->getVirtualBoundariesPresentFlag() )
+  {
+    xWriteFlag( picHeader->getVirtualBoundariesPresentFlag(), "ph_virtual_boundaries_present_flag" );
+    if( picHeader->getVirtualBoundariesPresentFlag() )
+    {
+#if GDR_ENABLED
+      if (sps->getGDREnabledFlag())
+      {
+        int n = picHeader->getNumVerVirtualBoundaries();
+        for (unsigned i = 0; i < n; i++)
+        {
+          if (picHeader->getVirtualBoundariesPosX(i) == pps->getPicWidthInLumaSamples())
+          {
+            n = n - 1;
+          }
+        }
+
+        xWriteUvlc(n, "ph_num_ver_virtual_boundaries");
+
+        if (pps->getPicWidthInLumaSamples() <= 8)
+        {
+          CHECK(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+        }
+        else
+        {
+          CHECK(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+        }
+
+        for (unsigned i = 0; i < picHeader->getNumVerVirtualBoundaries(); i++)
+        {
+          if (picHeader->getVirtualBoundariesPosX(i) != pps->getPicWidthInLumaSamples())
+          {
+            xWriteUvlc((picHeader->getVirtualBoundariesPosX(i) >> 3) - 1, "ph_virtual_boundary_pos_x_minus1[i]");
+            CHECK(((picHeader->getVirtualBoundariesPosX(i) >> 3) - 1) > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
+          }
+        }
+      }
+      else
+      {
+        xWriteUvlc(picHeader->getNumVerVirtualBoundaries(), "ph_num_ver_virtual_boundaries");
+        if (pps->getPicWidthInLumaSamples() <= 8)
+        {
+          CHECK(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+        }
+        else
+        {
+          CHECK(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+        }
+        for (unsigned i = 0; i < picHeader->getNumVerVirtualBoundaries(); i++)
+        {
+          xWriteUvlc((picHeader->getVirtualBoundariesPosX(i) >> 3) - 1, "ph_virtual_boundary_pos_x_minus1[i]");
+          CHECK(((picHeader->getVirtualBoundariesPosX(i) >> 3) - 1) > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
+        }
+      }
+#else
+      xWriteUvlc(picHeader->getNumVerVirtualBoundaries(), "ph_num_ver_virtual_boundaries");
+      if (pps->getPicWidthInLumaSamples() <= 8)
+      {
+        CHECK(picHeader->getNumVerVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of vertical virtual boundaries shall be equal to 0");
+      }
+      else
+      {
+        CHECK(picHeader->getNumVerVirtualBoundaries() > 3, "PH: The number of vertical virtual boundaries shall be in the range of 0 to 3");
+      }
+      for( unsigned i = 0; i < picHeader->getNumVerVirtualBoundaries(); i++ )
+      {
+        xWriteUvlc((picHeader->getVirtualBoundariesPosX(i) >> 3) - 1, "ph_virtual_boundary_pos_x_minus1[i]");
+        CHECK(((picHeader->getVirtualBoundariesPosX(i)>>3) - 1) > (((pps->getPicWidthInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_x_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_width_in_luma_samples / 8 ) - 2, inclusive.");
+      }
+#endif
+      xWriteUvlc(picHeader->getNumHorVirtualBoundaries(), "ph_num_hor_virtual_boundaries");
+      if (pps->getPicHeightInLumaSamples() <= 8)
+      {
+        CHECK(picHeader->getNumHorVirtualBoundaries() != 0, "PH: When picture width is less than or equal to 8, the number of horizontal virtual boundaries shall be equal to 0");
+      }
+      else
+      {
+        CHECK(picHeader->getNumHorVirtualBoundaries() > 3, "PH: The number of horizontal virtual boundaries shall be in the range of 0 to 3");
+      }
+      for( unsigned i = 0; i < picHeader->getNumHorVirtualBoundaries(); i++ )
+      {
+        xWriteUvlc((picHeader->getVirtualBoundariesPosY(i)>>3) - 1, "ph_virtual_boundary_pos_y_minus1[i]");
+        CHECK(((picHeader->getVirtualBoundariesPosY(i)>>3) - 1) > (((pps->getPicHeightInLumaSamples() + 7) >> 3) - 2), "The value of ph_virtual_boundary_pos_y_minus1[ i ] shall be in the range of 0 to Ceil( pps_pic_height_in_luma_samples / 8 ) - 2, inclusive.");
+      }
+    }
+    else
+    {
+      picHeader->setVirtualBoundariesPresentFlag( false );
+      picHeader->setNumVerVirtualBoundaries( 0 );
+      picHeader->setNumHorVirtualBoundaries( 0 );
+    }
+  }
+  else
+  {
+    picHeader->setVirtualBoundariesPresentFlag(sps->getVirtualBoundariesPresentFlag());
+    if (picHeader->getVirtualBoundariesPresentFlag())
+    {
+      picHeader->setNumVerVirtualBoundaries(sps->getNumVerVirtualBoundaries());
+      picHeader->setNumHorVirtualBoundaries(sps->getNumHorVirtualBoundaries());
+      for( unsigned i = 0; i < 3; i++ )
+      {
+        picHeader->setVirtualBoundariesPosX( sps->getVirtualBoundariesPosX(i), i );
+        picHeader->setVirtualBoundariesPosY( sps->getVirtualBoundariesPosY(i), i );
+      }
+    }
+  }
+
+
+  // picture output flag
+  if (pps->getOutputFlagPresentFlag() && !picHeader->getNonReferencePictureFlag())
+  {
+    xWriteFlag( picHeader->getPicOutputFlag(), "ph_pic_output_flag" );
+  }
+  else
+  {
+    picHeader->setPicOutputFlag(true);
+  }
+
+  // reference picture lists
+  if (pps->getRplInfoInPhFlag())
+  {
+    // List0 and List1
+    for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+    {
+      const int  numRplsInSps = sps->getNumRpl(l);
+      const int  rplIdx       = picHeader->getRplIdx(l);
+      const bool rplSpsFlag   = rplIdx != -1;
+
+      if (numRplsInSps == 0)
+      {
+        CHECK(rplSpsFlag, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+      }
+      else if (l == REF_PIC_LIST_0 || pps->getRpl1IdxPresentFlag())
+      {
+        xWriteFlag(rplSpsFlag ? 1 : 0, "rpl_sps_flag[i]");
+      }
+      else
+      {
+        bool rplSpsFlag0 = picHeader->getRplIdx(REF_PIC_LIST_0) != -1;
+        CHECK(rplSpsFlag != rplSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+      }
+
+      if (rplSpsFlag)
+      {
+        CHECK(rplIdx >= numRplsInSps, "rpl_idx is too large");
+
+        if (l == REF_PIC_LIST_0 || pps->getRpl1IdxPresentFlag())
+        {
+          if (numRplsInSps > 1)
+          {
+            const int numBits = ceilLog2(numRplsInSps);
+            xWriteCode(rplIdx, numBits, "rpl_idx[i]");
+          }
+        }
+        else
+        {
+          CHECK(rplIdx != picHeader->getRplIdx(REF_PIC_LIST_0),
+                "RPL1Idx is not signalled but it is not the same as RPL0Idx");
+        }
+      }
+      // explicit RPL in picture header
+      else
+      {
+        xCodeRefPicList(picHeader->getRpl(l), sps->getLongTermRefsPresent(), sps->getBitsForPOC(),
+                        !sps->getUseWP() && !sps->getUseWPBiPred(), -1);
+      }
+
+      // POC MSB cycle signalling for LTRP
+      const ReferencePictureList *rpl = picHeader->getRpl(l);
+
+      if (rpl != nullptr && rpl->getNumberOfLongtermPictures() > 0)
+      {
+        for (int i = 0; i < rpl->getNumRefEntries(); i++)
+        {
+          if (rpl->isRefPicLongterm(i))
+          {
+            if (rpl->getLtrpInSliceHeaderFlag())
+            {
+              xWriteCode(rpl->getRefPicIdentifier(i), sps->getBitsForPOC(), "poc_lsb_lt[listIdx][rplsIdx][j]");
+            }
+            xWriteFlag(rpl->getDeltaPocMSBPresentFlag(i) ? 1 : 0, "delta_poc_msb_present_flag[i][j]");
+            if (rpl->getDeltaPocMSBPresentFlag(i))
+            {
+              xWriteUvlc(rpl->getDeltaPocMSBCycleLT(i), "delta_poc_msb_cycle_lt[i][j]");
+            }
+          }
+        }
+      }
+    }
+  }
+
+  // partitioning constraint overrides
+  if (sps->getSplitConsOverrideEnabledFlag())
+  {
+    xWriteFlag(picHeader->getSplitConsOverrideFlag(), "ph_partition_constraints_override_flag");
+  }
+  else
+  {
+    picHeader->setSplitConsOverrideFlag(false);
+  }
+  // Q0781, two-flags
+  if (picHeader->getPicIntraSliceAllowedFlag())
+  {
+    if (picHeader->getSplitConsOverrideFlag())
+    {
+      xWriteUvlc(floorLog2(picHeader->getMinQTSize(I_SLICE)) - sps->getLog2MinCodingBlockSize(), "ph_log2_diff_min_qt_min_cb_intra_slice_luma");
+      xWriteUvlc(picHeader->getMaxMTTHierarchyDepth(I_SLICE), "ph_max_mtt_hierarchy_depth_intra_slice_luma");
+      if (picHeader->getMaxMTTHierarchyDepth(I_SLICE) != 0)
+      {
+        xWriteUvlc(floorLog2(picHeader->getMaxBTSize(I_SLICE)) - floorLog2(picHeader->getMinQTSize(I_SLICE)), "ph_log2_diff_max_bt_min_qt_intra_slice_luma");
+        xWriteUvlc(floorLog2(picHeader->getMaxTTSize(I_SLICE)) - floorLog2(picHeader->getMinQTSize(I_SLICE)), "ph_log2_diff_max_tt_min_qt_intra_slice_luma");
+      }
+
+      if (sps->getUseDualITree())
+      {
+        xWriteUvlc(floorLog2(picHeader->getMinQTSize(I_SLICE, ChannelType::CHROMA)) - sps->getLog2MinCodingBlockSize(),
+                   "ph_log2_diff_min_qt_min_cb_intra_slice_chroma");
+        xWriteUvlc(picHeader->getMaxMTTHierarchyDepth(I_SLICE, ChannelType::CHROMA),
+                   "ph_max_mtt_hierarchy_depth_intra_slice_chroma");
+        if (picHeader->getMaxMTTHierarchyDepth(I_SLICE, ChannelType::CHROMA) != 0)
+        {
+          xWriteUvlc(floorLog2(picHeader->getMaxBTSize(I_SLICE, ChannelType::CHROMA))
+                       - floorLog2(picHeader->getMinQTSize(I_SLICE, ChannelType::CHROMA)),
+                     "ph_log2_diff_max_bt_min_qt_intra_slice_chroma");
+          xWriteUvlc(floorLog2(picHeader->getMaxTTSize(I_SLICE, ChannelType::CHROMA))
+                       - floorLog2(picHeader->getMinQTSize(I_SLICE, ChannelType::CHROMA)),
+                     "ph_log2_diff_max_tt_min_qt_intra_slice_chroma");
+        }
+      }
+    }
+  }
+  if (picHeader->getPicIntraSliceAllowedFlag())
+  {
+  // delta quantization and chrom and chroma offset
+    if (pps->getUseDQP())
+    {
+      xWriteUvlc( picHeader->getCuQpDeltaSubdivIntra(), "ph_cu_qp_delta_subdiv_intra_slice" );
+    }
+    else
+    {
+      picHeader->setCuQpDeltaSubdivIntra( 0 );
+    }
+    if (pps->getCuChromaQpOffsetListEnabledFlag())
+    {
+      xWriteUvlc( picHeader->getCuChromaQpOffsetSubdivIntra(), "ph_cu_chroma_qp_offset_subdiv_intra_slice" );
+    }
+  }
+
+
+  if (picHeader->getPicInterSliceAllowedFlag())
+  {
+    if (picHeader->getSplitConsOverrideFlag())
+    {
+      xWriteUvlc(floorLog2(picHeader->getMinQTSize(P_SLICE)) - sps->getLog2MinCodingBlockSize(), "ph_log2_diff_min_qt_min_cb_inter_slice");
+      xWriteUvlc(picHeader->getMaxMTTHierarchyDepth(P_SLICE), "ph_max_mtt_hierarchy_depth_inter_slice");
+      if (picHeader->getMaxMTTHierarchyDepth(P_SLICE) != 0)
+      {
+        xWriteUvlc(floorLog2(picHeader->getMaxBTSize(P_SLICE)) - floorLog2(picHeader->getMinQTSize(P_SLICE)), "ph_log2_diff_max_bt_min_qt_inter_slice");
+        xWriteUvlc(floorLog2(picHeader->getMaxTTSize(P_SLICE)) - floorLog2(picHeader->getMinQTSize(P_SLICE)), "ph_log2_diff_max_tt_min_qt_inter_slice");
+      }
+    }
+
+    // delta quantization and chrom and chroma offset
+    if (pps->getUseDQP())
+    {
+      xWriteUvlc(picHeader->getCuQpDeltaSubdivInter(), "ph_cu_qp_delta_subdiv_inter_slice");
+    }
+    else
+    {
+      picHeader->setCuQpDeltaSubdivInter(0);
+    }
+    if (pps->getCuChromaQpOffsetListEnabledFlag())
+    {
+      xWriteUvlc(picHeader->getCuChromaQpOffsetSubdivInter(), "ph_cu_chroma_qp_offset_subdiv_inter_slice");
+    }
+
+    // temporal motion vector prediction
+    if (sps->getSPSTemporalMVPEnabledFlag())
+    {
+      xWriteFlag( picHeader->getEnableTMVPFlag(), "ph_temporal_mvp_enabled_flag" );
+      if (picHeader->getEnableTMVPFlag() && pps->getRplInfoInPhFlag())
+      {
+        if (picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 0)
+        {
+          xWriteCode(picHeader->getPicColFromL0Flag(), 1, "ph_collocated_from_l0_flag");
+        }
+        if ((picHeader->getPicColFromL0Flag() && picHeader->getRpl(REF_PIC_LIST_0)->getNumRefEntries() > 1)
+            || (!picHeader->getPicColFromL0Flag() && picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 1))
+        {
+          xWriteUvlc(picHeader->getColRefIdx(), "ph_collocated_ref_idx");
+        }
+      }
+    }
+    else
+    {
+      picHeader->setEnableTMVPFlag(false);
+    }
+
+    // merge candidate list size
+    // subblock merge candidate list size
+    if ( sps->getUseAffine() )
+    {
+      picHeader->setMaxNumAffineMergeCand(sps->getMaxNumAffineMergeCand());
+    }
+    else
+    {
+      picHeader->setMaxNumAffineMergeCand(sps->getSbTMVPEnabledFlag() && picHeader->getEnableTMVPFlag());
+    }
+
+  // full-pel MMVD flag
+    if (sps->getFpelMmvdEnabledFlag())
+    {
+      xWriteFlag( picHeader->getDisFracMMVD(), "ph_fpel_mmvd_enabled_flag" );
+    }
+    else
+    {
+      picHeader->setDisFracMMVD(false);
+    }
+
+    // mvd L1 zero flag
+    if (!pps->getRplInfoInPhFlag() || picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 0)
+    {
+      xWriteFlag(picHeader->getMvdL1ZeroFlag(), "ph_mvd_l1_zero_flag");
+    }
+
+    // picture level BDOF disable flags
+    if (sps->getBdofControlPresentInPhFlag()
+        && (!pps->getRplInfoInPhFlag() || picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 0))
+    {
+      xWriteFlag(picHeader->getBdofDisabledFlag(), "ph_bdof_disabled_flag");
+    }
+    else
+    {
+      picHeader->setBdofDisabledFlag(false);
+    }
+
+  // picture level DMVR disable flags
+    if (sps->getDmvrControlPresentInPhFlag()
+        && (!pps->getRplInfoInPhFlag() || picHeader->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 0))
+    {
+      xWriteFlag(picHeader->getDmvrDisabledFlag(), "ph_dmvr_disabled_flag");
+    }
+    else
+    {
+      picHeader->setDmvrDisabledFlag(false);
+    }
+
+  // picture level PROF disable flags
+    if (sps->getProfControlPresentInPhFlag())
+    {
+      xWriteFlag(picHeader->getProfDisabledFlag(), "ph_prof_disabled_flag");
+    }
+
+    if ((pps->getUseWP() || pps->getWPBiPred()) && pps->getWpInfoInPhFlag())
+    {
+      xCodePredWeightTable(picHeader, pps, sps);
+    }
+  }
+  // inherit constraint values from SPS
+  if (!sps->getSplitConsOverrideEnabledFlag() || !picHeader->getSplitConsOverrideFlag())
+  {
+    picHeader->setMinQTSizes(sps->getMinQTSizes());
+    picHeader->setMaxMTTHierarchyDepths(sps->getMaxMTTHierarchyDepths());
+    picHeader->setMaxBTSizes(sps->getMaxBTSizes());
+    picHeader->setMaxTTSizes(sps->getMaxTTSizes());
+  }
+  // ibc merge candidate list size
+  if (pps->getQpDeltaInfoInPhFlag())
+  {
+    xWriteSvlc(picHeader->getQpDelta(), "ph_qp_delta");
+  }
+
+  // joint Cb/Cr sign flag
+  if (sps->getJointCbCrEnabledFlag())
+  {
+    xWriteFlag( picHeader->getJointCbCrSignFlag(), "ph_joint_cbcr_sign_flag" );
+  }
+  else
+  {
+    picHeader->setJointCbCrSignFlag(false);
+  }
+
+  // sao enable flags
+  if(sps->getSAOEnabledFlag())
+  {
+    if (pps->getSaoInfoInPhFlag())
+    {
+      xWriteFlag(picHeader->getSaoEnabledFlag(ChannelType::LUMA), "ph_sao_luma_enabled_flag");
+      if (isChromaEnabled(sps->getChromaFormatIdc()))
+      {
+        xWriteFlag(picHeader->getSaoEnabledFlag(ChannelType::CHROMA), "ph_sao_chroma_enabled_flag");
+      }
+    }
+    else
+    {
+      picHeader->setSaoEnabledFlag(ChannelType::LUMA, true);
+      picHeader->setSaoEnabledFlag(ChannelType::CHROMA, true);
+    }
+  }
+  else
+  {
+    picHeader->setSaoEnabledFlag(ChannelType::LUMA, false);
+    picHeader->setSaoEnabledFlag(ChannelType::CHROMA, false);
+  }
+
+  // deblocking filter controls
+  if (pps->getDeblockingFilterControlPresentFlag())
+  {
+    if ( pps->getDbfInfoInPhFlag() )
+    {
+      xWriteFlag( picHeader->getDeblockingFilterOverrideFlag(), "ph_deblocking_params_present_flag" );
+    }
+    else
+    {
+      picHeader->setDeblockingFilterOverrideFlag(false);
+    }
+
+    if(picHeader->getDeblockingFilterOverrideFlag())
+    {
+      if (!pps->getPPSDeblockingFilterDisabledFlag())
+      {
+        xWriteFlag(picHeader->getDeblockingFilterDisable(), "ph_deblocking_filter_disabled_flag");
+      }
+      if( !picHeader->getDeblockingFilterDisable() )
+      {
+        xWriteSvlc( picHeader->getDeblockingFilterBetaOffsetDiv2(), "ph_beta_offset_div2" );
+        xWriteSvlc( picHeader->getDeblockingFilterTcOffsetDiv2(), "ph_tc_offset_div2" );
+        if( pps->getPPSChromaToolFlag() )
+        {
+          xWriteSvlc( picHeader->getDeblockingFilterCbBetaOffsetDiv2(), "ph_cb_beta_offset_div2" );
+          xWriteSvlc( picHeader->getDeblockingFilterCbTcOffsetDiv2(), "ph_cb_tc_offset_div2" );
+          xWriteSvlc( picHeader->getDeblockingFilterCrBetaOffsetDiv2(), "ph_cr_beta_offset_div2" );
+          xWriteSvlc( picHeader->getDeblockingFilterCrTcOffsetDiv2(), "ph_cr_tc_offset_div2" );
+        }
+      }
+    }
+    else
+    {
+      picHeader->setDeblockingFilterDisable       ( pps->getPPSDeblockingFilterDisabledFlag() );
+      picHeader->setDeblockingFilterBetaOffsetDiv2( pps->getDeblockingFilterBetaOffsetDiv2() );
+      picHeader->setDeblockingFilterTcOffsetDiv2  ( pps->getDeblockingFilterTcOffsetDiv2() );
+      picHeader->setDeblockingFilterCbBetaOffsetDiv2( pps->getDeblockingFilterCbBetaOffsetDiv2() );
+      picHeader->setDeblockingFilterCbTcOffsetDiv2  ( pps->getDeblockingFilterCbTcOffsetDiv2() );
+      picHeader->setDeblockingFilterCrBetaOffsetDiv2( pps->getDeblockingFilterCrBetaOffsetDiv2() );
+      picHeader->setDeblockingFilterCrTcOffsetDiv2  ( pps->getDeblockingFilterCrTcOffsetDiv2() );
+    }
+  }
+  else
+  {
+    picHeader->setDeblockingFilterDisable       ( false );
+    picHeader->setDeblockingFilterBetaOffsetDiv2( 0 );
+    picHeader->setDeblockingFilterTcOffsetDiv2  ( 0 );
+    picHeader->setDeblockingFilterCbBetaOffsetDiv2( 0 );
+    picHeader->setDeblockingFilterCbTcOffsetDiv2  ( 0 );
+    picHeader->setDeblockingFilterCrBetaOffsetDiv2( 0 );
+    picHeader->setDeblockingFilterCrTcOffsetDiv2  ( 0 );
+  }
+
+
+  // picture header extension
+  if(pps->getPictureHeaderExtensionPresentFlag())
+  {
+    xWriteUvlc(0,"ph_extension_length");
+  }
+
+  if ( writeRbspTrailingBits )
+  {
+    xWriteRbspTrailingBits();
+  }
+}
+
+void HLSWriter::codeSliceHeader         ( Slice* pcSlice, PicHeader *picHeader )
+{
+#if ENABLE_TRACING
+  xTraceSliceHeader ();
+#endif
+
+  if (!picHeader)
+  {
+    CodingStructure& cs = *pcSlice->getPic()->cs;
+    picHeader = cs.picHeader;
+  }
+  const ChromaFormat format                = pcSlice->getSPS()->getChromaFormatIdc();
+  const uint32_t         numberValidComponents = getNumberValidComponents(format);
+  const bool         chromaEnabled         = isChromaEnabled(format);
+  xWriteFlag(pcSlice->getPictureHeaderInSliceHeader() ? 1 : 0, "sh_picture_header_in_slice_header_flag");
+  if (pcSlice->getPictureHeaderInSliceHeader())
+  {
+    codePictureHeader(picHeader, false);
+#if GDR_ENC_TRACE
+    printf("-gdr_pic_flag:%d\n", picHeader->getGdrPicFlag());
+    printf("-recovery_poc_cnt:%d\n", picHeader->getRecoveryPocCnt());
+    printf("-InGdrInterval:%d\n", pcSlice->getPic()->gdrParam.inGdrInterval);
+    printf("-pic_lmcs_enabled_flag:%d\n", picHeader->getLmcsEnabledFlag() ? 1 : 0);
+    printf("-pic_chroma_residual_scale_flag:%d\n", picHeader->getLmcsChromaResidualScaleFlag() ? 1 : 0);
+#endif
+  }
+
+  if (pcSlice->getSPS()->getSubPicInfoPresentFlag())
+  {
+    uint32_t bitsSubPicId;
+    bitsSubPicId = pcSlice->getSPS()->getSubPicIdLen();
+    xWriteCode(pcSlice->getSliceSubPicId(), bitsSubPicId, "sh_subpic_id");
+  }
+
+  // raster scan slices
+  if( pcSlice->getPPS()->getRectSliceFlag() == 0 )
+  {
+    // slice address is the raster scan tile index of first tile in slice
+    if( pcSlice->getPPS()->getNumTiles() > 1 )
+    {
+      int bitsSliceAddress = ceilLog2(pcSlice->getPPS()->getNumTiles());
+      xWriteCode( pcSlice->getSliceID(), bitsSliceAddress, "sh_slice_address");
+      if ((int)pcSlice->getPPS()->getNumTiles() - (int)pcSlice->getSliceID() > 1)
+      {
+        xWriteUvlc(pcSlice->getNumTilesInSlice() - 1, "sh_num_tiles_in_slice_minus1");
+      }
+    }
+  }
+  // rectangular slices
+  else
+  {
+    // slice address is the index of the slice within the current sub-picture
+    uint32_t currSubPicIdx = pcSlice->getPPS()->getSubPicIdxFromSubPicId( pcSlice->getSliceSubPicId() );
+    SubPic currSubPic = pcSlice->getPPS()->getSubPic(currSubPicIdx);
+    if( currSubPic.getNumSlicesInSubPic() > 1 )
+    {
+      int numSlicesInPreviousSubPics = 0;
+      for(int sp = 0; sp < currSubPicIdx; sp++)
+      {
+        numSlicesInPreviousSubPics += pcSlice->getPPS()->getSubPic(sp).getNumSlicesInSubPic();
+      }
+      int bitsSliceAddress = ceilLog2(currSubPic.getNumSlicesInSubPic());
+      xWriteCode( pcSlice->getSliceID() - numSlicesInPreviousSubPics, bitsSliceAddress, "sh_slice_address");
+    }
+  }
+
+  if (picHeader->getPicInterSliceAllowedFlag())
+  {
+    xWriteUvlc(pcSlice->getSliceType(), "sh_slice_type");
+  }
+  if (pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_CRA || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_N_LP || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL || pcSlice->getNalUnitType() == NAL_UNIT_CODED_SLICE_GDR)
+  {
+    xWriteFlag(pcSlice->getNoOutputOfPriorPicsFlag(), "sh_no_output_of_prior_pics_flag");
+  }
+  if (!picHeader->getPicIntraSliceAllowedFlag())
+  {
+    CHECK(pcSlice->getSliceType() == I_SLICE, "when ph_intra_slice_allowed_flag = 0, no I_Slice is allowed");
+  }
+
+  if (pcSlice->getSPS()->getALFEnabledFlag() && !pcSlice->getPPS()->getAlfInfoInPhFlag())
+  {
+    const int alfEnabled = pcSlice->getAlfEnabledFlag(COMPONENT_Y);
+    xWriteFlag(alfEnabled, "sh_alf_enabled_flag");
+
+    if (alfEnabled)
+    {
+      xWriteCode(pcSlice->getNumAlfApsIdsLuma(), 3, "sh_num_alf_aps_ids_luma");
+      const AlfApsList &apsId = pcSlice->getAlfApsIdsLuma();
+      for (int i = 0; i < pcSlice->getNumAlfApsIdsLuma(); i++)
+      {
+        xWriteCode(apsId[i], 3, "sh_alf_aps_id_luma[i]");
+      }
+
+      const int alfChromaIdc = pcSlice->getAlfEnabledFlag(COMPONENT_Cb) + pcSlice->getAlfEnabledFlag(COMPONENT_Cr) * 2;
+      if (chromaEnabled)
+      {
+        xWriteCode(pcSlice->getAlfEnabledFlag(COMPONENT_Cb), 1, "sh_alf_cb_enabled_flag");
+        xWriteCode(pcSlice->getAlfEnabledFlag(COMPONENT_Cr), 1, "sh_alf_cr_enabled_flag");
+      }
+      if (alfChromaIdc)
+      {
+        xWriteCode(pcSlice->getAlfApsIdChroma(), 3, "sh_alf_aps_id_chroma");
+      }
+
+      if (pcSlice->getSPS()->getCCALFEnabledFlag())
+      {
+        CcAlfFilterParam &filterParam = pcSlice->m_ccAlfFilterParam;
+        xWriteFlag(filterParam.ccAlfFilterEnabled[COMPONENT_Cb - 1] ? 1 : 0, "sh_alf_cc_cb_enabled_flag");
+        if (filterParam.ccAlfFilterEnabled[COMPONENT_Cb - 1])
+        {
+          // write CC ALF Cb APS ID
+          xWriteCode(pcSlice->getCcAlfCbApsId(), 3, "sh_alf_cc_cb_aps_id");
+        }
+        // Cr
+        xWriteFlag(filterParam.ccAlfFilterEnabled[COMPONENT_Cr - 1] ? 1 : 0, "sh_alf_cc_cr_enabled_flag");
+        if (filterParam.ccAlfFilterEnabled[COMPONENT_Cr - 1])
+        {
+          // write CC ALF Cr APS ID
+          xWriteCode(pcSlice->getCcAlfCrApsId(), 3, "sh_alf_cc_cr_aps_id");
+        }
+      }
+    }
+  }
+
+  if (picHeader->getLmcsEnabledFlag() && !pcSlice->getPictureHeaderInSliceHeader())
+  {
+    xWriteFlag(pcSlice->getLmcsEnabledFlag(), "sh_lmcs_used_flag");
+  }
+  if (picHeader->getExplicitScalingListEnabledFlag() && !pcSlice->getPictureHeaderInSliceHeader())
+  {
+    xWriteFlag(pcSlice->getExplicitScalingListUsed(), "sh_explicit_scaling_list_used_flag");
+  }
+
+  if( !pcSlice->getPPS()->getRplInfoInPhFlag() && (!pcSlice->getIdrPicFlag() || pcSlice->getSPS()->getIDRRefParamListPresent()))
+  {
+    // Write L0 related syntax elements
+    const int numRplsInSps = pcSlice->getSPS()->getNumRpl(REF_PIC_LIST_0);
+    const int rplIdx       = pcSlice->getRplIdx(REF_PIC_LIST_0);
+
+    if (numRplsInSps > 0)
+    {
+      xWriteFlag(rplIdx != -1 ? 1 : 0, "ref_pic_list_sps_flag[0]");
+    }
+    if (rplIdx != -1)
+    {
+      if (numRplsInSps > 1)
+      {
+        int numBits = ceilLog2(numRplsInSps);
+        xWriteCode(rplIdx, numBits, "ref_pic_list_idx[0]");
+      }
+    }
+    else
+    {   // write local RPL0
+      xCodeRefPicList(pcSlice->getRpl(REF_PIC_LIST_0), pcSlice->getSPS()->getLongTermRefsPresent(),
+                      pcSlice->getSPS()->getBitsForPOC(),
+                      !pcSlice->getSPS()->getUseWP() && !pcSlice->getSPS()->getUseWPBiPred(), -1);
+    }
+    // Deal POC Msb cycle signalling for LTRP
+    if (pcSlice->getRpl(REF_PIC_LIST_0)->getNumberOfLongtermPictures())
+    {
+      for (int i = 0; i < pcSlice->getRpl(REF_PIC_LIST_0)->getNumRefEntries(); i++)
+      {
+        if (pcSlice->getRpl(REF_PIC_LIST_0)->isRefPicLongterm(i))
+        {
+          if (pcSlice->getRpl(REF_PIC_LIST_0)->getLtrpInSliceHeaderFlag())
+          {
+            xWriteCode(pcSlice->getRpl(REF_PIC_LIST_0)->getRefPicIdentifier(i), pcSlice->getSPS()->getBitsForPOC(),
+                       "slice_poc_lsb_lt[listIdx][rplsIdx][j]");
+          }
+          xWriteFlag(pcSlice->getRpl(REF_PIC_LIST_0)->getDeltaPocMSBPresentFlag(i) ? 1 : 0,
+                     "delta_poc_msb_present_flag[i][j]");
+          if (pcSlice->getRpl(REF_PIC_LIST_0)->getDeltaPocMSBPresentFlag(i))
+          {
+            xWriteUvlc(pcSlice->getRpl(REF_PIC_LIST_0)->getDeltaPocMSBCycleLT(i), "delta_poc_msb_cycle_lt[i][j]");
+          }
+        }
+      }
+    }
+
+    // Write L1 related syntax elements
+    if (pcSlice->getSPS()->getNumRpl(REF_PIC_LIST_1) > 0 && pcSlice->getPPS()->getRpl1IdxPresentFlag())
+    {
+      xWriteFlag(pcSlice->getRplIdx(REF_PIC_LIST_1) != -1 ? 1 : 0, "ref_pic_list_sps_flag[1]");
+    }
+    else if (pcSlice->getSPS()->getNumRpl(REF_PIC_LIST_1) == 0)
+    {
+      CHECK(pcSlice->getRplIdx(REF_PIC_LIST_1) != -1,
+            "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+    }
+    else
+    {
+      auto rplsSpsFlag0 = pcSlice->getRplIdx(REF_PIC_LIST_0) != -1 ? 1 : 0;
+      auto rplsSpsFlag1 = pcSlice->getRplIdx(REF_PIC_LIST_1) != -1 ? 1 : 0;
+      CHECK(rplsSpsFlag1 != rplsSpsFlag0, "rpl_sps_flag[1] will be infer to 0 and this is not what was expected");
+    }
+
+    if (pcSlice->getRplIdx(REF_PIC_LIST_1) != -1)
+    {
+      if (pcSlice->getSPS()->getNumRpl(REF_PIC_LIST_1) > 1 && pcSlice->getPPS()->getRpl1IdxPresentFlag())
+      {
+        int numBits = ceilLog2(pcSlice->getSPS()->getNumRpl(REF_PIC_LIST_1));
+        xWriteCode(pcSlice->getRplIdx(REF_PIC_LIST_1), numBits, "ref_pic_list_idx[1]");
+      }
+      else if (pcSlice->getSPS()->getNumRpl(REF_PIC_LIST_1) == 1)
+      {
+        CHECK(pcSlice->getRplIdx(REF_PIC_LIST_1) != 0, "RPL1Idx is not signalled but it is not equal to 0");
+      }
+      else
+      {
+        CHECK(pcSlice->getRplIdx(REF_PIC_LIST_1) != pcSlice->getRplIdx(REF_PIC_LIST_0),
+              "RPL1Idx is not signalled but it is not the same as RPL0Idx");
+      }
+    }
+    else
+    {   // write local RPL1
+      xCodeRefPicList(pcSlice->getRpl(REF_PIC_LIST_1), pcSlice->getSPS()->getLongTermRefsPresent(),
+                      pcSlice->getSPS()->getBitsForPOC(),
+                      !pcSlice->getSPS()->getUseWP() && !pcSlice->getSPS()->getUseWPBiPred(), -1);
+    }
+    // Deal POC Msb cycle signalling for LTRP
+    if (pcSlice->getRpl(REF_PIC_LIST_1)->getNumberOfLongtermPictures())
+    {
+      for (int i = 0; i < pcSlice->getRpl(REF_PIC_LIST_1)->getNumRefEntries(); i++)
+      {
+        if (pcSlice->getRpl(REF_PIC_LIST_1)->isRefPicLongterm(i))
+        {
+          if (pcSlice->getRpl(REF_PIC_LIST_1)->getLtrpInSliceHeaderFlag())
+          {
+            xWriteCode(pcSlice->getRpl(REF_PIC_LIST_1)->getRefPicIdentifier(i), pcSlice->getSPS()->getBitsForPOC(),
+                       "slice_poc_lsb_lt[listIdx][rplsIdx][j]");
+          }
+          xWriteFlag(pcSlice->getRpl(REF_PIC_LIST_1)->getDeltaPocMSBPresentFlag(i) ? 1 : 0,
+                     "delta_poc_msb_present_flag[i][j]");
+          if (pcSlice->getRpl(REF_PIC_LIST_1)->getDeltaPocMSBPresentFlag(i))
+          {
+            xWriteUvlc(pcSlice->getRpl(REF_PIC_LIST_1)->getDeltaPocMSBCycleLT(i), "delta_poc_msb_cycle_lt[i][j]");
+          }
+        }
+      }
+    }
+  }
+
+  // check if numbers of active references match the defaults. If not, override
+
+  CHECK(pcSlice->isIntra() && pcSlice->getNumRefIdx(REF_PIC_LIST_0) > 0, "Bad number of refs");
+  CHECK(!pcSlice->isInterB() && pcSlice->getNumRefIdx(REF_PIC_LIST_1) > 0, "Bad number of refs");
+
+  if ((!pcSlice->isIntra() && pcSlice->getRpl(REF_PIC_LIST_0)->getNumRefEntries() > 1)
+      || (pcSlice->isInterB() && pcSlice->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 1))
+  {
+    const int defaultL0 = std::min(pcSlice->getRpl(REF_PIC_LIST_0)->getNumRefEntries(),
+                                   pcSlice->getPPS()->getNumRefIdxDefaultActive(REF_PIC_LIST_0));
+
+    bool overrideFlag = pcSlice->getNumRefIdx(REF_PIC_LIST_0) != defaultL0;
+
+    if (!overrideFlag && pcSlice->isInterB())
+    {
+      const int defaultL1 = std::min(pcSlice->getRpl(REF_PIC_LIST_1)->getNumRefEntries(),
+                                     pcSlice->getPPS()->getNumRefIdxDefaultActive(REF_PIC_LIST_1));
+
+      overrideFlag = pcSlice->getNumRefIdx(REF_PIC_LIST_1) != defaultL1;
+    }
+
+    xWriteFlag(overrideFlag ? 1 : 0, "sh_num_ref_idx_active_override_flag");
+    if (overrideFlag)
+    {
+      if (pcSlice->getRpl(REF_PIC_LIST_0)->getNumRefEntries() > 1)
+      {
+        xWriteUvlc(pcSlice->getNumRefIdx(REF_PIC_LIST_0) - 1, "sh_num_ref_idx_active_minus1[0]");
+      }
+
+      if (pcSlice->isInterB() && pcSlice->getRpl(REF_PIC_LIST_1)->getNumRefEntries() > 1)
+      {
+        xWriteUvlc(pcSlice->getNumRefIdx(REF_PIC_LIST_1) - 1, "sh_num_ref_idx_active_minus1[1]");
+      }
+    }
+  }
+
+  if (!pcSlice->isIntra())
+  {
+    if (!pcSlice->isIntra() && pcSlice->getPPS()->getCabacInitPresentFlag())
+    {
+      SliceType sliceType        = pcSlice->getSliceType();
+      SliceType encCABACTableIdx = pcSlice->getEncCABACTableIdx();
+      bool      encCabacInitFlag = (sliceType != encCABACTableIdx && encCABACTableIdx != I_SLICE) ? true : false;
+      pcSlice->setCabacInitFlag(encCabacInitFlag);
+      xWriteFlag(encCabacInitFlag ? 1 : 0, "sh_cabac_init_flag");
+    }
+  }
+  if (pcSlice->getPicHeader()->getEnableTMVPFlag() && !pcSlice->getPPS()->getRplInfoInPhFlag())
+  {
+    if (!pcSlice->getPPS()->getRplInfoInPhFlag())
+    {
+      if (pcSlice->getSliceType() == B_SLICE)
+      {
+        xWriteFlag(pcSlice->getColFromL0Flag(), "sh_collocated_from_l0_flag");
+      }
+    }
+
+    if (pcSlice->getSliceType() != I_SLICE
+        && ((pcSlice->getColFromL0Flag() == 1 && pcSlice->getNumRefIdx(REF_PIC_LIST_0) > 1)
+            || (pcSlice->getColFromL0Flag() == 0 && pcSlice->getNumRefIdx(REF_PIC_LIST_1) > 1)))
+    {
+      xWriteUvlc(pcSlice->getColRefIdx(), "sh_collocated_ref_idx");
+    }
+  }
+
+  if ((pcSlice->getPPS()->getUseWP() && pcSlice->getSliceType() == P_SLICE)
+      || (pcSlice->getPPS()->getWPBiPred() && pcSlice->getSliceType() == B_SLICE))
+  {
+    if (!pcSlice->getPPS()->getWpInfoInPhFlag())
+    {
+      xCodePredWeightTable(pcSlice);
+    }
+  }
+
+  if (!pcSlice->getPPS()->getQpDeltaInfoInPhFlag())
+  {
+    xWriteSvlc(pcSlice->getSliceQp() - (pcSlice->getPPS()->getPicInitQPMinus26() + 26), "sh_qp_delta");
+  }
+  if (pcSlice->getPPS()->getSliceChromaQpFlag())
+  {
+    if (numberValidComponents > COMPONENT_Cb)
+    {
+      xWriteSvlc(pcSlice->getSliceChromaQpDelta(COMPONENT_Cb), "sh_cb_qp_offset");
+    }
+    if (numberValidComponents > COMPONENT_Cr)
+    {
+      xWriteSvlc(pcSlice->getSliceChromaQpDelta(COMPONENT_Cr), "sh_cr_qp_offset");
+      if (pcSlice->getSPS()->getJointCbCrEnabledFlag())
+      {
+        xWriteSvlc(pcSlice->getSliceChromaQpDelta(JOINT_CbCr), "sh_joint_cbcr_qp_offset");
+      }
+    }
+    CHECK(numberValidComponents < COMPONENT_Cr + 1, "Too many valid components");
+  }
+
+  if (pcSlice->getPPS()->getCuChromaQpOffsetListEnabledFlag())
+  {
+    xWriteFlag(pcSlice->getUseChromaQpAdj(), "sh_cu_chroma_qp_offset_enabled_flag");
+  }
+
+  if (pcSlice->getSPS()->getSAOEnabledFlag() && !pcSlice->getPPS()->getSaoInfoInPhFlag())
+  {
+    xWriteFlag(pcSlice->getSaoEnabledFlag(ChannelType::LUMA), "sh_sao_luma_used_flag");
+    if (chromaEnabled)
+    {
+      xWriteFlag(pcSlice->getSaoEnabledFlag(ChannelType::CHROMA), "sh_sao_chroma_used_flag");
+    }
+  }
+
+  if (pcSlice->getPPS()->getDeblockingFilterControlPresentFlag())
+  {
+    if (pcSlice->getPPS()->getDeblockingFilterOverrideEnabledFlag() && !pcSlice->getPPS()->getDbfInfoInPhFlag())
+    {
+      xWriteFlag(pcSlice->getDeblockingFilterOverrideFlag(), "sh_deblocking_params_present_flag");
+    }
+    else
+    {
+      pcSlice->setDeblockingFilterOverrideFlag(false);
+    }
+    if (pcSlice->getDeblockingFilterOverrideFlag())
+    {
+      if (!pcSlice->getPPS()->getPPSDeblockingFilterDisabledFlag())
+      {
+        xWriteFlag(pcSlice->getDeblockingFilterDisable(), "sh_deblocking_filter_disabled_flag");
+      }
+      if (!pcSlice->getDeblockingFilterDisable())
+      {
+        xWriteSvlc(pcSlice->getDeblockingFilterBetaOffsetDiv2(), "sh_luma_beta_offset_div2");
+        xWriteSvlc(pcSlice->getDeblockingFilterTcOffsetDiv2(), "sh_luma_tc_offset_div2");
+        if (pcSlice->getPPS()->getPPSChromaToolFlag())
+        {
+          xWriteSvlc(pcSlice->getDeblockingFilterCbBetaOffsetDiv2(), "sh_cb_beta_offset_div2");
+          xWriteSvlc(pcSlice->getDeblockingFilterCbTcOffsetDiv2(), "sh_cb_tc_offset_div2");
+          xWriteSvlc(pcSlice->getDeblockingFilterCrBetaOffsetDiv2(), "sh_cr_beta_offset_div2");
+          xWriteSvlc(pcSlice->getDeblockingFilterCrTcOffsetDiv2(), "sh_cr_tc_offset_div2");
+        }
+      }
+    }
+    else
+    {
+      pcSlice->setDeblockingFilterDisable(picHeader->getDeblockingFilterDisable());
+      pcSlice->setDeblockingFilterBetaOffsetDiv2(picHeader->getDeblockingFilterBetaOffsetDiv2());
+      pcSlice->setDeblockingFilterTcOffsetDiv2(picHeader->getDeblockingFilterTcOffsetDiv2());
+      pcSlice->setDeblockingFilterCbBetaOffsetDiv2(picHeader->getDeblockingFilterCbBetaOffsetDiv2());
+      pcSlice->setDeblockingFilterCbTcOffsetDiv2(picHeader->getDeblockingFilterCbTcOffsetDiv2());
+      pcSlice->setDeblockingFilterCrBetaOffsetDiv2(picHeader->getDeblockingFilterCrBetaOffsetDiv2());
+      pcSlice->setDeblockingFilterCrTcOffsetDiv2(picHeader->getDeblockingFilterCrTcOffsetDiv2());
+    }
+  }
+  else
+  {
+    pcSlice->setDeblockingFilterDisable(false);
+    pcSlice->setDeblockingFilterBetaOffsetDiv2(0);
+    pcSlice->setDeblockingFilterTcOffsetDiv2(0);
+    pcSlice->setDeblockingFilterCbBetaOffsetDiv2(0);
+    pcSlice->setDeblockingFilterCbTcOffsetDiv2(0);
+    pcSlice->setDeblockingFilterCrBetaOffsetDiv2(0);
+    pcSlice->setDeblockingFilterCrTcOffsetDiv2(0);
+  }
+
+  // dependent quantization
+  if( pcSlice->getSPS()->getDepQuantEnabledFlag() )
+  {
+    xWriteFlag(pcSlice->getDepQuantEnabledFlag(), "sh_dep_quant_used_flag");
+  }
+  else
+  {
+    pcSlice->setDepQuantEnabledFlag(false);
+  }
+
+  // sign data hiding
+  if( pcSlice->getSPS()->getSignDataHidingEnabledFlag() && !pcSlice->getDepQuantEnabledFlag() )
+  {
+    xWriteFlag(pcSlice->getSignDataHidingEnabledFlag(), "sh_sign_data_hiding_used_flag" );
+  }
+  else
+  {
+    pcSlice->setSignDataHidingEnabledFlag(false);
+  }
+
+  // signal TS residual coding disabled flag
+  if (pcSlice->getSPS()->getTransformSkipEnabledFlag() && !pcSlice->getDepQuantEnabledFlag() && !pcSlice->getSignDataHidingEnabledFlag())
+  {
+    xWriteFlag(pcSlice->getTSResidualCodingDisabledFlag() ? 1 : 0, "sh_ts_residual_coding_disabled_flag");
+  }
+
+  if ((!pcSlice->getTSResidualCodingDisabledFlag()) && (pcSlice->getSPS()->getSpsRangeExtension().getTSRCRicePresentFlag()))
+  {
+    xWriteCode(pcSlice->getTsrcIndex(), 3, "sh_ts_residual_coding_rice_idx_minus1");
+  }
+  if (pcSlice->getSPS()->getSpsRangeExtension().getReverseLastSigCoeffEnabledFlag())
+  {
+    xWriteFlag(pcSlice->getReverseLastSigCoeffFlag(), "sh_reverse_last_sig_coeff_flag");
+  }
+  if(pcSlice->getPPS()->getSliceHeaderExtensionPresentFlag())
+  {
+    xWriteUvlc(0,"sh_slice_header_extension_length");
+  }
+}
+
+void  HLSWriter::codeConstraintInfo  ( const ConstraintInfo* cinfo, const ProfileTierLevel* ptl )
+{
+  xWriteFlag(cinfo->getGciPresentFlag(), "gci_present_flag");
+  if (cinfo->getGciPresentFlag())
+  {
+    /* general */
+    xWriteFlag(cinfo->getIntraOnlyConstraintFlag() ? 1 : 0, "gci_intra_only_constraint_flag");
+    xWriteFlag(cinfo->getAllLayersIndependentConstraintFlag() ? 1 : 0, "gci_all_layers_independent_constraint_flag");
+    xWriteFlag(cinfo->getOnePictureOnlyConstraintFlag() ? 1 : 0, "gci_one_au_only_constraint_flag");
+
+    /* picture format */
+    xWriteCode(16 - cinfo->getMaxBitDepthConstraintIdc(), 4, "gci_sixteen_minus_max_bitdepth_constraint_idc");
+    xWriteCode(3 - to_underlying(cinfo->getMaxChromaFormatConstraintIdc()), 2,
+               "gci_three_minus_max_chroma_format_constraint_idc");
+
+    /* NAL unit type related */
+    xWriteFlag(cinfo->getNoMixedNaluTypesInPicConstraintFlag() ? 1 : 0, "gci_no_mixed_nalu_types_in_pic_constraint_flag");
+    xWriteFlag(cinfo->getNoTrailConstraintFlag() ? 1 : 0, "gci_no_trail_constraint_flag");
+    xWriteFlag(cinfo->getNoStsaConstraintFlag() ? 1 : 0, "gci_no_stsa_constraint_flag");
+    xWriteFlag(cinfo->getNoRaslConstraintFlag() ? 1 : 0, "gci_no_rasl_constraint_flag");
+    xWriteFlag(cinfo->getNoRadlConstraintFlag() ? 1 : 0, "gci_no_radl_constraint_flag");
+    xWriteFlag(cinfo->getNoIdrConstraintFlag() ? 1 : 0, "gci_no_idr_constraint_flag");
+    xWriteFlag(cinfo->getNoCraConstraintFlag() ? 1 : 0, "gci_no_cra_constraint_flag");
+    xWriteFlag(cinfo->getNoGdrConstraintFlag() ? 1 : 0, "gci_no_gdr_constraint_flag");
+    xWriteFlag(cinfo->getNoApsConstraintFlag() ? 1 : 0, "gci_no_aps_constraint_flag");
+    xWriteFlag(cinfo->getNoIdrRplConstraintFlag() ? 1: 0, "gci_no_idr_rpl_constraint_flag");
+
+    /* tile, slice, subpicture partitioning */
+    xWriteFlag(cinfo->getOneTilePerPicConstraintFlag() ? 1 : 0, "gci_one_tile_per_pic_constraint_flag");
+    xWriteFlag(cinfo->getPicHeaderInSliceHeaderConstraintFlag() ? 1 : 0, "gci_pic_header_in_slice_header_constraint_flag");
+    xWriteFlag(cinfo->getOneSlicePerPicConstraintFlag() ? 1 : 0, "gci_one_slice_per_pic_constraint_flag");
+    xWriteFlag(cinfo->getNoRectSliceConstraintFlag() ? 1 : 0, "gci_no_rectangular_slice_constraint_flag");
+    xWriteFlag(cinfo->getOneSlicePerSubpicConstraintFlag() ? 1 : 0, "gci_one_slice_per_subpic_constraint_flag");
+    xWriteFlag(cinfo->getNoSubpicInfoConstraintFlag() ? 1 : 0, "gci_no_subpic_info_constraint_flag");
+
+
+    /* CTU and block partitioning */
+    xWriteCode(3 - (cinfo->getMaxLog2CtuSizeConstraintIdc() - 5), 2, "gci_three_minus_max_log2_ctu_size_constraint_idc");
+    xWriteFlag(cinfo->getNoPartitionConstraintsOverrideConstraintFlag() ? 1 : 0, "gci_no_partition_constraints_override_constraint_flag");
+    xWriteFlag(cinfo->getNoMttConstraintFlag() ? 1 : 0, "gci_no_mtt_constraint_flag");
+    xWriteFlag(cinfo->getNoQtbttDualTreeIntraConstraintFlag() ? 1 : 0, "gci_no_qtbtt_dual_tree_intra_constraint_flag");
+
+    /* intra */
+    xWriteFlag(cinfo->getNoPaletteConstraintFlag() ? 1 : 0, "gci_no_palette_constraint_flag");
+    xWriteFlag(cinfo->getNoIbcConstraintFlag() ? 1 : 0, "gci_no_ibc_constraint_flag");
+    xWriteFlag(cinfo->getNoIspConstraintFlag() ? 1 : 0, "gci_no_isp_constraint_flag");
+    xWriteFlag(cinfo->getNoMrlConstraintFlag() ? 1 : 0, "gci_no_mrl_constraint_flag");
+    xWriteFlag(cinfo->getNoMipConstraintFlag() ? 1 : 0, "gci_no_mip_constraint_flag");
+    xWriteFlag(cinfo->getNoCclmConstraintFlag() ? 1 : 0, "gci_no_cclm_constraint_flag");
+
+    /* inter */
+    xWriteFlag(cinfo->getNoRprConstraintFlag() ? 1 : 0, "gci_no_ref_pic_resampling_constraint_flag");
+    xWriteFlag(cinfo->getNoResChangeInClvsConstraintFlag() ? 1 : 0, "gci_no_res_change_in_clvs_constraint_flag");
+    xWriteFlag(cinfo->getNoWeightedPredictionConstraintFlag() ? 1 : 0, "gci_no_weighted_prediction_constraint_flag");
+    xWriteFlag(cinfo->getNoRefWraparoundConstraintFlag() ? 1 : 0, "gci_no_ref_wraparound_constraint_flag");
+    xWriteFlag(cinfo->getNoTemporalMvpConstraintFlag() ? 1 : 0, "gci_no_temporal_mvp_constraint_flag");
+    xWriteFlag(cinfo->getNoSbtmvpConstraintFlag() ? 1 : 0, "gci_no_sbtmvp_constraint_flag");
+    xWriteFlag(cinfo->getNoAmvrConstraintFlag() ? 1 : 0, "gci_no_amvr_constraint_flag");
+    xWriteFlag(cinfo->getNoBdofConstraintFlag() ? 1 : 0, "gci_no_bdof_constraint_flag");
+    xWriteFlag(cinfo->getNoSmvdConstraintFlag() ? 1 : 0, "gci_no_smvd_constraint_flag");
+    xWriteFlag(cinfo->getNoDmvrConstraintFlag() ? 1 : 0, "gci_no_dmvr_constraint_flag");
+    xWriteFlag(cinfo->getNoMmvdConstraintFlag() ? 1 : 0, "gci_no_mmvd_constraint_flag");
+    xWriteFlag(cinfo->getNoAffineMotionConstraintFlag() ? 1 : 0, "gci_no_affine_motion_constraint_flag");
+    xWriteFlag(cinfo->getNoProfConstraintFlag() ? 1 : 0, "gci_no_prof_constraint_flag");
+    xWriteFlag(cinfo->getNoBcwConstraintFlag() ? 1 : 0, "gci_no_bcw_constraint_flag");
+    xWriteFlag(cinfo->getNoCiipConstraintFlag() ? 1 : 0, "gci_no_ciip_constraint_flag");
+    xWriteFlag(cinfo->getNoGeoConstraintFlag() ? 1 : 0, "gci_no_gpm_constraint_flag");
+
+    /* transform, quantization, residual */
+    xWriteFlag(cinfo->getNoLumaTransformSize64ConstraintFlag() ? 1 : 0, "gci_no_luma_transform_size_64_constraint_flag");
+    xWriteFlag(cinfo->getNoTransformSkipConstraintFlag() ? 1 : 0, "gci_no_transform_skip_constraint_flag");
+    xWriteFlag(cinfo->getNoBDPCMConstraintFlag() ? 1 : 0, "gci_no_bdpcm_constraint_flag");
+    xWriteFlag(cinfo->getNoMtsConstraintFlag() ? 1 : 0, "gci_no_mts_constraint_flag");
+    xWriteFlag(cinfo->getNoLfnstConstraintFlag() ? 1 : 0, "gci_no_lfnst_constraint_flag");
+    xWriteFlag(cinfo->getNoJointCbCrConstraintFlag() ? 1 : 0, "gci_no_joint_cbcr_constraint_flag");
+    xWriteFlag(cinfo->getNoSbtConstraintFlag() ? 1 : 0, "gci_no_sbt_constraint_flag");
+    xWriteFlag(cinfo->getNoActConstraintFlag() ? 1 : 0, "gci_no_act_constraint_flag");
+    xWriteFlag(cinfo->getNoExplicitScaleListConstraintFlag() ? 1 : 0, "gci_no_explicit_scaling_list_constraint_flag");
+    xWriteFlag(cinfo->getNoDepQuantConstraintFlag() ? 1 : 0, "gci_no_dep_quant_constraint_flag");
+    xWriteFlag(cinfo->getNoSignDataHidingConstraintFlag() ? 1 : 0, "gci_no_sign_data_hiding_constraint_flag");
+    xWriteFlag(cinfo->getNoCuQpDeltaConstraintFlag() ? 1 : 0, "gci_no_cu_qp_delta_constraint_flag");
+    xWriteFlag(cinfo->getNoChromaQpOffsetConstraintFlag() ? 1 : 0, "gci_no_chroma_qp_offset_constraint_flag");
+
+    /* loop filter */
+    xWriteFlag(cinfo->getNoSaoConstraintFlag() ? 1 : 0, "gci_no_sao_constraint_flag");
+    xWriteFlag(cinfo->getNoAlfConstraintFlag() ? 1 : 0, "gci_no_alf_constraint_flag");
+    xWriteFlag(cinfo->getNoCCAlfConstraintFlag() ? 1 : 0, "gci_no_ccalf_constraint_flag");
+    xWriteFlag(cinfo->getNoLmcsConstraintFlag() ? 1 : 0, "gci_no_lmcs_constraint_flag");
+    xWriteFlag(cinfo->getNoLadfConstraintFlag() ? 1 : 0, "gci_no_ladf_constraint_flag");
+    xWriteFlag(cinfo->getNoVirtualBoundaryConstraintFlag() ? 1 : 0, "gci_no_virtual_boundaries_constraint_flag");
+    Profile::Name profile = ptl->getProfileIdc();
+    if (profile == Profile::MAIN_12 || profile == Profile::MAIN_12_INTRA || profile == Profile::MAIN_12_STILL_PICTURE ||
+        profile == Profile::MAIN_12_444 || profile == Profile::MAIN_12_444_INTRA || profile == Profile::MAIN_12_444_STILL_PICTURE ||
+        profile == Profile::MAIN_16_444 || profile == Profile::MAIN_16_444_INTRA || profile == Profile::MAIN_16_444_STILL_PICTURE)
+    {
+      int numAdditionalBits = 6;
+      xWriteCode(numAdditionalBits, 8, "gci_num_additional_bits");
+      xWriteFlag(cinfo->getAllRapPicturesFlag() ? 1 : 0, "gci_all_rap_pictures_flag");
+      xWriteFlag(cinfo->getNoExtendedPrecisionProcessingConstraintFlag() ? 1 : 0, "gci_no_extended_precision_processing_constraint_flag");
+      xWriteFlag(cinfo->getNoTsResidualCodingRiceConstraintFlag() ? 1 : 0, "gci_no_ts_residual_coding_rice_constraint_flag");
+      xWriteFlag(cinfo->getNoRrcRiceExtensionConstraintFlag() ? 1 : 0, "gci_no_rrc_rice_extension_constraint_flag");
+      xWriteFlag(cinfo->getNoPersistentRiceAdaptationConstraintFlag() ? 1 : 0, "gci_no_persistent_rice_adaptation_constraint_flag");
+      xWriteFlag(cinfo->getNoReverseLastSigCoeffConstraintFlag() ? 1 : 0, "gci_no_reverse_last_sig_coeff_constraint_flag");
+    }
+    else
+    {
+      xWriteCode(0, 8, "gci_num_additional_bits");
+    }
+  }
+
+  while (!isByteAligned())
+  {
+    xWriteFlag(0, "gci_alignment_zero_bit");
+  }
+}
+
+void  HLSWriter::codeProfileTierLevel    ( const ProfileTierLevel* ptl, bool profileTierPresentFlag, int maxNumSubLayersMinus1 )
+{
+  if(profileTierPresentFlag)
+  {
+    xWriteCode( int(ptl->getProfileIdc()), 7 ,   "general_profile_idc"                     );
+    xWriteFlag( ptl->getTierFlag()==Level::HIGH, "general_tier_flag"                       );
+  }
+
+  xWriteCode( int( ptl->getLevelIdc() ), 8, "general_level_idc" );
+
+  xWriteFlag( ptl->getFrameOnlyConstraintFlag(), "ptl_frame_only_constraint_flag" );
+  xWriteFlag( ptl->getMultiLayerEnabledFlag(),   "ptl_multilayer_enabled_flag"    );
+
+  if(profileTierPresentFlag)
+  {
+    codeConstraintInfo(ptl->getConstraintInfo(), ptl);
+  }
+
+  for (int i = maxNumSubLayersMinus1 - 1; i >= 0; i--)
+  {
+    xWriteFlag( ptl->getSubLayerLevelPresentFlag(i),   "sub_layer_level_present_flag[i]" );
+  }
+
+  while (!isByteAligned())
+  {
+    xWriteFlag(0, "ptl_reserved_zero_bit");
+  }
+
+  for (int i = maxNumSubLayersMinus1 - 1; i >= 0; i--)
+  {
+    if( ptl->getSubLayerLevelPresentFlag(i) )
+    {
+      xWriteCode( int(ptl->getSubLayerLevelIdc(i)), 8, "sub_layer_level_idc[i]" );
+    }
+  }
+
+  if (profileTierPresentFlag)
+  {
+    xWriteCode(ptl->getNumSubProfile(), 8, "ptl_num_sub_profiles");
+    for (int i = 0; i < ptl->getNumSubProfile(); i++)
+    {
+      xWriteCode(ptl->getSubProfileIdc(i), 32, "general_sub_profile_idc[i]");
+    }
+  }
+}
+
+
+/**
+* Write tiles and wavefront substreams sizes for the slice header (entry points).
+*
+* \param pSlice Slice structure that contains the substream size information.
+*/
+void  HLSWriter::codeTilesWPPEntryPoint( Slice* pSlice )
+{
+  pSlice->setNumEntryPoints( pSlice->getSPS(), pSlice->getPPS() );
+  if( pSlice->getNumEntryPoints() == 0 )
+  {
+    return;
+  }
+  uint32_t maxOffset = 0;
+  for(int idx=0; idx<pSlice->getNumberOfSubstreamSizes(); idx++)
+  {
+    uint32_t offset=pSlice->getSubstreamSize(idx);
+    if ( offset > maxOffset )
+    {
+      maxOffset = offset;
+    }
+  }
+
+  // Determine number of bits "offsetLenMinus1+1" required for entry point information
+  uint32_t offsetLenMinus1 = 0;
+  while (maxOffset >= (1u << (offsetLenMinus1 + 1)))
+  {
+    offsetLenMinus1++;
+    CHECK(offsetLenMinus1 + 1 >= 32, "Invalid offset length minus 1");
+  }
+
+  if (pSlice->getNumberOfSubstreamSizes()>0)
+  {
+    xWriteUvlc(offsetLenMinus1, "sh_entry_offset_len_minus1");
+    for (uint32_t idx=0; idx<pSlice->getNumberOfSubstreamSizes(); idx++)
+    {
+      xWriteCode(pSlice->getSubstreamSize(idx)-1, offsetLenMinus1+1, "sh_entry_point_offset_minus1");
+    }
+  }
+}
+
+
+// ====================================================================================================================
+// Protected member functions
+// ====================================================================================================================
+
+//! Code weighted prediction tables
+void HLSWriter::xCodePredWeightTable( Slice* pcSlice )
+{
+  WPScalingParam  *wp;
+  const ChromaFormat format                    = pcSlice->getSPS()->getChromaFormatIdc();
+  const uint32_t     numberValidComponents     = getNumberValidComponents(format);
+  const bool         hasChroma                 = isChromaEnabled(format);
+  uint32_t           totalSignalledWeightFlags = 0;
+
+  wp = pcSlice->getWpScaling(REF_PIC_LIST_0, 0);
+
+  xWriteUvlc(wp[COMPONENT_Y].log2WeightDenom, "luma_log2_weight_denom");
+
+  if (hasChroma)
+  {
+    CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+          "Chroma blocks of different size not supported");
+    const int deltaDenom = (wp[COMPONENT_Cb].log2WeightDenom - wp[COMPONENT_Y].log2WeightDenom);
+    xWriteSvlc(deltaDenom, "delta_chroma_log2_weight_denom");
+  }
+
+  for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+  {
+    const bool l0 = l == REF_PIC_LIST_0;
+
+    if (!l0 && !pcSlice->isInterB())
+    {
+      continue;
+    }
+
+    // NOTE: wp[].log2WeightDenom and wp[].presentFlag are actually per-channel-type settings.
+
+    for (int refIdx = 0; refIdx < pcSlice->getNumRefIdx(l); refIdx++)
+    {
+      wp = pcSlice->getWpScaling(l, refIdx);
+      xWriteFlag(wp[COMPONENT_Y].presentFlag, (l0 ? "luma_weight_l0_flag[i]" : "luma_weight_l1_flag[i]"));
+      totalSignalledWeightFlags += wp[COMPONENT_Y].presentFlag;
+    }
+    if (hasChroma)
+    {
+      for (int refIdx = 0; refIdx < pcSlice->getNumRefIdx(l); refIdx++)
+      {
+        wp = pcSlice->getWpScaling(l, refIdx);
+        CHECK(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
+              "Inconsistent settings for chroma channels");
+        xWriteFlag(wp[COMPONENT_Cb].presentFlag, (l0 ? "chroma_weight_l0_flag[i]" : "chroma_weight_l1_flag[i]"));
+        totalSignalledWeightFlags += 2 * wp[COMPONENT_Cb].presentFlag;
+      }
+    }
+
+    for (int refIdx = 0; refIdx < pcSlice->getNumRefIdx(l); refIdx++)
+    {
+      wp = pcSlice->getWpScaling(l, refIdx);
+      if (wp[COMPONENT_Y].presentFlag)
+      {
+        int deltaWeight = (wp[COMPONENT_Y].codedWeight - (1 << wp[COMPONENT_Y].log2WeightDenom));
+        xWriteSvlc(deltaWeight, (l0 ? "delta_luma_weight_l0[i]" : "delta_luma_weight_l1[i]"));
+        xWriteSvlc(wp[COMPONENT_Y].codedOffset, (l0 ? "luma_offset_l0[i]" : "luma_offset_l1[i]"));
+      }
+
+      if (hasChroma)
+      {
+        if (wp[COMPONENT_Cb].presentFlag)
+        {
+          for (int j = COMPONENT_Cb; j < numberValidComponents; j++)
+          {
+            CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+                  "Chroma blocks of different size not supported");
+            int deltaWeight = (wp[j].codedWeight - (1 << wp[COMPONENT_Cb].log2WeightDenom));
+            xWriteSvlc(deltaWeight, (l0 ? "delta_chroma_weight_l0[i]" : "delta_chroma_weight_l1[i]"));
+
+            int range       = pcSlice->getSPS()->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag()
+                                ? (1 << pcSlice->getSPS()->getBitDepth(ChannelType::CHROMA)) / 2
+                                : 128;
+            int pred        = (range - ((range * wp[j].codedWeight) >> (wp[j].log2WeightDenom)));
+            int deltaChroma = (wp[j].codedOffset - pred);
+            xWriteSvlc(deltaChroma, (l0 ? "delta_chroma_offset_l0[i]" : "delta_chroma_offset_l1[i]"));
+          }
+        }
+      }
+    }
+  }
+  CHECK(totalSignalledWeightFlags > 24, "Too many signalled weight flags");
+}
+
+void HLSWriter::xCodePredWeightTable(PicHeader *picHeader, const PPS *pps, const SPS *sps)
+{
+  WPScalingParam *   wp;
+  const ChromaFormat format                      = sps->getChromaFormatIdc();
+  const uint32_t     numberValidComponents       = getNumberValidComponents(format);
+  const bool         chroma                      = isChromaEnabled(format);
+  uint32_t           totalSignalledWeightFlags   = 0;
+
+  wp = picHeader->getWpScaling(REF_PIC_LIST_0, 0);
+  xWriteUvlc(wp[COMPONENT_Y].log2WeightDenom, "luma_log2_weight_denom");
+
+  if (chroma)
+  {
+    CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+          "Chroma blocks of different size not supported");
+    const int deltaDenom = (wp[COMPONENT_Cb].log2WeightDenom - wp[COMPONENT_Y].log2WeightDenom);
+    xWriteSvlc(deltaDenom, "delta_chroma_log2_weight_denom");
+  }
+
+  for (const auto l: { REF_PIC_LIST_0, REF_PIC_LIST_1 })
+  {
+    const bool l0 = l == REF_PIC_LIST_0;
+
+    int numLxWeights = 0;
+    if (l0 || pps->getWPBiPred())
+    {
+      numLxWeights = picHeader->getNumWeights(l);
+      xWriteUvlc(numLxWeights, (l0 ? "num_l0_weights" : "num_l1_weights"));
+    }
+
+    for (int refIdx = 0; refIdx < numLxWeights; refIdx++)
+    {
+      wp = picHeader->getWpScaling(l, refIdx);
+      xWriteFlag(wp[COMPONENT_Y].presentFlag, (l0 ? "luma_weight_l0_flag[i]" : "luma_weight_l1_flag[i]"));
+      totalSignalledWeightFlags += wp[COMPONENT_Y].presentFlag;
+    }
+
+    if (chroma)
+    {
+      for (int refIdx = 0; refIdx < numLxWeights; refIdx++)
+      {
+        wp = picHeader->getWpScaling(l, refIdx);
+        CHECK(wp[COMPONENT_Cb].presentFlag != wp[COMPONENT_Cr].presentFlag,
+              "Inconsistent settings for chroma channels");
+        xWriteFlag(wp[COMPONENT_Cb].presentFlag, (l0 ? "chroma_weight_l0_flag[i]" : "chroma_weight_l1_flag[i]"));
+        totalSignalledWeightFlags += 2 * wp[COMPONENT_Cb].presentFlag;
+      }
+    }
+
+    for (int refIdx = 0; refIdx < numLxWeights; refIdx++)
+    {
+      wp = picHeader->getWpScaling(l, refIdx);
+      if (wp[COMPONENT_Y].presentFlag)
+      {
+        int deltaWeight = (wp[COMPONENT_Y].codedWeight - (1 << wp[COMPONENT_Y].log2WeightDenom));
+        xWriteSvlc(deltaWeight, (l0 ? "delta_luma_weight_l0[i]" : "delta_luma_weight_l1[i]"));
+        xWriteSvlc(wp[COMPONENT_Y].codedOffset, (l0 ? "luma_offset_l0[i]" : "luma_offset_l1[i]"));
+      }
+
+      if (chroma)
+      {
+        if (wp[COMPONENT_Cb].presentFlag)
+        {
+          for (int j = COMPONENT_Cb; j < numberValidComponents; j++)
+          {
+            CHECK(wp[COMPONENT_Cb].log2WeightDenom != wp[COMPONENT_Cr].log2WeightDenom,
+                  "Chroma blocks of different size not supported");
+            int deltaWeight = (wp[j].codedWeight - (1 << wp[COMPONENT_Cb].log2WeightDenom));
+            xWriteSvlc(deltaWeight, (l0 ? "delta_chroma_weight_l0[i]" : "delta_chroma_weight_l1[i]"));
+
+            int range       = sps->getSpsRangeExtension().getHighPrecisionOffsetsEnabledFlag()
+                                ? (1 << sps->getBitDepth(ChannelType::CHROMA)) / 2
+                                : 128;
+            int pred        = (range - ((range * wp[j].codedWeight) >> (wp[j].log2WeightDenom)));
+            int deltaChroma = (wp[j].codedOffset - pred);
+            xWriteSvlc(deltaChroma, (l0 ? "delta_chroma_offset_l0[i]" : "delta_chroma_offset_l1[i]"));
+          }
+        }
+      }
+    }
+  }
+
+  CHECK(totalSignalledWeightFlags > 24, "Too many signalled weight flags");
+}
+
+/** code quantization matrix
+*  \param scalingList quantization matrix information
+*/
+void HLSWriter::codeScalingList( const ScalingList &scalingList, bool aps_chromaPresentFlag )
+{
+  //for each size
+  for (uint32_t scalingListId = 0; scalingListId < 28; scalingListId++)
+  {
+    if (aps_chromaPresentFlag || scalingList.isLumaScalingList(scalingListId))
+    {
+      bool scalingListCopyModeFlag = scalingList.getScalingListCopyModeFlag(scalingListId);
+      xWriteFlag(scalingListCopyModeFlag, "scaling_list_copy_mode_flag");   // copy mode
+      if (!scalingListCopyModeFlag)                                         // Copy Mode
+      {
+        xWriteFlag(scalingList.getScalingListPreditorModeFlag(scalingListId), "scaling_list_predictor_mode_flag");
+      }
+      if ((scalingListCopyModeFlag || scalingList.getScalingListPreditorModeFlag(scalingListId))
+          && scalingListId != SCALING_LIST_1D_START_2x2 && scalingListId != SCALING_LIST_1D_START_4x4
+          && scalingListId != SCALING_LIST_1D_START_8x8)
+      {
+        xWriteUvlc((int) scalingListId - (int) scalingList.getRefMatrixId(scalingListId),
+                   "scaling_list_pred_matrix_id_delta");
+      }
+      if (!scalingListCopyModeFlag)
+      {
+        // DPCM
+        xCodeScalingList(&scalingList, scalingListId, scalingList.getScalingListPreditorModeFlag(scalingListId));
+      }
+    }
+  }
+  return;
+}
+/** code DPCM
+* \param scalingList quantization matrix information
+* \param sizeId      size index
+* \param listId      list index
+*/
+void HLSWriter::xCodeScalingList(const ScalingList* scalingList, uint32_t scalingListId, bool isPredictor)
+{
+  int matrixSize = (scalingListId < SCALING_LIST_1D_START_4x4) ? 2 : ((scalingListId < SCALING_LIST_1D_START_8x8) ? 4 : 8);
+  int coefNum = matrixSize * matrixSize;
+  ScanElement *scan = g_scanOrder[SCAN_UNGROUPED][CoeffScanType::DIAG][gp_sizeIdxInfo->idxFrom(matrixSize)][gp_sizeIdxInfo->idxFrom(matrixSize)];
+  int nextCoef = (isPredictor) ? 0 : SCALING_LIST_START_VALUE;
+
+  int data;
+  const int *src = scalingList->getScalingListAddress(scalingListId);
+  int PredListId = scalingList->getRefMatrixId(scalingListId);
+  const int *srcPred      = (isPredictor)
+                              ? ((scalingListId == PredListId) ? scalingList->getScalingListDefaultAddress(scalingListId)
+                                                               : scalingList->getScalingListAddress(PredListId))
+                              : nullptr;
+  int deltasrc[65] = { 0 };
+
+  if (isPredictor)
+  {
+    if (scalingListId >= SCALING_LIST_1D_START_16x16)
+    {
+      deltasrc[64] = scalingList->getScalingListDC(scalingListId) - ((PredListId >= SCALING_LIST_1D_START_16x16) ? ((scalingListId == PredListId) ? 16 : scalingList->getScalingListDC(PredListId)) : srcPred[scan[0].idx]);
+    }
+    for (int i = 0; i < coefNum; i++)
+    {
+      deltasrc[i] = (src[scan[i].idx] - srcPred[scan[i].idx]);
+    }
+  }
+  if (scalingListId >= SCALING_LIST_1D_START_16x16)
+  {
+    if (isPredictor)
+    {
+      data = deltasrc[64];
+      nextCoef = deltasrc[64];
+    }
+    else
+    {
+      data = scalingList->getScalingListDC(scalingListId) - nextCoef;
+      nextCoef = scalingList->getScalingListDC(scalingListId);
+    }
+    data = ((data + 128) & 255) - 128;
+    xWriteSvlc((int8_t)data, "scaling_list_dc_coef");
+  }
+  for(int i=0;i<coefNum;i++)
+  {
+    if (scalingListId >= SCALING_LIST_1D_START_64x64 && scan[i].x >= 4 && scan[i].y >= 4)
+    {
+      continue;
+    }
+    data = (isPredictor) ? (deltasrc[i] - nextCoef) : (src[scan[i].idx] - nextCoef);
+    nextCoef = (isPredictor) ? deltasrc[i] : src[scan[i].idx];
+    data = ((data + 128) & 255) - 128;
+    xWriteSvlc((int8_t)data, "scaling_list_delta_coef");
+  }
+}
+
+bool HLSWriter::xFindMatchingLTRP(Slice* pcSlice, uint32_t *ltrpsIndex, int ltrpPOC, bool usedFlag)
+{
+  // bool state = true, state2 = false;
+  int lsb = ltrpPOC & ((1<<pcSlice->getSPS()->getBitsForPOC())-1);
+  for (int k = 0; k < pcSlice->getSPS()->getNumLongTermRefPicSPS(); k++)
+  {
+    if ( (lsb == pcSlice->getSPS()->getLtRefPicPocLsbSps(k)) && (usedFlag == pcSlice->getSPS()->getUsedByCurrPicLtSPSFlag(k)) )
+    {
+      *ltrpsIndex = k;
+      return true;
+    }
+  }
+  return false;
+}
+
+
+void HLSWriter::alfFilter( const AlfParam& alfParam, const bool isChroma, const int altIdx )
+{
+  AlfFilterShape alfShape(isChroma ? 5 : 7);
+  const short* coeff = isChroma ? alfParam.chromaCoeff[altIdx] : alfParam.lumaCoeff;
+  const Pel* clipp = isChroma ? alfParam.chromaClipp[altIdx] : alfParam.lumaClipp;
+  const int numFilters = isChroma ? 1 : alfParam.numLumaFilters;
+
+  // vlc for all
+
+  // Filter coefficients
+  for( int ind = 0; ind < numFilters; ++ind )
+  {
+    for( int i = 0; i < alfShape.numCoeff - 1; i++ )
+    {
+      xWriteUvlc( abs(coeff[ ind* MAX_NUM_ALF_LUMA_COEFF + i ]), isChroma ? "alf_chroma_coeff_abs" : "alf_luma_coeff_abs" ); //alf_coeff_chroma[i], alf_coeff_luma_delta[i][j]
+      if( abs( coeff[ ind* MAX_NUM_ALF_LUMA_COEFF + i ] ) != 0 )
+      {
+        xWriteFlag( ( coeff[ ind* MAX_NUM_ALF_LUMA_COEFF + i ] < 0 ) ? 1 : 0, isChroma ? "alf_chroma_coeff_sign" : "alf_luma_coeff_sign" );
+      }
+    }
+  }
+
+  // Clipping values coding
+  if (alfParam.nonLinearFlag[isChroma ? ChannelType::CHROMA : ChannelType::LUMA])
+  {
+    for (int ind = 0; ind < numFilters; ++ind)
+    {
+      for (int i = 0; i < alfShape.numCoeff - 1; i++)
+      {
+        xWriteCode(clipp[ind* MAX_NUM_ALF_LUMA_COEFF + i], 2, isChroma ? "alf_chroma_clip_idx" : "alf_luma_clip_idx");
+      }
+    }
+  }
+}
+
+
+//! \}
diff --git a/source/Lib/SkipLib/VLCWriter.h b/source/Lib/SkipLib/VLCWriter.h
new file mode 100644
index 00000000..915b59f1
--- /dev/null
+++ b/source/Lib/SkipLib/VLCWriter.h
@@ -0,0 +1,142 @@
+/* The copyright in this software is being made available under the BSD
+* License, included below. This software may be subject to other third party
+* and contributor rights, including patent rights, and no such rights are
+* granted under this license.
+*
+* Copyright (c) 2010-2023, ITU/ISO/IEC
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions are met:
+*
+*  * Redistributions of source code must retain the above copyright notice,
+*    this list of conditions and the following disclaimer.
+*  * Redistributions in binary form must reproduce the above copyright notice,
+*    this list of conditions and the following disclaimer in the documentation
+*    and/or other materials provided with the distribution.
+*  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+*    be used to endorse or promote products derived from this software without
+*    specific prior written permission.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+* BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+* THE POSSIBILITY OF SUCH DAMAGE.
+*/
+
+/** \file     VLCWriter.h
+ *  \brief    Writer for high level syntax
+ */
+
+#ifndef __VLCWRITER__
+#define __VLCWRITER__
+
+#include "CommonLib/CommonDef.h"
+#include "CommonLib/BitStream.h"
+#include "CommonLib/Rom.h"
+#include "CommonLib/Slice.h"
+#include "CABACWriter.h"
+
+//! \ingroup EncoderLib
+//! \{
+
+#if ENABLE_TRACING
+extern bool g_HLSTraceEnable;
+#endif
+
+class VLCWriter
+{
+protected:
+
+  OutputBitstream*    m_pcBitIf;
+
+  VLCWriter() : m_pcBitIf(nullptr) {}
+  virtual ~VLCWriter() {}
+
+  void  setBitstream          ( OutputBitstream* p )  { m_pcBitIf = p;  }
+  OutputBitstream* getBitstream( )                    { return m_pcBitIf; }
+
+  void  xWriteSCode         ( int         value, uint32_t  length, const char *symbolName );
+  void  xWriteCode          ( uint32_t    value, uint32_t  length, const char *symbolName );
+  void  xWriteUvlc          ( uint32_t    value,                   const char *symbolName );
+  void  xWriteSvlc          ( int         value,                   const char *symbolName );
+  void  xWriteFlag          ( uint32_t    value,                   const char *symbolName );
+  void  xWriteString        ( const std::string &value,            const char *symbolName );
+
+  void  xWriteRbspTrailingBits();
+  bool isByteAligned()      { return (m_pcBitIf->getNumBitsUntilByteAligned() == 0); } ;
+
+private:
+  void  xWriteVlc           ( uint32_t    value );
+
+};
+
+
+class AUDWriter : public VLCWriter
+{
+public:
+  AUDWriter() {};
+  virtual ~AUDWriter() {};
+
+  void  codeAUD(OutputBitstream& bs, const bool audIrapOrGdrAuFlag, const int pictureType);
+};
+
+class FDWriter : public VLCWriter
+{
+public:
+  FDWriter() {};
+  virtual ~FDWriter() {};
+
+  void  codeFD(OutputBitstream& bs, uint32_t &fdSize);
+};
+
+
+class HLSWriter : public VLCWriter
+{
+public:
+  HLSWriter() {}
+  virtual ~HLSWriter() {}
+
+private:
+  void xCodeRefPicList( const ReferencePictureList* rpl, bool isLongTermPresent, uint32_t ltLsbBitsCount, const bool isForbiddenZeroDeltaPoc, int rplIdx);
+  bool xFindMatchingLTRP        ( Slice* pcSlice, uint32_t *ltrpsIndex, int ltrpPOC, bool usedFlag );
+  void xCodePredWeightTable     ( Slice* pcSlice );
+  void xCodePredWeightTable     ( PicHeader *picHeader, const PPS *pps, const SPS *sps );
+  void xCodeScalingList         ( const ScalingList* scalingList, uint32_t scalinListId, bool isPredictor);
+public:
+  void  setBitstream            ( OutputBitstream* p )  { m_pcBitIf = p;  }
+  uint32_t  getNumberOfWrittenBits  ()                      { return m_pcBitIf->getNumberOfWrittenBits();  }
+  void  codeVUI                 ( const VUI *pcVUI, const SPS* pcSPS );
+  void  codeSPS                 ( const SPS* pcSPS );
+  void  codePPS                 ( const PPS* pcPPS );
+  void  codeAPS                 ( APS* pcAPS );
+  void  codeAlfAps              ( APS* pcAPS );
+  void  codeLmcsAps             ( APS* pcAPS );
+  void  codeScalingListAps      ( APS* pcAPS );
+  void  codeVPS                 ( const VPS* pcVPS );
+  void  codeDCI                 ( const DCI* dci );
+  void  codePictureHeader       ( PicHeader* picHeader, bool writeRbspTrailingBits, Slice *slice = 0 );
+  void  codeSliceHeader         ( Slice* pcSlice, PicHeader *picheader = 0 );
+  void  codeOPI                 ( const OPI* opi );
+  void  codeConstraintInfo      ( const ConstraintInfo* cinfo, const ProfileTierLevel* ptl );
+  void  codeProfileTierLevel    ( const ProfileTierLevel* ptl, bool profileTierPresentFlag, int maxNumSubLayersMinus1 );
+  void  codeOlsHrdParameters(const GeneralHrdParams * generalHrd, const OlsHrdParams *olsHrd , const uint32_t firstSubLayer, const uint32_t maxNumSubLayersMinus1);
+
+  void codeGeneralHrdparameters(const GeneralHrdParams *hrd);
+  void  codeTilesWPPEntryPoint  ( Slice* pSlice );
+  void codeScalingList(const ScalingList &scalingList, bool aps_chromaPresentFlag);
+  void alfFilter( const AlfParam& alfParam, const bool isChroma, const int altIdx );
+  void dpb_parameters(int maxSubLayersMinus1, bool subLayerInfoFlag, const SPS *pcSPS);
+private:
+};
+
+//! \}
+
+#endif
-- 
2.17.1

