From 7b73a8648d9b144577aaf3d12f8ec9b53bec93c5 Mon Sep 17 00:00:00 2001
From: mamingy2 <mingyang.ma@intel.com>
Date: Tue, 23 May 2023 13:21:48 +0800
Subject: [PATCH 2/4] Add skip app

---
 CMakeLists.txt                    |    1 +
 source/App/SkipApp/CMakeLists.txt |   72 ++
 source/App/SkipApp/SkipApp.cpp    | 1611 +++++++++++++++++++++++++++++
 source/App/SkipApp/SkipApp.h      |  128 +++
 source/App/SkipApp/SkipAppCfg.cpp |  257 +++++
 source/App/SkipApp/SkipAppCfg.h   |  114 ++
 source/App/SkipApp/decmain.cpp    |  122 +++
 7 files changed, 2305 insertions(+)
 create mode 100644 source/App/SkipApp/CMakeLists.txt
 create mode 100644 source/App/SkipApp/SkipApp.cpp
 create mode 100644 source/App/SkipApp/SkipApp.h
 create mode 100644 source/App/SkipApp/SkipAppCfg.cpp
 create mode 100644 source/App/SkipApp/SkipAppCfg.h
 create mode 100644 source/App/SkipApp/decmain.cpp

diff --git a/CMakeLists.txt b/CMakeLists.txt
index cb85f8dc..284631a8 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -136,6 +136,7 @@ add_subdirectory( "source/Lib/Utilities" )
 
 add_subdirectory( "source/App/DecoderAnalyserApp" )
 add_subdirectory( "source/App/DecoderApp" )
+add_subdirectory( "source/App/SkipApp" )
 add_subdirectory( "source/App/EncoderApp" )
 add_subdirectory( "source/App/SEIRemovalApp" )
 add_subdirectory( "source/App/SEIFilmGrainApp" )
diff --git a/source/App/SkipApp/CMakeLists.txt b/source/App/SkipApp/CMakeLists.txt
new file mode 100644
index 00000000..6f149da4
--- /dev/null
+++ b/source/App/SkipApp/CMakeLists.txt
@@ -0,0 +1,72 @@
+# executable
+set( EXE_NAME SkipApp )
+
+# get source files
+file( GLOB SRC_FILES "*.cpp" )
+
+# get include files
+file( GLOB INC_FILES "*.h" )
+
+# get additional libs for gcc on Ubuntu systems
+if( CMAKE_SYSTEM_NAME STREQUAL "Linux" )
+  if( CMAKE_CXX_COMPILER_ID STREQUAL "GNU" )
+    if( USE_ADDRESS_SANITIZER )
+      set( ADDITIONAL_LIBS asan )
+    endif()
+  endif()
+endif()
+
+# NATVIS files for Visual Studio
+if( MSVC )
+  file( GLOB NATVIS_FILES "../../VisualStudio/*.natvis" )
+endif()
+
+# add executable
+add_executable( ${EXE_NAME} ${SRC_FILES} ${INC_FILES} ${NATVIS_FILES} )
+include_directories(${CMAKE_CURRENT_BINARY_DIR})
+
+if( DEFINED ENABLE_TRACING )
+  if( ENABLE_TRACING )
+    target_compile_definitions( ${EXE_NAME} PUBLIC ENABLE_TRACING=1 )
+  else()
+    target_compile_definitions( ${EXE_NAME} PUBLIC ENABLE_TRACING=0 )
+  endif()
+endif()
+
+if( DEFINED ENABLE_HIGH_BITDEPTH )
+  if( ENABLE_HIGH_BITDEPTH )
+    target_compile_definitions( ${EXE_NAME} PUBLIC RExt__HIGH_BIT_DEPTH_SUPPORT=1 )
+  else()
+    target_compile_definitions( ${EXE_NAME} PUBLIC RExt__HIGH_BIT_DEPTH_SUPPORT=0 )
+  endif()
+endif()
+
+if( CMAKE_COMPILER_IS_GNUCC AND BUILD_STATIC )
+  set( ADDITIONAL_LIBS ${ADDITIONAL_LIBS} -static -static-libgcc -static-libstdc++ )
+  target_compile_definitions( ${EXE_NAME} PUBLIC ENABLE_WPP_STATIC_LINK=1 )
+endif()
+
+target_link_libraries( ${EXE_NAME} CommonLib DecoderLib Utilities ${ADDITIONAL_LIBS} )
+
+# lldb custom data formatters
+if( XCODE )
+  add_dependencies( ${EXE_NAME} Install${PROJECT_NAME}LldbFiles )
+endif()
+
+if( CMAKE_SYSTEM_NAME STREQUAL "Linux" )
+  add_custom_command( TARGET ${EXE_NAME} POST_BUILD COMMAND ${CMAKE_COMMAND} -E copy
+                                                          $<$<CONFIG:Debug>:${CMAKE_RUNTIME_OUTPUT_DIRECTORY_DEBUG}/SkipApp>
+                                                          $<$<CONFIG:Release>:${CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELEASE}/SkipApp>
+                                                          $<$<CONFIG:RelWithDebInfo>:${CMAKE_RUNTIME_OUTPUT_DIRECTORY_RELWITHDEBINFO}/SkipApp>
+                                                          $<$<CONFIG:MinSizeRel>:${CMAKE_RUNTIME_OUTPUT_DIRECTORY_MINSIZEREL}/SkipApp>
+                                                          $<$<CONFIG:Debug>:${CMAKE_SOURCE_DIR}/bin/SkipAppStaticd>
+                                                          $<$<CONFIG:Release>:${CMAKE_SOURCE_DIR}/bin/SkipAppStatic>
+                                                          $<$<CONFIG:RelWithDebInfo>:${CMAKE_SOURCE_DIR}/bin/SkipAppStaticp>
+                                                          $<$<CONFIG:MinSizeRel>:${CMAKE_SOURCE_DIR}/bin/SkipAppStaticm> )
+endif()
+
+# example: place header files in different folders
+source_group( "Natvis Files" FILES ${NATVIS_FILES} )
+
+# set the folder where to place the projects
+set_target_properties( ${EXE_NAME}  PROPERTIES FOLDER app LINKER_LANGUAGE CXX )
diff --git a/source/App/SkipApp/SkipApp.cpp b/source/App/SkipApp/SkipApp.cpp
new file mode 100644
index 00000000..f6cb0f7c
--- /dev/null
+++ b/source/App/SkipApp/SkipApp.cpp
@@ -0,0 +1,1611 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     SkipApp.cpp
+    \brief    Decoder application class
+*/
+
+#include <list>
+#include <vector>
+#include <stdio.h>
+#include <fcntl.h>
+
+#include "SkipApp.h"
+#include "DecoderLib/AnnexBread.h"
+#include "DecoderLib/NALread.h"
+#if RExt__DECODER_DEBUG_STATISTICS
+#include "CommonLib/CodingStatistics.h"
+#endif
+#include "CommonLib/dtrace_codingstruct.h"
+
+//! \ingroup DecoderApp
+//! \{
+
+static int calcGcd(int a, int b)
+{
+  // assume that a >= b
+  return b == 0 ? a : calcGcd(b, a % b);
+}
+
+
+// ====================================================================================================================
+// Constructor / destructor / initialization / destroy
+// ====================================================================================================================
+
+SkipApp::SkipApp()
+: m_iPOCLastDisplay(-MAX_INT)
+{
+  for (int i = 0; i < MAX_NUM_LAYER_IDS; i++)
+  {
+    m_newCLVS[i] = true;
+  }
+}
+
+// ====================================================================================================================
+// Public member functions
+// ====================================================================================================================
+
+/**
+ - create internal class
+ - initialize internal class
+ - until the end of the bitstream, call decoding function in SkipApp class
+ - delete allocated buffers
+ - destroy internal class
+ - returns the number of mismatching pictures
+ */
+uint32_t SkipApp::decode()
+{
+  int      poc;
+  PicList *pcListPic = nullptr;
+  
+#if GREEN_METADATA_SEI_ENABLED
+  FeatureCounterStruct featureCounter;
+  FeatureCounterStruct featureCounterOld;
+  std::ifstream        bitstreamSize(m_bitstreamFileName.c_str(), std::ifstream::in | std::ifstream::binary);
+  std::streampos fsize = 0;
+  fsize = bitstreamSize.tellg();
+  bitstreamSize.seekg( 0, std::ios::end );
+  featureCounter.bytes = (int) bitstreamSize.tellg() - (int) fsize;
+  bitstreamSize.close();
+#endif
+
+  std::ifstream bitstreamFile(m_bitstreamFileName.c_str(), std::ifstream::in | std::ifstream::binary);
+  if (!bitstreamFile)
+  {
+    EXIT( "Failed to open bitstream file " << m_bitstreamFileName.c_str() << " for reading" ) ;
+  }
+
+  InputByteStream bytestream(bitstreamFile);
+
+  if (!m_outputDecodedSEIMessagesFilename.empty() && m_outputDecodedSEIMessagesFilename!="-")
+  {
+    m_seiMessageFileStream.open(m_outputDecodedSEIMessagesFilename.c_str(), std::ios::out);
+    if (!m_seiMessageFileStream.is_open() || !m_seiMessageFileStream.good())
+    {
+      EXIT( "Unable to open file "<< m_outputDecodedSEIMessagesFilename.c_str() << " for writing decoded SEI messages");
+    }
+  }
+
+  if (!m_oplFilename.empty() && m_oplFilename!="-")
+  {
+    m_oplFileStream.open(m_oplFilename.c_str(), std::ios::out);
+    if (!m_oplFileStream.is_open() || !m_oplFileStream.good())
+    {
+      EXIT( "Unable to open file "<< m_oplFilename.c_str() << " to write an opl-file for conformance testing (see JVET-P2008 for details)");
+    }
+  }
+
+  // create & initialize internal classes
+  xCreateDecLib();
+
+  m_iPOCLastDisplay += m_iSkipFrame;      // set the last displayed POC correctly for skip forward.
+
+  // clear contents of colour-remap-information-SEI output file
+  if (!m_colourRemapSEIFileName.empty())
+  {
+    std::ofstream ofile(m_colourRemapSEIFileName.c_str());
+    if (!ofile.good() || !ofile.is_open())
+    {
+      EXIT( "Unable to open file " << m_colourRemapSEIFileName.c_str() << " for writing colour-remap-information-SEI video");
+    }
+  }
+
+  // clear contents of annotated-Regions-SEI output file
+  if (!m_annotatedRegionsSEIFileName.empty())
+  {
+    std::ofstream ofile(m_annotatedRegionsSEIFileName.c_str());
+    if (!ofile.good() || !ofile.is_open())
+    {
+      fprintf(stderr, "\nUnable to open file '%s' for writing annotated-Regions-SEI\n", m_annotatedRegionsSEIFileName.c_str());
+      exit(EXIT_FAILURE);
+    }
+  }
+
+  // main decoder loop
+  bool loopFiltered[MAX_VPS_LAYERS] = { false };
+
+  bool bPicSkipped = false;
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+  bool openedPostFile = false;
+  setShutterFilterFlag(!m_shutterIntervalPostFileName.empty());   // not apply shutter interval SEI processing if filename is not specified.
+  m_cDecLib.setShutterFilterFlag(getShutterFilterFlag());
+#endif
+
+  bool isEosPresentInPu = false;
+  bool isEosPresentInLastPu = false;
+
+  bool outputPicturePresentInBitstream = false;
+  auto setOutputPicturePresentInStream = [&]()
+  {
+    if( !outputPicturePresentInBitstream )
+    {
+      PicList::iterator iterPic = pcListPic->begin();
+      while (!outputPicturePresentInBitstream && iterPic != pcListPic->end())
+      {
+        Picture *pcPic = *(iterPic++);
+        if (pcPic->neededForOutput)
+        {
+          outputPicturePresentInBitstream = true;
+        }
+      }
+    }
+  };
+
+    m_cDecLib.setHTidExternalSetFlag(m_mTidExternalSet);
+    m_cDecLib.setTOlsIdxExternalFlag(m_tOlsIdxTidExternalSet);
+
+#if GREEN_METADATA_SEI_ENABLED
+    m_cDecLib.setFeatureAnalysisFramewise( m_GMFAFramewise);
+    m_cDecLib.setGMFAFile(m_GMFAFile);
+#endif
+  
+  bool gdrRecoveryPeriod[MAX_NUM_LAYER_IDS] = { false };
+  bool prevPicSkipped = true;
+  int lastNaluLayerId = -1;
+  bool decodedSliceInAU = false;
+
+  while (!!bitstreamFile)
+  {
+    InputNALUnit nalu;
+    nalu.m_nalUnitType = NAL_UNIT_INVALID;
+
+    // determine if next NAL unit will be the first one from a new picture
+    bool bNewPicture = m_cDecLib.isNewPicture(&bitstreamFile, &bytestream);
+    bool bNewAccessUnit = bNewPicture && decodedSliceInAU && m_cDecLib.isNewAccessUnit( bNewPicture, &bitstreamFile, &bytestream );
+    if(!bNewPicture)
+    {
+      AnnexBStats stats = AnnexBStats();
+
+      // find next NAL unit in stream
+      byteStreamNALUnit(bytestream, nalu.getBitstream().getFifo(), stats);
+      if (nalu.getBitstream().getFifo().empty())
+      {
+        /* this can happen if the following occur:
+         *  - empty input file
+         *  - two back-to-back start_code_prefixes
+         *  - start_code_prefix immediately followed by EOF
+         */
+        msg( ERROR, "Warning: Attempt to decode an empty NAL unit\n");
+      }
+      else
+      {
+        // read NAL unit header
+        read(nalu);
+
+        // flush output for first slice of an IDR picture
+        if(m_cDecLib.getFirstSliceInPicture() &&
+            (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL ||
+             nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP))
+        {
+          if (!m_cDecLib.getMixedNaluTypesInPicFlag())
+          {
+            m_newCLVS[nalu.m_nuhLayerId] = true;   // An IDR picture starts a new CLVS
+            xFlushOutput(pcListPic, nalu.m_nuhLayerId);
+          }
+          else
+          {
+            m_newCLVS[nalu.m_nuhLayerId] = false;
+          }
+        }
+        else if (m_cDecLib.getFirstSliceInPicture() && nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA && isEosPresentInLastPu)
+        {
+          // A CRA that is immediately preceded by an EOS is a CLVSS
+          m_newCLVS[nalu.m_nuhLayerId] = true;
+          xFlushOutput(pcListPic, nalu.m_nuhLayerId);
+        }
+        else if (m_cDecLib.getFirstSliceInPicture() && nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA && !isEosPresentInLastPu)
+        {
+          // A CRA that is not immediately precede by an EOS is not a CLVSS
+          m_newCLVS[nalu.m_nuhLayerId] = false;
+        }
+        else if(m_cDecLib.getFirstSliceInPicture() && !isEosPresentInLastPu)
+        {
+          m_newCLVS[nalu.m_nuhLayerId] = false;
+        }
+
+        // parse NAL unit syntax if within target decoding layer
+        if( ( m_iMaxTemporalLayer < 0 || nalu.m_temporalId <= m_iMaxTemporalLayer ) && xIsNaluWithinTargetDecLayerIdSet( &nalu ) )
+        {
+          CHECK(nalu.m_temporalId > m_iMaxTemporalLayer, "bitstream shall not include any NAL unit with TemporalId greater than HighestTid");
+          if (m_targetDecLayerIdSet.size())
+          {
+            CHECK(std::find(m_targetDecLayerIdSet.begin(), m_targetDecLayerIdSet.end(), nalu.m_nuhLayerId) == m_targetDecLayerIdSet.end(), "bitstream shall not contain any other layers than included in the OLS with OlsIdx");
+          }
+          if (bPicSkipped)
+          {
+            if ((nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_TRAIL) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_RASL) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_RADL) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_GDR))
+            {
+              if (decodedSliceInAU && m_cDecLib.isSliceNaluFirstInAU(true, nalu))
+              {
+                m_cDecLib.resetAccessUnitNals();
+                m_cDecLib.resetAccessUnitApsNals();
+                m_cDecLib.resetAccessUnitPicInfo();
+              }
+              bPicSkipped = false;
+            }
+          }
+
+          int skipFrameCounter = m_iSkipFrame;
+          m_cDecLib.decode(nalu, m_iSkipFrame, m_iPOCLastDisplay, m_targetOlsIdx);
+
+          if ( prevPicSkipped && nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_GDR )
+          {
+            gdrRecoveryPeriod[nalu.m_nuhLayerId] = true;
+          }
+
+          if ( skipFrameCounter == 1 && ( nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_GDR  || nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA ))
+          {
+            skipFrameCounter--;
+          }
+
+          if ( m_iSkipFrame < skipFrameCounter  &&
+              ((nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_TRAIL) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_STSA) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_RASL) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_RADL) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_W_RADL) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_IDR_N_LP) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_CRA) || (nalu.m_nalUnitType == NAL_UNIT_CODED_SLICE_GDR)))
+          {
+            if (decodedSliceInAU && m_cDecLib.isSliceNaluFirstInAU(true, nalu))
+            {
+              m_cDecLib.checkSeiInPictureUnit();
+              m_cDecLib.resetPictureSeiNalus();
+              m_cDecLib.checkAPSInPictureUnit();
+              m_cDecLib.resetPictureUnitNals();
+              m_cDecLib.resetAccessUnitSeiTids();
+              m_cDecLib.checkSEIInAccessUnit();
+              m_cDecLib.resetAccessUnitSeiPayLoadTypes();
+              m_cDecLib.resetAccessUnitNals();
+              m_cDecLib.resetAccessUnitApsNals();
+              m_cDecLib.resetAccessUnitPicInfo();
+            }
+            bPicSkipped = true;
+            m_iSkipFrame++;   // skipFrame count restore, the real decrement occur at the begin of next frame
+          }
+
+          if (nalu.m_nalUnitType == NAL_UNIT_OPI)
+          {
+            if (!m_cDecLib.getHTidExternalSetFlag() && m_cDecLib.getOPI()->getHtidInfoPresentFlag())
+            {
+              m_iMaxTemporalLayer = m_cDecLib.getOPI()->getOpiHtidPlus1()-1;
+            }
+            m_cDecLib.setHTidOpiSetFlag(m_cDecLib.getOPI()->getHtidInfoPresentFlag());
+          }
+          if (nalu.m_nalUnitType == NAL_UNIT_VPS)
+          {
+            m_cDecLib.deriveTargetOutputLayerSet( m_cDecLib.getVPS()->m_targetOlsIdx );
+            m_targetDecLayerIdSet = m_cDecLib.getVPS()->m_targetLayerIdSet;
+            m_targetOutputLayerIdSet = m_cDecLib.getVPS()->m_targetOutputLayerIdSet;
+          }
+          if (nalu.isSlice())
+          {
+            decodedSliceInAU = true;
+          }
+        }
+        else
+        {
+          bPicSkipped = true;
+          if (nalu.isSlice())
+          {
+            m_cDecLib.setFirstSliceInPicture(false);
+          }
+        }
+      }
+
+      if( nalu.isSlice() && nalu.m_nalUnitType != NAL_UNIT_CODED_SLICE_RASL)
+      {
+        prevPicSkipped = bPicSkipped;
+      }
+
+      // once an EOS NAL unit appears in the current PU, mark the variable isEosPresentInPu as true
+      if (nalu.m_nalUnitType == NAL_UNIT_EOS)
+      {
+        isEosPresentInPu = true;
+        m_newCLVS[nalu.m_nuhLayerId] = true;  //The presence of EOS means that the next picture is the beginning of new CLVS
+      }
+      // within the current PU, only EOS and EOB are allowed to be sent after an EOS nal unit
+      if(isEosPresentInPu)
+      {
+        CHECK(nalu.m_nalUnitType != NAL_UNIT_EOS && nalu.m_nalUnitType != NAL_UNIT_EOB, "When an EOS NAL unit is present in a PU, it shall be the last NAL unit among all NAL units within the PU other than other EOS NAL units or an EOB NAL unit");
+      }
+      lastNaluLayerId = nalu.m_nuhLayerId;
+    }
+    else
+    {
+      nalu.m_nuhLayerId = lastNaluLayerId;
+    }
+
+    if (bNewPicture || !bitstreamFile || nalu.m_nalUnitType == NAL_UNIT_EOS)
+    {
+      if (!m_cDecLib.getFirstSliceInSequence(nalu.m_nuhLayerId) && !bPicSkipped)
+      {
+        if (!loopFiltered[nalu.m_nuhLayerId] || bitstreamFile)
+        {
+          m_cDecLib.executeLoopFilters();
+          m_cDecLib.finishPicture(poc, pcListPic, INFO, m_newCLVS[nalu.m_nuhLayerId]);
+        }
+        loopFiltered[nalu.m_nuhLayerId] = (nalu.m_nalUnitType == NAL_UNIT_EOS);
+        if (nalu.m_nalUnitType == NAL_UNIT_EOS)
+        {
+          m_cDecLib.setFirstSliceInSequence(true, nalu.m_nuhLayerId);
+        }
+
+        m_cDecLib.updateAssociatedIRAP();
+        m_cDecLib.updatePrevGDRInSameLayer();
+        m_cDecLib.updatePrevIRAPAndGDRSubpic();
+
+        if (gdrRecoveryPeriod[nalu.m_nuhLayerId])
+        {
+          if (m_cDecLib.getGDRRecoveryPocReached())
+          {
+            gdrRecoveryPeriod[nalu.m_nuhLayerId] = false;
+          }
+        }
+      }
+      else
+      {
+        m_cDecLib.setFirstSliceInPicture(true);
+      }
+    }
+
+    if( pcListPic )
+    {
+      if ( gdrRecoveryPeriod[nalu.m_nuhLayerId] ) // Suppress YUV and OPL output during GDR recovery
+      {
+        PicList::iterator iterPic = pcListPic->begin();
+        while (iterPic != pcListPic->end())
+        {
+          Picture *pcPic = *(iterPic++);
+          if (pcPic->layerId == nalu.m_nuhLayerId)
+          {
+            pcPic->neededForOutput = false;
+          }
+        }
+      }
+
+      BitDepths layerOutputBitDepth;
+
+      PicList::iterator iterPicLayer = pcListPic->begin();
+      for (; iterPicLayer != pcListPic->end(); ++iterPicLayer)
+      {
+        if ((*iterPicLayer)->layerId == nalu.m_nuhLayerId)
+        {
+          break;
+        }
+      }
+      if (iterPicLayer != pcListPic->end())
+      {
+        BitDepths &bitDepths = (*iterPicLayer)->m_bitDepths;
+
+        for (auto channelType: { ChannelType::LUMA, ChannelType::CHROMA })
+        {
+          if (m_outputBitDepth[channelType] == 0)
+          {
+            layerOutputBitDepth[channelType] = bitDepths[channelType];
+          }
+          else
+          {
+            layerOutputBitDepth[channelType] = m_outputBitDepth[channelType];
+          }
+        }
+        if (m_packedYUVMode
+            && (layerOutputBitDepth[ChannelType::LUMA] != 10 && layerOutputBitDepth[ChannelType::LUMA] != 12))
+        {
+          EXIT("Invalid output bit-depth for packed YUV output, aborting\n");
+        }
+
+        if (!m_reconFileName.empty() && !m_cVideoIOYuvReconFile[nalu.m_nuhLayerId].isOpen())
+        {
+          std::string reconFileName = m_reconFileName;
+          if (m_reconFileName.compare("/dev/null") && m_cDecLib.getVPS() != nullptr && m_cDecLib.getVPS()->getMaxLayers() > 1 && xIsNaluWithinTargetOutputLayerIdSet(&nalu))
+          {
+            size_t      pos         = reconFileName.find_last_of('.');
+            std::string layerString = std::string(".layer") + std::to_string(nalu.m_nuhLayerId);
+            if (pos != std::string::npos)
+            {
+              reconFileName.insert(pos, layerString);
+            }
+            else
+            {
+              reconFileName.append(layerString);
+            }
+          }
+          if ((m_cDecLib.getVPS() != nullptr && (m_cDecLib.getVPS()->getMaxLayers() == 1 || xIsNaluWithinTargetOutputLayerIdSet(&nalu))) || m_cDecLib.getVPS() == nullptr)
+          {
+            if (isY4mFileExt(reconFileName))
+            {
+              const auto sps        = pcListPic->front()->cs->sps;
+            int        frameRate  = 50;
+              int        frameScale = 1;
+              if(sps->getGeneralHrdParametersPresentFlag())
+              {
+                const auto hrd                 = sps->getGeneralHrdParameters();
+                const auto olsHrdParam         = sps->getOlsHrdParameters()[sps->getMaxTLayers() - 1];
+                int        elementDurationInTc = 1;
+                if (olsHrdParam.getFixedPicRateWithinCvsFlag())
+                {
+                  elementDurationInTc = olsHrdParam.getElementDurationInTcMinus1() + 1;
+                }
+                else
+                {
+                  msg(WARNING, "\nWarning: No fixed picture rate info is found in the bitstream, best guess is used.\n");
+                }
+                frameRate  = hrd->getTimeScale() * elementDurationInTc;
+                frameScale = hrd->getNumUnitsInTick();
+                int gcd    = calcGcd(std::max(frameRate, frameScale), std::min(frameRate, frameScale));
+                frameRate /= gcd;
+                frameScale /= gcd;
+              }
+              else
+              {
+                msg(WARNING, "\nWarning: No frame rate info found in the bitstream, default 50 fps is used.\n");
+              }
+              const auto pps = pcListPic->front()->cs->pps;
+              auto confWindow = pps->getConformanceWindow();
+              const auto sx = SPS::getWinUnitX(sps->getChromaFormatIdc());
+              const auto sy = SPS::getWinUnitY(sps->getChromaFormatIdc());
+              const int picWidth = pps->getPicWidthInLumaSamples() - (confWindow.getWindowLeftOffset() + confWindow.getWindowRightOffset()) * sx;
+              const int picHeight = pps->getPicHeightInLumaSamples() - (confWindow.getWindowTopOffset() + confWindow.getWindowBottomOffset()) * sy;
+              m_cVideoIOYuvReconFile[nalu.m_nuhLayerId].setOutputY4mInfo(picWidth, picHeight, frameRate, frameScale,
+                                                                         layerOutputBitDepth[ChannelType::LUMA],
+                                                                         sps->getChromaFormatIdc());
+            }
+            m_cVideoIOYuvReconFile[nalu.m_nuhLayerId].open(reconFileName, true, layerOutputBitDepth,
+                                                           layerOutputBitDepth, bitDepths);   // write mode
+          }
+        }
+        // update file bitdepth shift if recon bitdepth changed between sequences
+        for (auto channelType: { ChannelType::LUMA, ChannelType::CHROMA })
+        {
+          int reconBitdepth = (*iterPicLayer)->m_bitDepths[( ChannelType) channelType];
+          int fileBitdepth  = m_cVideoIOYuvReconFile[nalu.m_nuhLayerId].getFileBitdepth(channelType);
+          int bitdepthShift = m_cVideoIOYuvReconFile[nalu.m_nuhLayerId].getBitdepthShift(channelType);
+          if (fileBitdepth + bitdepthShift != reconBitdepth)
+          {
+            m_cVideoIOYuvReconFile[nalu.m_nuhLayerId].setBitdepthShift(channelType, reconBitdepth - fileBitdepth);
+          }
+        }
+
+        if (!m_SEIFGSFileName.empty() && !m_videoIOYuvSEIFGSFile[nalu.m_nuhLayerId].isOpen())
+        {
+          std::string SEIFGSFileName = m_SEIFGSFileName;
+          if (m_SEIFGSFileName.compare("/dev/null") && m_cDecLib.getVPS() != nullptr && m_cDecLib.getVPS()->getMaxLayers() > 1 && xIsNaluWithinTargetOutputLayerIdSet(&nalu))
+          {
+            size_t      pos         = SEIFGSFileName.find_last_of('.');
+            std::string layerString = std::string(".layer") + std::to_string(nalu.m_nuhLayerId);
+            if (pos != std::string::npos)
+            {
+              SEIFGSFileName.insert(pos, layerString);
+            }
+            else
+            {
+              SEIFGSFileName.append(layerString);
+            }
+          }
+          if ((m_cDecLib.getVPS() != nullptr && (m_cDecLib.getVPS()->getMaxLayers() == 1 || xIsNaluWithinTargetOutputLayerIdSet(&nalu))) || m_cDecLib.getVPS() == nullptr)
+          {
+            m_videoIOYuvSEIFGSFile[nalu.m_nuhLayerId].open(SEIFGSFileName, true, layerOutputBitDepth,
+                                                           layerOutputBitDepth, bitDepths);   // write mode
+          }
+        }
+        // update file bitdepth shift if recon bitdepth changed between sequences
+        if (!m_SEIFGSFileName.empty())
+        {
+          for (const auto channelType: { ChannelType::LUMA, ChannelType::CHROMA })
+          {
+            int reconBitdepth = (*iterPicLayer)->m_bitDepths[( ChannelType) channelType];
+            int fileBitdepth  = m_videoIOYuvSEIFGSFile[nalu.m_nuhLayerId].getFileBitdepth(channelType);
+            int bitdepthShift = m_videoIOYuvSEIFGSFile[nalu.m_nuhLayerId].getBitdepthShift(channelType);
+            if (fileBitdepth + bitdepthShift != reconBitdepth)
+            {
+              m_videoIOYuvSEIFGSFile[nalu.m_nuhLayerId].setBitdepthShift(channelType, reconBitdepth - fileBitdepth);
+            }
+          }
+        }
+
+        if (!m_SEICTIFileName.empty() && !m_cVideoIOYuvSEICTIFile[nalu.m_nuhLayerId].isOpen())
+        {
+          std::string SEICTIFileName = m_SEICTIFileName;
+          if (m_SEICTIFileName.compare("/dev/null") && m_cDecLib.getVPS() != nullptr && m_cDecLib.getVPS()->getMaxLayers() > 1 && xIsNaluWithinTargetOutputLayerIdSet(&nalu))
+          {
+            size_t pos = SEICTIFileName.find_last_of('.');
+            if (pos != std::string::npos)
+            {
+              SEICTIFileName.insert(pos, std::to_string(nalu.m_nuhLayerId));
+            }
+            else
+            {
+              SEICTIFileName.append(std::to_string(nalu.m_nuhLayerId));
+            }
+          }
+          if ((m_cDecLib.getVPS() != nullptr && (m_cDecLib.getVPS()->getMaxLayers() == 1 || xIsNaluWithinTargetOutputLayerIdSet(&nalu))) || m_cDecLib.getVPS() == nullptr)
+          {
+            m_cVideoIOYuvSEICTIFile[nalu.m_nuhLayerId].open(SEICTIFileName, true, layerOutputBitDepth,
+                                                            layerOutputBitDepth, bitDepths);   // write mode
+          }
+        }
+      }
+      if (!m_annotatedRegionsSEIFileName.empty())
+      {
+        xOutputAnnotatedRegions(pcListPic);
+      }
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+      PicList::iterator iterPic = pcListPic->begin();
+      Picture* pcPic = *(iterPic);
+      SEIMessages       shutterIntervalInfo = getSeisByType(pcPic->SEIs, SEI::PayloadType::SHUTTER_INTERVAL_INFO);
+
+      if (!m_shutterIntervalPostFileName.empty())
+      {
+        bool                    hasValidSII = true;
+        SEIShutterIntervalInfo *curSIIInfo  = nullptr;
+        if ((pcPic->getPictureType() == NAL_UNIT_CODED_SLICE_IDR_W_RADL ||
+          pcPic->getPictureType() == NAL_UNIT_CODED_SLICE_IDR_N_LP) && m_newCLVS[nalu.m_nuhLayerId])
+        {
+          IdrSiiInfo curSII;
+          curSII.m_picPoc = pcPic->getPOC();
+
+          curSII.m_isValidSii                             = false;
+          curSII.m_siiInfo.m_siiEnabled                   = false;
+          curSII.m_siiInfo.m_siiNumUnitsInShutterInterval = 0;
+          curSII.m_siiInfo.m_siiTimeScale = 0;
+          curSII.m_siiInfo.m_siiMaxSubLayersMinus1 = 0;
+          curSII.m_siiInfo.m_siiFixedSIwithinCLVS = 0;
+
+          if (shutterIntervalInfo.size() > 0)
+          {
+            SEIShutterIntervalInfo *seiShutterIntervalInfo = (SEIShutterIntervalInfo*) *(shutterIntervalInfo.begin());
+            curSII.m_isValidSii                            = true;
+
+            curSII.m_siiInfo.m_siiEnabled = seiShutterIntervalInfo->m_siiEnabled;
+            curSII.m_siiInfo.m_siiNumUnitsInShutterInterval = seiShutterIntervalInfo->m_siiNumUnitsInShutterInterval;
+            curSII.m_siiInfo.m_siiTimeScale = seiShutterIntervalInfo->m_siiTimeScale;
+            curSII.m_siiInfo.m_siiMaxSubLayersMinus1 = seiShutterIntervalInfo->m_siiMaxSubLayersMinus1;
+            curSII.m_siiInfo.m_siiFixedSIwithinCLVS = seiShutterIntervalInfo->m_siiFixedSIwithinCLVS;
+            curSII.m_siiInfo.m_siiSubLayerNumUnitsInSI.clear();
+            for (int i = 0; i < seiShutterIntervalInfo->m_siiSubLayerNumUnitsInSI.size(); i++)
+            {
+              curSII.m_siiInfo.m_siiSubLayerNumUnitsInSI.push_back(seiShutterIntervalInfo->m_siiSubLayerNumUnitsInSI[i]);
+            }
+
+            uint32_t tmpInfo = (uint32_t)(m_activeSiiInfo.size() + 1);
+            m_activeSiiInfo.insert(std::pair<uint32_t, IdrSiiInfo>(tmpInfo, curSII));
+            curSIIInfo = seiShutterIntervalInfo;
+          }
+          else
+          {
+            curSII.m_isValidSii = false;
+            hasValidSII         = false;
+            uint32_t tmpInfo = (uint32_t)(m_activeSiiInfo.size() + 1);
+            m_activeSiiInfo.insert(std::pair<uint32_t, IdrSiiInfo>(tmpInfo, curSII));
+          }
+        }
+        else
+        {
+          if (m_activeSiiInfo.size() == 1)
+          {
+            curSIIInfo = &(m_activeSiiInfo.begin()->second.m_siiInfo);
+          }
+          else
+          {
+            bool isLast = true;
+            for (int i = 1; i < m_activeSiiInfo.size() + 1; i++)
+            {
+              if (pcPic->getPOC() <= m_activeSiiInfo.at(i).m_picPoc)
+              {
+                if (m_activeSiiInfo[i - 1].m_isValidSii)
+                {
+                  curSIIInfo = &(m_activeSiiInfo.at(i - 1).m_siiInfo);
+                }
+                else
+                {
+                  hasValidSII = false;
+                }
+                isLast = false;
+                break;
+              }
+            }
+            if (isLast)
+            {
+              uint32_t tmpInfo = (uint32_t)(m_activeSiiInfo.size());
+              curSIIInfo = &(m_activeSiiInfo.at(tmpInfo).m_siiInfo);
+            }
+          }
+        }
+
+        if (hasValidSII)
+        {
+          if (!curSIIInfo->m_siiFixedSIwithinCLVS)
+          {
+            uint32_t siiMaxSubLayersMinus1 = curSIIInfo->m_siiMaxSubLayersMinus1;
+            uint32_t numUnitsLFR = curSIIInfo->m_siiSubLayerNumUnitsInSI[0];
+            uint32_t numUnitsHFR = curSIIInfo->m_siiSubLayerNumUnitsInSI[siiMaxSubLayersMinus1];
+
+            int blending_ratio = (numUnitsLFR / numUnitsHFR);
+            bool checkEqualValuesOfSFR = true;
+            bool checkSubLayerSI       = false;
+            int i;
+
+            //supports only the case of SFR = HFR / 2
+            if (curSIIInfo->m_siiSubLayerNumUnitsInSI[siiMaxSubLayersMinus1] <
+                        curSIIInfo->m_siiSubLayerNumUnitsInSI[siiMaxSubLayersMinus1 - 1])
+            {
+              checkSubLayerSI = true;
+            }
+            else
+            {
+              fprintf(stderr, "Warning: Shutter Interval SEI message processing is disabled due to SFR != (HFR / 2) \n");
+            }
+            //check shutter interval for all sublayer remains same for SFR pictures
+            for (i = 1; i < siiMaxSubLayersMinus1; i++)
+            {
+              if (curSIIInfo->m_siiSubLayerNumUnitsInSI[0] != curSIIInfo->m_siiSubLayerNumUnitsInSI[i])
+              {
+                checkEqualValuesOfSFR = false;
+              }
+            }
+            if (!checkEqualValuesOfSFR)
+            {
+              fprintf(stderr, "Warning: Shutter Interval SEI message processing is disabled when shutter interval is not same for SFR sublayers \n");
+            }
+            if (checkSubLayerSI && checkEqualValuesOfSFR)
+            {
+              setShutterFilterFlag(numUnitsLFR == blending_ratio * numUnitsHFR);
+              setBlendingRatio(blending_ratio);
+            }
+            else
+            {
+              setShutterFilterFlag(false);
+            }
+
+            const SPS* activeSPS = pcListPic->front()->cs->sps;
+
+            if (numUnitsLFR == blending_ratio * numUnitsHFR && activeSPS->getMaxTLayers() == 1 && activeSPS->getMaxDecPicBuffering(0) == 1)
+            {
+              fprintf(stderr, "Warning: Shutter Interval SEI message processing is disabled for single TempLayer and single frame in DPB\n");
+              setShutterFilterFlag(false);
+            }
+          }
+          else
+          {
+            fprintf(stderr, "Warning: Shutter Interval SEI message processing is disabled for fixed shutter interval case\n");
+            setShutterFilterFlag(false);
+          }
+        }
+        else
+        {
+          fprintf(stderr, "Warning: Shutter Interval information should be specified in SII-SEI message\n");
+          setShutterFilterFlag(false);
+        }
+      }
+
+
+      if (iterPicLayer != pcListPic->end())
+      {
+        if ((!m_shutterIntervalPostFileName.empty()) && (!openedPostFile) && getShutterFilterFlag())
+        {
+          BitDepths &bitDepths = (*iterPicLayer)->m_bitDepths;
+          std::ofstream ofile(m_shutterIntervalPostFileName.c_str());
+          if (!ofile.good() || !ofile.is_open())
+          {
+            fprintf(stderr, "\nUnable to open file '%s' for writing shutter-interval-SEI video\n", m_shutterIntervalPostFileName.c_str());
+            exit(EXIT_FAILURE);
+          }
+          m_cTVideoIOYuvSIIPostFile.open(m_shutterIntervalPostFileName, true, layerOutputBitDepth, layerOutputBitDepth,
+                                         bitDepths);   // write mode
+          openedPostFile = true;
+        }
+      }
+#endif
+
+      // write reconstruction to file
+      if( bNewPicture )
+      {
+        setOutputPicturePresentInStream();
+        xWriteOutput( pcListPic, nalu.m_temporalId );
+      }
+      if (nalu.m_nalUnitType == NAL_UNIT_EOS)
+      {
+        if (!m_annotatedRegionsSEIFileName.empty() && bNewPicture)
+        {
+          xOutputAnnotatedRegions(pcListPic);
+        }
+        setOutputPicturePresentInStream();
+        xWriteOutput( pcListPic, nalu.m_temporalId );
+        m_cDecLib.setFirstSliceInPicture (false);
+      }
+      // write reconstruction to file -- for additional bumping as defined in C.5.2.3
+      if (!bNewPicture && ((nalu.m_nalUnitType >= NAL_UNIT_CODED_SLICE_TRAIL && nalu.m_nalUnitType <= NAL_UNIT_RESERVED_IRAP_VCL_11)
+        || (nalu.m_nalUnitType >= NAL_UNIT_CODED_SLICE_IDR_W_RADL && nalu.m_nalUnitType <= NAL_UNIT_CODED_SLICE_GDR)))
+      {
+        setOutputPicturePresentInStream();
+        xWriteOutput( pcListPic, nalu.m_temporalId );
+      }
+    }
+    if( bNewPicture )
+    {
+      m_cDecLib.checkSeiInPictureUnit();
+      m_cDecLib.resetPictureSeiNalus();
+      // reset the EOS present status for the next PU check
+      isEosPresentInLastPu = isEosPresentInPu;
+      isEosPresentInPu = false;
+    }
+    if (bNewPicture || !bitstreamFile || nalu.m_nalUnitType == NAL_UNIT_EOS)
+    {
+      m_cDecLib.checkAPSInPictureUnit();
+      m_cDecLib.resetPictureUnitNals();
+    }
+    if (bNewAccessUnit || !bitstreamFile)
+    {
+      m_cDecLib.CheckNoOutputPriorPicFlagsInAccessUnit();
+      m_cDecLib.resetAccessUnitNoOutputPriorPicFlags();
+      m_cDecLib.checkLayerIdIncludedInCvss();
+      m_cDecLib.checkSEIInAccessUnit();
+      m_cDecLib.resetAccessUnitNestedSliSeiInfo();
+      m_cDecLib.resetIsFirstAuInCvs();
+      m_cDecLib.resetAccessUnitEos();
+      m_cDecLib.resetAudIrapOrGdrAuFlag();
+    }
+    if(bNewAccessUnit)
+    {
+      decodedSliceInAU = false;
+      m_cDecLib.checkTidLayerIdInAccessUnit();
+      m_cDecLib.resetAccessUnitSeiTids();
+      m_cDecLib.resetAccessUnitSeiPayLoadTypes();
+      m_cDecLib.checkSeiContentInAccessUnit();
+      m_cDecLib.resetAccessUnitSeiNalus();
+      m_cDecLib.resetAccessUnitNals();
+      m_cDecLib.resetAccessUnitApsNals();
+      m_cDecLib.resetAccessUnitPicInfo();
+    }
+#if GREEN_METADATA_SEI_ENABLED
+    if (m_GMFA && m_GMFAFramewise && bNewPicture)
+    {
+      FeatureCounterStruct featureCounterUpdated = m_cDecLib.getFeatureCounter();
+      writeGMFAOutput(featureCounterUpdated, featureCounterOld, m_GMFAFile,false);
+      featureCounterOld = m_cDecLib.getFeatureCounter();
+    }
+#endif
+  }
+  if (!m_annotatedRegionsSEIFileName.empty())
+  {
+    xOutputAnnotatedRegions(pcListPic);
+  }
+  // May need to check again one more time as in case one the bitstream has only one picture, the first check may miss it
+  setOutputPicturePresentInStream();
+  CHECK(!outputPicturePresentInBitstream, "It is required that there shall be at least one picture with PictureOutputFlag equal to 1 in the bitstream")
+  
+#if GREEN_METADATA_SEI_ENABLED
+  if (m_GMFA && m_GMFAFramewise) //Last frame
+  {
+    FeatureCounterStruct featureCounterUpdated = m_cDecLib.getFeatureCounter();
+    writeGMFAOutput(featureCounterUpdated, featureCounterOld, m_GMFAFile, false);
+    featureCounterOld = m_cDecLib.getFeatureCounter();
+  }
+  
+  if (m_GMFA)
+  {
+    // Summary
+    FeatureCounterStruct featureCounterFinal = m_cDecLib.getFeatureCounter();
+    FeatureCounterStruct dummy;
+    writeGMFAOutput(featureCounterFinal, dummy, m_GMFAFile, true);
+  }
+#endif
+
+#if JVET_AC0074_USE_OF_NNPFC_FOR_PIC_RATE_UPSAMPLING
+  m_cDecLib.applyNnPostFilter();
+#endif
+  
+  xFlushOutput( pcListPic );
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+  if (!m_shutterIntervalPostFileName.empty() && getShutterFilterFlag())
+  {
+    m_cTVideoIOYuvSIIPostFile.close();
+  }
+#endif
+
+  // get the number of checksum errors
+  uint32_t nRet = m_cDecLib.getNumberOfChecksumErrorsDetected();
+
+  // delete buffers
+  m_cDecLib.deletePicBuffer();
+  // destroy internal classes
+  xDestroyDecLib();
+
+#if RExt__DECODER_DEBUG_STATISTICS
+  CodingStatistics::DestroyInstance();
+#endif
+
+  destroyROM();
+
+  return nRet;
+}
+
+
+
+void SkipApp::writeLineToOutputLog(Picture * pcPic)
+{
+  if (m_oplFileStream.is_open() && m_oplFileStream.good())
+  {
+    const SPS *   sps             = pcPic->cs->sps;
+    ChromaFormat  chromaFormatIdc = sps->getChromaFormatIdc();
+    const Window &conf            = pcPic->getConformanceWindow();
+    const int     leftOffset      = conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc);
+    const int     rightOffset     = conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc);
+    const int     topOffset       = conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc);
+    const int     bottomOffset    = conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc);
+    PictureHash   recon_digest;
+    auto numChar = calcMD5WithCropping(((const Picture *) pcPic)->getRecoBuf(), recon_digest, sps->getBitDepths(),
+                                       leftOffset, rightOffset, topOffset, bottomOffset);
+
+    const int croppedWidth  = pcPic->Y().width - leftOffset - rightOffset;
+    const int croppedHeight = pcPic->Y().height - topOffset - bottomOffset;
+
+    m_oplFileStream << std::setw(3) << pcPic->layerId << ",";
+    m_oplFileStream << std::setw(8) << pcPic->getPOC() << "," << std::setw(5) << croppedWidth << "," << std::setw(5)
+                    << croppedHeight << "," << hashToString(recon_digest, numChar) << "\n";
+  }
+}
+
+// ====================================================================================================================
+// Protected member functions
+// ====================================================================================================================
+
+void SkipApp::xCreateDecLib()
+{
+  initROM();
+
+  // create decoder class
+  m_cDecLib.create();
+
+  // initialize decoder class
+  m_cDecLib.init(
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+    m_cacheCfgFile
+#endif
+  );
+  m_cDecLib.setDecodedPictureHashSEIEnabled(m_decodedPictureHashSEIEnabled);
+
+
+  if (!m_outputDecodedSEIMessagesFilename.empty())
+  {
+    std::ostream &os=m_seiMessageFileStream.is_open() ? m_seiMessageFileStream : std::cout;
+    m_cDecLib.setDecodedSEIMessageOutputStream(&os);
+  }
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+  if (!m_outputDecoded360SEIMessagesFilename.empty())
+  {
+    m_cDecLib.setDecoded360SEIMessageFileName(m_outputDecoded360SEIMessagesFilename);
+  }
+#endif
+  m_cDecLib.m_targetSubPicIdx = this->m_targetSubPicIdx;
+  m_cDecLib.initScalingList();
+#if GDR_LEAK_TEST
+  m_cDecLib.m_gdrPocRandomAccess = this->m_gdrPocRandomAccess;
+#endif // GDR_LEAK_TEST
+}
+
+void SkipApp::xDestroyDecLib()
+{
+  if( !m_reconFileName.empty() )
+  {
+    for( auto & recFile : m_cVideoIOYuvReconFile )
+    {
+      recFile.second.close();
+    }
+  }
+  if (!m_SEIFGSFileName.empty())
+  {
+    for (auto &recFile: m_videoIOYuvSEIFGSFile)
+    {
+      recFile.second.close();
+    }
+  }
+  if (!m_SEICTIFileName.empty())
+  {
+    for (auto& recFile : m_cVideoIOYuvSEICTIFile)
+    {
+      recFile.second.close();
+    }
+  }
+
+  // destroy decoder class
+  m_cDecLib.destroy();
+}
+
+
+/** \param pcListPic list of pictures to be written to file
+    \param tId       temporal sub-layer ID
+ */
+void SkipApp::xWriteOutput( PicList* pcListPic, uint32_t tId )
+{
+  if (pcListPic->empty())
+  {
+    return;
+  }
+
+  PicList::iterator iterPic   = pcListPic->begin();
+  int numPicsNotYetDisplayed = 0;
+  int dpbFullness = 0;
+  uint32_t maxNumReorderPicsHighestTid;
+  uint32_t maxDecPicBufferingHighestTid;
+  const VPS* referredVPS = pcListPic->front()->cs->vps;
+
+  if( referredVPS == nullptr || referredVPS->m_numLayersInOls[referredVPS->m_targetOlsIdx] == 1 )
+  {
+    const SPS* activeSPS = (pcListPic->front()->cs->sps);
+    const int temporalId = (m_iMaxTemporalLayer == -1 || m_iMaxTemporalLayer >= activeSPS->getMaxTLayers())
+      ? activeSPS->getMaxTLayers() - 1
+      : m_iMaxTemporalLayer;
+    maxNumReorderPicsHighestTid = activeSPS->getMaxNumReorderPics( temporalId );
+    maxDecPicBufferingHighestTid = activeSPS->getMaxDecPicBuffering( temporalId );
+  }
+  else
+  {
+    const int temporalId = (m_iMaxTemporalLayer == -1 || m_iMaxTemporalLayer >= referredVPS->getMaxSubLayers())
+      ? referredVPS->getMaxSubLayers() - 1
+      : m_iMaxTemporalLayer;
+    maxNumReorderPicsHighestTid = referredVPS->getMaxNumReorderPics( temporalId );
+    maxDecPicBufferingHighestTid = referredVPS->getMaxDecPicBuffering( temporalId );
+  }
+
+  while (iterPic != pcListPic->end())
+  {
+    Picture* pcPic = *(iterPic);
+    if(pcPic->neededForOutput && pcPic->getPOC() >= m_iPOCLastDisplay)
+    {
+      numPicsNotYetDisplayed++;
+      dpbFullness++;
+    }
+    else if(pcPic->referenced)
+    {
+      dpbFullness++;
+    }
+    iterPic++;
+  }
+
+  iterPic = pcListPic->begin();
+
+  if (numPicsNotYetDisplayed>2)
+  {
+    iterPic++;
+  }
+
+  Picture* pcPic = *(iterPic);
+  if( numPicsNotYetDisplayed>2 && pcPic->fieldPic ) //Field Decoding
+  {
+    PicList::iterator endPic   = pcListPic->end();
+    endPic--;
+    iterPic   = pcListPic->begin();
+    while (iterPic != endPic)
+    {
+      Picture* pcPicTop = *(iterPic);
+      iterPic++;
+      Picture* pcPicBottom = *(iterPic);
+
+      if ( pcPicTop->neededForOutput && pcPicBottom->neededForOutput &&
+          (numPicsNotYetDisplayed >  maxNumReorderPicsHighestTid || dpbFullness > maxDecPicBufferingHighestTid) &&
+          (!(pcPicTop->getPOC()%2) && pcPicBottom->getPOC() == pcPicTop->getPOC()+1) &&
+          (pcPicTop->getPOC() == m_iPOCLastDisplay+1 || m_iPOCLastDisplay < 0))
+      {
+        // write to file
+        numPicsNotYetDisplayed = numPicsNotYetDisplayed-2;
+        if ( !m_reconFileName.empty() )
+        {
+          const Window &conf = pcPicTop->getConformanceWindow();
+          const bool isTff = pcPicTop->topField;
+
+          bool display = true;
+
+          if (display)
+          {
+            m_cVideoIOYuvReconFile[pcPicTop->layerId].write(
+              pcPicTop->getRecoBuf(), pcPicBottom->getRecoBuf(), m_outputColourSpaceConvert,
+              false,   // TODO: m_packedYUVMode,
+              conf.getWindowLeftOffset() * SPS::getWinUnitX(pcPicTop->cs->sps->getChromaFormatIdc()),
+              conf.getWindowRightOffset() * SPS::getWinUnitX(pcPicTop->cs->sps->getChromaFormatIdc()),
+              conf.getWindowTopOffset() * SPS::getWinUnitY(pcPicTop->cs->sps->getChromaFormatIdc()),
+              conf.getWindowBottomOffset() * SPS::getWinUnitY(pcPicTop->cs->sps->getChromaFormatIdc()),
+              ChromaFormat::UNDEFINED, isTff);
+          }
+        }
+        writeLineToOutputLog(pcPicTop);
+        writeLineToOutputLog(pcPicBottom);
+
+        // update POC of display order
+        m_iPOCLastDisplay = pcPicBottom->getPOC();
+
+        // erase non-referenced picture in the reference picture list after display
+        if ( ! pcPicTop->referenced && pcPicTop->reconstructed )
+        {
+          pcPicTop->reconstructed = false;
+        }
+        if ( ! pcPicBottom->referenced && pcPicBottom->reconstructed )
+        {
+          pcPicBottom->reconstructed = false;
+        }
+        pcPicTop->neededForOutput = false;
+        pcPicBottom->neededForOutput = false;
+      }
+    }
+  }
+  else if( !pcPic->fieldPic ) //Frame Decoding
+  {
+    iterPic = pcListPic->begin();
+
+    while (iterPic != pcListPic->end())
+    {
+      pcPic = *(iterPic);
+
+      if(pcPic->neededForOutput && pcPic->getPOC() >= m_iPOCLastDisplay &&
+        (numPicsNotYetDisplayed >  maxNumReorderPicsHighestTid || dpbFullness > maxDecPicBufferingHighestTid))
+      {
+        // write to file
+        numPicsNotYetDisplayed--;
+        if (!pcPic->referenced)
+        {
+          dpbFullness--;
+        }
+
+
+        if (!m_reconFileName.empty())
+        {
+          const Window &conf = pcPic->getConformanceWindow();
+          ChromaFormat  chromaFormatIdc = pcPic->m_chromaFormatIdc;
+          if( m_upscaledOutput )
+          {
+            const SPS* sps = pcPic->cs->sps;
+            m_cVideoIOYuvReconFile[pcPic->layerId].writeUpscaledPicture(
+              *sps, *pcPic->cs->pps, pcPic->getRecoBuf(), m_outputColourSpaceConvert, m_packedYUVMode, m_upscaledOutput,
+              ChromaFormat::UNDEFINED, m_clipOutputVideoToRec709Range, m_upscaleFilterForDisplay);
+          }
+          else
+          {
+            m_cVideoIOYuvReconFile[pcPic->layerId].write(
+              pcPic->getRecoBuf().get(COMPONENT_Y).width, pcPic->getRecoBuf().get(COMPONENT_Y).height,
+              pcPic->getRecoBuf(), m_outputColourSpaceConvert, m_packedYUVMode,
+              conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc),
+              conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc),
+              conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc),
+              conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc), ChromaFormat::UNDEFINED,
+              m_clipOutputVideoToRec709Range);
+            }
+        }
+        // Perform FGS on decoded frame and write to output FGS file
+        if (!m_SEIFGSFileName.empty())
+        {
+          const Window& conf            = pcPic->getConformanceWindow();
+          const SPS* sps                = pcPic->cs->sps;
+          ChromaFormat  chromaFormatIdc    = sps->getChromaFormatIdc();
+          if (m_upscaledOutput)
+          {
+            m_videoIOYuvSEIFGSFile[pcPic->layerId].writeUpscaledPicture(
+              *sps, *pcPic->cs->pps, pcPic->getDisplayBufFG(), m_outputColourSpaceConvert, m_packedYUVMode,
+              m_upscaledOutput, ChromaFormat::UNDEFINED, m_clipOutputVideoToRec709Range, m_upscaleFilterForDisplay);
+          }
+          else
+          {
+            m_videoIOYuvSEIFGSFile[pcPic->layerId].write(
+              pcPic->getRecoBuf().get(COMPONENT_Y).width, pcPic->getRecoBuf().get(COMPONENT_Y).height,
+              pcPic->getDisplayBufFG(), m_outputColourSpaceConvert, m_packedYUVMode,
+              conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc),
+              conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc),
+              conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc),
+              conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc), ChromaFormat::UNDEFINED,
+              m_clipOutputVideoToRec709Range);
+          }
+        }
+
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+        if (!m_shutterIntervalPostFileName.empty() && getShutterFilterFlag())
+        {
+          int blendingRatio = getBlendingRatio();
+          pcPic->xOutputPostFilteredPic(pcPic, pcListPic, blendingRatio);
+
+          const Window &conf = pcPic->getConformanceWindow();
+          const SPS* sps = pcPic->cs->sps;
+          ChromaFormat  chromaFormatIdc = sps->getChromaFormatIdc();
+
+          m_cTVideoIOYuvSIIPostFile.write(pcPic->getPostRecBuf().get(COMPONENT_Y).width,
+                                          pcPic->getPostRecBuf().get(COMPONENT_Y).height, pcPic->getPostRecBuf(),
+                                          m_outputColourSpaceConvert, m_packedYUVMode,
+                                          conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                                          conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                                          conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc),
+                                          conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc),
+                                          ChromaFormat::UNDEFINED, m_clipOutputVideoToRec709Range);
+        }
+#endif
+
+        // Perform CTI on decoded frame and write to output CTI file
+        if (!m_SEICTIFileName.empty())
+        {
+          const Window& conf = pcPic->getConformanceWindow();
+          const SPS* sps = pcPic->cs->sps;
+          ChromaFormat  chromaFormatIdc = sps->getChromaFormatIdc();
+          if (m_upscaledOutput)
+          {
+            m_cVideoIOYuvSEICTIFile[pcPic->layerId].writeUpscaledPicture(
+              *sps, *pcPic->cs->pps, pcPic->getDisplayBuf(), m_outputColourSpaceConvert, m_packedYUVMode,
+              m_upscaledOutput, ChromaFormat::UNDEFINED, m_clipOutputVideoToRec709Range, m_upscaleFilterForDisplay);
+          }
+          else
+          {
+            m_cVideoIOYuvSEICTIFile[pcPic->layerId].write(
+              pcPic->getRecoBuf().get(COMPONENT_Y).width, pcPic->getRecoBuf().get(COMPONENT_Y).height,
+              pcPic->getDisplayBuf(), m_outputColourSpaceConvert, m_packedYUVMode,
+              conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc),
+              conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc),
+              conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc),
+              conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc), ChromaFormat::UNDEFINED,
+              m_clipOutputVideoToRec709Range);
+          }
+        }
+        writeLineToOutputLog(pcPic);
+
+        // update POC of display order
+        m_iPOCLastDisplay = pcPic->getPOC();
+
+        // erase non-referenced picture in the reference picture list after display
+        if (!pcPic->referenced && pcPic->reconstructed)
+        {
+          pcPic->reconstructed = false;
+        }
+        pcPic->neededForOutput = false;
+      }
+
+      iterPic++;
+    }
+  }
+}
+
+/** \param pcListPic list of pictures to be written to file
+ */
+void SkipApp::xFlushOutput( PicList* pcListPic, const int layerId )
+{
+  if(!pcListPic || pcListPic->empty())
+  {
+    return;
+  }
+  PicList::iterator iterPic   = pcListPic->begin();
+
+  iterPic   = pcListPic->begin();
+  Picture* pcPic = *(iterPic);
+
+  if (pcPic->fieldPic ) //Field Decoding
+  {
+    PicList::iterator endPic = pcListPic->end();
+    while (iterPic != endPic)
+    {
+      Picture *pcPicTop = *iterPic;
+      iterPic++;
+      Picture *pcPicBottom = iterPic == endPic ? pcPicTop : *iterPic;
+
+      if( pcPicTop->layerId != layerId && layerId != NOT_VALID )
+      {
+        continue;
+      }
+
+      if ( pcPicTop->neededForOutput && pcPicBottom->neededForOutput && !(pcPicTop->getPOC()%2) && (pcPicBottom->getPOC() == pcPicTop->getPOC()+1) )
+      {
+          // write to file
+          if ( !m_reconFileName.empty() )
+          {
+            const Window &conf = pcPicTop->getConformanceWindow();
+            const bool    isTff   = pcPicTop->topField;
+
+            m_cVideoIOYuvReconFile[pcPicTop->layerId].write(
+              pcPicTop->getRecoBuf(), pcPicBottom->getRecoBuf(), m_outputColourSpaceConvert,
+              false,   // TODO: m_packedYUVMode,
+              conf.getWindowLeftOffset() * SPS::getWinUnitX(pcPicTop->cs->sps->getChromaFormatIdc()),
+              conf.getWindowRightOffset() * SPS::getWinUnitX(pcPicTop->cs->sps->getChromaFormatIdc()),
+              conf.getWindowTopOffset() * SPS::getWinUnitY(pcPicTop->cs->sps->getChromaFormatIdc()),
+              conf.getWindowBottomOffset() * SPS::getWinUnitY(pcPicTop->cs->sps->getChromaFormatIdc()),
+              ChromaFormat::UNDEFINED, isTff);
+          }
+          writeLineToOutputLog(pcPicTop);
+          writeLineToOutputLog(pcPicBottom);
+        // update POC of display order
+        m_iPOCLastDisplay = pcPicBottom->getPOC();
+
+        // erase non-referenced picture in the reference picture list after display
+        if( ! pcPicTop->referenced && pcPicTop->reconstructed )
+        {
+          pcPicTop->reconstructed = false;
+        }
+        if( ! pcPicBottom->referenced && pcPicBottom->reconstructed )
+        {
+          pcPicBottom->reconstructed = false;
+        }
+        pcPicTop->neededForOutput = false;
+        pcPicBottom->neededForOutput = false;
+
+        pcPicTop->destroy();
+        delete pcPicTop;
+        pcPicBottom->destroy();
+        delete pcPicBottom;
+        iterPic--;
+        *iterPic = nullptr;
+        iterPic++;
+        *iterPic = nullptr;
+        iterPic++;
+      }
+      else
+      {
+        pcPicTop->destroy();
+        delete pcPicTop;
+        iterPic--;
+        *iterPic = nullptr;
+        iterPic++;
+      }
+    }
+  }
+  else //Frame decoding
+  {
+    while (iterPic != pcListPic->end())
+    {
+      pcPic = *(iterPic);
+
+      if( pcPic->layerId != layerId && layerId != NOT_VALID )
+      {
+        iterPic++;
+        continue;
+      }
+
+      if (pcPic->neededForOutput)
+      {
+          // write to file
+          if (!m_reconFileName.empty())
+          {
+            const Window &conf = pcPic->getConformanceWindow();
+            ChromaFormat  chromaFormatIdc = pcPic->m_chromaFormatIdc;
+            if( m_upscaledOutput )
+            {
+              const SPS* sps = pcPic->cs->sps;
+              m_cVideoIOYuvReconFile[pcPic->layerId].writeUpscaledPicture(
+                *sps, *pcPic->cs->pps, pcPic->getRecoBuf(), m_outputColourSpaceConvert, m_packedYUVMode,
+                m_upscaledOutput, ChromaFormat::UNDEFINED, m_clipOutputVideoToRec709Range, m_upscaleFilterForDisplay);
+            }
+            else
+            {
+              m_cVideoIOYuvReconFile[pcPic->layerId].write(
+                pcPic->getRecoBuf().get(COMPONENT_Y).width, pcPic->getRecoBuf().get(COMPONENT_Y).height,
+                pcPic->getRecoBuf(), m_outputColourSpaceConvert, m_packedYUVMode,
+                conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc),
+                conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc), ChromaFormat::UNDEFINED,
+                m_clipOutputVideoToRec709Range);
+              }
+          }
+          // Perform FGS on decoded frame and write to output FGS file
+          if (!m_SEIFGSFileName.empty())
+          {
+            const Window& conf            = pcPic->getConformanceWindow();
+            const SPS*    sps             = pcPic->cs->sps;
+            ChromaFormat  chromaFormatIdc = sps->getChromaFormatIdc();
+            if (m_upscaledOutput)
+            {
+              m_videoIOYuvSEIFGSFile[pcPic->layerId].writeUpscaledPicture(
+                *sps, *pcPic->cs->pps, pcPic->getDisplayBufFG(), m_outputColourSpaceConvert, m_packedYUVMode,
+                m_upscaledOutput, ChromaFormat::UNDEFINED, m_clipOutputVideoToRec709Range, m_upscaleFilterForDisplay);
+            }
+            else
+            {
+              m_videoIOYuvSEIFGSFile[pcPic->layerId].write(
+                pcPic->getRecoBuf().get(COMPONENT_Y).width, pcPic->getRecoBuf().get(COMPONENT_Y).height,
+                pcPic->getDisplayBufFG(), m_outputColourSpaceConvert, m_packedYUVMode,
+                conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc),
+                conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc), ChromaFormat::UNDEFINED,
+                m_clipOutputVideoToRec709Range);
+            }
+          }
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+          if (!m_shutterIntervalPostFileName.empty() && getShutterFilterFlag())
+          {
+            int blendingRatio = getBlendingRatio();
+            pcPic->xOutputPostFilteredPic(pcPic, pcListPic, blendingRatio);
+
+            const Window &conf = pcPic->getConformanceWindow();
+            const SPS* sps = pcPic->cs->sps;
+            ChromaFormat  chromaFormatIdc = sps->getChromaFormatIdc();
+
+            m_cTVideoIOYuvSIIPostFile.write(pcPic->getPostRecBuf().get(COMPONENT_Y).width,
+                                            pcPic->getPostRecBuf().get(COMPONENT_Y).height, pcPic->getPostRecBuf(),
+                                            m_outputColourSpaceConvert, m_packedYUVMode,
+                                            conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                                            conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                                            conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc),
+                                            conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc),
+                                            ChromaFormat::UNDEFINED, m_clipOutputVideoToRec709Range);
+          }
+#endif
+
+          // Perform CTI on decoded frame and write to output CTI file
+          if (!m_SEICTIFileName.empty())
+          {
+            const Window& conf = pcPic->getConformanceWindow();
+            const SPS* sps = pcPic->cs->sps;
+            ChromaFormat  chromaFormatIdc = sps->getChromaFormatIdc();
+            if (m_upscaledOutput)
+            {
+              m_cVideoIOYuvSEICTIFile[pcPic->layerId].writeUpscaledPicture(
+                *sps, *pcPic->cs->pps, pcPic->getDisplayBuf(), m_outputColourSpaceConvert, m_packedYUVMode,
+                m_upscaledOutput, ChromaFormat::UNDEFINED, m_clipOutputVideoToRec709Range, m_upscaleFilterForDisplay);
+            }
+            else
+            {
+              m_cVideoIOYuvSEICTIFile[pcPic->layerId].write(
+                pcPic->getRecoBuf().get(COMPONENT_Y).width, pcPic->getRecoBuf().get(COMPONENT_Y).height,
+                pcPic->getDisplayBuf(), m_outputColourSpaceConvert, m_packedYUVMode,
+                conf.getWindowLeftOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                conf.getWindowRightOffset() * SPS::getWinUnitX(chromaFormatIdc),
+                conf.getWindowTopOffset() * SPS::getWinUnitY(chromaFormatIdc),
+                conf.getWindowBottomOffset() * SPS::getWinUnitY(chromaFormatIdc), ChromaFormat::UNDEFINED,
+                m_clipOutputVideoToRec709Range);
+            }
+          }
+          writeLineToOutputLog(pcPic);
+        // update POC of display order
+        m_iPOCLastDisplay = pcPic->getPOC();
+
+        // erase non-referenced picture in the reference picture list after display
+        if (!pcPic->referenced && pcPic->reconstructed)
+        {
+          pcPic->reconstructed = false;
+        }
+        pcPic->neededForOutput = false;
+      }
+#if JVET_Z0120_SII_SEI_PROCESSING
+      if (pcPic != nullptr && (m_shutterIntervalPostFileName.empty() || !getShutterFilterFlag()))
+#else
+      if(pcPic != nullptr)
+#endif
+      {
+        pcPic->destroy();
+        delete pcPic;
+        pcPic    = nullptr;
+        *iterPic = nullptr;
+      }
+      iterPic++;
+    }
+  }
+
+  if( layerId != NOT_VALID )
+  {
+    pcListPic->remove_if([](Picture* p) { return p == nullptr; });
+  }
+  else
+  {
+    pcListPic->clear();
+  }
+  m_iPOCLastDisplay = -MAX_INT;
+}
+
+/** \param pcListPic list of pictures to be written to file
+ */
+void SkipApp::xOutputAnnotatedRegions(PicList* pcListPic)
+{
+  if(!pcListPic || pcListPic->empty())
+  {
+    return;
+  }
+  PicList::iterator iterPic   = pcListPic->begin();
+
+  while (iterPic != pcListPic->end())
+  {
+    Picture* pcPic = *(iterPic);
+    if (pcPic->neededForOutput)
+    {
+      // Check if any annotated region SEI has arrived
+      SEIMessages annotatedRegionSEIs = getSeisByType(pcPic->SEIs, SEI::PayloadType::ANNOTATED_REGIONS);
+      for(auto it=annotatedRegionSEIs.begin(); it!=annotatedRegionSEIs.end(); it++)
+      {
+        const SEIAnnotatedRegions &seiAnnotatedRegions = *(SEIAnnotatedRegions*)(*it);
+
+        if (seiAnnotatedRegions.m_hdr.m_cancelFlag)
+        {
+          m_arObjects.clear();
+          m_arLabels.clear();
+        }
+        else
+        {
+          if (m_arHeader.m_receivedSettingsOnce)
+          {
+            // validate those settings that must stay constant are constant.
+            assert(m_arHeader.m_occludedObjectFlag              == seiAnnotatedRegions.m_hdr.m_occludedObjectFlag);
+            assert(m_arHeader.m_partialObjectFlagPresentFlag    == seiAnnotatedRegions.m_hdr.m_partialObjectFlagPresentFlag);
+            assert(m_arHeader.m_objectConfidenceInfoPresentFlag == seiAnnotatedRegions.m_hdr.m_objectConfidenceInfoPresentFlag);
+            assert((!m_arHeader.m_objectConfidenceInfoPresentFlag) || m_arHeader.m_objectConfidenceLength == seiAnnotatedRegions.m_hdr.m_objectConfidenceLength);
+          }
+          else
+          {
+            m_arHeader.m_receivedSettingsOnce=true;
+            m_arHeader=seiAnnotatedRegions.m_hdr; // copy the settings.
+          }
+          // Process label updates
+          if (seiAnnotatedRegions.m_hdr.m_objectLabelPresentFlag)
+          {
+            for(auto srcIt=seiAnnotatedRegions.m_annotatedLabels.begin(); srcIt!=seiAnnotatedRegions.m_annotatedLabels.end(); srcIt++)
+            {
+              const uint32_t labIdx = srcIt->first;
+              if (srcIt->second.labelValid)
+              {
+                m_arLabels[labIdx] = srcIt->second.label;
+              }
+              else
+              {
+                m_arLabels.erase(labIdx);
+              }
+            }
+          }
+
+          // Process object updates
+          for(auto srcIt=seiAnnotatedRegions.m_annotatedRegions.begin(); srcIt!=seiAnnotatedRegions.m_annotatedRegions.end(); srcIt++)
+          {
+            uint32_t objIdx = srcIt->first;
+            const SEIAnnotatedRegions::AnnotatedRegionObject &src =srcIt->second;
+
+            if (src.objectCancelFlag)
+            {
+              m_arObjects.erase(objIdx);
+            }
+            else
+            {
+              auto destIt = m_arObjects.find(objIdx);
+
+              if (destIt == m_arObjects.end())
+              {
+                //New object arrived, needs to be appended to the map of tracked objects
+                m_arObjects[objIdx] = src;
+              }
+              else //Existing object, modifications to be done
+              {
+                SEIAnnotatedRegions::AnnotatedRegionObject &dst=destIt->second;
+
+                if (seiAnnotatedRegions.m_hdr.m_objectLabelPresentFlag && src.objectLabelValid)
+                {
+                  dst.objectLabelValid=true;
+                  dst.objLabelIdx = src.objLabelIdx;
+                }
+                if (src.boundingBoxValid)
+                {
+                  dst.boundingBoxTop    = src.boundingBoxTop   ;
+                  dst.boundingBoxLeft   = src.boundingBoxLeft  ;
+                  dst.boundingBoxWidth  = src.boundingBoxWidth ;
+                  dst.boundingBoxHeight = src.boundingBoxHeight;
+                  if (seiAnnotatedRegions.m_hdr.m_partialObjectFlagPresentFlag)
+                  {
+                    dst.partialObjectFlag = src.partialObjectFlag;
+                  }
+                  if (seiAnnotatedRegions.m_hdr.m_objectConfidenceInfoPresentFlag)
+                  {
+                    dst.objectConfidence = src.objectConfidence;
+                  }
+                }
+              }
+            }
+          }
+        }
+      }
+
+      if (!m_arObjects.empty())
+      {
+        FILE *fpPersist = fopen(m_annotatedRegionsSEIFileName.c_str(), "ab");
+        if (fpPersist == nullptr)
+        {
+          std::cout << "Not able to open file for writing persist SEI messages" << std::endl;
+        }
+        else
+        {
+          fprintf(fpPersist, "\n");
+          fprintf(fpPersist, "Number of objects = %d\n", (int)m_arObjects.size());
+          for (auto it = m_arObjects.begin(); it != m_arObjects.end(); ++it)
+          {
+            fprintf(fpPersist, "Object Idx = %d\n",    it->first);
+            fprintf(fpPersist, "Object Top = %d\n",    it->second.boundingBoxTop);
+            fprintf(fpPersist, "Object Left = %d\n",   it->second.boundingBoxLeft);
+            fprintf(fpPersist, "Object Width = %d\n",  it->second.boundingBoxWidth);
+            fprintf(fpPersist, "Object Height = %d\n", it->second.boundingBoxHeight);
+            if (it->second.objectLabelValid)
+            {
+              auto labelIt=m_arLabels.find(it->second.objLabelIdx);
+              fprintf(fpPersist, "Object Label = %s\n", labelIt!=m_arLabels.end() ? (labelIt->second.c_str()) : "<UNKNOWN>");
+            }
+            if (m_arHeader.m_partialObjectFlagPresentFlag)
+            {
+              fprintf(fpPersist, "Object Partial = %d\n", it->second.partialObjectFlag?1:0);
+            }
+            if (m_arHeader.m_objectConfidenceInfoPresentFlag)
+            {
+              fprintf(fpPersist, "Object Conf = %d\n", it->second.objectConfidence);
+            }
+          }
+          fclose(fpPersist);
+        }
+      }
+    }
+   iterPic++;
+  }
+}
+
+/** \param nalu Input nalu to check whether its LayerId is within targetDecLayerIdSet
+ */
+bool SkipApp::xIsNaluWithinTargetDecLayerIdSet( const InputNALUnit* nalu ) const
+{
+  if( !m_targetDecLayerIdSet.size() ) // By default, the set is empty, meaning all LayerIds are allowed
+  {
+    return true;
+  }
+
+  return std::find(m_targetDecLayerIdSet.begin(), m_targetDecLayerIdSet.end(), nalu->m_nuhLayerId)
+         != m_targetDecLayerIdSet.end();
+}
+
+/** \param nalu Input nalu to check whether its LayerId is within targetOutputLayerIdSet
+ */
+bool SkipApp::xIsNaluWithinTargetOutputLayerIdSet( const InputNALUnit* nalu ) const
+{
+  if( !m_targetOutputLayerIdSet.size() ) // By default, the set is empty, meaning all LayerIds are allowed
+  {
+    return true;
+  }
+
+  return std::find(m_targetOutputLayerIdSet.begin(), m_targetOutputLayerIdSet.end(), nalu->m_nuhLayerId)
+         != m_targetOutputLayerIdSet.end();
+}
+
+
+
+//! \}
diff --git a/source/App/SkipApp/SkipApp.h b/source/App/SkipApp/SkipApp.h
new file mode 100644
index 00000000..b505ceb4
--- /dev/null
+++ b/source/App/SkipApp/SkipApp.h
@@ -0,0 +1,128 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     TAppDecLib.h
+    \brief    Decoder application class (header)
+*/
+
+#ifndef __DECAPP__
+#define __DECAPP__
+
+#pragma once
+
+#include "Utilities/VideoIOYuv.h"
+#include "CommonLib/Picture.h"
+#include "DecoderLib/DecLib.h"
+#include "SkipAppCfg.h"
+
+//! \ingroup DecoderApp
+//! \{
+
+// ====================================================================================================================
+// Class definition
+// ====================================================================================================================
+
+/// decoder application class
+class SkipApp : public SkipAppCfg
+{
+private:
+  // class interface
+  DecLib          m_cDecLib;                     ///< decoder class
+  std::unordered_map<int, VideoIOYuv>      m_cVideoIOYuvReconFile;        ///< reconstruction YUV class
+  std::unordered_map<int, VideoIOYuv>      m_videoIOYuvSEIFGSFile;       ///< reconstruction YUV with FGS class
+  std::unordered_map<int, VideoIOYuv>      m_cVideoIOYuvSEICTIFile;       ///< reconstruction YUV with CTI class
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+  bool                                    m_ShutterFilterEnable;          ///< enable Post-processing with Shutter Interval SEI
+  VideoIOYuv                              m_cTVideoIOYuvSIIPostFile;      ///< post-filtered YUV class
+  int                                     m_SII_BlendingRatio;
+
+  struct IdrSiiInfo
+  {
+    SEIShutterIntervalInfo m_siiInfo;
+    uint32_t               m_picPoc;
+    bool                   m_isValidSii;
+  };
+
+  std::map<uint32_t, IdrSiiInfo> m_activeSiiInfo;
+
+#endif
+
+  // for output control
+  int             m_iPOCLastDisplay;              ///< last POC in display order
+  std::ofstream   m_seiMessageFileStream;         ///< Used for outputing SEI messages.
+
+  std::ofstream   m_oplFileStream;                ///< Used to output log file for confomance testing
+
+  bool            m_newCLVS[MAX_NUM_LAYER_IDS];   ///< used to record a new CLVSS
+
+  SEIAnnotatedRegions::AnnotatedRegionHeader                 m_arHeader; ///< AR header
+  std::map<uint32_t, SEIAnnotatedRegions::AnnotatedRegionObject> m_arObjects; ///< AR object pool
+  std::map<uint32_t, std::string>                                m_arLabels; ///< AR label pool
+
+private:
+  bool  xIsNaluWithinTargetDecLayerIdSet( const InputNALUnit* nalu ) const; ///< check whether given Nalu is within targetDecLayerIdSet
+  bool  xIsNaluWithinTargetOutputLayerIdSet( const InputNALUnit* nalu ) const; ///< check whether given Nalu is within targetOutputLayerIdSet
+
+public:
+  SkipApp();
+  virtual ~SkipApp         ()  {};
+
+  uint32_t  decode            (); ///< main decoding function
+#if JVET_Z0120_SII_SEI_PROCESSING
+  bool  getShutterFilterFlag()        const { return m_ShutterFilterEnable; }
+  void  setShutterFilterFlag(bool value) { m_ShutterFilterEnable = value; }
+  int   getBlendingRatio()             const { return m_SII_BlendingRatio; }
+  void  setBlendingRatio(int value) { m_SII_BlendingRatio = value; }
+#endif
+
+private:
+  void  xCreateDecLib     (); ///< create internal classes
+  void  xDestroyDecLib    (); ///< destroy internal classes
+  void  xWriteOutput      ( PicList* pcListPic , uint32_t tId); ///< write YUV to file
+  void  xFlushOutput( PicList* pcListPic, const int layerId = NOT_VALID ); ///< flush all remaining decoded pictures to file
+
+  // check if next NAL unit will be the first NAL unit from a new picture
+  bool isNewPicture(std::ifstream *bitstreamFile, class InputByteStream *bytestream);
+
+  // check if next NAL unit will be the first NAL unit from a new access unit
+  bool isNewAccessUnit(bool newPicture, std::ifstream *bitstreamFile, class InputByteStream *bytestream);
+
+  void  writeLineToOutputLog(Picture * pcPic);
+  void xOutputAnnotatedRegions(PicList* pcListPic);
+};
+
+//! \}
+
+#endif // __SKIPAPP__
+
diff --git a/source/App/SkipApp/SkipAppCfg.cpp b/source/App/SkipApp/SkipAppCfg.cpp
new file mode 100644
index 00000000..ada4b3b0
--- /dev/null
+++ b/source/App/SkipApp/SkipAppCfg.cpp
@@ -0,0 +1,257 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     SkipAppCfg.cpp
+    \brief    Decoder configuration class
+*/
+
+#include <cstdio>
+#include <cstring>
+#include <string>
+#include "SkipAppCfg.h"
+#include "Utilities/program_options_lite.h"
+#include "Utilities/VideoIOYuv.h"
+#include "CommonLib/ChromaFormat.h"
+#include "CommonLib/dtrace_next.h"
+
+namespace po = df::program_options_lite;
+
+//! \ingroup DecoderApp
+//! \{
+
+// ====================================================================================================================
+// Public member functions
+// ====================================================================================================================
+
+/** \param argc number of arguments
+    \param argv array of arguments
+ */
+bool SkipAppCfg::parseCfg( int argc, char* argv[] )
+{
+  bool do_help = false;
+  std::string cfg_TargetDecLayerIdSetFile;
+  std::string outputColourSpaceConvert;
+  int warnUnknowParameter = 0;
+#if ENABLE_TRACING
+  std::string sTracingRule;
+  std::string sTracingFile;
+  bool   bTracingChannelsList = false;
+#endif
+#if ENABLE_SIMD_OPT
+  std::string ignore;
+#endif
+  po::Options opts;
+
+  // clang-format off
+  opts.addOptions()
+  ("help",                      do_help,                               false,      "this help text")
+  ("BitstreamFile,b",           m_bitstreamFileName,                   std::string(""), "bitstream input file name")
+  ("ReconFile,o",               m_reconFileName,                       std::string(""), "reconstructed YUV output file name\n")
+  ("OplFile,-opl",              m_oplFilename,                         std::string(""), "opl-file name without extension for conformance testing\n")
+
+#if ENABLE_SIMD_OPT
+  ("SIMD",                      ignore,                                std::string(""), "SIMD extension to use (SCALAR, SSE41, SSE42, AVX, AVX2, AVX512), default: the highest supported extension\n")
+#endif
+  ("WarnUnknowParameter,w",     warnUnknowParameter,                   0,          "warn for unknown configuration parameters instead of failing")
+  ("SkipFrames,s",              m_iSkipFrame,                          0,          "number of frames to skip before random access")
+  ("OutputBitDepth,d",          m_outputBitDepth[ChannelType::LUMA],   0,          "bit depth of YUV output luma component (default: use 0 for native depth)")
+  ("OutputBitDepthC,d",         m_outputBitDepth[ChannelType::CHROMA], 0,          "bit depth of YUV output chroma component (default: use luma output bit-depth)")
+  ("OutputColourSpaceConvert",  outputColourSpaceConvert,              std::string(""), "Colour space conversion to apply to input 444 video. Permitted values are (empty string=UNCHANGED) " + getListOfColourSpaceConverts(false))
+  ("MaxTemporalLayer,t",        m_iMaxTemporalLayer,                   500,        "Maximum Temporal Layer to be decoded. -1 to decode all layers")
+  ("TargetOutputLayerSet,p",    m_targetOlsIdx,                        500,        "Target output layer set index")
+#if JVET_Z0120_SII_SEI_PROCESSING
+  ("SEIShutterIntervalPostFilename,-sii", m_shutterIntervalPostFileName, std::string(""), "Post Filtering with Shutter Interval SEI. If empty, no filtering is applied (ignore SEI message)\n")
+#endif
+  ("SEIDecodedPictureHash,-dph", m_decodedPictureHashSEIEnabled,       1,          "Control handling of decoded picture hash SEI messages\n"
+                                                                                   "\t1: check hash in SEI messages if available in the bitstream\n"
+                                                                                   "\t0: ignore SEI message")
+  ("SEINoDisplay",              m_decodedNoDisplaySEIEnabled,          true,       "Control handling of decoded no display SEI messages")
+  ("TarDecLayerIdSetFile,l",    cfg_TargetDecLayerIdSetFile,           std::string(""), "targetDecLayerIdSet file name. The file should include white space separated LayerId values to be decoded. Omitting the option or a value of -1 in the file decodes all layers.")
+  ("SEIColourRemappingInfoFilename", m_colourRemapSEIFileName,         std::string(""), "Colour Remapping YUV output file name. If empty, no remapping is applied (ignore SEI message)\n")
+  ("SEICTIFilename",            m_SEICTIFileName,                      std::string(""), "CTI YUV output file name. If empty, no Colour Transform is applied (ignore SEI message)\n")
+  ("SEIFGSFilename",            m_SEIFGSFileName,                      std::string(""), "FGS YUV output file name. If empty, no film grain is applied (ignore SEI message)\n")
+  ("SEIAnnotatedRegionsInfoFilename", m_annotatedRegionsSEIFileName,   std::string(""), "Annotated regions output file name. If empty, no object information will be saved (ignore SEI message)\n")
+  ("OutputDecodedSEIMessagesFilename", m_outputDecodedSEIMessagesFilename, std::string(""), "When non empty, output decoded SEI messages to the indicated file. If file is '-', then output to stdout\n")
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+  ("360DumpFile",               m_outputDecoded360SEIMessagesFilename, std::string(""), "When non empty, output decoded 360 SEI messages to the indicated file.\n")
+#endif
+  ("ClipOutputVideoToRec709Range",      m_clipOutputVideoToRec709Range,  false,   "If true then clip output video to the Rec. 709 Range on saving")
+  ("PYUV",                      m_packedYUVMode,                       false,      "If true then output 10-bit and 12-bit YUV data as 5-byte and 3-byte (respectively) packed YUV data. Ignored for interlaced output.")
+#if ENABLE_TRACING
+  ("TraceChannelsList",         bTracingChannelsList,                  false,      "List all available tracing channels")
+  ("TraceRule",                 sTracingRule,                          std::string(""), "Tracing rule (ex: \"D_CABAC:poc==8\" or \"D_REC_CB_LUMA:poc==8\")")
+  ("TraceFile",                 sTracingFile,                          std::string(""), "Tracing file")
+#endif
+#if JVET_J0090_MEMORY_BANDWITH_MEASURE
+  ("CacheCfg",                  m_cacheCfgFile,                        std::string(""), "CacheCfg File")
+#endif
+#if RExt__DECODER_DEBUG_STATISTICS
+  ("Stats",                     m_statMode,                            3,          "Control decoder debugging statistic output mode\n"
+                                                                                   "\t0: disable statistic\n"
+                                                                                   "\t1: enable bit statistic\n"
+                                                                                   "\t2: enable tool statistic\n"
+                                                                                   "\t3: enable bit and tool statistic\n")
+#endif
+#if GREEN_METADATA_SEI_ENABLED
+  ("GMFA", m_GMFA, false, "Write output file for the Green-Metadata analyzer for decoder complexity metrics (JVET-P0085)\n")
+  ("GMFAFile", m_GMFAFile, std::string(""), "File for the Green Metadata Bit Stream Feature Analyzer output (JVET-P0085)\n")
+  ("GMFAFramewise", m_GMFAFramewise, false, "Output of frame-wise Green Metadata Bit Stream Feature Analyzer files\n")
+#endif
+  ("MCTSCheck",                m_mctsCheck,                           false,       "If enabled, the decoder checks for violations of mc_exact_sample_value_match_flag in Temporal MCTS ")
+  ("targetSubPicIdx",          m_targetSubPicIdx,                     0,           "Specify which subpicture shall be written to output, using subpic index, 0: disabled, subpicIdx=m_targetSubPicIdx-1 \n" )
+  ( "UpscaledOutput",          m_upscaledOutput,                          0,       "Upscaled output for RPR" )
+  ("UpscaleFilterForDisplay",  m_upscaleFilterForDisplay,                 1,       "Filters used for upscaling reconstruction to full resolution (2: ECM 12 - tap luma and 6 - tap chroma MC filters, 1 : Alternative 12 - tap luma and 6 - tap chroma filters, 0 : VVC 8 - tap luma and 4 - tap chroma MC filters)")
+#if GDR_LEAK_TEST
+  ("RandomAccessPos",           m_gdrPocRandomAccess,                  0,          "POC of GDR Random access picture\n")
+#endif // GDR_LEAK_TEST
+    ;
+  // clang-format on
+
+  po::setDefaults(opts);
+  po::ErrorReporter err;
+  const std::list<const char *> &argv_unhandled = po::scanArgv(opts, argc, (const char **) argv, err);
+
+  for (std::list<const char *>::const_iterator it = argv_unhandled.begin(); it != argv_unhandled.end(); it++)
+  {
+    msg( ERROR, "Unhandled argument ignored: `%s'\n", *it);
+  }
+
+  if (argc == 1 || do_help)
+  {
+    po::doHelp(std::cout, opts);
+    return false;
+  }
+
+  if (err.is_errored)
+  {
+    if (!warnUnknowParameter)
+    {
+      /* errors have already been reported to stderr */
+      return false;
+    }
+  }
+
+#if ENABLE_TRACING
+  g_trace_ctx = tracing_init( sTracingFile, sTracingRule );
+  if( bTracingChannelsList && g_trace_ctx )
+  {
+    std::string sChannelsList;
+    g_trace_ctx->getChannelsList( sChannelsList );
+    msg( INFO, "\nAvailable tracing channels:\n\n%s\n", sChannelsList.c_str() );
+  }
+#endif
+
+  g_mctsDecCheckEnabled = m_mctsCheck;
+  // Chroma output bit-depth
+  if (m_outputBitDepth[ChannelType::LUMA] != 0 && m_outputBitDepth[ChannelType::CHROMA] == 0)
+  {
+    m_outputBitDepth[ChannelType::CHROMA] = m_outputBitDepth[ChannelType::LUMA];
+  }
+
+  m_outputColourSpaceConvert = stringToInputColourSpaceConvert(outputColourSpaceConvert, false);
+  if (m_outputColourSpaceConvert>=NUMBER_INPUT_COLOUR_SPACE_CONVERSIONS)
+  {
+    msg( ERROR, "Bad output colour space conversion string\n");
+    return false;
+  }
+
+  if (m_bitstreamFileName.empty())
+  {
+    msg( ERROR, "No input file specified, aborting\n");
+    return false;
+  }
+
+  if ( !cfg_TargetDecLayerIdSetFile.empty() )
+  {
+    FILE* targetDecLayerIdSetFile = fopen ( cfg_TargetDecLayerIdSetFile.c_str(), "r" );
+    if ( targetDecLayerIdSetFile )
+    {
+      bool isLayerIdZeroIncluded = false;
+      while ( !feof(targetDecLayerIdSetFile) )
+      {
+        int layerIdParsed = 0;
+        if ( fscanf( targetDecLayerIdSetFile, "%d ", &layerIdParsed ) != 1 )
+        {
+          if ( m_targetDecLayerIdSet.size() == 0 )
+          {
+            msg( ERROR, "No LayerId could be parsed in file %s. Decoding all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
+          }
+          break;
+        }
+        if ( layerIdParsed  == -1 ) // The file includes a -1, which means all LayerIds are to be decoded.
+        {
+          m_targetDecLayerIdSet.clear(); // Empty set means decoding all layers.
+          break;
+        }
+        if ( layerIdParsed < 0 || layerIdParsed >= MAX_NUM_LAYER_IDS )
+        {
+          msg( ERROR, "Warning! Parsed LayerId %d is not within allowed range [0,%d]. Ignoring this value.\n", layerIdParsed, MAX_NUM_LAYER_IDS-1 );
+        }
+        else
+        {
+          isLayerIdZeroIncluded = layerIdParsed == 0 ? true : isLayerIdZeroIncluded;
+          m_targetDecLayerIdSet.push_back ( layerIdParsed );
+        }
+      }
+      fclose (targetDecLayerIdSetFile);
+      if ( m_targetDecLayerIdSet.size() > 0 && !isLayerIdZeroIncluded )
+      {
+        msg( ERROR, "TargetDecLayerIdSet must contain LayerId=0, aborting" );
+        return false;
+      }
+    }
+    else
+    {
+      msg( ERROR, "File %s could not be opened. Using all LayerIds as default.\n", cfg_TargetDecLayerIdSetFile.c_str() );
+    }
+  }
+  if (m_iMaxTemporalLayer != 500)
+  {
+    m_mTidExternalSet = true;
+  }
+  else
+  {
+    m_iMaxTemporalLayer = -1;
+  }
+  if ( m_targetOlsIdx != 500)
+  {
+    m_tOlsIdxTidExternalSet = true;
+  }
+  else
+  {
+    m_targetOlsIdx = -1;
+  }
+
+  return true;
+}
+//! \}
diff --git a/source/App/SkipApp/SkipAppCfg.h b/source/App/SkipApp/SkipAppCfg.h
new file mode 100644
index 00000000..c66b5246
--- /dev/null
+++ b/source/App/SkipApp/SkipAppCfg.h
@@ -0,0 +1,114 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     SkipAppCfg.h
+    \brief    Decoder configuration class (header)
+*/
+
+#ifndef __SKIPAPPCFG__
+#define __SKIPAPPCFG__
+
+#pragma once
+
+#include "CommonLib/CommonDef.h"
+#include <vector>
+
+//! \ingroup DecoderApp
+//! \{
+
+// ====================================================================================================================
+// Class definition
+// ====================================================================================================================
+
+/// Decoder configuration class
+class SkipAppCfg
+{
+protected:
+  std::string   m_bitstreamFileName;                    ///< input bitstream file name
+  std::string   m_reconFileName;                        ///< output reconstruction file name
+
+  std::string   m_oplFilename;                        ///< filename to output conformance log.
+
+  int           m_iSkipFrame;                           ///< counter for frames prior to the random access point to skip
+  BitDepths     m_outputBitDepth;                       // bit depth used for writing output
+
+  InputColourSpaceConversion m_outputColourSpaceConvert;
+  int           m_targetOlsIdx;                       ///< target output layer set
+  std::vector<int> m_targetOutputLayerIdSet;          ///< set of LayerIds to be outputted
+  int           m_iMaxTemporalLayer;                  ///< maximum temporal layer to be decoded
+  bool          m_mTidExternalSet;                    ///< maximum temporal layer set externally
+  bool          m_tOlsIdxTidExternalSet;              ///< target output layer set index externally set
+  int           m_decodedPictureHashSEIEnabled;       ///< Checksum(3)/CRC(2)/MD5(1)/disable(0) acting on decoded picture hash SEI message
+  bool          m_decodedNoDisplaySEIEnabled;         ///< Enable(true)/disable(false) writing only pictures that get displayed based on the no display SEI message
+  std::string   m_colourRemapSEIFileName;             ///< output Colour Remapping file name
+  std::string   m_SEICTIFileName;                     ///< output Recon with CTI file name
+  std::string   m_SEIFGSFileName;                     ///< output file name for reconstructed sequence with film grain
+  std::string   m_annotatedRegionsSEIFileName;        ///< annotated regions file name
+  std::vector<int> m_targetDecLayerIdSet;             ///< set of LayerIds to be included in the sub-bitstream extraction process.
+  std::string   m_outputDecodedSEIMessagesFilename;   ///< filename to output decoded SEI messages to. If '-', then use stdout. If empty, do not output details.
+#if JVET_S0257_DUMP_360SEI_MESSAGE
+  std::string   m_outputDecoded360SEIMessagesFilename;   ///< filename to output decoded 360 SEI messages to.
+#endif
+
+#if JVET_Z0120_SII_SEI_PROCESSING
+  std::string   m_shutterIntervalPostFileName;        ///< output Post Filtering file name
+#endif
+
+  bool m_clipOutputVideoToRec709Range;   ///< If true, clip the output video to the Rec 709 range on saving.
+  bool          m_packedYUVMode;                      ///< If true, output 10-bit and 12-bit YUV data as 5-byte and 3-byte (respectively) packed YUV data
+  std::string   m_cacheCfgFile;                       ///< Config file of cache model
+  int           m_statMode;                           ///< Config statistic mode (0 - bit stat, 1 - tool stat, 3 - both)
+  bool          m_mctsCheck;
+#if GREEN_METADATA_SEI_ENABLED
+  bool          m_GMFA;
+  std::string   m_GMFAFile;
+  bool          m_GMFAFramewise;
+#endif
+  int          m_upscaledOutput;                     ////< Output upscaled (2), decoded but in full resolution buffer (1) or decoded cropped (0, default) picture for RPR.
+  int          m_upscaleFilterForDisplay;
+  int           m_targetSubPicIdx;                    ///< Specify which subpicture shall be write to output, using subpicture index
+#if GDR_LEAK_TEST
+  int           m_gdrPocRandomAccess;                   ///<
+#endif // GDR_LEAK_TEST
+public:
+  SkipAppCfg() {m_outputBitDepth.fill(0);};
+  virtual ~SkipAppCfg() {};
+
+  bool  parseCfg        ( int argc, char* argv[] );   ///< initialize option class from configuration
+};
+
+//! \}
+
+#endif  // __DECAPPCFG__
+
+
diff --git a/source/App/SkipApp/decmain.cpp b/source/App/SkipApp/decmain.cpp
new file mode 100644
index 00000000..ca8eed43
--- /dev/null
+++ b/source/App/SkipApp/decmain.cpp
@@ -0,0 +1,122 @@
+/* The copyright in this software is being made available under the BSD
+ * License, included below. This software may be subject to other third party
+ * and contributor rights, including patent rights, and no such rights are
+ * granted under this license.
+ *
+ * Copyright (c) 2010-2023, ITU/ISO/IEC
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ *  * Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *  * Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *  * Neither the name of the ITU/ISO/IEC nor the names of its contributors may
+ *    be used to endorse or promote products derived from this software without
+ *    specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS
+ * BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
+ * THE POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/** \file     decmain.cpp
+    \brief    Decoder application main
+*/
+
+#include <stdlib.h>
+#include <stdio.h>
+#include <time.h>
+#include "SkipApp.h"
+#include "program_options_lite.h"
+
+//! \ingroup DecoderApp
+//! \{
+
+// ====================================================================================================================
+// Main function
+// ====================================================================================================================
+
+int main(int argc, char* argv[])
+{
+  int returnCode = EXIT_SUCCESS;
+
+  // print information
+  fprintf( stdout, "\n" );
+  fprintf( stdout, "VVCSoftware: VTM Decoder Version %s ", VTM_VERSION );
+  fprintf( stdout, NVM_ONOS );
+  fprintf( stdout, NVM_COMPILEDBY );
+  fprintf( stdout, NVM_BITS );
+#if ENABLE_SIMD_OPT
+  std::string SIMD;
+  df::program_options_lite::Options optsSimd;
+  optsSimd.addOptions()("SIMD", SIMD, std::string(""), "");
+  df::program_options_lite::SilentReporter err;
+  df::program_options_lite::scanArgv( optsSimd, argc, ( const char** ) argv, err );
+  fprintf( stdout, "[SIMD=%s] ", read_x86_extension( SIMD ) );
+#endif
+#if ENABLE_TRACING
+  fprintf( stdout, "[ENABLE_TRACING] " );
+#endif
+  fprintf( stdout, "\n" );
+
+  SkipApp *pcSkipApp = new SkipApp;
+  // parse configuration
+  if(!pcSkipApp->parseCfg( argc, argv ))
+  {
+    returnCode = EXIT_FAILURE;
+
+    delete pcSkipApp;
+
+    return returnCode;
+  }
+
+  // starting time
+  double dResult;
+  clock_t lBefore = clock();
+
+  // call decoding function
+#ifndef _DEBUG
+  try
+  {
+#endif // !_DEBUG
+    if( 0 != pcSkipApp->decode() )
+    {
+      printf( "\n\n***ERROR*** A decoding mismatch occured: signalled md5sum does not match\n" );
+      returnCode = EXIT_FAILURE;
+    }
+#ifndef _DEBUG
+  }
+  catch( Exception &e )
+  {
+    std::cerr << e.what() << std::endl;
+    returnCode = EXIT_FAILURE;
+  }
+  catch (const std::bad_alloc &e)
+  {
+    std::cout << "Memory allocation failed: " << e.what() << std::endl;
+    returnCode = EXIT_FAILURE;
+  }
+#endif
+
+  // ending time
+  dResult = (double)(clock()-lBefore) / CLOCKS_PER_SEC;
+  printf("\n Total Time: %12.3f sec.\n", dResult);
+
+  delete pcSkipApp;
+
+  return returnCode;
+}
+
+//! \}
-- 
2.17.1

